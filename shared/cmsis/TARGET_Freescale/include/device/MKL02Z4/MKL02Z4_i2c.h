/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_I2C_REGISTERS_H__
#define __HW_I2C_REGISTERS_H__

#include "MKL02Z4.h"
#include "fsl_bitband.h"

/*
 * MKL02Z4 I2C
 *
 * Inter-Integrated Circuit
 *
 * Registers defined in this header file:
 * - HW_I2C_A1 - I2C Address Register 1
 * - HW_I2C_F - I2C Frequency Divider register
 * - HW_I2C_C1 - I2C Control Register 1
 * - HW_I2C_S - I2C Status register
 * - HW_I2C_D - I2C Data I/O register
 * - HW_I2C_C2 - I2C Control Register 2
 * - HW_I2C_FLT - I2C Programmable Input Glitch Filter register
 * - HW_I2C_RA - I2C Range Address register
 *
 * - hw_i2c_t - Struct containing all module registers.
 */

#define HW_I2C_INSTANCE_COUNT (2U) /*!< Number of instances of the I2C module. */
#define HW_I2C0 (0U) /*!< Instance number for I2C0. */
#define HW_I2C1 (1U) /*!< Instance number for I2C1. */

/*******************************************************************************
 * HW_I2C_A1 - I2C Address Register 1
 ******************************************************************************/

/*!
 * @brief HW_I2C_A1 - I2C Address Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the slave address to be used by the I2C module.
 */
typedef union _hw_i2c_a1
{
    uint8_t U;
    struct _hw_i2c_a1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t AD : 7;                /*!< [7:1] Address */
    } B;
} hw_i2c_a1_t;

/*!
 * @name Constants and macros for entire I2C_A1 register
 */
/*@{*/
#define HW_I2C_A1_ADDR(x)        ((x) + 0x0U)

#define HW_I2C_A1(x)             (*(__IO hw_i2c_a1_t *) HW_I2C_A1_ADDR(x))
#define HW_I2C_A1_RD(x)          (HW_I2C_A1(x).U)
#define HW_I2C_A1_WR(x, v)       (HW_I2C_A1(x).U = (v))
#define HW_I2C_A1_SET(x, v)      (BME_OR8(HW_I2C_A1_ADDR(x), (uint8_t)(v)))
#define HW_I2C_A1_CLR(x, v)      (BME_AND8(HW_I2C_A1_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_A1_TOG(x, v)      (BME_XOR8(HW_I2C_A1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_A1 bitfields
 */

/*!
 * @name Register I2C_A1, field AD[7:1] (RW)
 *
 * Contains the primary slave address used by the I2C module when it is
 * addressed as a slave. This field is used in the 7-bit address scheme and the lower
 * seven bits in the 10-bit address scheme.
 */
/*@{*/
#define BP_I2C_A1_AD         (1U)          /*!< Bit position for I2C_A1_AD. */
#define BM_I2C_A1_AD         (0xFEU)       /*!< Bit mask for I2C_A1_AD. */
#define BS_I2C_A1_AD         (7U)          /*!< Bit field size in bits for I2C_A1_AD. */

/*! @brief Read current value of the I2C_A1_AD field. */
#define BR_I2C_A1_AD(x)      (BME_UBFX8(HW_I2C_A1_ADDR(x), BP_I2C_A1_AD, BS_I2C_A1_AD))

/*! @brief Format value for bitfield I2C_A1_AD. */
#define BF_I2C_A1_AD(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_A1_AD) & BM_I2C_A1_AD)

/*! @brief Set the AD field to a new value. */
#define BW_I2C_A1_AD(x, v)   (BME_BFI8(HW_I2C_A1_ADDR(x), ((uint8_t)(v) << BP_I2C_A1_AD), BP_I2C_A1_AD, 7))
/*@}*/

/*******************************************************************************
 * HW_I2C_F - I2C Frequency Divider register
 ******************************************************************************/

/*!
 * @brief HW_I2C_F - I2C Frequency Divider register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_f
{
    uint8_t U;
    struct _hw_i2c_f_bitfields
    {
        uint8_t ICR : 6;               /*!< [5:0] ClockRate */
        uint8_t MULT : 2;              /*!< [7:6]  */
    } B;
} hw_i2c_f_t;

/*!
 * @name Constants and macros for entire I2C_F register
 */
/*@{*/
#define HW_I2C_F_ADDR(x)         ((x) + 0x1U)

#define HW_I2C_F(x)              (*(__IO hw_i2c_f_t *) HW_I2C_F_ADDR(x))
#define HW_I2C_F_RD(x)           (HW_I2C_F(x).U)
#define HW_I2C_F_WR(x, v)        (HW_I2C_F(x).U = (v))
#define HW_I2C_F_SET(x, v)       (BME_OR8(HW_I2C_F_ADDR(x), (uint8_t)(v)))
#define HW_I2C_F_CLR(x, v)       (BME_AND8(HW_I2C_F_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_F_TOG(x, v)       (BME_XOR8(HW_I2C_F_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_F bitfields
 */

/*!
 * @name Register I2C_F, field ICR[5:0] (RW)
 *
 * Prescales the bus clock for bit rate selection. This field and the MULT field
 * determine the I2C baud rate, the SDA hold time, the SCL start hold time, and
 * the SCL stop hold time. For a list of values corresponding to each ICR
 * setting, see I2C divider and hold values. The SCL divider multiplied by multiplier
 * factor (mul) determines the I2C baud rate. I2C baud rate = bus speed (Hz)/(mul *
 * SCL divider) The SDA hold time is the delay from the falling edge of SCL (I2C
 * clock) to the changing of SDA (I2C data). SDA hold time = bus period (s) *
 * mul * SDA hold value The SCL start hold time is the delay from the falling edge
 * of SDA (I2C data) while SCL is high (start condition) to the falling edge of
 * SCL (I2C clock). SCL start hold time = bus period (s) * mul * SCL start hold
 * value The SCL stop hold time is the delay from the rising edge of SCL (I2C
 * clock) to the rising edge of SDA (I2C data) while SCL is high (stop condition). SCL
 * stop hold time = bus period (s) * mul * SCL stop hold value For example, if
 * the bus speed is 8 MHz, the following table shows the possible hold time values
 * with different ICR and MULT selections to achieve an I2C baud rate of 100
 * kbps. MULT ICR Hold times (us) SDA SCL Start SCL Stop 2h 00h 3.500 3.000 5.500 1h
 * 07h 2.500 4.000 5.250 1h 0Bh 2.250 4.000 5.250 0h 14h 2.125 4.250 5.125 0h
 * 18h 1.125 4.750 5.125
 */
/*@{*/
#define BP_I2C_F_ICR         (0U)          /*!< Bit position for I2C_F_ICR. */
#define BM_I2C_F_ICR         (0x3FU)       /*!< Bit mask for I2C_F_ICR. */
#define BS_I2C_F_ICR         (6U)          /*!< Bit field size in bits for I2C_F_ICR. */

/*! @brief Read current value of the I2C_F_ICR field. */
#define BR_I2C_F_ICR(x)      (BME_UBFX8(HW_I2C_F_ADDR(x), BP_I2C_F_ICR, BS_I2C_F_ICR))

/*! @brief Format value for bitfield I2C_F_ICR. */
#define BF_I2C_F_ICR(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_F_ICR) & BM_I2C_F_ICR)

/*! @brief Set the ICR field to a new value. */
#define BW_I2C_F_ICR(x, v)   (BME_BFI8(HW_I2C_F_ADDR(x), ((uint8_t)(v) << BP_I2C_F_ICR), BP_I2C_F_ICR, 6))
/*@}*/

/*!
 * @name Register I2C_F, field MULT[7:6] (RW)
 *
 * The MULT bits define the multiplier factor mul. This factor is used along
 * with the SCL divider to generate the I2C baud rate.
 *
 * Values:
 * - 00 - mul = 1
 * - 01 - mul = 2
 * - 10 - mul = 4
 * - 11 - Reserved
 */
/*@{*/
#define BP_I2C_F_MULT        (6U)          /*!< Bit position for I2C_F_MULT. */
#define BM_I2C_F_MULT        (0xC0U)       /*!< Bit mask for I2C_F_MULT. */
#define BS_I2C_F_MULT        (2U)          /*!< Bit field size in bits for I2C_F_MULT. */

/*! @brief Read current value of the I2C_F_MULT field. */
#define BR_I2C_F_MULT(x)     (BME_UBFX8(HW_I2C_F_ADDR(x), BP_I2C_F_MULT, BS_I2C_F_MULT))

/*! @brief Format value for bitfield I2C_F_MULT. */
#define BF_I2C_F_MULT(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_F_MULT) & BM_I2C_F_MULT)

/*! @brief Set the MULT field to a new value. */
#define BW_I2C_F_MULT(x, v)  (BME_BFI8(HW_I2C_F_ADDR(x), ((uint8_t)(v) << BP_I2C_F_MULT), BP_I2C_F_MULT, 2))
/*@}*/

/*******************************************************************************
 * HW_I2C_C1 - I2C Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_I2C_C1 - I2C Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_c1
{
    uint8_t U;
    struct _hw_i2c_c1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t WUEN : 1;              /*!< [1] Wakeup Enable */
        uint8_t RSTA : 1;              /*!< [2] Repeat START */
        uint8_t TXAK : 1;              /*!< [3] Transmit Acknowledge Enable */
        uint8_t TX : 1;                /*!< [4] Transmit Mode Select */
        uint8_t MST : 1;               /*!< [5] Master Mode Select */
        uint8_t IICIE : 1;             /*!< [6] I2C Interrupt Enable */
        uint8_t IICEN : 1;             /*!< [7] I2C Enable */
    } B;
} hw_i2c_c1_t;

/*!
 * @name Constants and macros for entire I2C_C1 register
 */
/*@{*/
#define HW_I2C_C1_ADDR(x)        ((x) + 0x2U)

#define HW_I2C_C1(x)             (*(__IO hw_i2c_c1_t *) HW_I2C_C1_ADDR(x))
#define HW_I2C_C1_RD(x)          (HW_I2C_C1(x).U)
#define HW_I2C_C1_WR(x, v)       (HW_I2C_C1(x).U = (v))
#define HW_I2C_C1_SET(x, v)      (BME_OR8(HW_I2C_C1_ADDR(x), (uint8_t)(v)))
#define HW_I2C_C1_CLR(x, v)      (BME_AND8(HW_I2C_C1_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_C1_TOG(x, v)      (BME_XOR8(HW_I2C_C1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_C1 bitfields
 */

/*!
 * @name Register I2C_C1, field WUEN[1] (RW)
 *
 * The I2C module can wake the MCU from low power mode with no peripheral bus
 * running when slave address matching occurs.
 *
 * Values:
 * - 0 - Normal operation. No interrupt generated when address matching in low
 *     power mode.
 * - 1 - Enables the wakeup function in low power mode.
 */
/*@{*/
#define BP_I2C_C1_WUEN       (1U)          /*!< Bit position for I2C_C1_WUEN. */
#define BM_I2C_C1_WUEN       (0x02U)       /*!< Bit mask for I2C_C1_WUEN. */
#define BS_I2C_C1_WUEN       (1U)          /*!< Bit field size in bits for I2C_C1_WUEN. */

/*! @brief Read current value of the I2C_C1_WUEN field. */
#define BR_I2C_C1_WUEN(x)    (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_WUEN, BS_I2C_C1_WUEN))

/*! @brief Format value for bitfield I2C_C1_WUEN. */
#define BF_I2C_C1_WUEN(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C1_WUEN) & BM_I2C_C1_WUEN)

/*! @brief Set the WUEN field to a new value. */
#define BW_I2C_C1_WUEN(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_WUEN), BP_I2C_C1_WUEN, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field RSTA[2] (WORZ)
 *
 * Writing a one to this bit generates a repeated START condition provided it is
 * the current master. This bit will always be read as zero. Attempting a repeat
 * at the wrong time results in loss of arbitration.
 */
/*@{*/
#define BP_I2C_C1_RSTA       (2U)          /*!< Bit position for I2C_C1_RSTA. */
#define BM_I2C_C1_RSTA       (0x04U)       /*!< Bit mask for I2C_C1_RSTA. */
#define BS_I2C_C1_RSTA       (1U)          /*!< Bit field size in bits for I2C_C1_RSTA. */

/*! @brief Format value for bitfield I2C_C1_RSTA. */
#define BF_I2C_C1_RSTA(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C1_RSTA) & BM_I2C_C1_RSTA)

/*! @brief Set the RSTA field to a new value. */
#define BW_I2C_C1_RSTA(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_RSTA), BP_I2C_C1_RSTA, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field TXAK[3] (RW)
 *
 * Specifies the value driven onto the SDA during data acknowledge cycles for
 * both master and slave receivers. SCL is held low until TXAK is written.
 *
 * Values:
 * - 0 - An acknowledge signal is sent to the bus on the following receiving byte
 * - 1 - No acknowledge signal is sent to the bus on the following receiving
 *     data byte.
 */
/*@{*/
#define BP_I2C_C1_TXAK       (3U)          /*!< Bit position for I2C_C1_TXAK. */
#define BM_I2C_C1_TXAK       (0x08U)       /*!< Bit mask for I2C_C1_TXAK. */
#define BS_I2C_C1_TXAK       (1U)          /*!< Bit field size in bits for I2C_C1_TXAK. */

/*! @brief Read current value of the I2C_C1_TXAK field. */
#define BR_I2C_C1_TXAK(x)    (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_TXAK, BS_I2C_C1_TXAK))

/*! @brief Format value for bitfield I2C_C1_TXAK. */
#define BF_I2C_C1_TXAK(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C1_TXAK) & BM_I2C_C1_TXAK)

/*! @brief Set the TXAK field to a new value. */
#define BW_I2C_C1_TXAK(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_TXAK), BP_I2C_C1_TXAK, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field TX[4] (RW)
 *
 * Selects the direction of master and slave transfers. In master mode this bit
 * must be set according to the type of transfer required. Therefore, for address
 * cycles, this bit is always set. When addressed as a slave this bit must be
 * set by software according to the SRW bit in the status register.
 *
 * Values:
 * - 0 - Receive
 * - 1 - Transmit
 */
/*@{*/
#define BP_I2C_C1_TX         (4U)          /*!< Bit position for I2C_C1_TX. */
#define BM_I2C_C1_TX         (0x10U)       /*!< Bit mask for I2C_C1_TX. */
#define BS_I2C_C1_TX         (1U)          /*!< Bit field size in bits for I2C_C1_TX. */

/*! @brief Read current value of the I2C_C1_TX field. */
#define BR_I2C_C1_TX(x)      (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_TX, BS_I2C_C1_TX))

/*! @brief Format value for bitfield I2C_C1_TX. */
#define BF_I2C_C1_TX(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_C1_TX) & BM_I2C_C1_TX)

/*! @brief Set the TX field to a new value. */
#define BW_I2C_C1_TX(x, v)   (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_TX), BP_I2C_C1_TX, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field MST[5] (RW)
 *
 * When the MST bit is changed from a 0 to a 1, a START signal is generated on
 * the bus and master mode is selected. When this bit changes from a 1 to a 0, a
 * STOP signal is generated and the mode of operation changes from master to slave.
 *
 * Values:
 * - 0 - Slave mode
 * - 1 - Master mode
 */
/*@{*/
#define BP_I2C_C1_MST        (5U)          /*!< Bit position for I2C_C1_MST. */
#define BM_I2C_C1_MST        (0x20U)       /*!< Bit mask for I2C_C1_MST. */
#define BS_I2C_C1_MST        (1U)          /*!< Bit field size in bits for I2C_C1_MST. */

/*! @brief Read current value of the I2C_C1_MST field. */
#define BR_I2C_C1_MST(x)     (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_MST, BS_I2C_C1_MST))

/*! @brief Format value for bitfield I2C_C1_MST. */
#define BF_I2C_C1_MST(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_C1_MST) & BM_I2C_C1_MST)

/*! @brief Set the MST field to a new value. */
#define BW_I2C_C1_MST(x, v)  (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_MST), BP_I2C_C1_MST, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field IICIE[6] (RW)
 *
 * Enables I2C interrupt requests.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_I2C_C1_IICIE      (6U)          /*!< Bit position for I2C_C1_IICIE. */
#define BM_I2C_C1_IICIE      (0x40U)       /*!< Bit mask for I2C_C1_IICIE. */
#define BS_I2C_C1_IICIE      (1U)          /*!< Bit field size in bits for I2C_C1_IICIE. */

/*! @brief Read current value of the I2C_C1_IICIE field. */
#define BR_I2C_C1_IICIE(x)   (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_IICIE, BS_I2C_C1_IICIE))

/*! @brief Format value for bitfield I2C_C1_IICIE. */
#define BF_I2C_C1_IICIE(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C1_IICIE) & BM_I2C_C1_IICIE)

/*! @brief Set the IICIE field to a new value. */
#define BW_I2C_C1_IICIE(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_IICIE), BP_I2C_C1_IICIE, 1))
/*@}*/

/*!
 * @name Register I2C_C1, field IICEN[7] (RW)
 *
 * Enables I2C module operation.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_I2C_C1_IICEN      (7U)          /*!< Bit position for I2C_C1_IICEN. */
#define BM_I2C_C1_IICEN      (0x80U)       /*!< Bit mask for I2C_C1_IICEN. */
#define BS_I2C_C1_IICEN      (1U)          /*!< Bit field size in bits for I2C_C1_IICEN. */

/*! @brief Read current value of the I2C_C1_IICEN field. */
#define BR_I2C_C1_IICEN(x)   (BME_UBFX8(HW_I2C_C1_ADDR(x), BP_I2C_C1_IICEN, BS_I2C_C1_IICEN))

/*! @brief Format value for bitfield I2C_C1_IICEN. */
#define BF_I2C_C1_IICEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C1_IICEN) & BM_I2C_C1_IICEN)

/*! @brief Set the IICEN field to a new value. */
#define BW_I2C_C1_IICEN(x, v) (BME_BFI8(HW_I2C_C1_ADDR(x), ((uint8_t)(v) << BP_I2C_C1_IICEN), BP_I2C_C1_IICEN, 1))
/*@}*/

/*******************************************************************************
 * HW_I2C_S - I2C Status register
 ******************************************************************************/

/*!
 * @brief HW_I2C_S - I2C Status register (RW)
 *
 * Reset value: 0x80U
 */
typedef union _hw_i2c_s
{
    uint8_t U;
    struct _hw_i2c_s_bitfields
    {
        uint8_t RXAK : 1;              /*!< [0] Receive Acknowledge */
        uint8_t IICIF : 1;             /*!< [1] Interrupt Flag */
        uint8_t SRW : 1;               /*!< [2] Slave Read/Write */
        uint8_t RAM : 1;               /*!< [3] Range Address Match */
        uint8_t ARBL : 1;              /*!< [4] Arbitration Lost */
        uint8_t BUSY : 1;              /*!< [5] Bus Busy */
        uint8_t IAAS : 1;              /*!< [6] Addressed As A Slave */
        uint8_t TCF : 1;               /*!< [7] Transfer Complete Flag */
    } B;
} hw_i2c_s_t;

/*!
 * @name Constants and macros for entire I2C_S register
 */
/*@{*/
#define HW_I2C_S_ADDR(x)         ((x) + 0x3U)

#define HW_I2C_S(x)              (*(__IO hw_i2c_s_t *) HW_I2C_S_ADDR(x))
#define HW_I2C_S_RD(x)           (HW_I2C_S(x).U)
#define HW_I2C_S_WR(x, v)        (HW_I2C_S(x).U = (v))
#define HW_I2C_S_SET(x, v)       (BME_OR8(HW_I2C_S_ADDR(x), (uint8_t)(v)))
#define HW_I2C_S_CLR(x, v)       (BME_AND8(HW_I2C_S_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_S_TOG(x, v)       (BME_XOR8(HW_I2C_S_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_S bitfields
 */

/*!
 * @name Register I2C_S, field RXAK[0] (RO)
 *
 * Values:
 * - 0 - Acknowledge signal was received after the completion of one byte of
 *     data transmission on the bus
 * - 1 - No acknowledge signal detected
 */
/*@{*/
#define BP_I2C_S_RXAK        (0U)          /*!< Bit position for I2C_S_RXAK. */
#define BM_I2C_S_RXAK        (0x01U)       /*!< Bit mask for I2C_S_RXAK. */
#define BS_I2C_S_RXAK        (1U)          /*!< Bit field size in bits for I2C_S_RXAK. */

/*! @brief Read current value of the I2C_S_RXAK field. */
#define BR_I2C_S_RXAK(x)     (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_RXAK, BS_I2C_S_RXAK))
/*@}*/

/*!
 * @name Register I2C_S, field IICIF[1] (W1C)
 *
 * This bit sets when an interrupt is pending. This bit must be cleared by
 * software by writing a 1 to it, such as in the interrupt routine. One of the
 * following events can set this bit: One byte transfer, including ACK/NACK bit,
 * completes. An ACK or NACK is sent on the bus by writing 0 or 1 to TXAK after this bit
 * is set in receive mode. Match of slave address to calling address including
 * primary slave address, range slave address or general call address. Arbitration
 * lost I2C bus stop detection if the STOPIE bit in the Input Glitch Filter
 * register is 1 To clear the I2C bus stop detection interrupt: In the interrupt
 * service routine, first clear the STOPF bit in the Input Glitch Filter register by
 * writing 1 to it, and then clear the IICIF bit. If this sequence is reversed,
 * the IICIF bit is asserted again.
 *
 * Values:
 * - 0 - No interrupt pending
 * - 1 - Interrupt pending
 */
/*@{*/
#define BP_I2C_S_IICIF       (1U)          /*!< Bit position for I2C_S_IICIF. */
#define BM_I2C_S_IICIF       (0x02U)       /*!< Bit mask for I2C_S_IICIF. */
#define BS_I2C_S_IICIF       (1U)          /*!< Bit field size in bits for I2C_S_IICIF. */

/*! @brief Read current value of the I2C_S_IICIF field. */
#define BR_I2C_S_IICIF(x)    (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_IICIF, BS_I2C_S_IICIF))

/*! @brief Format value for bitfield I2C_S_IICIF. */
#define BF_I2C_S_IICIF(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_S_IICIF) & BM_I2C_S_IICIF)

/*! @brief Set the IICIF field to a new value. */
#define BW_I2C_S_IICIF(x, v) (BME_BFI8(HW_I2C_S_ADDR(x), ((uint8_t)(v) << BP_I2C_S_IICIF), BP_I2C_S_IICIF, 1))
/*@}*/

/*!
 * @name Register I2C_S, field SRW[2] (RO)
 *
 * When addressed as a slave, SRW indicates the value of the R/W command bit of
 * the calling address sent to the master.
 *
 * Values:
 * - 0 - Slave receive, master writing to slave
 * - 1 - Slave transmit, master reading from slave
 */
/*@{*/
#define BP_I2C_S_SRW         (2U)          /*!< Bit position for I2C_S_SRW. */
#define BM_I2C_S_SRW         (0x04U)       /*!< Bit mask for I2C_S_SRW. */
#define BS_I2C_S_SRW         (1U)          /*!< Bit field size in bits for I2C_S_SRW. */

/*! @brief Read current value of the I2C_S_SRW field. */
#define BR_I2C_S_SRW(x)      (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_SRW, BS_I2C_S_SRW))
/*@}*/

/*!
 * @name Register I2C_S, field RAM[3] (RW)
 *
 * This bit is set to 1 by any of the following conditions: Any nonzero calling
 * address is received that matches the address in the RA register. The RMEN bit
 * is set and the calling address is within the range of values of the A1 and RA
 * registers. For the RAM bit to be set to 1 correctly, C1[IICIE] must be set to
 * 1. Writing the C1 register with any value clears this bit to 0.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
#define BP_I2C_S_RAM         (3U)          /*!< Bit position for I2C_S_RAM. */
#define BM_I2C_S_RAM         (0x08U)       /*!< Bit mask for I2C_S_RAM. */
#define BS_I2C_S_RAM         (1U)          /*!< Bit field size in bits for I2C_S_RAM. */

/*! @brief Read current value of the I2C_S_RAM field. */
#define BR_I2C_S_RAM(x)      (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_RAM, BS_I2C_S_RAM))

/*! @brief Format value for bitfield I2C_S_RAM. */
#define BF_I2C_S_RAM(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_S_RAM) & BM_I2C_S_RAM)

/*! @brief Set the RAM field to a new value. */
#define BW_I2C_S_RAM(x, v)   (BME_BFI8(HW_I2C_S_ADDR(x), ((uint8_t)(v) << BP_I2C_S_RAM), BP_I2C_S_RAM, 1))
/*@}*/

/*!
 * @name Register I2C_S, field ARBL[4] (W1C)
 *
 * This bit is set by hardware when the arbitration procedure is lost. The ARBL
 * bit must be cleared by software, by writing a one to it.
 *
 * Values:
 * - 0 - Standard bus operation.
 * - 1 - Loss of arbitration.
 */
/*@{*/
#define BP_I2C_S_ARBL        (4U)          /*!< Bit position for I2C_S_ARBL. */
#define BM_I2C_S_ARBL        (0x10U)       /*!< Bit mask for I2C_S_ARBL. */
#define BS_I2C_S_ARBL        (1U)          /*!< Bit field size in bits for I2C_S_ARBL. */

/*! @brief Read current value of the I2C_S_ARBL field. */
#define BR_I2C_S_ARBL(x)     (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_ARBL, BS_I2C_S_ARBL))

/*! @brief Format value for bitfield I2C_S_ARBL. */
#define BF_I2C_S_ARBL(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_S_ARBL) & BM_I2C_S_ARBL)

/*! @brief Set the ARBL field to a new value. */
#define BW_I2C_S_ARBL(x, v)  (BME_BFI8(HW_I2C_S_ADDR(x), ((uint8_t)(v) << BP_I2C_S_ARBL), BP_I2C_S_ARBL, 1))
/*@}*/

/*!
 * @name Register I2C_S, field BUSY[5] (RO)
 *
 * Indicates the status of the bus regardless of slave or master mode. This bit
 * is set when a START signal is detected and cleared when a STOP signal is
 * detected.
 *
 * Values:
 * - 0 - Bus is idle
 * - 1 - Bus is busy
 */
/*@{*/
#define BP_I2C_S_BUSY        (5U)          /*!< Bit position for I2C_S_BUSY. */
#define BM_I2C_S_BUSY        (0x20U)       /*!< Bit mask for I2C_S_BUSY. */
#define BS_I2C_S_BUSY        (1U)          /*!< Bit field size in bits for I2C_S_BUSY. */

/*! @brief Read current value of the I2C_S_BUSY field. */
#define BR_I2C_S_BUSY(x)     (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_BUSY, BS_I2C_S_BUSY))
/*@}*/

/*!
 * @name Register I2C_S, field IAAS[6] (RW)
 *
 * This bit is set by one of the following conditions: The calling address
 * matches the programmed slave primary address in the A1 register or range address in
 * the RA register (which must be set to a nonzero value). GCAEN is set and a
 * general call is received. RMEN is set and an address is received that is within
 * the range between the values of the A1 and RA registers. This bit sets before
 * the ACK bit. The CPU must check the SRW bit and set TX/RX accordingly. Writing
 * the C1 register with any value clears this bit.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
#define BP_I2C_S_IAAS        (6U)          /*!< Bit position for I2C_S_IAAS. */
#define BM_I2C_S_IAAS        (0x40U)       /*!< Bit mask for I2C_S_IAAS. */
#define BS_I2C_S_IAAS        (1U)          /*!< Bit field size in bits for I2C_S_IAAS. */

/*! @brief Read current value of the I2C_S_IAAS field. */
#define BR_I2C_S_IAAS(x)     (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_IAAS, BS_I2C_S_IAAS))

/*! @brief Format value for bitfield I2C_S_IAAS. */
#define BF_I2C_S_IAAS(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_S_IAAS) & BM_I2C_S_IAAS)

/*! @brief Set the IAAS field to a new value. */
#define BW_I2C_S_IAAS(x, v)  (BME_BFI8(HW_I2C_S_ADDR(x), ((uint8_t)(v) << BP_I2C_S_IAAS), BP_I2C_S_IAAS, 1))
/*@}*/

/*!
 * @name Register I2C_S, field TCF[7] (RO)
 *
 * This bit sets on the completion of a byte and acknowledge bit transfer. This
 * bit is valid only during or immediately following a transfer to or from the
 * I2C module. The TCF bit is cleared by reading the I2C data register in receive
 * mode or by writing to the I2C data register in transmit mode.
 *
 * Values:
 * - 0 - Transfer in progress
 * - 1 - Transfer complete
 */
/*@{*/
#define BP_I2C_S_TCF         (7U)          /*!< Bit position for I2C_S_TCF. */
#define BM_I2C_S_TCF         (0x80U)       /*!< Bit mask for I2C_S_TCF. */
#define BS_I2C_S_TCF         (1U)          /*!< Bit field size in bits for I2C_S_TCF. */

/*! @brief Read current value of the I2C_S_TCF field. */
#define BR_I2C_S_TCF(x)      (BME_UBFX8(HW_I2C_S_ADDR(x), BP_I2C_S_TCF, BS_I2C_S_TCF))
/*@}*/

/*******************************************************************************
 * HW_I2C_D - I2C Data I/O register
 ******************************************************************************/

/*!
 * @brief HW_I2C_D - I2C Data I/O register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_d
{
    uint8_t U;
    struct _hw_i2c_d_bitfields
    {
        uint8_t DATA : 8;              /*!< [7:0] Data */
    } B;
} hw_i2c_d_t;

/*!
 * @name Constants and macros for entire I2C_D register
 */
/*@{*/
#define HW_I2C_D_ADDR(x)         ((x) + 0x4U)

#define HW_I2C_D(x)              (*(__IO hw_i2c_d_t *) HW_I2C_D_ADDR(x))
#define HW_I2C_D_RD(x)           (HW_I2C_D(x).U)
#define HW_I2C_D_WR(x, v)        (HW_I2C_D(x).U = (v))
#define HW_I2C_D_SET(x, v)       (BME_OR8(HW_I2C_D_ADDR(x), (uint8_t)(v)))
#define HW_I2C_D_CLR(x, v)       (BME_AND8(HW_I2C_D_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_D_TOG(x, v)       (BME_XOR8(HW_I2C_D_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_D bitfields
 */

/*!
 * @name Register I2C_D, field DATA[7:0] (RW)
 *
 * In master transmit mode, when data is written to this register, a data
 * transfer is initiated. The most significant bit is sent first. In master receive
 * mode, reading this register initiates receiving of the next byte of data. When
 * making the transition out of master receive mode, switch the I2C mode before
 * reading the Data register to prevent an inadvertent initiation of a master
 * receive data transfer. In slave mode, the same functions are available after an
 * address match occurs. The C1[TX] bit must correctly reflect the desired direction
 * of transfer in master and slave modes for the transmission to begin. For
 * example, if the I2C module is configured for master transmit but a master receive
 * is desired, reading the Data register does not initiate the receive. Reading
 * the Data register returns the last byte received while the I2C module is
 * configured in master receive or slave receive mode. The Data register does not
 * reflect every byte that is transmitted on the I2C bus, and neither can software
 * verify that a byte has been written to the Data register correctly by reading it
 * back. In master transmit mode, the first byte of data written to the Data
 * register following assertion of MST (start bit) or assertion of RSTA (repeated
 * start bit) is used for the address transfer and must consist of the calling
 * address (in bits 7-1) concatenated with the required R/W bit (in position bit 0).
 */
/*@{*/
#define BP_I2C_D_DATA        (0U)          /*!< Bit position for I2C_D_DATA. */
#define BM_I2C_D_DATA        (0xFFU)       /*!< Bit mask for I2C_D_DATA. */
#define BS_I2C_D_DATA        (8U)          /*!< Bit field size in bits for I2C_D_DATA. */

/*! @brief Read current value of the I2C_D_DATA field. */
#define BR_I2C_D_DATA(x)     (HW_I2C_D(x).U)

/*! @brief Format value for bitfield I2C_D_DATA. */
#define BF_I2C_D_DATA(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_D_DATA) & BM_I2C_D_DATA)

/*! @brief Set the DATA field to a new value. */
#define BW_I2C_D_DATA(x, v)  (HW_I2C_D_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_I2C_C2 - I2C Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_I2C_C2 - I2C Control Register 2 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_c2
{
    uint8_t U;
    struct _hw_i2c_c2_bitfields
    {
        uint8_t AD : 3;                /*!< [2:0] Slave Address */
        uint8_t RMEN : 1;              /*!< [3] Range Address Matching Enable */
        uint8_t SBRC : 1;              /*!< [4] Slave Baud Rate Control */
        uint8_t HDRS : 1;              /*!< [5] High Drive Select */
        uint8_t ADEXT : 1;             /*!< [6] Address Extension */
        uint8_t GCAEN : 1;             /*!< [7] General Call Address Enable */
    } B;
} hw_i2c_c2_t;

/*!
 * @name Constants and macros for entire I2C_C2 register
 */
/*@{*/
#define HW_I2C_C2_ADDR(x)        ((x) + 0x5U)

#define HW_I2C_C2(x)             (*(__IO hw_i2c_c2_t *) HW_I2C_C2_ADDR(x))
#define HW_I2C_C2_RD(x)          (HW_I2C_C2(x).U)
#define HW_I2C_C2_WR(x, v)       (HW_I2C_C2(x).U = (v))
#define HW_I2C_C2_SET(x, v)      (BME_OR8(HW_I2C_C2_ADDR(x), (uint8_t)(v)))
#define HW_I2C_C2_CLR(x, v)      (BME_AND8(HW_I2C_C2_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_C2_TOG(x, v)      (BME_XOR8(HW_I2C_C2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_C2 bitfields
 */

/*!
 * @name Register I2C_C2, field AD[2:0] (RW)
 *
 * Contains the upper three bits of the slave address in the 10-bit address
 * scheme. This field is valid only while the ADEXT bit is set.
 */
/*@{*/
#define BP_I2C_C2_AD         (0U)          /*!< Bit position for I2C_C2_AD. */
#define BM_I2C_C2_AD         (0x07U)       /*!< Bit mask for I2C_C2_AD. */
#define BS_I2C_C2_AD         (3U)          /*!< Bit field size in bits for I2C_C2_AD. */

/*! @brief Read current value of the I2C_C2_AD field. */
#define BR_I2C_C2_AD(x)      (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_AD, BS_I2C_C2_AD))

/*! @brief Format value for bitfield I2C_C2_AD. */
#define BF_I2C_C2_AD(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_C2_AD) & BM_I2C_C2_AD)

/*! @brief Set the AD field to a new value. */
#define BW_I2C_C2_AD(x, v)   (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_AD), BP_I2C_C2_AD, 3))
/*@}*/

/*!
 * @name Register I2C_C2, field RMEN[3] (RW)
 *
 * This bit controls slave address matching for addresses between the values of
 * the A1 and RA registers. When this bit is set, a slave address match occurs
 * for any address greater than the value of the A1 register and less than or equal
 * to the value of the RA register.
 *
 * Values:
 * - 0 - Range mode disabled. No address match occurs for an address within the
 *     range of values of the A1 and RA registers.
 * - 1 - Range mode enabled. Address matching occurs when a slave receives an
 *     address within the range of values of the A1 and RA registers.
 */
/*@{*/
#define BP_I2C_C2_RMEN       (3U)          /*!< Bit position for I2C_C2_RMEN. */
#define BM_I2C_C2_RMEN       (0x08U)       /*!< Bit mask for I2C_C2_RMEN. */
#define BS_I2C_C2_RMEN       (1U)          /*!< Bit field size in bits for I2C_C2_RMEN. */

/*! @brief Read current value of the I2C_C2_RMEN field. */
#define BR_I2C_C2_RMEN(x)    (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_RMEN, BS_I2C_C2_RMEN))

/*! @brief Format value for bitfield I2C_C2_RMEN. */
#define BF_I2C_C2_RMEN(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C2_RMEN) & BM_I2C_C2_RMEN)

/*! @brief Set the RMEN field to a new value. */
#define BW_I2C_C2_RMEN(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_RMEN), BP_I2C_C2_RMEN, 1))
/*@}*/

/*!
 * @name Register I2C_C2, field SBRC[4] (RW)
 *
 * Enables independent slave mode baud rate at maximum frequency, which forces
 * clock stretching on SCL in very fast I2C modes. To a slave, an example of a
 * "very fast" mode is when the master transfers at 40 kbps but the slave can
 * capture the master's data at only 10 kbps.
 *
 * Values:
 * - 0 - The slave baud rate follows the master baud rate and clock stretching
 *     may occur
 * - 1 - Slave baud rate is independent of the master baud rate
 */
/*@{*/
#define BP_I2C_C2_SBRC       (4U)          /*!< Bit position for I2C_C2_SBRC. */
#define BM_I2C_C2_SBRC       (0x10U)       /*!< Bit mask for I2C_C2_SBRC. */
#define BS_I2C_C2_SBRC       (1U)          /*!< Bit field size in bits for I2C_C2_SBRC. */

/*! @brief Read current value of the I2C_C2_SBRC field. */
#define BR_I2C_C2_SBRC(x)    (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_SBRC, BS_I2C_C2_SBRC))

/*! @brief Format value for bitfield I2C_C2_SBRC. */
#define BF_I2C_C2_SBRC(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C2_SBRC) & BM_I2C_C2_SBRC)

/*! @brief Set the SBRC field to a new value. */
#define BW_I2C_C2_SBRC(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_SBRC), BP_I2C_C2_SBRC, 1))
/*@}*/

/*!
 * @name Register I2C_C2, field HDRS[5] (RW)
 *
 * Controls the drive capability of the I2C pads.
 *
 * Values:
 * - 0 - Normal drive mode
 * - 1 - High drive mode
 */
/*@{*/
#define BP_I2C_C2_HDRS       (5U)          /*!< Bit position for I2C_C2_HDRS. */
#define BM_I2C_C2_HDRS       (0x20U)       /*!< Bit mask for I2C_C2_HDRS. */
#define BS_I2C_C2_HDRS       (1U)          /*!< Bit field size in bits for I2C_C2_HDRS. */

/*! @brief Read current value of the I2C_C2_HDRS field. */
#define BR_I2C_C2_HDRS(x)    (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_HDRS, BS_I2C_C2_HDRS))

/*! @brief Format value for bitfield I2C_C2_HDRS. */
#define BF_I2C_C2_HDRS(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C2_HDRS) & BM_I2C_C2_HDRS)

/*! @brief Set the HDRS field to a new value. */
#define BW_I2C_C2_HDRS(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_HDRS), BP_I2C_C2_HDRS, 1))
/*@}*/

/*!
 * @name Register I2C_C2, field ADEXT[6] (RW)
 *
 * Controls the number of bits used for the slave address.
 *
 * Values:
 * - 0 - 7-bit address scheme
 * - 1 - 10-bit address scheme
 */
/*@{*/
#define BP_I2C_C2_ADEXT      (6U)          /*!< Bit position for I2C_C2_ADEXT. */
#define BM_I2C_C2_ADEXT      (0x40U)       /*!< Bit mask for I2C_C2_ADEXT. */
#define BS_I2C_C2_ADEXT      (1U)          /*!< Bit field size in bits for I2C_C2_ADEXT. */

/*! @brief Read current value of the I2C_C2_ADEXT field. */
#define BR_I2C_C2_ADEXT(x)   (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_ADEXT, BS_I2C_C2_ADEXT))

/*! @brief Format value for bitfield I2C_C2_ADEXT. */
#define BF_I2C_C2_ADEXT(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C2_ADEXT) & BM_I2C_C2_ADEXT)

/*! @brief Set the ADEXT field to a new value. */
#define BW_I2C_C2_ADEXT(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_ADEXT), BP_I2C_C2_ADEXT, 1))
/*@}*/

/*!
 * @name Register I2C_C2, field GCAEN[7] (RW)
 *
 * Enables general call address.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_I2C_C2_GCAEN      (7U)          /*!< Bit position for I2C_C2_GCAEN. */
#define BM_I2C_C2_GCAEN      (0x80U)       /*!< Bit mask for I2C_C2_GCAEN. */
#define BS_I2C_C2_GCAEN      (1U)          /*!< Bit field size in bits for I2C_C2_GCAEN. */

/*! @brief Read current value of the I2C_C2_GCAEN field. */
#define BR_I2C_C2_GCAEN(x)   (BME_UBFX8(HW_I2C_C2_ADDR(x), BP_I2C_C2_GCAEN, BS_I2C_C2_GCAEN))

/*! @brief Format value for bitfield I2C_C2_GCAEN. */
#define BF_I2C_C2_GCAEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C2_GCAEN) & BM_I2C_C2_GCAEN)

/*! @brief Set the GCAEN field to a new value. */
#define BW_I2C_C2_GCAEN(x, v) (BME_BFI8(HW_I2C_C2_ADDR(x), ((uint8_t)(v) << BP_I2C_C2_GCAEN), BP_I2C_C2_GCAEN, 1))
/*@}*/

/*******************************************************************************
 * HW_I2C_FLT - I2C Programmable Input Glitch Filter register
 ******************************************************************************/

/*!
 * @brief HW_I2C_FLT - I2C Programmable Input Glitch Filter register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_flt
{
    uint8_t U;
    struct _hw_i2c_flt_bitfields
    {
        uint8_t FLT : 5;               /*!< [4:0] I2C Programmable Filter Factor */
        uint8_t STOPIE : 1;            /*!< [5] I2C Bus Stop Interrupt Enable */
        uint8_t STOPF : 1;             /*!< [6] I2C Bus Stop Detect Flag */
        uint8_t SHEN : 1;              /*!< [7] Stop Hold Enable */
    } B;
} hw_i2c_flt_t;

/*!
 * @name Constants and macros for entire I2C_FLT register
 */
/*@{*/
#define HW_I2C_FLT_ADDR(x)       ((x) + 0x6U)

#define HW_I2C_FLT(x)            (*(__IO hw_i2c_flt_t *) HW_I2C_FLT_ADDR(x))
#define HW_I2C_FLT_RD(x)         (HW_I2C_FLT(x).U)
#define HW_I2C_FLT_WR(x, v)      (HW_I2C_FLT(x).U = (v))
#define HW_I2C_FLT_SET(x, v)     (BME_OR8(HW_I2C_FLT_ADDR(x), (uint8_t)(v)))
#define HW_I2C_FLT_CLR(x, v)     (BME_AND8(HW_I2C_FLT_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_FLT_TOG(x, v)     (BME_XOR8(HW_I2C_FLT_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_FLT bitfields
 */

/*!
 * @name Register I2C_FLT, field FLT[4:0] (RW)
 *
 * Controls the width of the glitch, in terms of bus clock cycles, that the
 * filter must absorb. For any glitch whose size is less than or equal to this width
 * setting, the filter does not allow the glitch to pass.
 *
 * Values:
 * - 0 - No filter/bypass
 */
/*@{*/
#define BP_I2C_FLT_FLT       (0U)          /*!< Bit position for I2C_FLT_FLT. */
#define BM_I2C_FLT_FLT       (0x1FU)       /*!< Bit mask for I2C_FLT_FLT. */
#define BS_I2C_FLT_FLT       (5U)          /*!< Bit field size in bits for I2C_FLT_FLT. */

/*! @brief Read current value of the I2C_FLT_FLT field. */
#define BR_I2C_FLT_FLT(x)    (BME_UBFX8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_FLT, BS_I2C_FLT_FLT))

/*! @brief Format value for bitfield I2C_FLT_FLT. */
#define BF_I2C_FLT_FLT(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_FLT) & BM_I2C_FLT_FLT)

/*! @brief Set the FLT field to a new value. */
#define BW_I2C_FLT_FLT(x, v) (BME_BFI8(HW_I2C_FLT_ADDR(x), ((uint8_t)(v) << BP_I2C_FLT_FLT), BP_I2C_FLT_FLT, 5))
/*@}*/

/*!
 * @name Register I2C_FLT, field STOPIE[5] (RW)
 *
 * This bit enables the interrupt for I2C bus stop detection. To clear the I2C
 * bus stop detection interrupt: In the interrupt service routine, first clear the
 * STOPF bit by writing 1 to it, and then clear the IICIF bit in the status
 * register. If this sequence is reversed, the IICIF bit is asserted again.
 *
 * Values:
 * - 0 - Stop detection interrupt is disabled
 * - 1 - Stop detection interrupt is enabled
 */
/*@{*/
#define BP_I2C_FLT_STOPIE    (5U)          /*!< Bit position for I2C_FLT_STOPIE. */
#define BM_I2C_FLT_STOPIE    (0x20U)       /*!< Bit mask for I2C_FLT_STOPIE. */
#define BS_I2C_FLT_STOPIE    (1U)          /*!< Bit field size in bits for I2C_FLT_STOPIE. */

/*! @brief Read current value of the I2C_FLT_STOPIE field. */
#define BR_I2C_FLT_STOPIE(x) (BME_UBFX8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_STOPIE, BS_I2C_FLT_STOPIE))

/*! @brief Format value for bitfield I2C_FLT_STOPIE. */
#define BF_I2C_FLT_STOPIE(v) ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_STOPIE) & BM_I2C_FLT_STOPIE)

/*! @brief Set the STOPIE field to a new value. */
#define BW_I2C_FLT_STOPIE(x, v) (BME_BFI8(HW_I2C_FLT_ADDR(x), ((uint8_t)(v) << BP_I2C_FLT_STOPIE), BP_I2C_FLT_STOPIE, 1))
/*@}*/

/*!
 * @name Register I2C_FLT, field STOPF[6] (W1C)
 *
 * Hardware sets this bit when the I2C bus's stop status is detected. The STOPF
 * bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No stop happens on I2C bus
 * - 1 - Stop detected on I2C bus
 */
/*@{*/
#define BP_I2C_FLT_STOPF     (6U)          /*!< Bit position for I2C_FLT_STOPF. */
#define BM_I2C_FLT_STOPF     (0x40U)       /*!< Bit mask for I2C_FLT_STOPF. */
#define BS_I2C_FLT_STOPF     (1U)          /*!< Bit field size in bits for I2C_FLT_STOPF. */

/*! @brief Read current value of the I2C_FLT_STOPF field. */
#define BR_I2C_FLT_STOPF(x)  (BME_UBFX8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_STOPF, BS_I2C_FLT_STOPF))

/*! @brief Format value for bitfield I2C_FLT_STOPF. */
#define BF_I2C_FLT_STOPF(v)  ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_STOPF) & BM_I2C_FLT_STOPF)

/*! @brief Set the STOPF field to a new value. */
#define BW_I2C_FLT_STOPF(x, v) (BME_BFI8(HW_I2C_FLT_ADDR(x), ((uint8_t)(v) << BP_I2C_FLT_STOPF), BP_I2C_FLT_STOPF, 1))
/*@}*/

/*!
 * @name Register I2C_FLT, field SHEN[7] (RW)
 *
 * Set this bit to hold off entry to stop mode when any data transmission or
 * reception is occurring. The following scenario explains the holdoff
 * functionality: The I2C module is configured for a basic transfer, and the SHEN bit is set
 * to 1. A transfer begins. The MCU signals the I2C module to enter stop mode. The
 * byte currently being transferred, including both address and data, completes
 * its transfer. The I2C slave or master acknowledges that the in-transfer byte
 * completed its transfer and acknowledges the request to enter stop mode. After
 * receiving the I2C module's acknowledgment of the request to enter stop mode,
 * the MCU determines whether to shut off the I2C module's clock. If the SHEN bit
 * is set to 1 and the I2C module is in an idle or disabled state when the MCU
 * signals to enter stop mode, the module immediately acknowledges the request to
 * enter stop mode. If SHEN is cleared to 0 and the overall data transmission or
 * reception that was suspended by stop mode entry was incomplete: To resume the
 * overall transmission or reception after the MCU exits stop mode, software must
 * reinitialize the transfer by resending the address of the slave. If the I2C
 * Control Register 1's IICIE bit was set to 1 before the MCU entered stop mode,
 * system software will receive the interrupt triggered by the I2C Status Register's
 * TCF bit after the MCU wakes from the stop mode.
 *
 * Values:
 * - 0 - Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
 * - 1 - Stop holdoff is enabled.
 */
/*@{*/
#define BP_I2C_FLT_SHEN      (7U)          /*!< Bit position for I2C_FLT_SHEN. */
#define BM_I2C_FLT_SHEN      (0x80U)       /*!< Bit mask for I2C_FLT_SHEN. */
#define BS_I2C_FLT_SHEN      (1U)          /*!< Bit field size in bits for I2C_FLT_SHEN. */

/*! @brief Read current value of the I2C_FLT_SHEN field. */
#define BR_I2C_FLT_SHEN(x)   (BME_UBFX8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_SHEN, BS_I2C_FLT_SHEN))

/*! @brief Format value for bitfield I2C_FLT_SHEN. */
#define BF_I2C_FLT_SHEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_SHEN) & BM_I2C_FLT_SHEN)

/*! @brief Set the SHEN field to a new value. */
#define BW_I2C_FLT_SHEN(x, v) (BME_BFI8(HW_I2C_FLT_ADDR(x), ((uint8_t)(v) << BP_I2C_FLT_SHEN), BP_I2C_FLT_SHEN, 1))
/*@}*/

/*******************************************************************************
 * HW_I2C_RA - I2C Range Address register
 ******************************************************************************/

/*!
 * @brief HW_I2C_RA - I2C Range Address register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_ra
{
    uint8_t U;
    struct _hw_i2c_ra_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t RAD : 7;               /*!< [7:1] Range Slave Address */
    } B;
} hw_i2c_ra_t;

/*!
 * @name Constants and macros for entire I2C_RA register
 */
/*@{*/
#define HW_I2C_RA_ADDR(x)        ((x) + 0x7U)

#define HW_I2C_RA(x)             (*(__IO hw_i2c_ra_t *) HW_I2C_RA_ADDR(x))
#define HW_I2C_RA_RD(x)          (HW_I2C_RA(x).U)
#define HW_I2C_RA_WR(x, v)       (HW_I2C_RA(x).U = (v))
#define HW_I2C_RA_SET(x, v)      (BME_OR8(HW_I2C_RA_ADDR(x), (uint8_t)(v)))
#define HW_I2C_RA_CLR(x, v)      (BME_AND8(HW_I2C_RA_ADDR(x), (uint8_t)(~(v))))
#define HW_I2C_RA_TOG(x, v)      (BME_XOR8(HW_I2C_RA_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual I2C_RA bitfields
 */

/*!
 * @name Register I2C_RA, field RAD[7:1] (RW)
 *
 * This field contains the slave address to be used by the I2C module. The field
 * is used in the 7-bit address scheme. Any nonzero write enables this register.
 * This register's use is similar to that of the A1 register, but in addition
 * this register can be considered a maximum boundary in range matching mode.
 */
/*@{*/
#define BP_I2C_RA_RAD        (1U)          /*!< Bit position for I2C_RA_RAD. */
#define BM_I2C_RA_RAD        (0xFEU)       /*!< Bit mask for I2C_RA_RAD. */
#define BS_I2C_RA_RAD        (7U)          /*!< Bit field size in bits for I2C_RA_RAD. */

/*! @brief Read current value of the I2C_RA_RAD field. */
#define BR_I2C_RA_RAD(x)     (BME_UBFX8(HW_I2C_RA_ADDR(x), BP_I2C_RA_RAD, BS_I2C_RA_RAD))

/*! @brief Format value for bitfield I2C_RA_RAD. */
#define BF_I2C_RA_RAD(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_RA_RAD) & BM_I2C_RA_RAD)

/*! @brief Set the RAD field to a new value. */
#define BW_I2C_RA_RAD(x, v)  (BME_BFI8(HW_I2C_RA_ADDR(x), ((uint8_t)(v) << BP_I2C_RA_RAD), BP_I2C_RA_RAD, 7))
/*@}*/

/*******************************************************************************
 * hw_i2c_t - module struct
 ******************************************************************************/
/*!
 * @brief All I2C module registers.
 */
#pragma pack(1)
typedef struct _hw_i2c
{
    __IO hw_i2c_a1_t A1;                   /*!< [0x0] I2C Address Register 1 */
    __IO hw_i2c_f_t F;                     /*!< [0x1] I2C Frequency Divider register */
    __IO hw_i2c_c1_t C1;                   /*!< [0x2] I2C Control Register 1 */
    __IO hw_i2c_s_t S;                     /*!< [0x3] I2C Status register */
    __IO hw_i2c_d_t D;                     /*!< [0x4] I2C Data I/O register */
    __IO hw_i2c_c2_t C2;                   /*!< [0x5] I2C Control Register 2 */
    __IO hw_i2c_flt_t FLT;                 /*!< [0x6] I2C Programmable Input Glitch Filter register */
    __IO hw_i2c_ra_t RA;                   /*!< [0x7] I2C Range Address register */
} hw_i2c_t;
#pragma pack()

/*! @brief Macro to access all I2C registers. */
/*! @param x I2C module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_I2C(I2C0_BASE)</code>. */
#define HW_I2C(x)      (*(hw_i2c_t *)(x))

#endif /* __HW_I2C_REGISTERS_H__ */
/* v33/140401/2.1.0 */
/* EOF */

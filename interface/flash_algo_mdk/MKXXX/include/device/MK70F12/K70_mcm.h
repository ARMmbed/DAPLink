/*
 * Copyright (c) 2013, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_MCM_REGISTERS_H__
#define __HW_MCM_REGISTERS_H__

#include "regs.h"

/*
 * K70 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - HW_MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 * - HW_MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 * - HW_MCM_CR - Control Register
 * - HW_MCM_IS_C_R - Interrupt Status and Control Register
 * - HW_MCM_ETBCC - ETB Counter Control register
 * - HW_MCM_ETBRL - ETB Reload register
 * - HW_MCM_ETBCNT - ETB Counter Value register
 * - HW_MCM_FADR - Fault address register
 * - HW_MCM_FATR - Fault attributes register
 * - HW_MCM_FDR - Fault data register
 * - HW_MCM_PID - Process ID register
 *
 * - hw_mcm_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_MCM_BASE
#define HW_MCM_INSTANCE_COUNT (1U) //!< Number of instances of the MCM module.
#define REGS_MCM_BASE (0xe0080000U) //!< Base address for MCM.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration (RO)
 *
 * Reset value: 0x001fU
 *
 * PLASC is a 16-bit read-only register identifying the presence/absence of bus slave connections to
 * the device’s crossbar switch.
 */
typedef union _hw_mcm_plasc
{
    uint16_t U;
    struct _hw_mcm_plasc_bitfields
    {
        uint16_t ASC : 8; //!< [7:0] Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
        uint16_t RESERVED0 : 8; //!< [15:8] 
    } B;
} hw_mcm_plasc_t;
#endif

/*!
 * @name Constants and macros for entire MCM_PLASC register
 */
//@{
#define HW_MCM_PLASC_ADDR      (REGS_MCM_BASE + 0x8U)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_PLASC           (*(__I hw_mcm_plasc_t *) HW_MCM_PLASC_ADDR)
#define HW_MCM_PLASC_RD()      (HW_MCM_PLASC.U)
#endif
//@}

/*
 * constants & macros for individual MCM_PLASC bitfields
 */

/*! @name Register MCM_PLASC, field ASC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus slave connection to AXBS input port n is absent
 * - 1 - A bus slave connection to AXBS input port n is present
 */
//@{
#define BP_MCM_PLASC_ASC      (0U)      //!< Bit position for MCM_PLASC_ASC.
#define BM_MCM_PLASC_ASC      (0x00ffU)  //!< Bit mask for MCM_PLASC_ASC.
#define BS_MCM_PLASC_ASC      (8U)  //!< Bitfield size in bits for MCM_PLASC_ASC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_PLASC_ASC field.
#define BR_MCM_PLASC_ASC()   (HW_MCM_PLASC.B.ASC)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration (RO)
 *
 * Reset value: 0x003fU
 *
 * PLAMC is a 16-bit read-only register identifying the presence/absence of bus master connections
 * to the device's crossbar switch.
 */
typedef union _hw_mcm_plamc
{
    uint16_t U;
    struct _hw_mcm_plamc_bitfields
    {
        uint16_t AMC : 8; //!< [7:0] Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
        uint16_t RESERVED0 : 8; //!< [15:8] 
    } B;
} hw_mcm_plamc_t;
#endif

/*!
 * @name Constants and macros for entire MCM_PLAMC register
 */
//@{
#define HW_MCM_PLAMC_ADDR      (REGS_MCM_BASE + 0xaU)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_PLAMC           (*(__I hw_mcm_plamc_t *) HW_MCM_PLAMC_ADDR)
#define HW_MCM_PLAMC_RD()      (HW_MCM_PLAMC.U)
#endif
//@}

/*
 * constants & macros for individual MCM_PLAMC bitfields
 */

/*! @name Register MCM_PLAMC, field AMC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus master connection to AXBS input port n is absent
 * - 1 - A bus master connection to AXBS input port n is present
 */
//@{
#define BP_MCM_PLAMC_AMC      (0U)      //!< Bit position for MCM_PLAMC_AMC.
#define BM_MCM_PLAMC_AMC      (0x00ffU)  //!< Bit mask for MCM_PLAMC_AMC.
#define BS_MCM_PLAMC_AMC      (8U)  //!< Bitfield size in bits for MCM_PLAMC_AMC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_PLAMC_AMC field.
#define BR_MCM_PLAMC_AMC()   (HW_MCM_PLAMC.B.AMC)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_CR - Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * CR defines the arbitration and protection schemes for the two system RAM arrays. Bits 23- 22, 19-
 * 0 are undefined after reset.
 */
typedef union _hw_mcm_cr
{
    uint32_t U;
    struct _hw_mcm_cr_bitfields
    {
        uint32_t RESERVED1 : 20; //!< [19:0] Reserved.
        uint32_t DDRSIZE : 2; //!< [21:20] DDR address size translation
        uint32_t RESERVED2 : 2; //!< [23:22] 
        uint32_t SRAMUAP : 2; //!< [25:24] SRAM_U arbitration priority
        uint32_t SRAMUWP : 1; //!< [26] SRAM_U write protect
        uint32_t RESERVED3 : 1; //!< [27] 
        uint32_t SRAMLAP : 2; //!< [29:28] SRAM_L arbitration priority
        uint32_t SRAMLWP : 1; //!< [30] SRAM_L Write Protect
        uint32_t RESERVED4 : 1; //!< [31] 
    } B;
} hw_mcm_cr_t;
#endif

/*!
 * @name Constants and macros for entire MCM_CR register
 */
//@{
#define HW_MCM_CR_ADDR      (REGS_MCM_BASE + 0xcU)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_CR           (*(__IO hw_mcm_cr_t *) HW_MCM_CR_ADDR)
#define HW_MCM_CR_RD()      (HW_MCM_CR.U)
#define HW_MCM_CR_WR(v)     (HW_MCM_CR.U = (v))
#define HW_MCM_CR_SET(v)    (HW_MCM_CR_WR(HW_MCM_CR_RD() |  (v)))
#define HW_MCM_CR_CLR(v)    (HW_MCM_CR_WR(HW_MCM_CR_RD() & ~(v)))
#define HW_MCM_CR_TOG(v)    (HW_MCM_CR_WR(HW_MCM_CR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual MCM_CR bitfields
 */

/*! @name Register MCM_CR, field DDRSIZE[21:20] (RW)
 *
 * Values:
 * - 00 - DDR address translation is disabled
 * - 01 - DDR size is 128 Mbytes
 * - 10 - DDR size is 256 Mbytes
 * - 11 - DDR size is 512 Mbytes
 */
//@{
#define BP_MCM_CR_DDRSIZE      (20U)      //!< Bit position for MCM_CR_DDRSIZE.
#define BM_MCM_CR_DDRSIZE      (0x00300000U)  //!< Bit mask for MCM_CR_DDRSIZE.
#define BS_MCM_CR_DDRSIZE      (2U)  //!< Bitfield size in bits for MCM_CR_DDRSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_CR_DDRSIZE field.
#define BR_MCM_CR_DDRSIZE()   (HW_MCM_CR.B.DDRSIZE)
#endif

//! @brief Format value for bitfield MCM_CR_DDRSIZE.
#define BF_MCM_CR_DDRSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_CR_DDRSIZE), uint32_t) & BM_MCM_CR_DDRSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DDRSIZE field to a new value.
#define BW_MCM_CR_DDRSIZE(v)   (HW_MCM_CR_WR((HW_MCM_CR_RD() & ~BM_MCM_CR_DDRSIZE) | BF_MCM_CR_DDRSIZE(v)))
#endif
//@}

/*! @name Register MCM_CR, field SRAMUAP[25:24] (RW)
 *
 * Defines the arbitration scheme and priority for the processor and SRAM backdoor accesses to the
 * SRAM_U array.
 *
 * Values:
 * - 00 - Round robin
 * - 01 - Special round robin (favors SRAM backoor accesses over the processor)
 * - 10 - Fixed priority. Processor has highest, backdoor has lowest
 * - 11 - Fixed priority. Backdoor has highest, processor has lowest
 */
//@{
#define BP_MCM_CR_SRAMUAP      (24U)      //!< Bit position for MCM_CR_SRAMUAP.
#define BM_MCM_CR_SRAMUAP      (0x03000000U)  //!< Bit mask for MCM_CR_SRAMUAP.
#define BS_MCM_CR_SRAMUAP      (2U)  //!< Bitfield size in bits for MCM_CR_SRAMUAP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_CR_SRAMUAP field.
#define BR_MCM_CR_SRAMUAP()   (HW_MCM_CR.B.SRAMUAP)
#endif

//! @brief Format value for bitfield MCM_CR_SRAMUAP.
#define BF_MCM_CR_SRAMUAP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_CR_SRAMUAP), uint32_t) & BM_MCM_CR_SRAMUAP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SRAMUAP field to a new value.
#define BW_MCM_CR_SRAMUAP(v)   (HW_MCM_CR_WR((HW_MCM_CR_RD() & ~BM_MCM_CR_SRAMUAP) | BF_MCM_CR_SRAMUAP(v)))
#endif
//@}

/*! @name Register MCM_CR, field SRAMUWP[26] (RW)
 *
 * When this bit is set, writes to SRAM_U array generates a bus error.
 */
//@{
#define BP_MCM_CR_SRAMUWP      (26U)      //!< Bit position for MCM_CR_SRAMUWP.
#define BM_MCM_CR_SRAMUWP      (0x04000000U)  //!< Bit mask for MCM_CR_SRAMUWP.
#define BS_MCM_CR_SRAMUWP      (1U)  //!< Bitfield size in bits for MCM_CR_SRAMUWP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_CR_SRAMUWP field.
#define BR_MCM_CR_SRAMUWP()   (BITBAND_ACCESS32(HW_MCM_CR_ADDR, BP_MCM_CR_SRAMUWP))
#endif

//! @brief Format value for bitfield MCM_CR_SRAMUWP.
#define BF_MCM_CR_SRAMUWP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_CR_SRAMUWP), uint32_t) & BM_MCM_CR_SRAMUWP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SRAMUWP field to a new value.
#define BW_MCM_CR_SRAMUWP(v)   (BITBAND_ACCESS32(HW_MCM_CR_ADDR, BP_MCM_CR_SRAMUWP) = (v))
#endif
//@}

/*! @name Register MCM_CR, field SRAMLAP[29:28] (RW)
 *
 * Defines the arbitration scheme and priority for the processor and SRAM backdoor accesses to the
 * SRAM_L array.
 *
 * Values:
 * - 00 - Round robin
 * - 01 - Special round robin (favors SRAM backoor accesses over the processor)
 * - 10 - Fixed priority. Processor has highest, backdoor has lowest
 * - 11 - Fixed priority. Backdoor has highest, processor has lowest
 */
//@{
#define BP_MCM_CR_SRAMLAP      (28U)      //!< Bit position for MCM_CR_SRAMLAP.
#define BM_MCM_CR_SRAMLAP      (0x30000000U)  //!< Bit mask for MCM_CR_SRAMLAP.
#define BS_MCM_CR_SRAMLAP      (2U)  //!< Bitfield size in bits for MCM_CR_SRAMLAP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_CR_SRAMLAP field.
#define BR_MCM_CR_SRAMLAP()   (HW_MCM_CR.B.SRAMLAP)
#endif

//! @brief Format value for bitfield MCM_CR_SRAMLAP.
#define BF_MCM_CR_SRAMLAP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_CR_SRAMLAP), uint32_t) & BM_MCM_CR_SRAMLAP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SRAMLAP field to a new value.
#define BW_MCM_CR_SRAMLAP(v)   (HW_MCM_CR_WR((HW_MCM_CR_RD() & ~BM_MCM_CR_SRAMLAP) | BF_MCM_CR_SRAMLAP(v)))
#endif
//@}

/*! @name Register MCM_CR, field SRAMLWP[30] (RW)
 *
 * When this bit is set, writes to SRAM_L array generates a bus error.
 */
//@{
#define BP_MCM_CR_SRAMLWP      (30U)      //!< Bit position for MCM_CR_SRAMLWP.
#define BM_MCM_CR_SRAMLWP      (0x40000000U)  //!< Bit mask for MCM_CR_SRAMLWP.
#define BS_MCM_CR_SRAMLWP      (1U)  //!< Bitfield size in bits for MCM_CR_SRAMLWP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_CR_SRAMLWP field.
#define BR_MCM_CR_SRAMLWP()   (BITBAND_ACCESS32(HW_MCM_CR_ADDR, BP_MCM_CR_SRAMLWP))
#endif

//! @brief Format value for bitfield MCM_CR_SRAMLWP.
#define BF_MCM_CR_SRAMLWP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_CR_SRAMLWP), uint32_t) & BM_MCM_CR_SRAMLWP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SRAMLWP field to a new value.
#define BW_MCM_CR_SRAMLWP(v)   (BITBAND_ACCESS32(HW_MCM_CR_ADDR, BP_MCM_CR_SRAMLWP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_IS_C_R - Interrupt Status and Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_IS_C_R - Interrupt Status and Control Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The MCM_ISCR register defines the configuration and reports status for a number of core-related
 * interrupt exception conditions. It includes the enable and status bits associated with the core’s
 * floating-point exceptions, bus errors associated with the core’s cache write buffer, and events
 * associated with the debug ETB module. The individual event indicators are first qualified with
 * their exception enables and then logically summed to form an interrupt request sent to the core’s
 * NVIC. Bits 15-8 are read-only indicator flags based on the processor’s FPSCR register. Attempted
 * writes to these bits are ignored. Once set, the flags remain asserted until software clears the
 * corresponding FPSCR bit.
 */
typedef union _hw_mcm_is_c_r
{
    uint32_t U;
    struct _hw_mcm_is_c_r_bitfields
    {
        uint32_t RESERVED0 : 1; //!< [0] 
        uint32_t IRQ : 1; //!< [1] Normal Interrupt Pending
        uint32_t NMI : 1; //!< [2] Non-maskable Interrupt Pending
        uint32_t DHREQ : 1; //!< [3] Debug Halt Request Indicator
        uint32_t CWBER : 1; //!< [4] Cache write buffer error status
        uint32_t RESERVED1 : 3; //!< [7:5] 
        uint32_t FIOC : 1; //!< [8] FPU invalid operation interrupt status
        uint32_t FDZC : 1; //!< [9] FPU divide-by-zero interrupt status
        uint32_t FOFC : 1; //!< [10] FPU overflow interrupt status
        uint32_t FUFC : 1; //!< [11] FPU underflow interrupt status
        uint32_t FIXC : 1; //!< [12] FPU inexact interrupt status
        uint32_t RESERVED2 : 2; //!< [14:13] 
        uint32_t FIDC : 1; //!< [15] FPU input denormal interrupt status
        uint32_t RESERVED3 : 4; //!< [19:16] 
        uint32_t CWBEE : 1; //!< [20] Cache write buffer error enable
        uint32_t RESERVED4 : 3; //!< [23:21] 
        uint32_t FIOCE : 1; //!< [24] FPU invalid operation interrupt enable
        uint32_t FDZCE : 1; //!< [25] FPU divide-by-zero interrupt enable
        uint32_t FOFCE : 1; //!< [26] FPU overflow interrupt enable
        uint32_t FUFCE : 1; //!< [27] FPU underflow interrupt enable
        uint32_t FIXCE : 1; //!< [28] FPU inexact interrupt enable
        uint32_t RESERVED5 : 2; //!< [30:29] 
        uint32_t FIDCE : 1; //!< [31] FPU input denormal interrupt enable
    } B;
} hw_mcm_is_c_r_t;
#endif

/*!
 * @name Constants and macros for entire MCM_IS_C_R register
 */
//@{
#define HW_MCM_IS_C_R_ADDR      (REGS_MCM_BASE + 0x10U)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_IS_C_R           (*(__I hw_mcm_is_c_r_t *) HW_MCM_IS_C_R_ADDR)
#define HW_MCM_IS_C_R_RD()      (HW_MCM_IS_C_R.U)
#endif
//@}

/*
 * constants & macros for individual MCM_IS_C_R bitfields
 */

/*! @name Register MCM_IS_C_R, field IRQ[1] (W1C)
 *
 * If ETBCC[RSPT] is set to 01b, this bit is set when the ETB counter expires.
 *
 * Values:
 * - 0 - No pending interrupt
 * - 1 - Due to the ETB counter expiring, a normal interrupt is pending
 */
//@{
#define BP_MCM_IS_C_R_IRQ      (1U)      //!< Bit position for MCM_IS_C_R_IRQ.
#define BM_MCM_IS_C_R_IRQ      (0x00000002U)  //!< Bit mask for MCM_IS_C_R_IRQ.
#define BS_MCM_IS_C_R_IRQ      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_IRQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_IRQ field.
#define BR_MCM_IS_C_R_IRQ()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_IRQ))
#endif
//@}

/*! @name Register MCM_IS_C_R, field NMI[2] (W1C)
 *
 * If ETBCC[RSPT] is set to 10b, this bit is set when the ETB counter expires.
 *
 * Values:
 * - 0 - No pending NMI
 * - 1 - Due to the ETB counter expiring, an NMI is pending
 */
//@{
#define BP_MCM_IS_C_R_NMI      (2U)      //!< Bit position for MCM_IS_C_R_NMI.
#define BM_MCM_IS_C_R_NMI      (0x00000004U)  //!< Bit mask for MCM_IS_C_R_NMI.
#define BS_MCM_IS_C_R_NMI      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_NMI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_NMI field.
#define BR_MCM_IS_C_R_NMI()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_NMI))
#endif
//@}

/*! @name Register MCM_IS_C_R, field DHREQ[3] (RO)
 *
 * Indicates that a debug halt request is initiated due to a ETB counter expiration, ETBCC[2:0] =
 * 3b111 & ETBCV[10:0] = 11h0. This bit is cleared when the counter is disabled or when the ETB
 * counter is reloaded.
 *
 * Values:
 * - 0 - No debug halt request
 * - 1 - Debug halt request initiated
 */
//@{
#define BP_MCM_IS_C_R_DHREQ      (3U)      //!< Bit position for MCM_IS_C_R_DHREQ.
#define BM_MCM_IS_C_R_DHREQ      (0x00000008U)  //!< Bit mask for MCM_IS_C_R_DHREQ.
#define BS_MCM_IS_C_R_DHREQ      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_DHREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_DHREQ field.
#define BR_MCM_IS_C_R_DHREQ()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_DHREQ))
#endif
//@}

/*! @name Register MCM_IS_C_R, field CWBER[4] (W1C)
 *
 * Signals a data transfer from the core’s cache write buffer was terminated with a bus error. This
 * bit only sets when the corresponding enable bit (CWBEE) is set. The corresponding core fault
 * address, attributes and write data are typically retrieved from the FADR, FATR, and FDR registers
 * during the interrupt service routine before clearing the CWBER flag.
 *
 * Values:
 * - 0 - No error
 * - 1 - Error occurred
 */
//@{
#define BP_MCM_IS_C_R_CWBER      (4U)      //!< Bit position for MCM_IS_C_R_CWBER.
#define BM_MCM_IS_C_R_CWBER      (0x00000010U)  //!< Bit mask for MCM_IS_C_R_CWBER.
#define BS_MCM_IS_C_R_CWBER      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_CWBER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_CWBER field.
#define BR_MCM_IS_C_R_CWBER()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_CWBER))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FIOC[8] (RO)
 *
 * This read-only bit is a copy of the core’s FPSCR[IOC] bit and signals an illegal operation has
 * been detected in the processor’s FPU. Once set, this bit remains set until software clears the
 * FPSCR[IOC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
//@{
#define BP_MCM_IS_C_R_FIOC      (8U)      //!< Bit position for MCM_IS_C_R_FIOC.
#define BM_MCM_IS_C_R_FIOC      (0x00000100U)  //!< Bit mask for MCM_IS_C_R_FIOC.
#define BS_MCM_IS_C_R_FIOC      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FIOC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FIOC field.
#define BR_MCM_IS_C_R_FIOC()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FIOC))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FDZC[9] (RO)
 *
 * This read-only bit is a copy of the core’s FPSCR[DZC] bit and signals a divide by zero has been
 * detected in the processor’s FPU. Once set, this bit remains set until software clears the
 * FPSCR[DZC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
//@{
#define BP_MCM_IS_C_R_FDZC      (9U)      //!< Bit position for MCM_IS_C_R_FDZC.
#define BM_MCM_IS_C_R_FDZC      (0x00000200U)  //!< Bit mask for MCM_IS_C_R_FDZC.
#define BS_MCM_IS_C_R_FDZC      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FDZC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FDZC field.
#define BR_MCM_IS_C_R_FDZC()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FDZC))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FOFC[10] (RO)
 *
 * This read-only bit is a copy of the core’s FPSCR[OFC] bit and signals an overflow has been
 * detected in the processor’s FPU. Once set, this bit remains set until software clears the
 * FPSCR[OFC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
//@{
#define BP_MCM_IS_C_R_FOFC      (10U)      //!< Bit position for MCM_IS_C_R_FOFC.
#define BM_MCM_IS_C_R_FOFC      (0x00000400U)  //!< Bit mask for MCM_IS_C_R_FOFC.
#define BS_MCM_IS_C_R_FOFC      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FOFC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FOFC field.
#define BR_MCM_IS_C_R_FOFC()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FOFC))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FUFC[11] (RO)
 *
 * This read-only bit is a copy of the core’s FPSCR[UFC] bit and signals an underflow has been
 * detected in the processor’s FPU. Once set, this bit remains set until software clears the
 * FPSCR[UFC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
//@{
#define BP_MCM_IS_C_R_FUFC      (11U)      //!< Bit position for MCM_IS_C_R_FUFC.
#define BM_MCM_IS_C_R_FUFC      (0x00000800U)  //!< Bit mask for MCM_IS_C_R_FUFC.
#define BS_MCM_IS_C_R_FUFC      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FUFC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FUFC field.
#define BR_MCM_IS_C_R_FUFC()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FUFC))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FIXC[12] (RO)
 *
 * This read-only bit is a copy of the core’s FPSCR[IXC] bit and signals an inexact number has been
 * detected in the processor’s FPU. Once set, this bit remains set until software clears the
 * FPSCR[IXC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
//@{
#define BP_MCM_IS_C_R_FIXC      (12U)      //!< Bit position for MCM_IS_C_R_FIXC.
#define BM_MCM_IS_C_R_FIXC      (0x00001000U)  //!< Bit mask for MCM_IS_C_R_FIXC.
#define BS_MCM_IS_C_R_FIXC      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FIXC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FIXC field.
#define BR_MCM_IS_C_R_FIXC()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FIXC))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FIDC[15] (RO)
 *
 * This read-only bit is a copy of the core’s FPSCR[IDC] bit and signals input denormalized number
 * has been detected in the processor’s FPU. Once set, this bit remains set until software clears
 * the FPSCR[IDC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
//@{
#define BP_MCM_IS_C_R_FIDC      (15U)      //!< Bit position for MCM_IS_C_R_FIDC.
#define BM_MCM_IS_C_R_FIDC      (0x00008000U)  //!< Bit mask for MCM_IS_C_R_FIDC.
#define BS_MCM_IS_C_R_FIDC      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FIDC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FIDC field.
#define BR_MCM_IS_C_R_FIDC()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FIDC))
#endif
//@}

/*! @name Register MCM_IS_C_R, field CWBEE[20] (RW)
 *
 * Enables the generation of an interrupt in response to a bus error termination reported on a
 * system bus transfer initiated from the cache’s write buffer.
 *
 * Values:
 * - 0 - Disable error interrupt
 * - 1 - Enable error interrupt
 */
//@{
#define BP_MCM_IS_C_R_CWBEE      (20U)      //!< Bit position for MCM_IS_C_R_CWBEE.
#define BM_MCM_IS_C_R_CWBEE      (0x00100000U)  //!< Bit mask for MCM_IS_C_R_CWBEE.
#define BS_MCM_IS_C_R_CWBEE      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_CWBEE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_CWBEE field.
#define BR_MCM_IS_C_R_CWBEE()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_CWBEE))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FIOCE[24] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
//@{
#define BP_MCM_IS_C_R_FIOCE      (24U)      //!< Bit position for MCM_IS_C_R_FIOCE.
#define BM_MCM_IS_C_R_FIOCE      (0x01000000U)  //!< Bit mask for MCM_IS_C_R_FIOCE.
#define BS_MCM_IS_C_R_FIOCE      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FIOCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FIOCE field.
#define BR_MCM_IS_C_R_FIOCE()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FIOCE))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FDZCE[25] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
//@{
#define BP_MCM_IS_C_R_FDZCE      (25U)      //!< Bit position for MCM_IS_C_R_FDZCE.
#define BM_MCM_IS_C_R_FDZCE      (0x02000000U)  //!< Bit mask for MCM_IS_C_R_FDZCE.
#define BS_MCM_IS_C_R_FDZCE      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FDZCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FDZCE field.
#define BR_MCM_IS_C_R_FDZCE()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FDZCE))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FOFCE[26] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
//@{
#define BP_MCM_IS_C_R_FOFCE      (26U)      //!< Bit position for MCM_IS_C_R_FOFCE.
#define BM_MCM_IS_C_R_FOFCE      (0x04000000U)  //!< Bit mask for MCM_IS_C_R_FOFCE.
#define BS_MCM_IS_C_R_FOFCE      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FOFCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FOFCE field.
#define BR_MCM_IS_C_R_FOFCE()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FOFCE))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FUFCE[27] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
//@{
#define BP_MCM_IS_C_R_FUFCE      (27U)      //!< Bit position for MCM_IS_C_R_FUFCE.
#define BM_MCM_IS_C_R_FUFCE      (0x08000000U)  //!< Bit mask for MCM_IS_C_R_FUFCE.
#define BS_MCM_IS_C_R_FUFCE      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FUFCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FUFCE field.
#define BR_MCM_IS_C_R_FUFCE()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FUFCE))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FIXCE[28] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
//@{
#define BP_MCM_IS_C_R_FIXCE      (28U)      //!< Bit position for MCM_IS_C_R_FIXCE.
#define BM_MCM_IS_C_R_FIXCE      (0x10000000U)  //!< Bit mask for MCM_IS_C_R_FIXCE.
#define BS_MCM_IS_C_R_FIXCE      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FIXCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FIXCE field.
#define BR_MCM_IS_C_R_FIXCE()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FIXCE))
#endif
//@}

/*! @name Register MCM_IS_C_R, field FIDCE[31] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
//@{
#define BP_MCM_IS_C_R_FIDCE      (31U)      //!< Bit position for MCM_IS_C_R_FIDCE.
#define BM_MCM_IS_C_R_FIDCE      (0x80000000U)  //!< Bit mask for MCM_IS_C_R_FIDCE.
#define BS_MCM_IS_C_R_FIDCE      (1U)  //!< Bitfield size in bits for MCM_IS_C_R_FIDCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_IS_C_R_FIDCE field.
#define BR_MCM_IS_C_R_FIDCE()   (BITBAND_ACCESS32(HW_MCM_IS_C_R_ADDR, BP_MCM_IS_C_R_FIDCE))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_ETBCC - ETB Counter Control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_ETBCC - ETB Counter Control register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_mcm_etbcc
{
    uint32_t U;
    struct _hw_mcm_etbcc_bitfields
    {
        uint32_t CNTEN : 1; //!< [0] Counter Enable
        uint32_t RSPT : 2; //!< [2:1] Response Type
        uint32_t RLRQ : 1; //!< [3] Reload Request
        uint32_t ETDIS : 1; //!< [4] ETM-To-TPIU Disable
        uint32_t ITDIS : 1; //!< [5] ITM-To-TPIU Disable
        uint32_t RESERVED0 : 26; //!< [31:6] 
    } B;
} hw_mcm_etbcc_t;
#endif

/*!
 * @name Constants and macros for entire MCM_ETBCC register
 */
//@{
#define HW_MCM_ETBCC_ADDR      (REGS_MCM_BASE + 0x14U)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_ETBCC           (*(__IO hw_mcm_etbcc_t *) HW_MCM_ETBCC_ADDR)
#define HW_MCM_ETBCC_RD()      (HW_MCM_ETBCC.U)
#define HW_MCM_ETBCC_WR(v)     (HW_MCM_ETBCC.U = (v))
#define HW_MCM_ETBCC_SET(v)    (HW_MCM_ETBCC_WR(HW_MCM_ETBCC_RD() |  (v)))
#define HW_MCM_ETBCC_CLR(v)    (HW_MCM_ETBCC_WR(HW_MCM_ETBCC_RD() & ~(v)))
#define HW_MCM_ETBCC_TOG(v)    (HW_MCM_ETBCC_WR(HW_MCM_ETBCC_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual MCM_ETBCC bitfields
 */

/*! @name Register MCM_ETBCC, field CNTEN[0] (RW)
 *
 * Enables the ETB counter.
 *
 * Values:
 * - 0 - ETB counter disabled
 * - 1 - ETB counter enabled
 */
//@{
#define BP_MCM_ETBCC_CNTEN      (0U)      //!< Bit position for MCM_ETBCC_CNTEN.
#define BM_MCM_ETBCC_CNTEN      (0x00000001U)  //!< Bit mask for MCM_ETBCC_CNTEN.
#define BS_MCM_ETBCC_CNTEN      (1U)  //!< Bitfield size in bits for MCM_ETBCC_CNTEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_ETBCC_CNTEN field.
#define BR_MCM_ETBCC_CNTEN()   (BITBAND_ACCESS32(HW_MCM_ETBCC_ADDR, BP_MCM_ETBCC_CNTEN))
#endif

//! @brief Format value for bitfield MCM_ETBCC_CNTEN.
#define BF_MCM_ETBCC_CNTEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_ETBCC_CNTEN), uint32_t) & BM_MCM_ETBCC_CNTEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CNTEN field to a new value.
#define BW_MCM_ETBCC_CNTEN(v)   (BITBAND_ACCESS32(HW_MCM_ETBCC_ADDR, BP_MCM_ETBCC_CNTEN) = (v))
#endif
//@}

/*! @name Register MCM_ETBCC, field RSPT[2:1] (RW)
 *
 * Values:
 * - 00 - No response when the ETB count expires
 * - 01 - Generate a normal interrupt when the ETB count expires
 * - 10 - Generate an NMI when the ETB count expires
 * - 11 - Generate a debug halt when the ETB count expires
 */
//@{
#define BP_MCM_ETBCC_RSPT      (1U)      //!< Bit position for MCM_ETBCC_RSPT.
#define BM_MCM_ETBCC_RSPT      (0x00000006U)  //!< Bit mask for MCM_ETBCC_RSPT.
#define BS_MCM_ETBCC_RSPT      (2U)  //!< Bitfield size in bits for MCM_ETBCC_RSPT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_ETBCC_RSPT field.
#define BR_MCM_ETBCC_RSPT()   (HW_MCM_ETBCC.B.RSPT)
#endif

//! @brief Format value for bitfield MCM_ETBCC_RSPT.
#define BF_MCM_ETBCC_RSPT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_ETBCC_RSPT), uint32_t) & BM_MCM_ETBCC_RSPT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RSPT field to a new value.
#define BW_MCM_ETBCC_RSPT(v)   (HW_MCM_ETBCC_WR((HW_MCM_ETBCC_RD() & ~BM_MCM_ETBCC_RSPT) | BF_MCM_ETBCC_RSPT(v)))
#endif
//@}

/*! @name Register MCM_ETBCC, field RLRQ[3] (RW)
 *
 * Reloads the ETB packet counter with the MCM_ETBRL RELOAD value. If IRQ or NMI interrupts were
 * enabled and an NMI or IRQ interrupt was generated on counter expiration, setting this bit clears
 * the pending NMI or IRQ interrupt request. If debug halt was enabled and a debug halt request was
 * asserted on counter expiration, setting this bit clears the debug halt request.
 *
 * Values:
 * - 0 - No effect
 * - 1 - Clears pending debug halt, NMI, or IRQ interrupt requests
 */
//@{
#define BP_MCM_ETBCC_RLRQ      (3U)      //!< Bit position for MCM_ETBCC_RLRQ.
#define BM_MCM_ETBCC_RLRQ      (0x00000008U)  //!< Bit mask for MCM_ETBCC_RLRQ.
#define BS_MCM_ETBCC_RLRQ      (1U)  //!< Bitfield size in bits for MCM_ETBCC_RLRQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_ETBCC_RLRQ field.
#define BR_MCM_ETBCC_RLRQ()   (BITBAND_ACCESS32(HW_MCM_ETBCC_ADDR, BP_MCM_ETBCC_RLRQ))
#endif

//! @brief Format value for bitfield MCM_ETBCC_RLRQ.
#define BF_MCM_ETBCC_RLRQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_ETBCC_RLRQ), uint32_t) & BM_MCM_ETBCC_RLRQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RLRQ field to a new value.
#define BW_MCM_ETBCC_RLRQ(v)   (BITBAND_ACCESS32(HW_MCM_ETBCC_ADDR, BP_MCM_ETBCC_RLRQ) = (v))
#endif
//@}

/*! @name Register MCM_ETBCC, field ETDIS[4] (RW)
 *
 * Disables the trace path from ETM to TPIU.
 *
 * Values:
 * - 0 - ETM-to-TPIU trace path enabled
 * - 1 - ETM-to-TPIU trace path disabled
 */
//@{
#define BP_MCM_ETBCC_ETDIS      (4U)      //!< Bit position for MCM_ETBCC_ETDIS.
#define BM_MCM_ETBCC_ETDIS      (0x00000010U)  //!< Bit mask for MCM_ETBCC_ETDIS.
#define BS_MCM_ETBCC_ETDIS      (1U)  //!< Bitfield size in bits for MCM_ETBCC_ETDIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_ETBCC_ETDIS field.
#define BR_MCM_ETBCC_ETDIS()   (BITBAND_ACCESS32(HW_MCM_ETBCC_ADDR, BP_MCM_ETBCC_ETDIS))
#endif

//! @brief Format value for bitfield MCM_ETBCC_ETDIS.
#define BF_MCM_ETBCC_ETDIS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_ETBCC_ETDIS), uint32_t) & BM_MCM_ETBCC_ETDIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ETDIS field to a new value.
#define BW_MCM_ETBCC_ETDIS(v)   (BITBAND_ACCESS32(HW_MCM_ETBCC_ADDR, BP_MCM_ETBCC_ETDIS) = (v))
#endif
//@}

/*! @name Register MCM_ETBCC, field ITDIS[5] (RW)
 *
 * Disables the trace path from ITM to TPIU.
 *
 * Values:
 * - 0 - ITM-to-TPIU trace path enabled
 * - 1 - ITM-to-TPIU trace path disabled
 */
//@{
#define BP_MCM_ETBCC_ITDIS      (5U)      //!< Bit position for MCM_ETBCC_ITDIS.
#define BM_MCM_ETBCC_ITDIS      (0x00000020U)  //!< Bit mask for MCM_ETBCC_ITDIS.
#define BS_MCM_ETBCC_ITDIS      (1U)  //!< Bitfield size in bits for MCM_ETBCC_ITDIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_ETBCC_ITDIS field.
#define BR_MCM_ETBCC_ITDIS()   (BITBAND_ACCESS32(HW_MCM_ETBCC_ADDR, BP_MCM_ETBCC_ITDIS))
#endif

//! @brief Format value for bitfield MCM_ETBCC_ITDIS.
#define BF_MCM_ETBCC_ITDIS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_ETBCC_ITDIS), uint32_t) & BM_MCM_ETBCC_ITDIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ITDIS field to a new value.
#define BW_MCM_ETBCC_ITDIS(v)   (BITBAND_ACCESS32(HW_MCM_ETBCC_ADDR, BP_MCM_ETBCC_ITDIS) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_ETBRL - ETB Reload register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_ETBRL - ETB Reload register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_mcm_etbrl
{
    uint32_t U;
    struct _hw_mcm_etbrl_bitfields
    {
        uint32_t RELOAD : 11; //!< [10:0] Byte Count Reload Value
        uint32_t RESERVED0 : 21; //!< [31:11] 
    } B;
} hw_mcm_etbrl_t;
#endif

/*!
 * @name Constants and macros for entire MCM_ETBRL register
 */
//@{
#define HW_MCM_ETBRL_ADDR      (REGS_MCM_BASE + 0x18U)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_ETBRL           (*(__IO hw_mcm_etbrl_t *) HW_MCM_ETBRL_ADDR)
#define HW_MCM_ETBRL_RD()      (HW_MCM_ETBRL.U)
#define HW_MCM_ETBRL_WR(v)     (HW_MCM_ETBRL.U = (v))
#define HW_MCM_ETBRL_SET(v)    (HW_MCM_ETBRL_WR(HW_MCM_ETBRL_RD() |  (v)))
#define HW_MCM_ETBRL_CLR(v)    (HW_MCM_ETBRL_WR(HW_MCM_ETBRL_RD() & ~(v)))
#define HW_MCM_ETBRL_TOG(v)    (HW_MCM_ETBRL_WR(HW_MCM_ETBRL_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual MCM_ETBRL bitfields
 */

/*! @name Register MCM_ETBRL, field RELOAD[10:0] (RW)
 *
 * Indicates the 0-mod-4 value the counter reloads to. Writing a non-0-mod-4 value to this field
 * results in a bus error.
 */
//@{
#define BP_MCM_ETBRL_RELOAD      (0U)      //!< Bit position for MCM_ETBRL_RELOAD.
#define BM_MCM_ETBRL_RELOAD      (0x000007ffU)  //!< Bit mask for MCM_ETBRL_RELOAD.
#define BS_MCM_ETBRL_RELOAD      (11U)  //!< Bitfield size in bits for MCM_ETBRL_RELOAD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_ETBRL_RELOAD field.
#define BR_MCM_ETBRL_RELOAD()   (HW_MCM_ETBRL.B.RELOAD)
#endif

//! @brief Format value for bitfield MCM_ETBRL_RELOAD.
#define BF_MCM_ETBRL_RELOAD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_ETBRL_RELOAD), uint32_t) & BM_MCM_ETBRL_RELOAD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RELOAD field to a new value.
#define BW_MCM_ETBRL_RELOAD(v)   (HW_MCM_ETBRL_WR((HW_MCM_ETBRL_RD() & ~BM_MCM_ETBRL_RELOAD) | BF_MCM_ETBRL_RELOAD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_ETBCNT - ETB Counter Value register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_ETBCNT - ETB Counter Value register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_mcm_etbcnt
{
    uint32_t U;
    struct _hw_mcm_etbcnt_bitfields
    {
        uint32_t COUNTER : 11; //!< [10:0] Byte Count Counter Value
        uint32_t RESERVED0 : 21; //!< [31:11] 
    } B;
} hw_mcm_etbcnt_t;
#endif

/*!
 * @name Constants and macros for entire MCM_ETBCNT register
 */
//@{
#define HW_MCM_ETBCNT_ADDR      (REGS_MCM_BASE + 0x1cU)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_ETBCNT           (*(__I hw_mcm_etbcnt_t *) HW_MCM_ETBCNT_ADDR)
#define HW_MCM_ETBCNT_RD()      (HW_MCM_ETBCNT.U)
#endif
//@}

/*
 * constants & macros for individual MCM_ETBCNT bitfields
 */

/*! @name Register MCM_ETBCNT, field COUNTER[10:0] (RO)
 *
 * Indicates the current 0-mod-4 value of the counter.
 */
//@{
#define BP_MCM_ETBCNT_COUNTER      (0U)      //!< Bit position for MCM_ETBCNT_COUNTER.
#define BM_MCM_ETBCNT_COUNTER      (0x000007ffU)  //!< Bit mask for MCM_ETBCNT_COUNTER.
#define BS_MCM_ETBCNT_COUNTER      (11U)  //!< Bitfield size in bits for MCM_ETBCNT_COUNTER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_ETBCNT_COUNTER field.
#define BR_MCM_ETBCNT_COUNTER()   (HW_MCM_ETBCNT.B.COUNTER)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_FADR - Fault address register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_FADR - Fault address register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When a properly-enabled cache write buffer error interrupt event is detected, the faulting
 * address is captured in the MCM_FADR register. The MCM logic supports capturing a single cache
 * write buffer bus error event; if a subsequent error is detected before the captured error
 * information has been read from the corresponding registers and the MCM_ISCR[CWBER] indicator
 * cleared, the MCM_FATR[BEOVR] flag is set. However, no additional information is captured. The
 * bits in this register are set by hardware and signaled by the assertion of MCM_ISCR[CWBER].
 * Attempted writes to this location are terminated with an error.
 */
typedef union _hw_mcm_fadr
{
    uint32_t U;
    struct _hw_mcm_fadr_bitfields
    {
        uint32_t ADDRESS : 32; //!< [31:0] Fault address
    } B;
} hw_mcm_fadr_t;
#endif

/*!
 * @name Constants and macros for entire MCM_FADR register
 */
//@{
#define HW_MCM_FADR_ADDR      (REGS_MCM_BASE + 0x20U)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_FADR           (*(__I hw_mcm_fadr_t *) HW_MCM_FADR_ADDR)
#define HW_MCM_FADR_RD()      (HW_MCM_FADR.U)
#endif
//@}

/*
 * constants & macros for individual MCM_FADR bitfields
 */

/*! @name Register MCM_FADR, field ADDRESS[31:0] (RO)
 */
//@{
#define BP_MCM_FADR_ADDRESS      (0U)      //!< Bit position for MCM_FADR_ADDRESS.
#define BM_MCM_FADR_ADDRESS      (0xffffffffU)  //!< Bit mask for MCM_FADR_ADDRESS.
#define BS_MCM_FADR_ADDRESS      (32U)  //!< Bitfield size in bits for MCM_FADR_ADDRESS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_FADR_ADDRESS field.
#define BR_MCM_FADR_ADDRESS()   (HW_MCM_FADR.B.ADDRESS)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_FATR - Fault attributes register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_FATR - Fault attributes register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When a properly-enabled cache write buffer error interrupt event is detected, the faulting
 * attributes are captured in the MCM_FATR register. The bits in this register are set by hardware
 * and signaled by the assertion of MCM_ISCR[CWBER]. Attempted writes to this location are
 * terminated with an error.
 */
typedef union _hw_mcm_fatr
{
    uint32_t U;
    struct _hw_mcm_fatr_bitfields
    {
        uint32_t BEDA : 1; //!< [0] Bus error access type
        uint32_t BEMD : 1; //!< [1] Bus error privilege level
        uint32_t RESERVED0 : 2; //!< [3:2] 
        uint32_t BESZ : 2; //!< [5:4] Bus error size
        uint32_t RESERVED1 : 1; //!< [6] 
        uint32_t BEWT : 1; //!< [7] Bus error write
        uint32_t BEMN : 4; //!< [11:8] Bus error master number
        uint32_t RESERVED2 : 19; //!< [30:12] 
        uint32_t BEOVR : 1; //!< [31] Bus error overrun
    } B;
} hw_mcm_fatr_t;
#endif

/*!
 * @name Constants and macros for entire MCM_FATR register
 */
//@{
#define HW_MCM_FATR_ADDR      (REGS_MCM_BASE + 0x24U)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_FATR           (*(__I hw_mcm_fatr_t *) HW_MCM_FATR_ADDR)
#define HW_MCM_FATR_RD()      (HW_MCM_FATR.U)
#endif
//@}

/*
 * constants & macros for individual MCM_FATR bitfields
 */

/*! @name Register MCM_FATR, field BEDA[0] (RO)
 *
 * Indicates the type of cache write buffer access when the error was detected. This attribute is
 * always a logical one signaling a data reference.
 *
 * Values:
 * - 0 - Instruction
 * - 1 - Data
 */
//@{
#define BP_MCM_FATR_BEDA      (0U)      //!< Bit position for MCM_FATR_BEDA.
#define BM_MCM_FATR_BEDA      (0x00000001U)  //!< Bit mask for MCM_FATR_BEDA.
#define BS_MCM_FATR_BEDA      (1U)  //!< Bitfield size in bits for MCM_FATR_BEDA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_FATR_BEDA field.
#define BR_MCM_FATR_BEDA()   (BITBAND_ACCESS32(HW_MCM_FATR_ADDR, BP_MCM_FATR_BEDA))
#endif
//@}

/*! @name Register MCM_FATR, field BEMD[1] (RO)
 *
 * Indicates the privilege level of the cache write buffer access when the error was detected.
 *
 * Values:
 * - 0 - User mode
 * - 1 - Supervisor/privileged mode
 */
//@{
#define BP_MCM_FATR_BEMD      (1U)      //!< Bit position for MCM_FATR_BEMD.
#define BM_MCM_FATR_BEMD      (0x00000002U)  //!< Bit mask for MCM_FATR_BEMD.
#define BS_MCM_FATR_BEMD      (1U)  //!< Bitfield size in bits for MCM_FATR_BEMD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_FATR_BEMD field.
#define BR_MCM_FATR_BEMD()   (BITBAND_ACCESS32(HW_MCM_FATR_ADDR, BP_MCM_FATR_BEMD))
#endif
//@}

/*! @name Register MCM_FATR, field BESZ[5:4] (RO)
 *
 * Indicates the size of the cache write buffer access when the error was detected.
 *
 * Values:
 * - 00 - 8-bit access
 * - 01 - 16-bit access
 * - 10 - 32-bit access
 * - 11 - Reserved
 */
//@{
#define BP_MCM_FATR_BESZ      (4U)      //!< Bit position for MCM_FATR_BESZ.
#define BM_MCM_FATR_BESZ      (0x00000030U)  //!< Bit mask for MCM_FATR_BESZ.
#define BS_MCM_FATR_BESZ      (2U)  //!< Bitfield size in bits for MCM_FATR_BESZ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_FATR_BESZ field.
#define BR_MCM_FATR_BESZ()   (HW_MCM_FATR.B.BESZ)
#endif
//@}

/*! @name Register MCM_FATR, field BEWT[7] (RO)
 *
 * Indicates the type of system bus access when the error was detected. Since this logic is
 * monitoring data transfers from the cache write buffer, this bit is always a logical one,
 * signaling a write operation.
 *
 * Values:
 * - 0 - Read access
 * - 1 - Write access
 */
//@{
#define BP_MCM_FATR_BEWT      (7U)      //!< Bit position for MCM_FATR_BEWT.
#define BM_MCM_FATR_BEWT      (0x00000080U)  //!< Bit mask for MCM_FATR_BEWT.
#define BS_MCM_FATR_BEWT      (1U)  //!< Bitfield size in bits for MCM_FATR_BEWT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_FATR_BEWT field.
#define BR_MCM_FATR_BEWT()   (BITBAND_ACCESS32(HW_MCM_FATR_ADDR, BP_MCM_FATR_BEWT))
#endif
//@}

/*! @name Register MCM_FATR, field BEMN[11:8] (RO)
 *
 * Crossbar switch bus master number of the captured cache write buffer bus error. For this device,
 * this value is always 0x1.
 */
//@{
#define BP_MCM_FATR_BEMN      (8U)      //!< Bit position for MCM_FATR_BEMN.
#define BM_MCM_FATR_BEMN      (0x00000f00U)  //!< Bit mask for MCM_FATR_BEMN.
#define BS_MCM_FATR_BEMN      (4U)  //!< Bitfield size in bits for MCM_FATR_BEMN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_FATR_BEMN field.
#define BR_MCM_FATR_BEMN()   (HW_MCM_FATR.B.BEMN)
#endif
//@}

/*! @name Register MCM_FATR, field BEOVR[31] (RO)
 *
 * Indicates if anothercache write buffer bus error is detected before system software has retrieved
 * all the error information from the original event, this overrun flag is set. The window of time
 * is defined from the detection of the original cache write buffer error termination until the
 * MCM_ISCR[CWBER] is written with a 1 to clear it and rearm the capture logic. This bit is set by
 * the hardware and cleared whenever software writes a 1 to the CWBER bit.
 *
 * Values:
 * - 0 - No bus error overrun
 * - 1 - Bus error overrun occurred. The FADR and FDR registers and the other FATR bits are not updated to
 *     reflect this new bus error.
 */
//@{
#define BP_MCM_FATR_BEOVR      (31U)      //!< Bit position for MCM_FATR_BEOVR.
#define BM_MCM_FATR_BEOVR      (0x80000000U)  //!< Bit mask for MCM_FATR_BEOVR.
#define BS_MCM_FATR_BEOVR      (1U)  //!< Bitfield size in bits for MCM_FATR_BEOVR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_FATR_BEOVR field.
#define BR_MCM_FATR_BEOVR()   (BITBAND_ACCESS32(HW_MCM_FATR_ADDR, BP_MCM_FATR_BEOVR))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_FDR - Fault data register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_FDR - Fault data register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When a properly-enabled cache write buffer error interrupt event is detected, the faulting data
 * is captured in the MCM_FDR register. The bits in this register are set by hardware and signaled
 * by the assertion of MCM_ISCR[CWBER]. For byte and halfword writes, only the accessed byte lanes
 * contain valid data; the contents of the other bytes are undefined. Attempted writes to this
 * location are terminated with an error.
 */
typedef union _hw_mcm_fdr
{
    uint32_t U;
    struct _hw_mcm_fdr_bitfields
    {
        uint32_t DATA : 32; //!< [31:0] Fault data
    } B;
} hw_mcm_fdr_t;
#endif

/*!
 * @name Constants and macros for entire MCM_FDR register
 */
//@{
#define HW_MCM_FDR_ADDR      (REGS_MCM_BASE + 0x28U)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_FDR           (*(__I hw_mcm_fdr_t *) HW_MCM_FDR_ADDR)
#define HW_MCM_FDR_RD()      (HW_MCM_FDR.U)
#endif
//@}

/*
 * constants & macros for individual MCM_FDR bitfields
 */

/*! @name Register MCM_FDR, field DATA[31:0] (RO)
 */
//@{
#define BP_MCM_FDR_DATA      (0U)      //!< Bit position for MCM_FDR_DATA.
#define BM_MCM_FDR_DATA      (0xffffffffU)  //!< Bit mask for MCM_FDR_DATA.
#define BS_MCM_FDR_DATA      (32U)  //!< Bitfield size in bits for MCM_FDR_DATA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_FDR_DATA field.
#define BR_MCM_FDR_DATA()   (HW_MCM_FDR.B.DATA)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCM_PID - Process ID register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCM_PID - Process ID register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register drives the M0_PID and M1_PID values in the Memory Protection Unit(MPU). System
 * software loads this register before passing control to a given user mode process. If the PID of
 * the process does not match the value in this register, a bus error occurs. See the MPU chapter
 * for more details.
 */
typedef union _hw_mcm_pid
{
    uint32_t U;
    struct _hw_mcm_pid_bitfields
    {
        uint32_t PID : 8; //!< [7:0] M0_PID And M1_PID For MPU
        uint32_t RESERVED0 : 24; //!< [31:8] 
    } B;
} hw_mcm_pid_t;
#endif

/*!
 * @name Constants and macros for entire MCM_PID register
 */
//@{
#define HW_MCM_PID_ADDR      (REGS_MCM_BASE + 0x30U)

#ifndef __LANGUAGE_ASM__
#define HW_MCM_PID           (*(__IO hw_mcm_pid_t *) HW_MCM_PID_ADDR)
#define HW_MCM_PID_RD()      (HW_MCM_PID.U)
#define HW_MCM_PID_WR(v)     (HW_MCM_PID.U = (v))
#define HW_MCM_PID_SET(v)    (HW_MCM_PID_WR(HW_MCM_PID_RD() |  (v)))
#define HW_MCM_PID_CLR(v)    (HW_MCM_PID_WR(HW_MCM_PID_RD() & ~(v)))
#define HW_MCM_PID_TOG(v)    (HW_MCM_PID_WR(HW_MCM_PID_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual MCM_PID bitfields
 */

/*! @name Register MCM_PID, field PID[7:0] (RW)
 *
 * Drives the M0_PID and M1_PID values in the MPU.
 */
//@{
#define BP_MCM_PID_PID      (0U)      //!< Bit position for MCM_PID_PID.
#define BM_MCM_PID_PID      (0x000000ffU)  //!< Bit mask for MCM_PID_PID.
#define BS_MCM_PID_PID      (8U)  //!< Bitfield size in bits for MCM_PID_PID.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCM_PID_PID field.
#define BR_MCM_PID_PID()   (HW_MCM_PID.B.PID)
#endif

//! @brief Format value for bitfield MCM_PID_PID.
#define BF_MCM_PID_PID(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_MCM_PID_PID), uint32_t) & BM_MCM_PID_PID)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PID field to a new value.
#define BW_MCM_PID_PID(v)   (HW_MCM_PID_WR((HW_MCM_PID_RD() & ~BM_MCM_PID_PID) | BF_MCM_PID_PID(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_mcm_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All MCM module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_mcm
{
    uint32_t _reserved0[2];
    __I hw_mcm_plasc_t PLASC; //!< [0x8] Crossbar Switch (AXBS) Slave Configuration
    __I hw_mcm_plamc_t PLAMC; //!< [0xa] Crossbar Switch (AXBS) Master Configuration
    __IO hw_mcm_cr_t CR; //!< [0xc] Control Register
    __I hw_mcm_is_c_r_t IS_C_R; //!< [0x10] Interrupt Status and Control Register
    __IO hw_mcm_etbcc_t ETBCC; //!< [0x14] ETB Counter Control register
    __IO hw_mcm_etbrl_t ETBRL; //!< [0x18] ETB Reload register
    __I hw_mcm_etbcnt_t ETBCNT; //!< [0x1c] ETB Counter Value register
    __I hw_mcm_fadr_t FADR; //!< [0x20] Fault address register
    __I hw_mcm_fatr_t FATR; //!< [0x24] Fault attributes register
    __I hw_mcm_fdr_t FDR; //!< [0x28] Fault data register
    uint32_t _reserved1;
    __IO hw_mcm_pid_t PID; //!< [0x30] Process ID register
} hw_mcm_t;
#pragma pack()

//! @brief Macro to access all MCM registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_MCM</code>.
#define HW_MCM     (*(hw_mcm_t *) REGS_MCM_BASE)
#endif

#endif // __HW_MCM_REGISTERS_H__
// v22/130417/1.2.6
// EOF

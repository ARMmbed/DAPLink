/*
 * Copyright (c) 2013, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_DMA_REGISTERS_H__
#define __HW_DMA_REGISTERS_H__

#include "regs.h"

/*
 * K70 DMA
 *
 * Enhanced direct memory access controller
 *
 * Registers defined in this header file:
 * - HW_DMA_CR - Control Register
 * - HW_DMA_ES - Error Status Register
 * - HW_DMA_ERQ - Enable Request Register
 * - HW_DMA_EEI - Enable Error Interrupt Register
 * - HW_DMA_CEEI - Clear Enable Error Interrupt Register
 * - HW_DMA_SEEI - Set Enable Error Interrupt Register
 * - HW_DMA_CERQ - Clear Enable Request Register
 * - HW_DMA_SERQ - Set Enable Request Register
 * - HW_DMA_CDNE - Clear DONE Status Bit Register
 * - HW_DMA_SSRT - Set START Bit Register
 * - HW_DMA_CERR - Clear Error Register
 * - HW_DMA_CINT - Clear Interrupt Request Register
 * - HW_DMA_INT - Interrupt Request Register
 * - HW_DMA_ERR - Error Register
 * - HW_DMA_HRS - Hardware Request Status Register
 * - HW_DMA_DCHPRI3 - Channel n Priority Register
 * - HW_DMA_DCHPRI2 - Channel n Priority Register
 * - HW_DMA_DCHPRI1 - Channel n Priority Register
 * - HW_DMA_DCHPRI0 - Channel n Priority Register
 * - HW_DMA_DCHPRI7 - Channel n Priority Register
 * - HW_DMA_DCHPRI6 - Channel n Priority Register
 * - HW_DMA_DCHPRI5 - Channel n Priority Register
 * - HW_DMA_DCHPRI4 - Channel n Priority Register
 * - HW_DMA_DCHPRI11 - Channel n Priority Register
 * - HW_DMA_DCHPRI10 - Channel n Priority Register
 * - HW_DMA_DCHPRI9 - Channel n Priority Register
 * - HW_DMA_DCHPRI8 - Channel n Priority Register
 * - HW_DMA_DCHPRI15 - Channel n Priority Register
 * - HW_DMA_DCHPRI14 - Channel n Priority Register
 * - HW_DMA_DCHPRI13 - Channel n Priority Register
 * - HW_DMA_DCHPRI12 - Channel n Priority Register
 * - HW_DMA_DCHPRI19 - Channel n Priority Register
 * - HW_DMA_DCHPRI18 - Channel n Priority Register
 * - HW_DMA_DCHPRI17 - Channel n Priority Register
 * - HW_DMA_DCHPRI16 - Channel n Priority Register
 * - HW_DMA_DCHPRI23 - Channel n Priority Register
 * - HW_DMA_DCHPRI22 - Channel n Priority Register
 * - HW_DMA_DCHPRI21 - Channel n Priority Register
 * - HW_DMA_DCHPRI20 - Channel n Priority Register
 * - HW_DMA_DCHPRI27 - Channel n Priority Register
 * - HW_DMA_DCHPRI26 - Channel n Priority Register
 * - HW_DMA_DCHPRI25 - Channel n Priority Register
 * - HW_DMA_DCHPRI24 - Channel n Priority Register
 * - HW_DMA_DCHPRI31 - Channel n Priority Register
 * - HW_DMA_DCHPRI30 - Channel n Priority Register
 * - HW_DMA_DCHPRI29 - Channel n Priority Register
 * - HW_DMA_DCHPRI28 - Channel n Priority Register
 * - HW_DMA_TCD0_SADDR - TCD Source Address
 * - HW_DMA_TCD0_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD0_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD0_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD0_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD0_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD0_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD0_DADDR - TCD Destination Address
 * - HW_DMA_TCD0_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD0_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD0_CITER_ELINKNO - 
 * - HW_DMA_TCD0_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD0_CSR - TCD Control and Status
 * - HW_DMA_TCD0_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD0_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD1_SADDR - TCD Source Address
 * - HW_DMA_TCD1_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD1_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD1_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD1_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD1_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD1_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD1_DADDR - TCD Destination Address
 * - HW_DMA_TCD1_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD1_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD1_CITER_ELINKNO - 
 * - HW_DMA_TCD1_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD1_CSR - TCD Control and Status
 * - HW_DMA_TCD1_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD1_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD2_SADDR - TCD Source Address
 * - HW_DMA_TCD2_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD2_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD2_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD2_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD2_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD2_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD2_DADDR - TCD Destination Address
 * - HW_DMA_TCD2_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD2_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD2_CITER_ELINKNO - 
 * - HW_DMA_TCD2_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD2_CSR - TCD Control and Status
 * - HW_DMA_TCD2_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD2_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD3_SADDR - TCD Source Address
 * - HW_DMA_TCD3_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD3_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD3_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD3_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD3_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD3_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD3_DADDR - TCD Destination Address
 * - HW_DMA_TCD3_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD3_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD3_CITER_ELINKNO - 
 * - HW_DMA_TCD3_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD3_CSR - TCD Control and Status
 * - HW_DMA_TCD3_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD3_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD4_SADDR - TCD Source Address
 * - HW_DMA_TCD4_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD4_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD4_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD4_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD4_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD4_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD4_DADDR - TCD Destination Address
 * - HW_DMA_TCD4_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD4_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD4_CITER_ELINKNO - 
 * - HW_DMA_TCD4_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD4_CSR - TCD Control and Status
 * - HW_DMA_TCD4_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD4_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD5_SADDR - TCD Source Address
 * - HW_DMA_TCD5_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD5_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD5_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD5_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD5_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD5_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD5_DADDR - TCD Destination Address
 * - HW_DMA_TCD5_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD5_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD5_CITER_ELINKNO - 
 * - HW_DMA_TCD5_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD5_CSR - TCD Control and Status
 * - HW_DMA_TCD5_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD5_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD6_SADDR - TCD Source Address
 * - HW_DMA_TCD6_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD6_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD6_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD6_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD6_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD6_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD6_DADDR - TCD Destination Address
 * - HW_DMA_TCD6_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD6_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD6_CITER_ELINKNO - 
 * - HW_DMA_TCD6_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD6_CSR - TCD Control and Status
 * - HW_DMA_TCD6_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD6_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD7_SADDR - TCD Source Address
 * - HW_DMA_TCD7_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD7_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD7_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD7_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD7_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD7_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD7_DADDR - TCD Destination Address
 * - HW_DMA_TCD7_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD7_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD7_CITER_ELINKNO - 
 * - HW_DMA_TCD7_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD7_CSR - TCD Control and Status
 * - HW_DMA_TCD7_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD7_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD8_SADDR - TCD Source Address
 * - HW_DMA_TCD8_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD8_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD8_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD8_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD8_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD8_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD8_DADDR - TCD Destination Address
 * - HW_DMA_TCD8_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD8_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD8_CITER_ELINKNO - 
 * - HW_DMA_TCD8_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD8_CSR - TCD Control and Status
 * - HW_DMA_TCD8_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD8_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD9_SADDR - TCD Source Address
 * - HW_DMA_TCD9_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD9_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD9_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD9_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD9_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD9_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD9_DADDR - TCD Destination Address
 * - HW_DMA_TCD9_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD9_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD9_CITER_ELINKNO - 
 * - HW_DMA_TCD9_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD9_CSR - TCD Control and Status
 * - HW_DMA_TCD9_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD9_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD10_SADDR - TCD Source Address
 * - HW_DMA_TCD10_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD10_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD10_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD10_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD10_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD10_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD10_DADDR - TCD Destination Address
 * - HW_DMA_TCD10_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD10_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD10_CITER_ELINKNO - 
 * - HW_DMA_TCD10_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD10_CSR - TCD Control and Status
 * - HW_DMA_TCD10_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD10_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD11_SADDR - TCD Source Address
 * - HW_DMA_TCD11_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD11_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD11_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD11_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD11_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD11_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD11_DADDR - TCD Destination Address
 * - HW_DMA_TCD11_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD11_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD11_CITER_ELINKNO - 
 * - HW_DMA_TCD11_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD11_CSR - TCD Control and Status
 * - HW_DMA_TCD11_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD11_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD12_SADDR - TCD Source Address
 * - HW_DMA_TCD12_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD12_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD12_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD12_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD12_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD12_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD12_DADDR - TCD Destination Address
 * - HW_DMA_TCD12_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD12_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD12_CITER_ELINKNO - 
 * - HW_DMA_TCD12_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD12_CSR - TCD Control and Status
 * - HW_DMA_TCD12_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD12_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD13_SADDR - TCD Source Address
 * - HW_DMA_TCD13_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD13_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD13_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD13_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD13_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD13_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD13_DADDR - TCD Destination Address
 * - HW_DMA_TCD13_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD13_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD13_CITER_ELINKNO - 
 * - HW_DMA_TCD13_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD13_CSR - TCD Control and Status
 * - HW_DMA_TCD13_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD13_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD14_SADDR - TCD Source Address
 * - HW_DMA_TCD14_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD14_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD14_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD14_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD14_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD14_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD14_DADDR - TCD Destination Address
 * - HW_DMA_TCD14_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD14_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD14_CITER_ELINKNO - 
 * - HW_DMA_TCD14_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD14_CSR - TCD Control and Status
 * - HW_DMA_TCD14_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD14_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD15_SADDR - TCD Source Address
 * - HW_DMA_TCD15_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD15_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD15_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD15_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD15_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD15_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD15_DADDR - TCD Destination Address
 * - HW_DMA_TCD15_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD15_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD15_CITER_ELINKNO - 
 * - HW_DMA_TCD15_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD15_CSR - TCD Control and Status
 * - HW_DMA_TCD15_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD15_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD16_SADDR - TCD Source Address
 * - HW_DMA_TCD16_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD16_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD16_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD16_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD16_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD16_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD16_DADDR - TCD Destination Address
 * - HW_DMA_TCD16_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD16_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD16_CITER_ELINKNO - 
 * - HW_DMA_TCD16_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD16_CSR - TCD Control and Status
 * - HW_DMA_TCD16_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD16_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD17_SADDR - TCD Source Address
 * - HW_DMA_TCD17_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD17_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD17_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD17_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD17_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD17_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD17_DADDR - TCD Destination Address
 * - HW_DMA_TCD17_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD17_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD17_CITER_ELINKNO - 
 * - HW_DMA_TCD17_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD17_CSR - TCD Control and Status
 * - HW_DMA_TCD17_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD17_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD18_SADDR - TCD Source Address
 * - HW_DMA_TCD18_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD18_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD18_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD18_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD18_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD18_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD18_DADDR - TCD Destination Address
 * - HW_DMA_TCD18_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD18_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD18_CITER_ELINKNO - 
 * - HW_DMA_TCD18_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD18_CSR - TCD Control and Status
 * - HW_DMA_TCD18_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD18_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD19_SADDR - TCD Source Address
 * - HW_DMA_TCD19_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD19_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD19_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD19_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD19_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD19_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD19_DADDR - TCD Destination Address
 * - HW_DMA_TCD19_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD19_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD19_CITER_ELINKNO - 
 * - HW_DMA_TCD19_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD19_CSR - TCD Control and Status
 * - HW_DMA_TCD19_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD19_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD20_SADDR - TCD Source Address
 * - HW_DMA_TCD20_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD20_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD20_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD20_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD20_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD20_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD20_DADDR - TCD Destination Address
 * - HW_DMA_TCD20_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD20_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD20_CITER_ELINKNO - 
 * - HW_DMA_TCD20_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD20_CSR - TCD Control and Status
 * - HW_DMA_TCD20_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD20_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD21_SADDR - TCD Source Address
 * - HW_DMA_TCD21_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD21_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD21_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD21_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD21_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD21_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD21_DADDR - TCD Destination Address
 * - HW_DMA_TCD21_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD21_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD21_CITER_ELINKNO - 
 * - HW_DMA_TCD21_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD21_CSR - TCD Control and Status
 * - HW_DMA_TCD21_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD21_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD22_SADDR - TCD Source Address
 * - HW_DMA_TCD22_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD22_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD22_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD22_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD22_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD22_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD22_DADDR - TCD Destination Address
 * - HW_DMA_TCD22_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD22_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD22_CITER_ELINKNO - 
 * - HW_DMA_TCD22_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD22_CSR - TCD Control and Status
 * - HW_DMA_TCD22_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD22_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD23_SADDR - TCD Source Address
 * - HW_DMA_TCD23_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD23_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD23_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD23_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD23_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD23_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD23_DADDR - TCD Destination Address
 * - HW_DMA_TCD23_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD23_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD23_CITER_ELINKNO - 
 * - HW_DMA_TCD23_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD23_CSR - TCD Control and Status
 * - HW_DMA_TCD23_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD23_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD24_SADDR - TCD Source Address
 * - HW_DMA_TCD24_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD24_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD24_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD24_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD24_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD24_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD24_DADDR - TCD Destination Address
 * - HW_DMA_TCD24_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD24_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD24_CITER_ELINKNO - 
 * - HW_DMA_TCD24_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD24_CSR - TCD Control and Status
 * - HW_DMA_TCD24_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD24_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD25_SADDR - TCD Source Address
 * - HW_DMA_TCD25_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD25_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD25_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD25_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD25_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD25_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD25_DADDR - TCD Destination Address
 * - HW_DMA_TCD25_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD25_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD25_CITER_ELINKNO - 
 * - HW_DMA_TCD25_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD25_CSR - TCD Control and Status
 * - HW_DMA_TCD25_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD25_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD26_SADDR - TCD Source Address
 * - HW_DMA_TCD26_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD26_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD26_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD26_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD26_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD26_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD26_DADDR - TCD Destination Address
 * - HW_DMA_TCD26_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD26_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD26_CITER_ELINKNO - 
 * - HW_DMA_TCD26_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD26_CSR - TCD Control and Status
 * - HW_DMA_TCD26_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD26_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD27_SADDR - TCD Source Address
 * - HW_DMA_TCD27_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD27_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD27_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD27_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD27_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD27_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD27_DADDR - TCD Destination Address
 * - HW_DMA_TCD27_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD27_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD27_CITER_ELINKNO - 
 * - HW_DMA_TCD27_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD27_CSR - TCD Control and Status
 * - HW_DMA_TCD27_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD27_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD28_SADDR - TCD Source Address
 * - HW_DMA_TCD28_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD28_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD28_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD28_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD28_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD28_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD28_DADDR - TCD Destination Address
 * - HW_DMA_TCD28_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD28_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD28_CITER_ELINKNO - 
 * - HW_DMA_TCD28_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD28_CSR - TCD Control and Status
 * - HW_DMA_TCD28_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD28_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD29_SADDR - TCD Source Address
 * - HW_DMA_TCD29_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD29_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD29_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD29_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD29_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD29_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD29_DADDR - TCD Destination Address
 * - HW_DMA_TCD29_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD29_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD29_CITER_ELINKNO - 
 * - HW_DMA_TCD29_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD29_CSR - TCD Control and Status
 * - HW_DMA_TCD29_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD29_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD30_SADDR - TCD Source Address
 * - HW_DMA_TCD30_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD30_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD30_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD30_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD30_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD30_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD30_DADDR - TCD Destination Address
 * - HW_DMA_TCD30_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD30_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD30_CITER_ELINKNO - 
 * - HW_DMA_TCD30_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD30_CSR - TCD Control and Status
 * - HW_DMA_TCD30_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD30_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCD31_SADDR - TCD Source Address
 * - HW_DMA_TCD31_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCD31_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCD31_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCD31_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCD31_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCD31_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCD31_DADDR - TCD Destination Address
 * - HW_DMA_TCD31_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCD31_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD31_CITER_ELINKNO - 
 * - HW_DMA_TCD31_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCD31_CSR - TCD Control and Status
 * - HW_DMA_TCD31_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCD31_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 *
 * - hw_dma_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_DMA_BASE
#define HW_DMA_INSTANCE_COUNT (1U) //!< Number of instances of the DMA module.
#define REGS_DMA_BASE (0x40008000U) //!< Base address for DMA.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_CR - Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_CR - Control Register (RW)
 *
 * Reset value: 0x00000400U
 *
 * The CR defines the basic operating configuration of the DMA. The DMA arbitrates channel service
 * requests in two groups of 16 channels each: Group 1 contains channels 31-16 Group 0 contains
 * channels 15-0 Arbitration within a group can be configured to use either a fixed-priority or a
 * round-robin scheme. For fixed-priority arbitration, the highest priority channel requesting
 * service is selected to execute. The channel priority registers assign the priorities; see the
 * DCHPRIn registers. For round-robin arbitration, the channel priorities are ignored and channels
 * within each group are cycled through (from high to low channel number) without regard to
 * priority. For proper operation, writes to the CR register must be performed only when the DMA
 * channels are inactive; that is, when TCDn_CSR[ACTIVE] bits are cleared. The group priorities
 * operate in a similar fashion. In group fixed priority arbitration mode, channel service requests
 * in the highest priority group are executed first, where priority level 1 is the highest and
 * priority level 0 is the lowest. The group priorities are assigned in the GRPnPRI fields of the
 * DMA Control Register (CR). All group priorities must have unique values prior to any channel
 * service requests occurring; otherwise, a configuration error will be reported. For group round
 * robin arbitration, the group priorities are ignored and the groups are cycled through (from high
 * to low group number) without regard to priority. Minor loop offsets are address offset values
 * added to the final source address (TCDn_SADDR) or destination address (TCDn_DADDR) upon minor
 * loop completion. When minor loop offsets are enabled, the minor loop offset (MLOFF) is added to
 * the final source address (TCDn_SADDR), to the final destination address (TCDn_DADDR), or to both
 * prior to the addresses being written back into the TCD. If the major loop is complete, the minor
 * loop offset is ignored and the major loop address offsets (TCDn_SLAST and TCDn_DLAST_SGA) are
 * used to compute the next TCDn_SADDR and TCDn_DADDR values. When minor loop mapping is enabled
 * (EMLM is 1), TCDn word2 is redefined. A portion of TCDn word2 is used to specify multiple fields:
 * a source enable bit (SMLOE) to specify the minor loop offset should be applied to the source
 * address (TCDn_SADDR) upon minor loop completion, a destination enable bit (DMLOE) to specify the
 * minor loop offset should be applied to the destination address (TCDn_DADDR) upon minor loop
 * completion, and the sign extended minor loop offset value (MLOFF). The same offset value (MLOFF)
 * is used for both source and destination minor loop offsets. When either minor loop offset is
 * enabled (SMLOE set or DMLOE set), the NBYTES field is reduced to 10 bits. When both minor loop
 * offsets are disabled (SMLOE cleared and DMLOE cleared), the NBYTES field is a 30-bit vector. When
 * minor loop mapping is disabled (EMLM is 0), all 32 bits of TCDn word2 are assigned to the NBYTES
 * field.
 */
typedef union _hw_dma_cr
{
    uint32_t U;
    struct _hw_dma_cr_bitfields
    {
        uint32_t RESERVED0 : 1; //!< [0] 
        uint32_t EDBG : 1; //!< [1] Enable Debug
        uint32_t ERCA : 1; //!< [2] Enable Round Robin Channel Arbitration
        uint32_t ERGA : 1; //!< [3] Enable Round Robin Group Arbitration
        uint32_t HOE : 1; //!< [4] Halt On Error
        uint32_t HALT : 1; //!< [5] Halt DMA Operations
        uint32_t CLM : 1; //!< [6] Continuous Link Mode
        uint32_t EMLM : 1; //!< [7] Enable Minor Loop Mapping
        uint32_t GRP0PRI : 1; //!< [8] Channel Group 0 Priority
        uint32_t RESERVED1 : 1; //!< [9] 
        uint32_t GRP1PRI : 1; //!< [10] Channel Group 1 Priority
        uint32_t RESERVED2 : 5; //!< [15:11] Reserved.
        uint32_t ECX : 1; //!< [16] Error Cancel Transfer
        uint32_t CX : 1; //!< [17] Cancel Transfer
        uint32_t RESERVED3 : 14; //!< [31:18] 
    } B;
} hw_dma_cr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_CR register
 */
//@{
#define HW_DMA_CR_ADDR      (REGS_DMA_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_CR           (*(__IO hw_dma_cr_t *) HW_DMA_CR_ADDR)
#define HW_DMA_CR_RD()      (HW_DMA_CR.U)
#define HW_DMA_CR_WR(v)     (HW_DMA_CR.U = (v))
#define HW_DMA_CR_SET(v)    (HW_DMA_CR_WR(HW_DMA_CR_RD() |  (v)))
#define HW_DMA_CR_CLR(v)    (HW_DMA_CR_WR(HW_DMA_CR_RD() & ~(v)))
#define HW_DMA_CR_TOG(v)    (HW_DMA_CR_WR(HW_DMA_CR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_CR bitfields
 */

/*! @name Register DMA_CR, field EDBG[1] (RW)
 *
 * Values:
 * - 0 - When in debug mode, the DMA continues to operate.
 * - 1 - When in debug mode, the DMA stalls the start of a new channel. Executing channels are allowed to
 *     complete. Channel execution resumes when the system exits debug mode or the EDBG bit is
 *     cleared.
 */
//@{
#define BP_DMA_CR_EDBG      (1U)      //!< Bit position for DMA_CR_EDBG.
#define BM_DMA_CR_EDBG      (0x00000002U)  //!< Bit mask for DMA_CR_EDBG.
#define BS_DMA_CR_EDBG      (1U)  //!< Bitfield size in bits for DMA_CR_EDBG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_EDBG field.
#define BR_DMA_CR_EDBG()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_EDBG))
#endif

//! @brief Format value for bitfield DMA_CR_EDBG.
#define BF_DMA_CR_EDBG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_EDBG), uint32_t) & BM_DMA_CR_EDBG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EDBG field to a new value.
#define BW_DMA_CR_EDBG(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_EDBG) = (v))
#endif
//@}

/*! @name Register DMA_CR, field ERCA[2] (RW)
 *
 * Values:
 * - 0 - Fixed priority arbitration is used for channel selection within each group .
 * - 1 - Round robin arbitration is used for channel selection within each group .
 */
//@{
#define BP_DMA_CR_ERCA      (2U)      //!< Bit position for DMA_CR_ERCA.
#define BM_DMA_CR_ERCA      (0x00000004U)  //!< Bit mask for DMA_CR_ERCA.
#define BS_DMA_CR_ERCA      (1U)  //!< Bitfield size in bits for DMA_CR_ERCA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_ERCA field.
#define BR_DMA_CR_ERCA()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_ERCA))
#endif

//! @brief Format value for bitfield DMA_CR_ERCA.
#define BF_DMA_CR_ERCA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_ERCA), uint32_t) & BM_DMA_CR_ERCA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERCA field to a new value.
#define BW_DMA_CR_ERCA(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_ERCA) = (v))
#endif
//@}

/*! @name Register DMA_CR, field ERGA[3] (RW)
 *
 * Values:
 * - 0 - Fixed priority arbitration is used for selection among the groups.
 * - 1 - Round robin arbitration is used for selection among the groups.
 */
//@{
#define BP_DMA_CR_ERGA      (3U)      //!< Bit position for DMA_CR_ERGA.
#define BM_DMA_CR_ERGA      (0x00000008U)  //!< Bit mask for DMA_CR_ERGA.
#define BS_DMA_CR_ERGA      (1U)  //!< Bitfield size in bits for DMA_CR_ERGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_ERGA field.
#define BR_DMA_CR_ERGA()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_ERGA))
#endif

//! @brief Format value for bitfield DMA_CR_ERGA.
#define BF_DMA_CR_ERGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_ERGA), uint32_t) & BM_DMA_CR_ERGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERGA field to a new value.
#define BW_DMA_CR_ERGA(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_ERGA) = (v))
#endif
//@}

/*! @name Register DMA_CR, field HOE[4] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT
 *     bit is cleared.
 */
//@{
#define BP_DMA_CR_HOE      (4U)      //!< Bit position for DMA_CR_HOE.
#define BM_DMA_CR_HOE      (0x00000010U)  //!< Bit mask for DMA_CR_HOE.
#define BS_DMA_CR_HOE      (1U)  //!< Bitfield size in bits for DMA_CR_HOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_HOE field.
#define BR_DMA_CR_HOE()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_HOE))
#endif

//! @brief Format value for bitfield DMA_CR_HOE.
#define BF_DMA_CR_HOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_HOE), uint32_t) & BM_DMA_CR_HOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HOE field to a new value.
#define BW_DMA_CR_HOE(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_HOE) = (v))
#endif
//@}

/*! @name Register DMA_CR, field HALT[5] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Stall the start of any new channels. Executing channels are allowed to complete. Channel execution
 *     resumes when this bit is cleared.
 */
//@{
#define BP_DMA_CR_HALT      (5U)      //!< Bit position for DMA_CR_HALT.
#define BM_DMA_CR_HALT      (0x00000020U)  //!< Bit mask for DMA_CR_HALT.
#define BS_DMA_CR_HALT      (1U)  //!< Bitfield size in bits for DMA_CR_HALT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_HALT field.
#define BR_DMA_CR_HALT()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_HALT))
#endif

//! @brief Format value for bitfield DMA_CR_HALT.
#define BF_DMA_CR_HALT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_HALT), uint32_t) & BM_DMA_CR_HALT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HALT field to a new value.
#define BW_DMA_CR_HALT(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_HALT) = (v))
#endif
//@}

/*! @name Register DMA_CR, field CLM[6] (RW)
 *
 * Values:
 * - 0 - A minor loop channel link made to itself goes through channel arbitration before being activated
 *     again.
 * - 1 - A minor loop channel link made to itself does not go through channel arbitration before being
 *     activated again. Upon minor loop completion, the channel activates again if that channel has
 *     a minor loop channel link enabled and the link channel is itself. This effectively applies
 *     the minor loop offsets and restarts the next minor loop.
 */
//@{
#define BP_DMA_CR_CLM      (6U)      //!< Bit position for DMA_CR_CLM.
#define BM_DMA_CR_CLM      (0x00000040U)  //!< Bit mask for DMA_CR_CLM.
#define BS_DMA_CR_CLM      (1U)  //!< Bitfield size in bits for DMA_CR_CLM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_CLM field.
#define BR_DMA_CR_CLM()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_CLM))
#endif

//! @brief Format value for bitfield DMA_CR_CLM.
#define BF_DMA_CR_CLM(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_CLM), uint32_t) & BM_DMA_CR_CLM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CLM field to a new value.
#define BW_DMA_CR_CLM(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_CLM) = (v))
#endif
//@}

/*! @name Register DMA_CR, field EMLM[7] (RW)
 *
 * Values:
 * - 0 - Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
 * - 1 - Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the
 *     NBYTES field. The individual enable fields allow the minor loop offset to be applied to the
 *     source address, the destination address, or both. The NBYTES field is reduced when either
 *     offset is enabled.
 */
//@{
#define BP_DMA_CR_EMLM      (7U)      //!< Bit position for DMA_CR_EMLM.
#define BM_DMA_CR_EMLM      (0x00000080U)  //!< Bit mask for DMA_CR_EMLM.
#define BS_DMA_CR_EMLM      (1U)  //!< Bitfield size in bits for DMA_CR_EMLM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_EMLM field.
#define BR_DMA_CR_EMLM()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_EMLM))
#endif

//! @brief Format value for bitfield DMA_CR_EMLM.
#define BF_DMA_CR_EMLM(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_EMLM), uint32_t) & BM_DMA_CR_EMLM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EMLM field to a new value.
#define BW_DMA_CR_EMLM(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_EMLM) = (v))
#endif
//@}

/*! @name Register DMA_CR, field GRP0PRI[8] (RW)
 *
 * Group 0 priority level when fixed priority group arbitration is enabled.
 */
//@{
#define BP_DMA_CR_GRP0PRI      (8U)      //!< Bit position for DMA_CR_GRP0PRI.
#define BM_DMA_CR_GRP0PRI      (0x00000100U)  //!< Bit mask for DMA_CR_GRP0PRI.
#define BS_DMA_CR_GRP0PRI      (1U)  //!< Bitfield size in bits for DMA_CR_GRP0PRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_GRP0PRI field.
#define BR_DMA_CR_GRP0PRI()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_GRP0PRI))
#endif

//! @brief Format value for bitfield DMA_CR_GRP0PRI.
#define BF_DMA_CR_GRP0PRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_GRP0PRI), uint32_t) & BM_DMA_CR_GRP0PRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GRP0PRI field to a new value.
#define BW_DMA_CR_GRP0PRI(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_GRP0PRI) = (v))
#endif
//@}

/*! @name Register DMA_CR, field GRP1PRI[10] (RW)
 *
 * Group 1 priority level when fixed priority group arbitration is enabled.
 */
//@{
#define BP_DMA_CR_GRP1PRI      (10U)      //!< Bit position for DMA_CR_GRP1PRI.
#define BM_DMA_CR_GRP1PRI      (0x00000400U)  //!< Bit mask for DMA_CR_GRP1PRI.
#define BS_DMA_CR_GRP1PRI      (1U)  //!< Bitfield size in bits for DMA_CR_GRP1PRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_GRP1PRI field.
#define BR_DMA_CR_GRP1PRI()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_GRP1PRI))
#endif

//! @brief Format value for bitfield DMA_CR_GRP1PRI.
#define BF_DMA_CR_GRP1PRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_GRP1PRI), uint32_t) & BM_DMA_CR_GRP1PRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GRP1PRI field to a new value.
#define BW_DMA_CR_GRP1PRI(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_GRP1PRI) = (v))
#endif
//@}

/*! @name Register DMA_CR, field ECX[16] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and
 *     force the minor loop to finish. The cancel takes effect after the last write of the current
 *     read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to
 *     cancelling the transfer, ECX treats the cancel as an error condition, thus updating the Error
 *     Status register (DMAx_ES) and generating an optional error interrupt.
 */
//@{
#define BP_DMA_CR_ECX      (16U)      //!< Bit position for DMA_CR_ECX.
#define BM_DMA_CR_ECX      (0x00010000U)  //!< Bit mask for DMA_CR_ECX.
#define BS_DMA_CR_ECX      (1U)  //!< Bitfield size in bits for DMA_CR_ECX.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_ECX field.
#define BR_DMA_CR_ECX()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_ECX))
#endif

//! @brief Format value for bitfield DMA_CR_ECX.
#define BF_DMA_CR_ECX(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_ECX), uint32_t) & BM_DMA_CR_ECX)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECX field to a new value.
#define BW_DMA_CR_ECX(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_ECX) = (v))
#endif
//@}

/*! @name Register DMA_CR, field CX[17] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish.
 *     The cancel takes effect after the last write of the current read/write sequence. The CX bit
 *     clears itself after the cancel has been honored. This cancel retires the channel normally as
 *     if the minor loop was completed.
 */
//@{
#define BP_DMA_CR_CX      (17U)      //!< Bit position for DMA_CR_CX.
#define BM_DMA_CR_CX      (0x00020000U)  //!< Bit mask for DMA_CR_CX.
#define BS_DMA_CR_CX      (1U)  //!< Bitfield size in bits for DMA_CR_CX.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CR_CX field.
#define BR_DMA_CR_CX()   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_CX))
#endif

//! @brief Format value for bitfield DMA_CR_CX.
#define BF_DMA_CR_CX(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_CR_CX), uint32_t) & BM_DMA_CR_CX)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CX field to a new value.
#define BW_DMA_CR_CX(v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR, BP_DMA_CR_CX) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_ES - Error Status Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_ES - Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The ES provides information concerning the last recorded channel error. Channel errors can be
 * caused by: A configuration error, that is: An illegal setting in the transfer-control descriptor,
 * or An illegal priority register setting in fixed-arbitration An error termination to a bus master
 * read or write cycle See the Error Reporting and Handling section for more details.
 */
typedef union _hw_dma_es
{
    uint32_t U;
    struct _hw_dma_es_bitfields
    {
        uint32_t DBE : 1; //!< [0] Destination Bus Error
        uint32_t SBE : 1; //!< [1] Source Bus Error
        uint32_t SGE : 1; //!< [2] Scatter/Gather Configuration Error
        uint32_t NCE : 1; //!< [3] NBYTES/CITER Configuration Error
        uint32_t DOE : 1; //!< [4] Destination Offset Error
        uint32_t DAE : 1; //!< [5] Destination Address Error
        uint32_t SOE : 1; //!< [6] Source Offset Error
        uint32_t SAE : 1; //!< [7] Source Address Error
        uint32_t ERRCHN : 5; //!< [12:8] Error Channel Number or Canceled Channel Number
        uint32_t RESERVED0 : 1; //!< [13] 
        uint32_t CPE : 1; //!< [14] Channel Priority Error
        uint32_t GPE : 1; //!< [15] Group Priority Error
        uint32_t ECX : 1; //!< [16] Transfer Canceled
        uint32_t RESERVED1 : 14; //!< [30:17] 
        uint32_t VLD : 1; //!< [31] Logical OR of all ERR status bits
    } B;
} hw_dma_es_t;
#endif

/*!
 * @name Constants and macros for entire DMA_ES register
 */
//@{
#define HW_DMA_ES_ADDR      (REGS_DMA_BASE + 0x4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_ES           (*(__I hw_dma_es_t *) HW_DMA_ES_ADDR)
#define HW_DMA_ES_RD()      (HW_DMA_ES.U)
#endif
//@}

/*
 * constants & macros for individual DMA_ES bitfields
 */

/*! @name Register DMA_ES, field DBE[0] (RO)
 *
 * Values:
 * - 0 - No destination bus error
 * - 1 - The last recorded error was a bus error on a destination write
 */
//@{
#define BP_DMA_ES_DBE      (0U)      //!< Bit position for DMA_ES_DBE.
#define BM_DMA_ES_DBE      (0x00000001U)  //!< Bit mask for DMA_ES_DBE.
#define BS_DMA_ES_DBE      (1U)  //!< Bitfield size in bits for DMA_ES_DBE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_DBE field.
#define BR_DMA_ES_DBE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_DBE))
#endif
//@}

/*! @name Register DMA_ES, field SBE[1] (RO)
 *
 * Values:
 * - 0 - No source bus error
 * - 1 - The last recorded error was a bus error on a source read
 */
//@{
#define BP_DMA_ES_SBE      (1U)      //!< Bit position for DMA_ES_SBE.
#define BM_DMA_ES_SBE      (0x00000002U)  //!< Bit mask for DMA_ES_SBE.
#define BS_DMA_ES_SBE      (1U)  //!< Bitfield size in bits for DMA_ES_SBE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_SBE field.
#define BR_DMA_ES_SBE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_SBE))
#endif
//@}

/*! @name Register DMA_ES, field SGE[2] (RO)
 *
 * Values:
 * - 0 - No scatter/gather configuration error
 * - 1 - The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is
 *     checked at the beginning of a scatter/gather operation after major loop completion if
 *     TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.
 */
//@{
#define BP_DMA_ES_SGE      (2U)      //!< Bit position for DMA_ES_SGE.
#define BM_DMA_ES_SGE      (0x00000004U)  //!< Bit mask for DMA_ES_SGE.
#define BS_DMA_ES_SGE      (1U)  //!< Bitfield size in bits for DMA_ES_SGE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_SGE field.
#define BR_DMA_ES_SGE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_SGE))
#endif
//@}

/*! @name Register DMA_ES, field NCE[3] (RO)
 *
 * Values:
 * - 0 - No NBYTES/CITER configuration error
 * - 1 - The last recorded error was a configuration error detected in the TCDn_NBYTES or TCDn_CITER fields.
 *     TCDn_NBYTES is not a multiple of TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or  TCDn_CITER[CITER]
 *     is equal to zero, or  TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
 */
//@{
#define BP_DMA_ES_NCE      (3U)      //!< Bit position for DMA_ES_NCE.
#define BM_DMA_ES_NCE      (0x00000008U)  //!< Bit mask for DMA_ES_NCE.
#define BS_DMA_ES_NCE      (1U)  //!< Bitfield size in bits for DMA_ES_NCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_NCE field.
#define BR_DMA_ES_NCE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_NCE))
#endif
//@}

/*! @name Register DMA_ES, field DOE[4] (RO)
 *
 * Values:
 * - 0 - No destination offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is
 *     inconsistent with TCDn_ATTR[DSIZE].
 */
//@{
#define BP_DMA_ES_DOE      (4U)      //!< Bit position for DMA_ES_DOE.
#define BM_DMA_ES_DOE      (0x00000010U)  //!< Bit mask for DMA_ES_DOE.
#define BS_DMA_ES_DOE      (1U)  //!< Bitfield size in bits for DMA_ES_DOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_DOE field.
#define BR_DMA_ES_DOE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_DOE))
#endif
//@}

/*! @name Register DMA_ES, field DAE[5] (RO)
 *
 * Values:
 * - 0 - No destination address configuration error
 * - 1 - The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is
 *     inconsistent with TCDn_ATTR[DSIZE].
 */
//@{
#define BP_DMA_ES_DAE      (5U)      //!< Bit position for DMA_ES_DAE.
#define BM_DMA_ES_DAE      (0x00000020U)  //!< Bit mask for DMA_ES_DAE.
#define BS_DMA_ES_DAE      (1U)  //!< Bitfield size in bits for DMA_ES_DAE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_DAE field.
#define BR_DMA_ES_DAE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_DAE))
#endif
//@}

/*! @name Register DMA_ES, field SOE[6] (RO)
 *
 * Values:
 * - 0 - No source offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is
 *     inconsistent with TCDn_ATTR[SSIZE].
 */
//@{
#define BP_DMA_ES_SOE      (6U)      //!< Bit position for DMA_ES_SOE.
#define BM_DMA_ES_SOE      (0x00000040U)  //!< Bit mask for DMA_ES_SOE.
#define BS_DMA_ES_SOE      (1U)  //!< Bitfield size in bits for DMA_ES_SOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_SOE field.
#define BR_DMA_ES_SOE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_SOE))
#endif
//@}

/*! @name Register DMA_ES, field SAE[7] (RO)
 *
 * Values:
 * - 0 - No source address configuration error.
 * - 1 - The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is
 *     inconsistent with TCDn_ATTR[SSIZE].
 */
//@{
#define BP_DMA_ES_SAE      (7U)      //!< Bit position for DMA_ES_SAE.
#define BM_DMA_ES_SAE      (0x00000080U)  //!< Bit mask for DMA_ES_SAE.
#define BS_DMA_ES_SAE      (1U)  //!< Bitfield size in bits for DMA_ES_SAE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_SAE field.
#define BR_DMA_ES_SAE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_SAE))
#endif
//@}

/*! @name Register DMA_ES, field ERRCHN[12:8] (RO)
 *
 * The channel number of the last recorded error, excluding GPE and CPE errors, or last recorded
 * error canceled transfer .
 */
//@{
#define BP_DMA_ES_ERRCHN      (8U)      //!< Bit position for DMA_ES_ERRCHN.
#define BM_DMA_ES_ERRCHN      (0x00001f00U)  //!< Bit mask for DMA_ES_ERRCHN.
#define BS_DMA_ES_ERRCHN      (5U)  //!< Bitfield size in bits for DMA_ES_ERRCHN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_ERRCHN field.
#define BR_DMA_ES_ERRCHN()   (HW_DMA_ES.B.ERRCHN)
#endif
//@}

/*! @name Register DMA_ES, field CPE[14] (RO)
 *
 * Values:
 * - 0 - No channel priority error
 * - 1 - The last recorded error was a configuration error in the channel priorities within a group . Channel
 *     priorities within a group are not unique.
 */
//@{
#define BP_DMA_ES_CPE      (14U)      //!< Bit position for DMA_ES_CPE.
#define BM_DMA_ES_CPE      (0x00004000U)  //!< Bit mask for DMA_ES_CPE.
#define BS_DMA_ES_CPE      (1U)  //!< Bitfield size in bits for DMA_ES_CPE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_CPE field.
#define BR_DMA_ES_CPE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_CPE))
#endif
//@}

/*! @name Register DMA_ES, field GPE[15] (RO)
 *
 * Values:
 * - 0 - No group priority error
 * - 1 - The last recorded error was a configuration error among the group priorities. All group priorities
 *     are not unique.
 */
//@{
#define BP_DMA_ES_GPE      (15U)      //!< Bit position for DMA_ES_GPE.
#define BM_DMA_ES_GPE      (0x00008000U)  //!< Bit mask for DMA_ES_GPE.
#define BS_DMA_ES_GPE      (1U)  //!< Bitfield size in bits for DMA_ES_GPE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_GPE field.
#define BR_DMA_ES_GPE()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_GPE))
#endif
//@}

/*! @name Register DMA_ES, field ECX[16] (RO)
 *
 * Values:
 * - 0 - No canceled transfers
 * - 1 - The last recorded entry was a canceled transfer by the error cancel transfer input
 */
//@{
#define BP_DMA_ES_ECX      (16U)      //!< Bit position for DMA_ES_ECX.
#define BM_DMA_ES_ECX      (0x00010000U)  //!< Bit mask for DMA_ES_ECX.
#define BS_DMA_ES_ECX      (1U)  //!< Bitfield size in bits for DMA_ES_ECX.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_ECX field.
#define BR_DMA_ES_ECX()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_ECX))
#endif
//@}

/*! @name Register DMA_ES, field VLD[31] (RO)
 *
 * Logical OR of all ERR status bits
 *
 * Values:
 * - 0 - No ERR bits are set
 * - 1 - At least one ERR bit is set indicating a valid error exists that has not been cleared
 */
//@{
#define BP_DMA_ES_VLD      (31U)      //!< Bit position for DMA_ES_VLD.
#define BM_DMA_ES_VLD      (0x80000000U)  //!< Bit mask for DMA_ES_VLD.
#define BS_DMA_ES_VLD      (1U)  //!< Bitfield size in bits for DMA_ES_VLD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ES_VLD field.
#define BR_DMA_ES_VLD()   (BITBAND_ACCESS32(HW_DMA_ES_ADDR, BP_DMA_ES_VLD))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_ERQ - Enable Request Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_ERQ - Enable Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERQ register provide s a bit map for the 32 implemented channels to enable the request signal
 * for each channel. The state of any given channel enable is directly affected by writes to this
 * register; it is also affected by writes to the SERQ and CERQ. The {S,C}ERQ registers are provided
 * so the request enable for a single channel can easily be modified without needing to perform a
 * read-modify-write sequence to the ERQ. DMA request input signals and this enable request flag
 * must be asserted before a channels hardware service request is accepted. The state of the DMA
 * enable request flag does not affect a channel service request made explicitly through software or
 * a linked channel request.
 */
typedef union _hw_dma_erq
{
    uint32_t U;
    struct _hw_dma_erq_bitfields
    {
        uint32_t ERQ0 : 1; //!< [0] Enable DMA Request 0
        uint32_t ERQ1 : 1; //!< [1] Enable DMA Request 1
        uint32_t ERQ2 : 1; //!< [2] Enable DMA Request 2
        uint32_t ERQ3 : 1; //!< [3] Enable DMA Request 3
        uint32_t ERQ4 : 1; //!< [4] Enable DMA Request 4
        uint32_t ERQ5 : 1; //!< [5] Enable DMA Request 5
        uint32_t ERQ6 : 1; //!< [6] Enable DMA Request 6
        uint32_t ERQ7 : 1; //!< [7] Enable DMA Request 7
        uint32_t ERQ8 : 1; //!< [8] Enable DMA Request 8
        uint32_t ERQ9 : 1; //!< [9] Enable DMA Request 9
        uint32_t ERQ10 : 1; //!< [10] Enable DMA Request 10
        uint32_t ERQ11 : 1; //!< [11] Enable DMA Request 11
        uint32_t ERQ12 : 1; //!< [12] Enable DMA Request 12
        uint32_t ERQ13 : 1; //!< [13] Enable DMA Request 13
        uint32_t ERQ14 : 1; //!< [14] Enable DMA Request 14
        uint32_t ERQ15 : 1; //!< [15] Enable DMA Request 15
        uint32_t ERQ16 : 1; //!< [16] Enable DMA Request 16
        uint32_t ERQ17 : 1; //!< [17] Enable DMA Request 17
        uint32_t ERQ18 : 1; //!< [18] Enable DMA Request 18
        uint32_t ERQ19 : 1; //!< [19] Enable DMA Request 19
        uint32_t ERQ20 : 1; //!< [20] Enable DMA Request 20
        uint32_t ERQ21 : 1; //!< [21] Enable DMA Request 21
        uint32_t ERQ22 : 1; //!< [22] Enable DMA Request 22
        uint32_t ERQ23 : 1; //!< [23] Enable DMA Request 23
        uint32_t ERQ24 : 1; //!< [24] Enable DMA Request 24
        uint32_t ERQ25 : 1; //!< [25] Enable DMA Request 25
        uint32_t ERQ26 : 1; //!< [26] Enable DMA Request 26
        uint32_t ERQ27 : 1; //!< [27] Enable DMA Request 27
        uint32_t ERQ28 : 1; //!< [28] Enable DMA Request 28
        uint32_t ERQ29 : 1; //!< [29] Enable DMA Request 29
        uint32_t ERQ30 : 1; //!< [30] Enable DMA Request 30
        uint32_t ERQ31 : 1; //!< [31] Enable DMA Request 31
    } B;
} hw_dma_erq_t;
#endif

/*!
 * @name Constants and macros for entire DMA_ERQ register
 */
//@{
#define HW_DMA_ERQ_ADDR      (REGS_DMA_BASE + 0xcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_ERQ           (*(__IO hw_dma_erq_t *) HW_DMA_ERQ_ADDR)
#define HW_DMA_ERQ_RD()      (HW_DMA_ERQ.U)
#define HW_DMA_ERQ_WR(v)     (HW_DMA_ERQ.U = (v))
#define HW_DMA_ERQ_SET(v)    (HW_DMA_ERQ_WR(HW_DMA_ERQ_RD() |  (v)))
#define HW_DMA_ERQ_CLR(v)    (HW_DMA_ERQ_WR(HW_DMA_ERQ_RD() & ~(v)))
#define HW_DMA_ERQ_TOG(v)    (HW_DMA_ERQ_WR(HW_DMA_ERQ_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_ERQ bitfields
 */

/*! @name Register DMA_ERQ, field ERQ0[0] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ0      (0U)      //!< Bit position for DMA_ERQ_ERQ0.
#define BM_DMA_ERQ_ERQ0      (0x00000001U)  //!< Bit mask for DMA_ERQ_ERQ0.
#define BS_DMA_ERQ_ERQ0      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ0 field.
#define BR_DMA_ERQ_ERQ0()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ0))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ0.
#define BF_DMA_ERQ_ERQ0(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ0), uint32_t) & BM_DMA_ERQ_ERQ0)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ0 field to a new value.
#define BW_DMA_ERQ_ERQ0(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ0) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ1[1] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ1      (1U)      //!< Bit position for DMA_ERQ_ERQ1.
#define BM_DMA_ERQ_ERQ1      (0x00000002U)  //!< Bit mask for DMA_ERQ_ERQ1.
#define BS_DMA_ERQ_ERQ1      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ1 field.
#define BR_DMA_ERQ_ERQ1()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ1))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ1.
#define BF_DMA_ERQ_ERQ1(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ1), uint32_t) & BM_DMA_ERQ_ERQ1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ1 field to a new value.
#define BW_DMA_ERQ_ERQ1(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ1) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ2[2] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ2      (2U)      //!< Bit position for DMA_ERQ_ERQ2.
#define BM_DMA_ERQ_ERQ2      (0x00000004U)  //!< Bit mask for DMA_ERQ_ERQ2.
#define BS_DMA_ERQ_ERQ2      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ2 field.
#define BR_DMA_ERQ_ERQ2()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ2))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ2.
#define BF_DMA_ERQ_ERQ2(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ2), uint32_t) & BM_DMA_ERQ_ERQ2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ2 field to a new value.
#define BW_DMA_ERQ_ERQ2(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ2) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ3[3] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ3      (3U)      //!< Bit position for DMA_ERQ_ERQ3.
#define BM_DMA_ERQ_ERQ3      (0x00000008U)  //!< Bit mask for DMA_ERQ_ERQ3.
#define BS_DMA_ERQ_ERQ3      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ3.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ3 field.
#define BR_DMA_ERQ_ERQ3()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ3))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ3.
#define BF_DMA_ERQ_ERQ3(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ3), uint32_t) & BM_DMA_ERQ_ERQ3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ3 field to a new value.
#define BW_DMA_ERQ_ERQ3(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ3) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ4[4] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ4      (4U)      //!< Bit position for DMA_ERQ_ERQ4.
#define BM_DMA_ERQ_ERQ4      (0x00000010U)  //!< Bit mask for DMA_ERQ_ERQ4.
#define BS_DMA_ERQ_ERQ4      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ4.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ4 field.
#define BR_DMA_ERQ_ERQ4()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ4))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ4.
#define BF_DMA_ERQ_ERQ4(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ4), uint32_t) & BM_DMA_ERQ_ERQ4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ4 field to a new value.
#define BW_DMA_ERQ_ERQ4(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ4) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ5[5] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ5      (5U)      //!< Bit position for DMA_ERQ_ERQ5.
#define BM_DMA_ERQ_ERQ5      (0x00000020U)  //!< Bit mask for DMA_ERQ_ERQ5.
#define BS_DMA_ERQ_ERQ5      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ5.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ5 field.
#define BR_DMA_ERQ_ERQ5()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ5))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ5.
#define BF_DMA_ERQ_ERQ5(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ5), uint32_t) & BM_DMA_ERQ_ERQ5)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ5 field to a new value.
#define BW_DMA_ERQ_ERQ5(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ5) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ6[6] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ6      (6U)      //!< Bit position for DMA_ERQ_ERQ6.
#define BM_DMA_ERQ_ERQ6      (0x00000040U)  //!< Bit mask for DMA_ERQ_ERQ6.
#define BS_DMA_ERQ_ERQ6      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ6.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ6 field.
#define BR_DMA_ERQ_ERQ6()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ6))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ6.
#define BF_DMA_ERQ_ERQ6(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ6), uint32_t) & BM_DMA_ERQ_ERQ6)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ6 field to a new value.
#define BW_DMA_ERQ_ERQ6(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ6) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ7[7] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ7      (7U)      //!< Bit position for DMA_ERQ_ERQ7.
#define BM_DMA_ERQ_ERQ7      (0x00000080U)  //!< Bit mask for DMA_ERQ_ERQ7.
#define BS_DMA_ERQ_ERQ7      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ7.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ7 field.
#define BR_DMA_ERQ_ERQ7()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ7))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ7.
#define BF_DMA_ERQ_ERQ7(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ7), uint32_t) & BM_DMA_ERQ_ERQ7)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ7 field to a new value.
#define BW_DMA_ERQ_ERQ7(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ7) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ8[8] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ8      (8U)      //!< Bit position for DMA_ERQ_ERQ8.
#define BM_DMA_ERQ_ERQ8      (0x00000100U)  //!< Bit mask for DMA_ERQ_ERQ8.
#define BS_DMA_ERQ_ERQ8      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ8.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ8 field.
#define BR_DMA_ERQ_ERQ8()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ8))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ8.
#define BF_DMA_ERQ_ERQ8(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ8), uint32_t) & BM_DMA_ERQ_ERQ8)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ8 field to a new value.
#define BW_DMA_ERQ_ERQ8(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ8) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ9[9] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ9      (9U)      //!< Bit position for DMA_ERQ_ERQ9.
#define BM_DMA_ERQ_ERQ9      (0x00000200U)  //!< Bit mask for DMA_ERQ_ERQ9.
#define BS_DMA_ERQ_ERQ9      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ9.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ9 field.
#define BR_DMA_ERQ_ERQ9()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ9))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ9.
#define BF_DMA_ERQ_ERQ9(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ9), uint32_t) & BM_DMA_ERQ_ERQ9)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ9 field to a new value.
#define BW_DMA_ERQ_ERQ9(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ9) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ10[10] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ10      (10U)      //!< Bit position for DMA_ERQ_ERQ10.
#define BM_DMA_ERQ_ERQ10      (0x00000400U)  //!< Bit mask for DMA_ERQ_ERQ10.
#define BS_DMA_ERQ_ERQ10      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ10.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ10 field.
#define BR_DMA_ERQ_ERQ10()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ10))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ10.
#define BF_DMA_ERQ_ERQ10(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ10), uint32_t) & BM_DMA_ERQ_ERQ10)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ10 field to a new value.
#define BW_DMA_ERQ_ERQ10(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ10) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ11[11] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ11      (11U)      //!< Bit position for DMA_ERQ_ERQ11.
#define BM_DMA_ERQ_ERQ11      (0x00000800U)  //!< Bit mask for DMA_ERQ_ERQ11.
#define BS_DMA_ERQ_ERQ11      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ11.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ11 field.
#define BR_DMA_ERQ_ERQ11()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ11))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ11.
#define BF_DMA_ERQ_ERQ11(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ11), uint32_t) & BM_DMA_ERQ_ERQ11)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ11 field to a new value.
#define BW_DMA_ERQ_ERQ11(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ11) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ12[12] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ12      (12U)      //!< Bit position for DMA_ERQ_ERQ12.
#define BM_DMA_ERQ_ERQ12      (0x00001000U)  //!< Bit mask for DMA_ERQ_ERQ12.
#define BS_DMA_ERQ_ERQ12      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ12.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ12 field.
#define BR_DMA_ERQ_ERQ12()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ12))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ12.
#define BF_DMA_ERQ_ERQ12(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ12), uint32_t) & BM_DMA_ERQ_ERQ12)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ12 field to a new value.
#define BW_DMA_ERQ_ERQ12(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ12) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ13[13] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ13      (13U)      //!< Bit position for DMA_ERQ_ERQ13.
#define BM_DMA_ERQ_ERQ13      (0x00002000U)  //!< Bit mask for DMA_ERQ_ERQ13.
#define BS_DMA_ERQ_ERQ13      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ13.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ13 field.
#define BR_DMA_ERQ_ERQ13()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ13))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ13.
#define BF_DMA_ERQ_ERQ13(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ13), uint32_t) & BM_DMA_ERQ_ERQ13)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ13 field to a new value.
#define BW_DMA_ERQ_ERQ13(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ13) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ14[14] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ14      (14U)      //!< Bit position for DMA_ERQ_ERQ14.
#define BM_DMA_ERQ_ERQ14      (0x00004000U)  //!< Bit mask for DMA_ERQ_ERQ14.
#define BS_DMA_ERQ_ERQ14      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ14.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ14 field.
#define BR_DMA_ERQ_ERQ14()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ14))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ14.
#define BF_DMA_ERQ_ERQ14(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ14), uint32_t) & BM_DMA_ERQ_ERQ14)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ14 field to a new value.
#define BW_DMA_ERQ_ERQ14(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ14) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ15[15] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ15      (15U)      //!< Bit position for DMA_ERQ_ERQ15.
#define BM_DMA_ERQ_ERQ15      (0x00008000U)  //!< Bit mask for DMA_ERQ_ERQ15.
#define BS_DMA_ERQ_ERQ15      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ15.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ15 field.
#define BR_DMA_ERQ_ERQ15()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ15))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ15.
#define BF_DMA_ERQ_ERQ15(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ15), uint32_t) & BM_DMA_ERQ_ERQ15)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ15 field to a new value.
#define BW_DMA_ERQ_ERQ15(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ15) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ16[16] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ16      (16U)      //!< Bit position for DMA_ERQ_ERQ16.
#define BM_DMA_ERQ_ERQ16      (0x00010000U)  //!< Bit mask for DMA_ERQ_ERQ16.
#define BS_DMA_ERQ_ERQ16      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ16.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ16 field.
#define BR_DMA_ERQ_ERQ16()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ16))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ16.
#define BF_DMA_ERQ_ERQ16(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ16), uint32_t) & BM_DMA_ERQ_ERQ16)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ16 field to a new value.
#define BW_DMA_ERQ_ERQ16(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ16) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ17[17] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ17      (17U)      //!< Bit position for DMA_ERQ_ERQ17.
#define BM_DMA_ERQ_ERQ17      (0x00020000U)  //!< Bit mask for DMA_ERQ_ERQ17.
#define BS_DMA_ERQ_ERQ17      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ17.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ17 field.
#define BR_DMA_ERQ_ERQ17()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ17))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ17.
#define BF_DMA_ERQ_ERQ17(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ17), uint32_t) & BM_DMA_ERQ_ERQ17)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ17 field to a new value.
#define BW_DMA_ERQ_ERQ17(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ17) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ18[18] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ18      (18U)      //!< Bit position for DMA_ERQ_ERQ18.
#define BM_DMA_ERQ_ERQ18      (0x00040000U)  //!< Bit mask for DMA_ERQ_ERQ18.
#define BS_DMA_ERQ_ERQ18      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ18.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ18 field.
#define BR_DMA_ERQ_ERQ18()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ18))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ18.
#define BF_DMA_ERQ_ERQ18(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ18), uint32_t) & BM_DMA_ERQ_ERQ18)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ18 field to a new value.
#define BW_DMA_ERQ_ERQ18(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ18) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ19[19] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ19      (19U)      //!< Bit position for DMA_ERQ_ERQ19.
#define BM_DMA_ERQ_ERQ19      (0x00080000U)  //!< Bit mask for DMA_ERQ_ERQ19.
#define BS_DMA_ERQ_ERQ19      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ19.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ19 field.
#define BR_DMA_ERQ_ERQ19()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ19))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ19.
#define BF_DMA_ERQ_ERQ19(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ19), uint32_t) & BM_DMA_ERQ_ERQ19)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ19 field to a new value.
#define BW_DMA_ERQ_ERQ19(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ19) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ20[20] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ20      (20U)      //!< Bit position for DMA_ERQ_ERQ20.
#define BM_DMA_ERQ_ERQ20      (0x00100000U)  //!< Bit mask for DMA_ERQ_ERQ20.
#define BS_DMA_ERQ_ERQ20      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ20.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ20 field.
#define BR_DMA_ERQ_ERQ20()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ20))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ20.
#define BF_DMA_ERQ_ERQ20(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ20), uint32_t) & BM_DMA_ERQ_ERQ20)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ20 field to a new value.
#define BW_DMA_ERQ_ERQ20(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ20) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ21[21] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ21      (21U)      //!< Bit position for DMA_ERQ_ERQ21.
#define BM_DMA_ERQ_ERQ21      (0x00200000U)  //!< Bit mask for DMA_ERQ_ERQ21.
#define BS_DMA_ERQ_ERQ21      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ21.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ21 field.
#define BR_DMA_ERQ_ERQ21()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ21))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ21.
#define BF_DMA_ERQ_ERQ21(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ21), uint32_t) & BM_DMA_ERQ_ERQ21)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ21 field to a new value.
#define BW_DMA_ERQ_ERQ21(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ21) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ22[22] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ22      (22U)      //!< Bit position for DMA_ERQ_ERQ22.
#define BM_DMA_ERQ_ERQ22      (0x00400000U)  //!< Bit mask for DMA_ERQ_ERQ22.
#define BS_DMA_ERQ_ERQ22      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ22.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ22 field.
#define BR_DMA_ERQ_ERQ22()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ22))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ22.
#define BF_DMA_ERQ_ERQ22(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ22), uint32_t) & BM_DMA_ERQ_ERQ22)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ22 field to a new value.
#define BW_DMA_ERQ_ERQ22(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ22) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ23[23] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ23      (23U)      //!< Bit position for DMA_ERQ_ERQ23.
#define BM_DMA_ERQ_ERQ23      (0x00800000U)  //!< Bit mask for DMA_ERQ_ERQ23.
#define BS_DMA_ERQ_ERQ23      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ23.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ23 field.
#define BR_DMA_ERQ_ERQ23()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ23))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ23.
#define BF_DMA_ERQ_ERQ23(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ23), uint32_t) & BM_DMA_ERQ_ERQ23)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ23 field to a new value.
#define BW_DMA_ERQ_ERQ23(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ23) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ24[24] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ24      (24U)      //!< Bit position for DMA_ERQ_ERQ24.
#define BM_DMA_ERQ_ERQ24      (0x01000000U)  //!< Bit mask for DMA_ERQ_ERQ24.
#define BS_DMA_ERQ_ERQ24      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ24.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ24 field.
#define BR_DMA_ERQ_ERQ24()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ24))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ24.
#define BF_DMA_ERQ_ERQ24(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ24), uint32_t) & BM_DMA_ERQ_ERQ24)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ24 field to a new value.
#define BW_DMA_ERQ_ERQ24(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ24) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ25[25] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ25      (25U)      //!< Bit position for DMA_ERQ_ERQ25.
#define BM_DMA_ERQ_ERQ25      (0x02000000U)  //!< Bit mask for DMA_ERQ_ERQ25.
#define BS_DMA_ERQ_ERQ25      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ25.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ25 field.
#define BR_DMA_ERQ_ERQ25()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ25))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ25.
#define BF_DMA_ERQ_ERQ25(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ25), uint32_t) & BM_DMA_ERQ_ERQ25)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ25 field to a new value.
#define BW_DMA_ERQ_ERQ25(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ25) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ26[26] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ26      (26U)      //!< Bit position for DMA_ERQ_ERQ26.
#define BM_DMA_ERQ_ERQ26      (0x04000000U)  //!< Bit mask for DMA_ERQ_ERQ26.
#define BS_DMA_ERQ_ERQ26      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ26.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ26 field.
#define BR_DMA_ERQ_ERQ26()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ26))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ26.
#define BF_DMA_ERQ_ERQ26(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ26), uint32_t) & BM_DMA_ERQ_ERQ26)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ26 field to a new value.
#define BW_DMA_ERQ_ERQ26(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ26) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ27[27] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ27      (27U)      //!< Bit position for DMA_ERQ_ERQ27.
#define BM_DMA_ERQ_ERQ27      (0x08000000U)  //!< Bit mask for DMA_ERQ_ERQ27.
#define BS_DMA_ERQ_ERQ27      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ27.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ27 field.
#define BR_DMA_ERQ_ERQ27()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ27))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ27.
#define BF_DMA_ERQ_ERQ27(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ27), uint32_t) & BM_DMA_ERQ_ERQ27)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ27 field to a new value.
#define BW_DMA_ERQ_ERQ27(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ27) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ28[28] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ28      (28U)      //!< Bit position for DMA_ERQ_ERQ28.
#define BM_DMA_ERQ_ERQ28      (0x10000000U)  //!< Bit mask for DMA_ERQ_ERQ28.
#define BS_DMA_ERQ_ERQ28      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ28.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ28 field.
#define BR_DMA_ERQ_ERQ28()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ28))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ28.
#define BF_DMA_ERQ_ERQ28(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ28), uint32_t) & BM_DMA_ERQ_ERQ28)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ28 field to a new value.
#define BW_DMA_ERQ_ERQ28(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ28) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ29[29] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ29      (29U)      //!< Bit position for DMA_ERQ_ERQ29.
#define BM_DMA_ERQ_ERQ29      (0x20000000U)  //!< Bit mask for DMA_ERQ_ERQ29.
#define BS_DMA_ERQ_ERQ29      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ29.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ29 field.
#define BR_DMA_ERQ_ERQ29()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ29))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ29.
#define BF_DMA_ERQ_ERQ29(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ29), uint32_t) & BM_DMA_ERQ_ERQ29)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ29 field to a new value.
#define BW_DMA_ERQ_ERQ29(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ29) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ30[30] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ30      (30U)      //!< Bit position for DMA_ERQ_ERQ30.
#define BM_DMA_ERQ_ERQ30      (0x40000000U)  //!< Bit mask for DMA_ERQ_ERQ30.
#define BS_DMA_ERQ_ERQ30      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ30.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ30 field.
#define BR_DMA_ERQ_ERQ30()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ30))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ30.
#define BF_DMA_ERQ_ERQ30(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ30), uint32_t) & BM_DMA_ERQ_ERQ30)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ30 field to a new value.
#define BW_DMA_ERQ_ERQ30(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ30) = (v))
#endif
//@}

/*! @name Register DMA_ERQ, field ERQ31[31] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
//@{
#define BP_DMA_ERQ_ERQ31      (31U)      //!< Bit position for DMA_ERQ_ERQ31.
#define BM_DMA_ERQ_ERQ31      (0x80000000U)  //!< Bit mask for DMA_ERQ_ERQ31.
#define BS_DMA_ERQ_ERQ31      (1U)  //!< Bitfield size in bits for DMA_ERQ_ERQ31.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERQ_ERQ31 field.
#define BR_DMA_ERQ_ERQ31()   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ31))
#endif

//! @brief Format value for bitfield DMA_ERQ_ERQ31.
#define BF_DMA_ERQ_ERQ31(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERQ_ERQ31), uint32_t) & BM_DMA_ERQ_ERQ31)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERQ31 field to a new value.
#define BW_DMA_ERQ_ERQ31(v)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR, BP_DMA_ERQ_ERQ31) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_EEI - Enable Error Interrupt Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_EEI - Enable Error Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The EEI register provides a bit map for the 32 channels to enable the error interrupt signal for
 * each channel. The state of any given channels error interrupt enable is directly affected by
 * writes to this register; it is also affected by writes to the SEEI and CEEI. The {S,C}EEI are
 * provided so the error interrupt enable for a single channel can easily be modified without the
 * need to perform a read-modify-write sequence to the EEI register. The DMA error indicator and the
 * error interrupt enable flag must be asserted before an error interrupt request for a given
 * channel is asserted to the interrupt controller.
 */
typedef union _hw_dma_eei
{
    uint32_t U;
    struct _hw_dma_eei_bitfields
    {
        uint32_t EEI0 : 1; //!< [0] Enable Error Interrupt 0
        uint32_t EEI1 : 1; //!< [1] Enable Error Interrupt 1
        uint32_t EEI2 : 1; //!< [2] Enable Error Interrupt 2
        uint32_t EEI3 : 1; //!< [3] Enable Error Interrupt 3
        uint32_t EEI4 : 1; //!< [4] Enable Error Interrupt 4
        uint32_t EEI5 : 1; //!< [5] Enable Error Interrupt 5
        uint32_t EEI6 : 1; //!< [6] Enable Error Interrupt 6
        uint32_t EEI7 : 1; //!< [7] Enable Error Interrupt 7
        uint32_t EEI8 : 1; //!< [8] Enable Error Interrupt 8
        uint32_t EEI9 : 1; //!< [9] Enable Error Interrupt 9
        uint32_t EEI10 : 1; //!< [10] Enable Error Interrupt 10
        uint32_t EEI11 : 1; //!< [11] Enable Error Interrupt 11
        uint32_t EEI12 : 1; //!< [12] Enable Error Interrupt 12
        uint32_t EEI13 : 1; //!< [13] Enable Error Interrupt 13
        uint32_t EEI14 : 1; //!< [14] Enable Error Interrupt 14
        uint32_t EEI15 : 1; //!< [15] Enable Error Interrupt 15
        uint32_t EEI16 : 1; //!< [16] Enable Error Interrupt 16
        uint32_t EEI17 : 1; //!< [17] Enable Error Interrupt 17
        uint32_t EEI18 : 1; //!< [18] Enable Error Interrupt 18
        uint32_t EEI19 : 1; //!< [19] Enable Error Interrupt 19
        uint32_t EEI20 : 1; //!< [20] Enable Error Interrupt 20
        uint32_t EEI21 : 1; //!< [21] Enable Error Interrupt 21
        uint32_t EEI22 : 1; //!< [22] Enable Error Interrupt 22
        uint32_t EEI23 : 1; //!< [23] Enable Error Interrupt 23
        uint32_t EEI24 : 1; //!< [24] Enable Error Interrupt 24
        uint32_t EEI25 : 1; //!< [25] Enable Error Interrupt 25
        uint32_t EEI26 : 1; //!< [26] Enable Error Interrupt 26
        uint32_t EEI27 : 1; //!< [27] Enable Error Interrupt 27
        uint32_t EEI28 : 1; //!< [28] Enable Error Interrupt 28
        uint32_t EEI29 : 1; //!< [29] Enable Error Interrupt 29
        uint32_t EEI30 : 1; //!< [30] Enable Error Interrupt 30
        uint32_t EEI31 : 1; //!< [31] Enable Error Interrupt 31
    } B;
} hw_dma_eei_t;
#endif

/*!
 * @name Constants and macros for entire DMA_EEI register
 */
//@{
#define HW_DMA_EEI_ADDR      (REGS_DMA_BASE + 0x14U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_EEI           (*(__IO hw_dma_eei_t *) HW_DMA_EEI_ADDR)
#define HW_DMA_EEI_RD()      (HW_DMA_EEI.U)
#define HW_DMA_EEI_WR(v)     (HW_DMA_EEI.U = (v))
#define HW_DMA_EEI_SET(v)    (HW_DMA_EEI_WR(HW_DMA_EEI_RD() |  (v)))
#define HW_DMA_EEI_CLR(v)    (HW_DMA_EEI_WR(HW_DMA_EEI_RD() & ~(v)))
#define HW_DMA_EEI_TOG(v)    (HW_DMA_EEI_WR(HW_DMA_EEI_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_EEI bitfields
 */

/*! @name Register DMA_EEI, field EEI0[0] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI0      (0U)      //!< Bit position for DMA_EEI_EEI0.
#define BM_DMA_EEI_EEI0      (0x00000001U)  //!< Bit mask for DMA_EEI_EEI0.
#define BS_DMA_EEI_EEI0      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI0 field.
#define BR_DMA_EEI_EEI0()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI0))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI0.
#define BF_DMA_EEI_EEI0(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI0), uint32_t) & BM_DMA_EEI_EEI0)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI0 field to a new value.
#define BW_DMA_EEI_EEI0(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI0) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI1[1] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI1      (1U)      //!< Bit position for DMA_EEI_EEI1.
#define BM_DMA_EEI_EEI1      (0x00000002U)  //!< Bit mask for DMA_EEI_EEI1.
#define BS_DMA_EEI_EEI1      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI1 field.
#define BR_DMA_EEI_EEI1()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI1))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI1.
#define BF_DMA_EEI_EEI1(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI1), uint32_t) & BM_DMA_EEI_EEI1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI1 field to a new value.
#define BW_DMA_EEI_EEI1(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI1) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI2[2] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI2      (2U)      //!< Bit position for DMA_EEI_EEI2.
#define BM_DMA_EEI_EEI2      (0x00000004U)  //!< Bit mask for DMA_EEI_EEI2.
#define BS_DMA_EEI_EEI2      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI2 field.
#define BR_DMA_EEI_EEI2()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI2))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI2.
#define BF_DMA_EEI_EEI2(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI2), uint32_t) & BM_DMA_EEI_EEI2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI2 field to a new value.
#define BW_DMA_EEI_EEI2(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI2) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI3[3] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI3      (3U)      //!< Bit position for DMA_EEI_EEI3.
#define BM_DMA_EEI_EEI3      (0x00000008U)  //!< Bit mask for DMA_EEI_EEI3.
#define BS_DMA_EEI_EEI3      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI3.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI3 field.
#define BR_DMA_EEI_EEI3()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI3))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI3.
#define BF_DMA_EEI_EEI3(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI3), uint32_t) & BM_DMA_EEI_EEI3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI3 field to a new value.
#define BW_DMA_EEI_EEI3(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI3) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI4[4] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI4      (4U)      //!< Bit position for DMA_EEI_EEI4.
#define BM_DMA_EEI_EEI4      (0x00000010U)  //!< Bit mask for DMA_EEI_EEI4.
#define BS_DMA_EEI_EEI4      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI4.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI4 field.
#define BR_DMA_EEI_EEI4()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI4))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI4.
#define BF_DMA_EEI_EEI4(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI4), uint32_t) & BM_DMA_EEI_EEI4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI4 field to a new value.
#define BW_DMA_EEI_EEI4(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI4) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI5[5] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI5      (5U)      //!< Bit position for DMA_EEI_EEI5.
#define BM_DMA_EEI_EEI5      (0x00000020U)  //!< Bit mask for DMA_EEI_EEI5.
#define BS_DMA_EEI_EEI5      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI5.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI5 field.
#define BR_DMA_EEI_EEI5()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI5))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI5.
#define BF_DMA_EEI_EEI5(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI5), uint32_t) & BM_DMA_EEI_EEI5)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI5 field to a new value.
#define BW_DMA_EEI_EEI5(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI5) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI6[6] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI6      (6U)      //!< Bit position for DMA_EEI_EEI6.
#define BM_DMA_EEI_EEI6      (0x00000040U)  //!< Bit mask for DMA_EEI_EEI6.
#define BS_DMA_EEI_EEI6      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI6.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI6 field.
#define BR_DMA_EEI_EEI6()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI6))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI6.
#define BF_DMA_EEI_EEI6(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI6), uint32_t) & BM_DMA_EEI_EEI6)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI6 field to a new value.
#define BW_DMA_EEI_EEI6(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI6) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI7[7] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI7      (7U)      //!< Bit position for DMA_EEI_EEI7.
#define BM_DMA_EEI_EEI7      (0x00000080U)  //!< Bit mask for DMA_EEI_EEI7.
#define BS_DMA_EEI_EEI7      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI7.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI7 field.
#define BR_DMA_EEI_EEI7()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI7))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI7.
#define BF_DMA_EEI_EEI7(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI7), uint32_t) & BM_DMA_EEI_EEI7)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI7 field to a new value.
#define BW_DMA_EEI_EEI7(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI7) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI8[8] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI8      (8U)      //!< Bit position for DMA_EEI_EEI8.
#define BM_DMA_EEI_EEI8      (0x00000100U)  //!< Bit mask for DMA_EEI_EEI8.
#define BS_DMA_EEI_EEI8      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI8.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI8 field.
#define BR_DMA_EEI_EEI8()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI8))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI8.
#define BF_DMA_EEI_EEI8(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI8), uint32_t) & BM_DMA_EEI_EEI8)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI8 field to a new value.
#define BW_DMA_EEI_EEI8(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI8) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI9[9] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI9      (9U)      //!< Bit position for DMA_EEI_EEI9.
#define BM_DMA_EEI_EEI9      (0x00000200U)  //!< Bit mask for DMA_EEI_EEI9.
#define BS_DMA_EEI_EEI9      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI9.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI9 field.
#define BR_DMA_EEI_EEI9()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI9))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI9.
#define BF_DMA_EEI_EEI9(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI9), uint32_t) & BM_DMA_EEI_EEI9)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI9 field to a new value.
#define BW_DMA_EEI_EEI9(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI9) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI10[10] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI10      (10U)      //!< Bit position for DMA_EEI_EEI10.
#define BM_DMA_EEI_EEI10      (0x00000400U)  //!< Bit mask for DMA_EEI_EEI10.
#define BS_DMA_EEI_EEI10      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI10.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI10 field.
#define BR_DMA_EEI_EEI10()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI10))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI10.
#define BF_DMA_EEI_EEI10(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI10), uint32_t) & BM_DMA_EEI_EEI10)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI10 field to a new value.
#define BW_DMA_EEI_EEI10(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI10) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI11[11] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI11      (11U)      //!< Bit position for DMA_EEI_EEI11.
#define BM_DMA_EEI_EEI11      (0x00000800U)  //!< Bit mask for DMA_EEI_EEI11.
#define BS_DMA_EEI_EEI11      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI11.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI11 field.
#define BR_DMA_EEI_EEI11()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI11))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI11.
#define BF_DMA_EEI_EEI11(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI11), uint32_t) & BM_DMA_EEI_EEI11)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI11 field to a new value.
#define BW_DMA_EEI_EEI11(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI11) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI12[12] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI12      (12U)      //!< Bit position for DMA_EEI_EEI12.
#define BM_DMA_EEI_EEI12      (0x00001000U)  //!< Bit mask for DMA_EEI_EEI12.
#define BS_DMA_EEI_EEI12      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI12.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI12 field.
#define BR_DMA_EEI_EEI12()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI12))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI12.
#define BF_DMA_EEI_EEI12(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI12), uint32_t) & BM_DMA_EEI_EEI12)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI12 field to a new value.
#define BW_DMA_EEI_EEI12(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI12) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI13[13] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI13      (13U)      //!< Bit position for DMA_EEI_EEI13.
#define BM_DMA_EEI_EEI13      (0x00002000U)  //!< Bit mask for DMA_EEI_EEI13.
#define BS_DMA_EEI_EEI13      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI13.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI13 field.
#define BR_DMA_EEI_EEI13()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI13))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI13.
#define BF_DMA_EEI_EEI13(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI13), uint32_t) & BM_DMA_EEI_EEI13)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI13 field to a new value.
#define BW_DMA_EEI_EEI13(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI13) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI14[14] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI14      (14U)      //!< Bit position for DMA_EEI_EEI14.
#define BM_DMA_EEI_EEI14      (0x00004000U)  //!< Bit mask for DMA_EEI_EEI14.
#define BS_DMA_EEI_EEI14      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI14.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI14 field.
#define BR_DMA_EEI_EEI14()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI14))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI14.
#define BF_DMA_EEI_EEI14(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI14), uint32_t) & BM_DMA_EEI_EEI14)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI14 field to a new value.
#define BW_DMA_EEI_EEI14(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI14) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI15[15] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI15      (15U)      //!< Bit position for DMA_EEI_EEI15.
#define BM_DMA_EEI_EEI15      (0x00008000U)  //!< Bit mask for DMA_EEI_EEI15.
#define BS_DMA_EEI_EEI15      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI15.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI15 field.
#define BR_DMA_EEI_EEI15()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI15))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI15.
#define BF_DMA_EEI_EEI15(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI15), uint32_t) & BM_DMA_EEI_EEI15)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI15 field to a new value.
#define BW_DMA_EEI_EEI15(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI15) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI16[16] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI16      (16U)      //!< Bit position for DMA_EEI_EEI16.
#define BM_DMA_EEI_EEI16      (0x00010000U)  //!< Bit mask for DMA_EEI_EEI16.
#define BS_DMA_EEI_EEI16      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI16.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI16 field.
#define BR_DMA_EEI_EEI16()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI16))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI16.
#define BF_DMA_EEI_EEI16(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI16), uint32_t) & BM_DMA_EEI_EEI16)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI16 field to a new value.
#define BW_DMA_EEI_EEI16(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI16) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI17[17] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI17      (17U)      //!< Bit position for DMA_EEI_EEI17.
#define BM_DMA_EEI_EEI17      (0x00020000U)  //!< Bit mask for DMA_EEI_EEI17.
#define BS_DMA_EEI_EEI17      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI17.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI17 field.
#define BR_DMA_EEI_EEI17()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI17))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI17.
#define BF_DMA_EEI_EEI17(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI17), uint32_t) & BM_DMA_EEI_EEI17)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI17 field to a new value.
#define BW_DMA_EEI_EEI17(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI17) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI18[18] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI18      (18U)      //!< Bit position for DMA_EEI_EEI18.
#define BM_DMA_EEI_EEI18      (0x00040000U)  //!< Bit mask for DMA_EEI_EEI18.
#define BS_DMA_EEI_EEI18      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI18.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI18 field.
#define BR_DMA_EEI_EEI18()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI18))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI18.
#define BF_DMA_EEI_EEI18(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI18), uint32_t) & BM_DMA_EEI_EEI18)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI18 field to a new value.
#define BW_DMA_EEI_EEI18(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI18) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI19[19] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI19      (19U)      //!< Bit position for DMA_EEI_EEI19.
#define BM_DMA_EEI_EEI19      (0x00080000U)  //!< Bit mask for DMA_EEI_EEI19.
#define BS_DMA_EEI_EEI19      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI19.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI19 field.
#define BR_DMA_EEI_EEI19()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI19))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI19.
#define BF_DMA_EEI_EEI19(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI19), uint32_t) & BM_DMA_EEI_EEI19)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI19 field to a new value.
#define BW_DMA_EEI_EEI19(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI19) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI20[20] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI20      (20U)      //!< Bit position for DMA_EEI_EEI20.
#define BM_DMA_EEI_EEI20      (0x00100000U)  //!< Bit mask for DMA_EEI_EEI20.
#define BS_DMA_EEI_EEI20      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI20.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI20 field.
#define BR_DMA_EEI_EEI20()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI20))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI20.
#define BF_DMA_EEI_EEI20(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI20), uint32_t) & BM_DMA_EEI_EEI20)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI20 field to a new value.
#define BW_DMA_EEI_EEI20(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI20) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI21[21] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI21      (21U)      //!< Bit position for DMA_EEI_EEI21.
#define BM_DMA_EEI_EEI21      (0x00200000U)  //!< Bit mask for DMA_EEI_EEI21.
#define BS_DMA_EEI_EEI21      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI21.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI21 field.
#define BR_DMA_EEI_EEI21()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI21))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI21.
#define BF_DMA_EEI_EEI21(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI21), uint32_t) & BM_DMA_EEI_EEI21)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI21 field to a new value.
#define BW_DMA_EEI_EEI21(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI21) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI22[22] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI22      (22U)      //!< Bit position for DMA_EEI_EEI22.
#define BM_DMA_EEI_EEI22      (0x00400000U)  //!< Bit mask for DMA_EEI_EEI22.
#define BS_DMA_EEI_EEI22      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI22.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI22 field.
#define BR_DMA_EEI_EEI22()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI22))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI22.
#define BF_DMA_EEI_EEI22(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI22), uint32_t) & BM_DMA_EEI_EEI22)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI22 field to a new value.
#define BW_DMA_EEI_EEI22(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI22) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI23[23] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI23      (23U)      //!< Bit position for DMA_EEI_EEI23.
#define BM_DMA_EEI_EEI23      (0x00800000U)  //!< Bit mask for DMA_EEI_EEI23.
#define BS_DMA_EEI_EEI23      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI23.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI23 field.
#define BR_DMA_EEI_EEI23()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI23))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI23.
#define BF_DMA_EEI_EEI23(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI23), uint32_t) & BM_DMA_EEI_EEI23)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI23 field to a new value.
#define BW_DMA_EEI_EEI23(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI23) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI24[24] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI24      (24U)      //!< Bit position for DMA_EEI_EEI24.
#define BM_DMA_EEI_EEI24      (0x01000000U)  //!< Bit mask for DMA_EEI_EEI24.
#define BS_DMA_EEI_EEI24      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI24.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI24 field.
#define BR_DMA_EEI_EEI24()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI24))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI24.
#define BF_DMA_EEI_EEI24(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI24), uint32_t) & BM_DMA_EEI_EEI24)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI24 field to a new value.
#define BW_DMA_EEI_EEI24(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI24) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI25[25] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI25      (25U)      //!< Bit position for DMA_EEI_EEI25.
#define BM_DMA_EEI_EEI25      (0x02000000U)  //!< Bit mask for DMA_EEI_EEI25.
#define BS_DMA_EEI_EEI25      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI25.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI25 field.
#define BR_DMA_EEI_EEI25()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI25))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI25.
#define BF_DMA_EEI_EEI25(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI25), uint32_t) & BM_DMA_EEI_EEI25)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI25 field to a new value.
#define BW_DMA_EEI_EEI25(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI25) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI26[26] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI26      (26U)      //!< Bit position for DMA_EEI_EEI26.
#define BM_DMA_EEI_EEI26      (0x04000000U)  //!< Bit mask for DMA_EEI_EEI26.
#define BS_DMA_EEI_EEI26      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI26.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI26 field.
#define BR_DMA_EEI_EEI26()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI26))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI26.
#define BF_DMA_EEI_EEI26(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI26), uint32_t) & BM_DMA_EEI_EEI26)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI26 field to a new value.
#define BW_DMA_EEI_EEI26(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI26) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI27[27] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI27      (27U)      //!< Bit position for DMA_EEI_EEI27.
#define BM_DMA_EEI_EEI27      (0x08000000U)  //!< Bit mask for DMA_EEI_EEI27.
#define BS_DMA_EEI_EEI27      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI27.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI27 field.
#define BR_DMA_EEI_EEI27()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI27))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI27.
#define BF_DMA_EEI_EEI27(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI27), uint32_t) & BM_DMA_EEI_EEI27)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI27 field to a new value.
#define BW_DMA_EEI_EEI27(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI27) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI28[28] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI28      (28U)      //!< Bit position for DMA_EEI_EEI28.
#define BM_DMA_EEI_EEI28      (0x10000000U)  //!< Bit mask for DMA_EEI_EEI28.
#define BS_DMA_EEI_EEI28      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI28.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI28 field.
#define BR_DMA_EEI_EEI28()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI28))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI28.
#define BF_DMA_EEI_EEI28(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI28), uint32_t) & BM_DMA_EEI_EEI28)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI28 field to a new value.
#define BW_DMA_EEI_EEI28(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI28) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI29[29] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI29      (29U)      //!< Bit position for DMA_EEI_EEI29.
#define BM_DMA_EEI_EEI29      (0x20000000U)  //!< Bit mask for DMA_EEI_EEI29.
#define BS_DMA_EEI_EEI29      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI29.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI29 field.
#define BR_DMA_EEI_EEI29()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI29))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI29.
#define BF_DMA_EEI_EEI29(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI29), uint32_t) & BM_DMA_EEI_EEI29)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI29 field to a new value.
#define BW_DMA_EEI_EEI29(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI29) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI30[30] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI30      (30U)      //!< Bit position for DMA_EEI_EEI30.
#define BM_DMA_EEI_EEI30      (0x40000000U)  //!< Bit mask for DMA_EEI_EEI30.
#define BS_DMA_EEI_EEI30      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI30.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI30 field.
#define BR_DMA_EEI_EEI30()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI30))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI30.
#define BF_DMA_EEI_EEI30(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI30), uint32_t) & BM_DMA_EEI_EEI30)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI30 field to a new value.
#define BW_DMA_EEI_EEI30(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI30) = (v))
#endif
//@}

/*! @name Register DMA_EEI, field EEI31[31] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates an error interrupt request
 */
//@{
#define BP_DMA_EEI_EEI31      (31U)      //!< Bit position for DMA_EEI_EEI31.
#define BM_DMA_EEI_EEI31      (0x80000000U)  //!< Bit mask for DMA_EEI_EEI31.
#define BS_DMA_EEI_EEI31      (1U)  //!< Bitfield size in bits for DMA_EEI_EEI31.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_EEI_EEI31 field.
#define BR_DMA_EEI_EEI31()   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI31))
#endif

//! @brief Format value for bitfield DMA_EEI_EEI31.
#define BF_DMA_EEI_EEI31(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_EEI_EEI31), uint32_t) & BM_DMA_EEI_EEI31)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EEI31 field to a new value.
#define BW_DMA_EEI_EEI31(v)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR, BP_DMA_EEI_EEI31) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_CEEI - Clear Enable Error Interrupt Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_CEEI - Clear Enable Error Interrupt Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The CEEI provides a simple memory-mapped mechanism to clear a given bit in the EEI to disable the
 * error interrupt for a given channel. The data value on a register write causes the corresponding
 * bit in the EEI to be cleared. Setting the CAEE bit provides a global clear function, forcing the
 * EEI contents to be cleared, disabling all DMA request inputs. If the NOP bit is set, the command
 * is ignored. This allows you to write multiple-byte registers as a 32-bit word. Reads of this
 * register return all zeroes.
 */
typedef union _hw_dma_ceei
{
    uint8_t U;
    struct _hw_dma_ceei_bitfields
    {
        uint8_t CEEI : 5; //!< [4:0] Clear Enable Error Interrupt
        uint8_t RESERVED0 : 1; //!< [5] 
        uint8_t CAEE : 1; //!< [6] Clear All Enable Error Interrupts
        uint8_t NOP : 1; //!< [7] No Op enable
    } B;
} hw_dma_ceei_t;
#endif

/*!
 * @name Constants and macros for entire DMA_CEEI register
 */
//@{
#define HW_DMA_CEEI_ADDR      (REGS_DMA_BASE + 0x18U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_CEEI           (*(__O hw_dma_ceei_t *) HW_DMA_CEEI_ADDR)
#define HW_DMA_CEEI_WR(v)     (HW_DMA_CEEI.U = (v))
#endif
//@}

/*
 * constants & macros for individual DMA_CEEI bitfields
 */

/*! @name Register DMA_CEEI, field CEEI[4:0] (WORZ)
 *
 * Clears the corresponding bit in EEI
 */
//@{
#define BP_DMA_CEEI_CEEI      (0U)      //!< Bit position for DMA_CEEI_CEEI.
#define BM_DMA_CEEI_CEEI      (0x1fU)  //!< Bit mask for DMA_CEEI_CEEI.
#define BS_DMA_CEEI_CEEI      (5U)  //!< Bitfield size in bits for DMA_CEEI_CEEI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CEEI_CEEI field.
#define BR_DMA_CEEI_CEEI()   (HW_DMA_CEEI.B.CEEI)
#endif

//! @brief Format value for bitfield DMA_CEEI_CEEI.
#define BF_DMA_CEEI_CEEI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CEEI_CEEI), uint8_t) & BM_DMA_CEEI_CEEI)
//@}

/*! @name Register DMA_CEEI, field CAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the EEI bit specified in the CEEI field
 * - 1 - Clear all bits in EEI
 */
//@{
#define BP_DMA_CEEI_CAEE      (6U)      //!< Bit position for DMA_CEEI_CAEE.
#define BM_DMA_CEEI_CAEE      (0x40U)  //!< Bit mask for DMA_CEEI_CAEE.
#define BS_DMA_CEEI_CAEE      (1U)  //!< Bitfield size in bits for DMA_CEEI_CAEE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CEEI_CAEE field.
#define BR_DMA_CEEI_CAEE()   (BITBAND_ACCESS8(HW_DMA_CEEI_ADDR, BP_DMA_CEEI_CAEE))
#endif

//! @brief Format value for bitfield DMA_CEEI_CAEE.
#define BF_DMA_CEEI_CAEE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CEEI_CAEE), uint8_t) & BM_DMA_CEEI_CAEE)
//@}

/*! @name Register DMA_CEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
//@{
#define BP_DMA_CEEI_NOP      (7U)      //!< Bit position for DMA_CEEI_NOP.
#define BM_DMA_CEEI_NOP      (0x80U)  //!< Bit mask for DMA_CEEI_NOP.
#define BS_DMA_CEEI_NOP      (1U)  //!< Bitfield size in bits for DMA_CEEI_NOP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CEEI_NOP field.
#define BR_DMA_CEEI_NOP()   (BITBAND_ACCESS8(HW_DMA_CEEI_ADDR, BP_DMA_CEEI_NOP))
#endif

//! @brief Format value for bitfield DMA_CEEI_NOP.
#define BF_DMA_CEEI_NOP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CEEI_NOP), uint8_t) & BM_DMA_CEEI_NOP)
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_SEEI - Set Enable Error Interrupt Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_SEEI - Set Enable Error Interrupt Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SEEI provides a simple memory-mapped mechanism to set a given bit in the EEI to enable the
 * error interrupt for a given channel. The data value on a register write causes the corresponding
 * bit in the EEI to be set. Setting the SAEE bit provides a global set function, forcing the entire
 * EEI contents to be set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_seei
{
    uint8_t U;
    struct _hw_dma_seei_bitfields
    {
        uint8_t SEEI : 5; //!< [4:0] Set Enable Error Interrupt
        uint8_t RESERVED0 : 1; //!< [5] 
        uint8_t SAEE : 1; //!< [6] Sets All Enable Error Interrupts
        uint8_t NOP : 1; //!< [7] No Op enable
    } B;
} hw_dma_seei_t;
#endif

/*!
 * @name Constants and macros for entire DMA_SEEI register
 */
//@{
#define HW_DMA_SEEI_ADDR      (REGS_DMA_BASE + 0x19U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_SEEI           (*(__O hw_dma_seei_t *) HW_DMA_SEEI_ADDR)
#define HW_DMA_SEEI_WR(v)     (HW_DMA_SEEI.U = (v))
#endif
//@}

/*
 * constants & macros for individual DMA_SEEI bitfields
 */

/*! @name Register DMA_SEEI, field SEEI[4:0] (WORZ)
 *
 * Sets the corresponding bit in EEI
 */
//@{
#define BP_DMA_SEEI_SEEI      (0U)      //!< Bit position for DMA_SEEI_SEEI.
#define BM_DMA_SEEI_SEEI      (0x1fU)  //!< Bit mask for DMA_SEEI_SEEI.
#define BS_DMA_SEEI_SEEI      (5U)  //!< Bitfield size in bits for DMA_SEEI_SEEI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_SEEI_SEEI field.
#define BR_DMA_SEEI_SEEI()   (HW_DMA_SEEI.B.SEEI)
#endif

//! @brief Format value for bitfield DMA_SEEI_SEEI.
#define BF_DMA_SEEI_SEEI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_SEEI_SEEI), uint8_t) & BM_DMA_SEEI_SEEI)
//@}

/*! @name Register DMA_SEEI, field SAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the EEI bit specified in the SEEI field.
 * - 1 - Sets all bits in EEI
 */
//@{
#define BP_DMA_SEEI_SAEE      (6U)      //!< Bit position for DMA_SEEI_SAEE.
#define BM_DMA_SEEI_SAEE      (0x40U)  //!< Bit mask for DMA_SEEI_SAEE.
#define BS_DMA_SEEI_SAEE      (1U)  //!< Bitfield size in bits for DMA_SEEI_SAEE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_SEEI_SAEE field.
#define BR_DMA_SEEI_SAEE()   (BITBAND_ACCESS8(HW_DMA_SEEI_ADDR, BP_DMA_SEEI_SAEE))
#endif

//! @brief Format value for bitfield DMA_SEEI_SAEE.
#define BF_DMA_SEEI_SAEE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_SEEI_SAEE), uint8_t) & BM_DMA_SEEI_SAEE)
//@}

/*! @name Register DMA_SEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
//@{
#define BP_DMA_SEEI_NOP      (7U)      //!< Bit position for DMA_SEEI_NOP.
#define BM_DMA_SEEI_NOP      (0x80U)  //!< Bit mask for DMA_SEEI_NOP.
#define BS_DMA_SEEI_NOP      (1U)  //!< Bitfield size in bits for DMA_SEEI_NOP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_SEEI_NOP field.
#define BR_DMA_SEEI_NOP()   (BITBAND_ACCESS8(HW_DMA_SEEI_ADDR, BP_DMA_SEEI_NOP))
#endif

//! @brief Format value for bitfield DMA_SEEI_NOP.
#define BF_DMA_SEEI_NOP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_SEEI_NOP), uint8_t) & BM_DMA_SEEI_NOP)
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_CERQ - Clear Enable Request Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_CERQ - Clear Enable Request Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The CERQ provides a simple memory-mapped mechanism to clear a given bit in the ERQ to disable the
 * DMA request for a given channel. The data value on a register write causes the corresponding bit
 * in the ERQ to be cleared. Setting the CAER bit provides a global clear function, forcing the
 * entire contents of the ERQ to be cleared, disabling all DMA request inputs. If NOP is set, the
 * command is ignored. This allows you to write multiple-byte registers as a 32-bit word. Reads of
 * this register return all zeroes.
 */
typedef union _hw_dma_cerq
{
    uint8_t U;
    struct _hw_dma_cerq_bitfields
    {
        uint8_t CERQ : 5; //!< [4:0] Clear Enable Request
        uint8_t RESERVED0 : 1; //!< [5] 
        uint8_t CAER : 1; //!< [6] Clear All Enable Requests
        uint8_t NOP : 1; //!< [7] No Op enable
    } B;
} hw_dma_cerq_t;
#endif

/*!
 * @name Constants and macros for entire DMA_CERQ register
 */
//@{
#define HW_DMA_CERQ_ADDR      (REGS_DMA_BASE + 0x1aU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_CERQ           (*(__O hw_dma_cerq_t *) HW_DMA_CERQ_ADDR)
#define HW_DMA_CERQ_WR(v)     (HW_DMA_CERQ.U = (v))
#endif
//@}

/*
 * constants & macros for individual DMA_CERQ bitfields
 */

/*! @name Register DMA_CERQ, field CERQ[4:0] (WORZ)
 *
 * Clears the corresponding bit in ERQ{H,L}
 */
//@{
#define BP_DMA_CERQ_CERQ      (0U)      //!< Bit position for DMA_CERQ_CERQ.
#define BM_DMA_CERQ_CERQ      (0x1fU)  //!< Bit mask for DMA_CERQ_CERQ.
#define BS_DMA_CERQ_CERQ      (5U)  //!< Bitfield size in bits for DMA_CERQ_CERQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CERQ_CERQ field.
#define BR_DMA_CERQ_CERQ()   (HW_DMA_CERQ.B.CERQ)
#endif

//! @brief Format value for bitfield DMA_CERQ_CERQ.
#define BF_DMA_CERQ_CERQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CERQ_CERQ), uint8_t) & BM_DMA_CERQ_CERQ)
//@}

/*! @name Register DMA_CERQ, field CAER[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERQ bit specified in the CERQ field
 * - 1 - Clear all bits in ERQ
 */
//@{
#define BP_DMA_CERQ_CAER      (6U)      //!< Bit position for DMA_CERQ_CAER.
#define BM_DMA_CERQ_CAER      (0x40U)  //!< Bit mask for DMA_CERQ_CAER.
#define BS_DMA_CERQ_CAER      (1U)  //!< Bitfield size in bits for DMA_CERQ_CAER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CERQ_CAER field.
#define BR_DMA_CERQ_CAER()   (BITBAND_ACCESS8(HW_DMA_CERQ_ADDR, BP_DMA_CERQ_CAER))
#endif

//! @brief Format value for bitfield DMA_CERQ_CAER.
#define BF_DMA_CERQ_CAER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CERQ_CAER), uint8_t) & BM_DMA_CERQ_CAER)
//@}

/*! @name Register DMA_CERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
//@{
#define BP_DMA_CERQ_NOP      (7U)      //!< Bit position for DMA_CERQ_NOP.
#define BM_DMA_CERQ_NOP      (0x80U)  //!< Bit mask for DMA_CERQ_NOP.
#define BS_DMA_CERQ_NOP      (1U)  //!< Bitfield size in bits for DMA_CERQ_NOP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CERQ_NOP field.
#define BR_DMA_CERQ_NOP()   (BITBAND_ACCESS8(HW_DMA_CERQ_ADDR, BP_DMA_CERQ_NOP))
#endif

//! @brief Format value for bitfield DMA_CERQ_NOP.
#define BF_DMA_CERQ_NOP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CERQ_NOP), uint8_t) & BM_DMA_CERQ_NOP)
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_SERQ - Set Enable Request Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_SERQ - Set Enable Request Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SERQ provides a simple memory-mapped mechanism to set a given bit in the ERQ to enable the
 * DMA request for a given channel. The data value on a register write causes the corresponding bit
 * in the ERQ to be set. Setting the SAER bit provides a global set function, forcing the entire
 * contents of ERQ to be set. If the NOP bit is set, the command is ignored. This allows you to
 * write multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_serq
{
    uint8_t U;
    struct _hw_dma_serq_bitfields
    {
        uint8_t SERQ : 5; //!< [4:0] Set Enable Request
        uint8_t RESERVED0 : 1; //!< [5] 
        uint8_t SAER : 1; //!< [6] Set All Enable Requests
        uint8_t NOP : 1; //!< [7] No Op enable
    } B;
} hw_dma_serq_t;
#endif

/*!
 * @name Constants and macros for entire DMA_SERQ register
 */
//@{
#define HW_DMA_SERQ_ADDR      (REGS_DMA_BASE + 0x1bU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_SERQ           (*(__O hw_dma_serq_t *) HW_DMA_SERQ_ADDR)
#define HW_DMA_SERQ_WR(v)     (HW_DMA_SERQ.U = (v))
#endif
//@}

/*
 * constants & macros for individual DMA_SERQ bitfields
 */

/*! @name Register DMA_SERQ, field SERQ[4:0] (WORZ)
 *
 * Sets the corresponding bit in ERQ
 */
//@{
#define BP_DMA_SERQ_SERQ      (0U)      //!< Bit position for DMA_SERQ_SERQ.
#define BM_DMA_SERQ_SERQ      (0x1fU)  //!< Bit mask for DMA_SERQ_SERQ.
#define BS_DMA_SERQ_SERQ      (5U)  //!< Bitfield size in bits for DMA_SERQ_SERQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_SERQ_SERQ field.
#define BR_DMA_SERQ_SERQ()   (HW_DMA_SERQ.B.SERQ)
#endif

//! @brief Format value for bitfield DMA_SERQ_SERQ.
#define BF_DMA_SERQ_SERQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_SERQ_SERQ), uint8_t) & BM_DMA_SERQ_SERQ)
//@}

/*! @name Register DMA_SERQ, field SAER[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the ERQ bit specified in the SERQ field
 * - 1 - Set all bits in ERQ
 */
//@{
#define BP_DMA_SERQ_SAER      (6U)      //!< Bit position for DMA_SERQ_SAER.
#define BM_DMA_SERQ_SAER      (0x40U)  //!< Bit mask for DMA_SERQ_SAER.
#define BS_DMA_SERQ_SAER      (1U)  //!< Bitfield size in bits for DMA_SERQ_SAER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_SERQ_SAER field.
#define BR_DMA_SERQ_SAER()   (BITBAND_ACCESS8(HW_DMA_SERQ_ADDR, BP_DMA_SERQ_SAER))
#endif

//! @brief Format value for bitfield DMA_SERQ_SAER.
#define BF_DMA_SERQ_SAER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_SERQ_SAER), uint8_t) & BM_DMA_SERQ_SAER)
//@}

/*! @name Register DMA_SERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
//@{
#define BP_DMA_SERQ_NOP      (7U)      //!< Bit position for DMA_SERQ_NOP.
#define BM_DMA_SERQ_NOP      (0x80U)  //!< Bit mask for DMA_SERQ_NOP.
#define BS_DMA_SERQ_NOP      (1U)  //!< Bitfield size in bits for DMA_SERQ_NOP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_SERQ_NOP field.
#define BR_DMA_SERQ_NOP()   (BITBAND_ACCESS8(HW_DMA_SERQ_ADDR, BP_DMA_SERQ_NOP))
#endif

//! @brief Format value for bitfield DMA_SERQ_NOP.
#define BF_DMA_SERQ_NOP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_SERQ_NOP), uint8_t) & BM_DMA_SERQ_NOP)
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_CDNE - Clear DONE Status Bit Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_CDNE - Clear DONE Status Bit Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The CDNE provides a simple memory-mapped mechanism to clear the DONE bit in the TCD of the given
 * channel. The data value on a register write causes the DONE bit in the corresponding transfer
 * control descriptor to be cleared. Setting the CADN bit provides a global clear function, forcing
 * all DONE bits to be cleared. If the NOP bit is set, the command is ignored. This allows you to
 * write multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_cdne
{
    uint8_t U;
    struct _hw_dma_cdne_bitfields
    {
        uint8_t CDNE : 5; //!< [4:0] Clear DONE Bit
        uint8_t RESERVED0 : 1; //!< [5] 
        uint8_t CADN : 1; //!< [6] Clears All DONE Bits
        uint8_t NOP : 1; //!< [7] No Op enable
    } B;
} hw_dma_cdne_t;
#endif

/*!
 * @name Constants and macros for entire DMA_CDNE register
 */
//@{
#define HW_DMA_CDNE_ADDR      (REGS_DMA_BASE + 0x1cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_CDNE           (*(__O hw_dma_cdne_t *) HW_DMA_CDNE_ADDR)
#define HW_DMA_CDNE_WR(v)     (HW_DMA_CDNE.U = (v))
#endif
//@}

/*
 * constants & macros for individual DMA_CDNE bitfields
 */

/*! @name Register DMA_CDNE, field CDNE[4:0] (WORZ)
 *
 * Clears the corresponding bit in TCDn_CSR[DONE]
 */
//@{
#define BP_DMA_CDNE_CDNE      (0U)      //!< Bit position for DMA_CDNE_CDNE.
#define BM_DMA_CDNE_CDNE      (0x1fU)  //!< Bit mask for DMA_CDNE_CDNE.
#define BS_DMA_CDNE_CDNE      (5U)  //!< Bitfield size in bits for DMA_CDNE_CDNE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CDNE_CDNE field.
#define BR_DMA_CDNE_CDNE()   (HW_DMA_CDNE.B.CDNE)
#endif

//! @brief Format value for bitfield DMA_CDNE_CDNE.
#define BF_DMA_CDNE_CDNE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CDNE_CDNE), uint8_t) & BM_DMA_CDNE_CDNE)
//@}

/*! @name Register DMA_CDNE, field CADN[6] (WORZ)
 *
 * Values:
 * - 0 - Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
 * - 1 - Clears all bits in TCDn_CSR[DONE]
 */
//@{
#define BP_DMA_CDNE_CADN      (6U)      //!< Bit position for DMA_CDNE_CADN.
#define BM_DMA_CDNE_CADN      (0x40U)  //!< Bit mask for DMA_CDNE_CADN.
#define BS_DMA_CDNE_CADN      (1U)  //!< Bitfield size in bits for DMA_CDNE_CADN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CDNE_CADN field.
#define BR_DMA_CDNE_CADN()   (BITBAND_ACCESS8(HW_DMA_CDNE_ADDR, BP_DMA_CDNE_CADN))
#endif

//! @brief Format value for bitfield DMA_CDNE_CADN.
#define BF_DMA_CDNE_CADN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CDNE_CADN), uint8_t) & BM_DMA_CDNE_CADN)
//@}

/*! @name Register DMA_CDNE, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
//@{
#define BP_DMA_CDNE_NOP      (7U)      //!< Bit position for DMA_CDNE_NOP.
#define BM_DMA_CDNE_NOP      (0x80U)  //!< Bit mask for DMA_CDNE_NOP.
#define BS_DMA_CDNE_NOP      (1U)  //!< Bitfield size in bits for DMA_CDNE_NOP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CDNE_NOP field.
#define BR_DMA_CDNE_NOP()   (BITBAND_ACCESS8(HW_DMA_CDNE_ADDR, BP_DMA_CDNE_NOP))
#endif

//! @brief Format value for bitfield DMA_CDNE_NOP.
#define BF_DMA_CDNE_NOP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CDNE_NOP), uint8_t) & BM_DMA_CDNE_NOP)
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_SSRT - Set START Bit Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_SSRT - Set START Bit Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SSRT provides a simple memory-mapped mechanism to set the START bit in the TCD of the given
 * channel. The data value on a register write causes the START bit in the corresponding transfer
 * control descriptor to be set. Setting the SAST bit provides a global set function, forcing all
 * START bits to be set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_ssrt
{
    uint8_t U;
    struct _hw_dma_ssrt_bitfields
    {
        uint8_t SSRT : 5; //!< [4:0] Set START Bit
        uint8_t RESERVED0 : 1; //!< [5] 
        uint8_t SAST : 1; //!< [6] Set All START Bits (activates all channels)
        uint8_t NOP : 1; //!< [7] No Op enable
    } B;
} hw_dma_ssrt_t;
#endif

/*!
 * @name Constants and macros for entire DMA_SSRT register
 */
//@{
#define HW_DMA_SSRT_ADDR      (REGS_DMA_BASE + 0x1dU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_SSRT           (*(__O hw_dma_ssrt_t *) HW_DMA_SSRT_ADDR)
#define HW_DMA_SSRT_WR(v)     (HW_DMA_SSRT.U = (v))
#endif
//@}

/*
 * constants & macros for individual DMA_SSRT bitfields
 */

/*! @name Register DMA_SSRT, field SSRT[4:0] (WORZ)
 *
 * Sets the corresponding bit in TCDn_CSR[START]
 */
//@{
#define BP_DMA_SSRT_SSRT      (0U)      //!< Bit position for DMA_SSRT_SSRT.
#define BM_DMA_SSRT_SSRT      (0x1fU)  //!< Bit mask for DMA_SSRT_SSRT.
#define BS_DMA_SSRT_SSRT      (5U)  //!< Bitfield size in bits for DMA_SSRT_SSRT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_SSRT_SSRT field.
#define BR_DMA_SSRT_SSRT()   (HW_DMA_SSRT.B.SSRT)
#endif

//! @brief Format value for bitfield DMA_SSRT_SSRT.
#define BF_DMA_SSRT_SSRT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_SSRT_SSRT), uint8_t) & BM_DMA_SSRT_SSRT)
//@}

/*! @name Register DMA_SSRT, field SAST[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the TCDn_CSR[START] bit specified in the SSRT field
 * - 1 - Set all bits in TCDn_CSR[START]
 */
//@{
#define BP_DMA_SSRT_SAST      (6U)      //!< Bit position for DMA_SSRT_SAST.
#define BM_DMA_SSRT_SAST      (0x40U)  //!< Bit mask for DMA_SSRT_SAST.
#define BS_DMA_SSRT_SAST      (1U)  //!< Bitfield size in bits for DMA_SSRT_SAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_SSRT_SAST field.
#define BR_DMA_SSRT_SAST()   (BITBAND_ACCESS8(HW_DMA_SSRT_ADDR, BP_DMA_SSRT_SAST))
#endif

//! @brief Format value for bitfield DMA_SSRT_SAST.
#define BF_DMA_SSRT_SAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_SSRT_SAST), uint8_t) & BM_DMA_SSRT_SAST)
//@}

/*! @name Register DMA_SSRT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
//@{
#define BP_DMA_SSRT_NOP      (7U)      //!< Bit position for DMA_SSRT_NOP.
#define BM_DMA_SSRT_NOP      (0x80U)  //!< Bit mask for DMA_SSRT_NOP.
#define BS_DMA_SSRT_NOP      (1U)  //!< Bitfield size in bits for DMA_SSRT_NOP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_SSRT_NOP field.
#define BR_DMA_SSRT_NOP()   (BITBAND_ACCESS8(HW_DMA_SSRT_ADDR, BP_DMA_SSRT_NOP))
#endif

//! @brief Format value for bitfield DMA_SSRT_NOP.
#define BF_DMA_SSRT_NOP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_SSRT_NOP), uint8_t) & BM_DMA_SSRT_NOP)
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_CERR - Clear Error Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_CERR - Clear Error Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The CERR provides a simple memory-mapped mechanism to clear a given bit in the ERR to disable the
 * error condition flag for a given channel. The given value on a register write causes the
 * corresponding bit in the ERR to be cleared. Setting the CAEI bit provides a global clear
 * function, forcing the ERR contents to be cleared, clearing all channel error indicators. If the
 * NOP bit is set, the command is ignored. This allows you to write multiple-byte registers as a
 * 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_cerr
{
    uint8_t U;
    struct _hw_dma_cerr_bitfields
    {
        uint8_t CERR : 5; //!< [4:0] Clear Error Indicator
        uint8_t RESERVED0 : 1; //!< [5] 
        uint8_t CAEI : 1; //!< [6] Clear All Error Indicators
        uint8_t NOP : 1; //!< [7] No Op enable
    } B;
} hw_dma_cerr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_CERR register
 */
//@{
#define HW_DMA_CERR_ADDR      (REGS_DMA_BASE + 0x1eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_CERR           (*(__O hw_dma_cerr_t *) HW_DMA_CERR_ADDR)
#define HW_DMA_CERR_WR(v)     (HW_DMA_CERR.U = (v))
#endif
//@}

/*
 * constants & macros for individual DMA_CERR bitfields
 */

/*! @name Register DMA_CERR, field CERR[4:0] (WORZ)
 *
 * Clears the corresponding bit in ERR
 */
//@{
#define BP_DMA_CERR_CERR      (0U)      //!< Bit position for DMA_CERR_CERR.
#define BM_DMA_CERR_CERR      (0x1fU)  //!< Bit mask for DMA_CERR_CERR.
#define BS_DMA_CERR_CERR      (5U)  //!< Bitfield size in bits for DMA_CERR_CERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CERR_CERR field.
#define BR_DMA_CERR_CERR()   (HW_DMA_CERR.B.CERR)
#endif

//! @brief Format value for bitfield DMA_CERR_CERR.
#define BF_DMA_CERR_CERR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CERR_CERR), uint8_t) & BM_DMA_CERR_CERR)
//@}

/*! @name Register DMA_CERR, field CAEI[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERR bit specified in the CERR field
 * - 1 - Clear all bits in ERR
 */
//@{
#define BP_DMA_CERR_CAEI      (6U)      //!< Bit position for DMA_CERR_CAEI.
#define BM_DMA_CERR_CAEI      (0x40U)  //!< Bit mask for DMA_CERR_CAEI.
#define BS_DMA_CERR_CAEI      (1U)  //!< Bitfield size in bits for DMA_CERR_CAEI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CERR_CAEI field.
#define BR_DMA_CERR_CAEI()   (BITBAND_ACCESS8(HW_DMA_CERR_ADDR, BP_DMA_CERR_CAEI))
#endif

//! @brief Format value for bitfield DMA_CERR_CAEI.
#define BF_DMA_CERR_CAEI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CERR_CAEI), uint8_t) & BM_DMA_CERR_CAEI)
//@}

/*! @name Register DMA_CERR, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
//@{
#define BP_DMA_CERR_NOP      (7U)      //!< Bit position for DMA_CERR_NOP.
#define BM_DMA_CERR_NOP      (0x80U)  //!< Bit mask for DMA_CERR_NOP.
#define BS_DMA_CERR_NOP      (1U)  //!< Bitfield size in bits for DMA_CERR_NOP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CERR_NOP field.
#define BR_DMA_CERR_NOP()   (BITBAND_ACCESS8(HW_DMA_CERR_ADDR, BP_DMA_CERR_NOP))
#endif

//! @brief Format value for bitfield DMA_CERR_NOP.
#define BF_DMA_CERR_NOP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CERR_NOP), uint8_t) & BM_DMA_CERR_NOP)
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_CINT - Clear Interrupt Request Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_CINT - Clear Interrupt Request Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The CINT provides a simple, memory-mapped mechanism to clear a given bit in the INT to disable
 * the interrupt request for a given channel. The given value on a register write causes the
 * corresponding bit in the INT to be cleared. Setting the CAIR bit provides a global clear
 * function, forcing the entire contents of the INT to be cleared, disabling all DMA interrupt
 * requests. If the NOP bit is set, the command is ignored. This allows you to write multiple-byte
 * registers as a 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_cint
{
    uint8_t U;
    struct _hw_dma_cint_bitfields
    {
        uint8_t CINT : 5; //!< [4:0] Clear interrupt request
        uint8_t RESERVED0 : 1; //!< [5] 
        uint8_t CAIR : 1; //!< [6] Clear All Interrupt Requests
        uint8_t NOP : 1; //!< [7] No Op enable
    } B;
} hw_dma_cint_t;
#endif

/*!
 * @name Constants and macros for entire DMA_CINT register
 */
//@{
#define HW_DMA_CINT_ADDR      (REGS_DMA_BASE + 0x1fU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_CINT           (*(__O hw_dma_cint_t *) HW_DMA_CINT_ADDR)
#define HW_DMA_CINT_WR(v)     (HW_DMA_CINT.U = (v))
#endif
//@}

/*
 * constants & macros for individual DMA_CINT bitfields
 */

/*! @name Register DMA_CINT, field CINT[4:0] (WORZ)
 *
 * Clears the corresponding bit in INT
 */
//@{
#define BP_DMA_CINT_CINT      (0U)      //!< Bit position for DMA_CINT_CINT.
#define BM_DMA_CINT_CINT      (0x1fU)  //!< Bit mask for DMA_CINT_CINT.
#define BS_DMA_CINT_CINT      (5U)  //!< Bitfield size in bits for DMA_CINT_CINT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CINT_CINT field.
#define BR_DMA_CINT_CINT()   (HW_DMA_CINT.B.CINT)
#endif

//! @brief Format value for bitfield DMA_CINT_CINT.
#define BF_DMA_CINT_CINT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CINT_CINT), uint8_t) & BM_DMA_CINT_CINT)
//@}

/*! @name Register DMA_CINT, field CAIR[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the INT bit specified in the CINT field
 * - 1 - Clear all bits in INT
 */
//@{
#define BP_DMA_CINT_CAIR      (6U)      //!< Bit position for DMA_CINT_CAIR.
#define BM_DMA_CINT_CAIR      (0x40U)  //!< Bit mask for DMA_CINT_CAIR.
#define BS_DMA_CINT_CAIR      (1U)  //!< Bitfield size in bits for DMA_CINT_CAIR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CINT_CAIR field.
#define BR_DMA_CINT_CAIR()   (BITBAND_ACCESS8(HW_DMA_CINT_ADDR, BP_DMA_CINT_CAIR))
#endif

//! @brief Format value for bitfield DMA_CINT_CAIR.
#define BF_DMA_CINT_CAIR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CINT_CAIR), uint8_t) & BM_DMA_CINT_CAIR)
//@}

/*! @name Register DMA_CINT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
//@{
#define BP_DMA_CINT_NOP      (7U)      //!< Bit position for DMA_CINT_NOP.
#define BM_DMA_CINT_NOP      (0x80U)  //!< Bit mask for DMA_CINT_NOP.
#define BS_DMA_CINT_NOP      (1U)  //!< Bitfield size in bits for DMA_CINT_NOP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_CINT_NOP field.
#define BR_DMA_CINT_NOP()   (BITBAND_ACCESS8(HW_DMA_CINT_ADDR, BP_DMA_CINT_NOP))
#endif

//! @brief Format value for bitfield DMA_CINT_NOP.
#define BF_DMA_CINT_NOP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_CINT_NOP), uint8_t) & BM_DMA_CINT_NOP)
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_INT - Interrupt Request Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_INT - Interrupt Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The INT register provides a bit map for the 32 channels signaling the presence of an interrupt
 * request for each channel. Depending on the appropriate bit setting in the transfer-control
 * descriptors, the eDMA engine generates an interrupt on data transfer completion. The outputs of
 * this register are directly routed to the interrupt controller (INTC). During the interrupt-
 * service routine associated with any given channel, it is the softwares responsibility to clear
 * the appropriate bit, negating the interrupt request. Typically, a write to the CINT register in
 * the interrupt service routine is used for this purpose. The state of any given channels
 * interrupt request is directly affected by writes to this register; it is also affected by writes
 * to the CINT register. On writes to INT, a 1 in any bit position clears the corresponding
 * channels interrupt request. A zero in any bit position has no affect on the corresponding
 * channels current interrupt status. The CINT register is provided so the interrupt request for a
 * single channel can easily be cleared without the need to perform a read-modify-write sequence to
 * the INT register.
 */
typedef union _hw_dma_int
{
    uint32_t U;
    struct _hw_dma_int_bitfields
    {
        uint32_t INT0 : 1; //!< [0] Interrupt Request 0
        uint32_t INT1 : 1; //!< [1] Interrupt Request 1
        uint32_t INT2 : 1; //!< [2] Interrupt Request 2
        uint32_t INT3 : 1; //!< [3] Interrupt Request 3
        uint32_t INT4 : 1; //!< [4] Interrupt Request 4
        uint32_t INT5 : 1; //!< [5] Interrupt Request 5
        uint32_t INT6 : 1; //!< [6] Interrupt Request 6
        uint32_t INT7 : 1; //!< [7] Interrupt Request 7
        uint32_t INT8 : 1; //!< [8] Interrupt Request 8
        uint32_t INT9 : 1; //!< [9] Interrupt Request 9
        uint32_t INT10 : 1; //!< [10] Interrupt Request 10
        uint32_t INT11 : 1; //!< [11] Interrupt Request 11
        uint32_t INT12 : 1; //!< [12] Interrupt Request 12
        uint32_t INT13 : 1; //!< [13] Interrupt Request 13
        uint32_t INT14 : 1; //!< [14] Interrupt Request 14
        uint32_t INT15 : 1; //!< [15] Interrupt Request 15
        uint32_t INT16 : 1; //!< [16] Interrupt Request 16
        uint32_t INT17 : 1; //!< [17] Interrupt Request 17
        uint32_t INT18 : 1; //!< [18] Interrupt Request 18
        uint32_t INT19 : 1; //!< [19] Interrupt Request 19
        uint32_t INT20 : 1; //!< [20] Interrupt Request 20
        uint32_t INT21 : 1; //!< [21] Interrupt Request 21
        uint32_t INT22 : 1; //!< [22] Interrupt Request 22
        uint32_t INT23 : 1; //!< [23] Interrupt Request 23
        uint32_t INT24 : 1; //!< [24] Interrupt Request 24
        uint32_t INT25 : 1; //!< [25] Interrupt Request 25
        uint32_t INT26 : 1; //!< [26] Interrupt Request 26
        uint32_t INT27 : 1; //!< [27] Interrupt Request 27
        uint32_t INT28 : 1; //!< [28] Interrupt Request 28
        uint32_t INT29 : 1; //!< [29] Interrupt Request 29
        uint32_t INT30 : 1; //!< [30] Interrupt Request 30
        uint32_t INT31 : 1; //!< [31] Interrupt Request 31
    } B;
} hw_dma_int_t;
#endif

/*!
 * @name Constants and macros for entire DMA_INT register
 */
//@{
#define HW_DMA_INT_ADDR      (REGS_DMA_BASE + 0x24U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_INT           (*(__IO hw_dma_int_t *) HW_DMA_INT_ADDR)
#define HW_DMA_INT_RD()      (HW_DMA_INT.U)
#define HW_DMA_INT_WR(v)     (HW_DMA_INT.U = (v))
#define HW_DMA_INT_SET(v)    (HW_DMA_INT_WR(HW_DMA_INT_RD() |  (v)))
#define HW_DMA_INT_CLR(v)    (HW_DMA_INT_WR(HW_DMA_INT_RD() & ~(v)))
#define HW_DMA_INT_TOG(v)    (HW_DMA_INT_WR(HW_DMA_INT_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_INT bitfields
 */

/*! @name Register DMA_INT, field INT0[0] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT0      (0U)      //!< Bit position for DMA_INT_INT0.
#define BM_DMA_INT_INT0      (0x00000001U)  //!< Bit mask for DMA_INT_INT0.
#define BS_DMA_INT_INT0      (1U)  //!< Bitfield size in bits for DMA_INT_INT0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT0 field.
#define BR_DMA_INT_INT0()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT0))
#endif

//! @brief Format value for bitfield DMA_INT_INT0.
#define BF_DMA_INT_INT0(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT0), uint32_t) & BM_DMA_INT_INT0)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT0 field to a new value.
#define BW_DMA_INT_INT0(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT0) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT1[1] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT1      (1U)      //!< Bit position for DMA_INT_INT1.
#define BM_DMA_INT_INT1      (0x00000002U)  //!< Bit mask for DMA_INT_INT1.
#define BS_DMA_INT_INT1      (1U)  //!< Bitfield size in bits for DMA_INT_INT1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT1 field.
#define BR_DMA_INT_INT1()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT1))
#endif

//! @brief Format value for bitfield DMA_INT_INT1.
#define BF_DMA_INT_INT1(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT1), uint32_t) & BM_DMA_INT_INT1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT1 field to a new value.
#define BW_DMA_INT_INT1(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT1) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT2[2] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT2      (2U)      //!< Bit position for DMA_INT_INT2.
#define BM_DMA_INT_INT2      (0x00000004U)  //!< Bit mask for DMA_INT_INT2.
#define BS_DMA_INT_INT2      (1U)  //!< Bitfield size in bits for DMA_INT_INT2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT2 field.
#define BR_DMA_INT_INT2()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT2))
#endif

//! @brief Format value for bitfield DMA_INT_INT2.
#define BF_DMA_INT_INT2(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT2), uint32_t) & BM_DMA_INT_INT2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT2 field to a new value.
#define BW_DMA_INT_INT2(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT2) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT3[3] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT3      (3U)      //!< Bit position for DMA_INT_INT3.
#define BM_DMA_INT_INT3      (0x00000008U)  //!< Bit mask for DMA_INT_INT3.
#define BS_DMA_INT_INT3      (1U)  //!< Bitfield size in bits for DMA_INT_INT3.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT3 field.
#define BR_DMA_INT_INT3()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT3))
#endif

//! @brief Format value for bitfield DMA_INT_INT3.
#define BF_DMA_INT_INT3(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT3), uint32_t) & BM_DMA_INT_INT3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT3 field to a new value.
#define BW_DMA_INT_INT3(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT3) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT4[4] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT4      (4U)      //!< Bit position for DMA_INT_INT4.
#define BM_DMA_INT_INT4      (0x00000010U)  //!< Bit mask for DMA_INT_INT4.
#define BS_DMA_INT_INT4      (1U)  //!< Bitfield size in bits for DMA_INT_INT4.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT4 field.
#define BR_DMA_INT_INT4()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT4))
#endif

//! @brief Format value for bitfield DMA_INT_INT4.
#define BF_DMA_INT_INT4(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT4), uint32_t) & BM_DMA_INT_INT4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT4 field to a new value.
#define BW_DMA_INT_INT4(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT4) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT5[5] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT5      (5U)      //!< Bit position for DMA_INT_INT5.
#define BM_DMA_INT_INT5      (0x00000020U)  //!< Bit mask for DMA_INT_INT5.
#define BS_DMA_INT_INT5      (1U)  //!< Bitfield size in bits for DMA_INT_INT5.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT5 field.
#define BR_DMA_INT_INT5()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT5))
#endif

//! @brief Format value for bitfield DMA_INT_INT5.
#define BF_DMA_INT_INT5(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT5), uint32_t) & BM_DMA_INT_INT5)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT5 field to a new value.
#define BW_DMA_INT_INT5(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT5) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT6[6] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT6      (6U)      //!< Bit position for DMA_INT_INT6.
#define BM_DMA_INT_INT6      (0x00000040U)  //!< Bit mask for DMA_INT_INT6.
#define BS_DMA_INT_INT6      (1U)  //!< Bitfield size in bits for DMA_INT_INT6.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT6 field.
#define BR_DMA_INT_INT6()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT6))
#endif

//! @brief Format value for bitfield DMA_INT_INT6.
#define BF_DMA_INT_INT6(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT6), uint32_t) & BM_DMA_INT_INT6)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT6 field to a new value.
#define BW_DMA_INT_INT6(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT6) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT7[7] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT7      (7U)      //!< Bit position for DMA_INT_INT7.
#define BM_DMA_INT_INT7      (0x00000080U)  //!< Bit mask for DMA_INT_INT7.
#define BS_DMA_INT_INT7      (1U)  //!< Bitfield size in bits for DMA_INT_INT7.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT7 field.
#define BR_DMA_INT_INT7()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT7))
#endif

//! @brief Format value for bitfield DMA_INT_INT7.
#define BF_DMA_INT_INT7(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT7), uint32_t) & BM_DMA_INT_INT7)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT7 field to a new value.
#define BW_DMA_INT_INT7(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT7) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT8[8] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT8      (8U)      //!< Bit position for DMA_INT_INT8.
#define BM_DMA_INT_INT8      (0x00000100U)  //!< Bit mask for DMA_INT_INT8.
#define BS_DMA_INT_INT8      (1U)  //!< Bitfield size in bits for DMA_INT_INT8.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT8 field.
#define BR_DMA_INT_INT8()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT8))
#endif

//! @brief Format value for bitfield DMA_INT_INT8.
#define BF_DMA_INT_INT8(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT8), uint32_t) & BM_DMA_INT_INT8)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT8 field to a new value.
#define BW_DMA_INT_INT8(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT8) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT9[9] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT9      (9U)      //!< Bit position for DMA_INT_INT9.
#define BM_DMA_INT_INT9      (0x00000200U)  //!< Bit mask for DMA_INT_INT9.
#define BS_DMA_INT_INT9      (1U)  //!< Bitfield size in bits for DMA_INT_INT9.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT9 field.
#define BR_DMA_INT_INT9()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT9))
#endif

//! @brief Format value for bitfield DMA_INT_INT9.
#define BF_DMA_INT_INT9(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT9), uint32_t) & BM_DMA_INT_INT9)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT9 field to a new value.
#define BW_DMA_INT_INT9(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT9) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT10[10] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT10      (10U)      //!< Bit position for DMA_INT_INT10.
#define BM_DMA_INT_INT10      (0x00000400U)  //!< Bit mask for DMA_INT_INT10.
#define BS_DMA_INT_INT10      (1U)  //!< Bitfield size in bits for DMA_INT_INT10.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT10 field.
#define BR_DMA_INT_INT10()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT10))
#endif

//! @brief Format value for bitfield DMA_INT_INT10.
#define BF_DMA_INT_INT10(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT10), uint32_t) & BM_DMA_INT_INT10)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT10 field to a new value.
#define BW_DMA_INT_INT10(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT10) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT11[11] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT11      (11U)      //!< Bit position for DMA_INT_INT11.
#define BM_DMA_INT_INT11      (0x00000800U)  //!< Bit mask for DMA_INT_INT11.
#define BS_DMA_INT_INT11      (1U)  //!< Bitfield size in bits for DMA_INT_INT11.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT11 field.
#define BR_DMA_INT_INT11()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT11))
#endif

//! @brief Format value for bitfield DMA_INT_INT11.
#define BF_DMA_INT_INT11(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT11), uint32_t) & BM_DMA_INT_INT11)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT11 field to a new value.
#define BW_DMA_INT_INT11(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT11) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT12[12] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT12      (12U)      //!< Bit position for DMA_INT_INT12.
#define BM_DMA_INT_INT12      (0x00001000U)  //!< Bit mask for DMA_INT_INT12.
#define BS_DMA_INT_INT12      (1U)  //!< Bitfield size in bits for DMA_INT_INT12.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT12 field.
#define BR_DMA_INT_INT12()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT12))
#endif

//! @brief Format value for bitfield DMA_INT_INT12.
#define BF_DMA_INT_INT12(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT12), uint32_t) & BM_DMA_INT_INT12)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT12 field to a new value.
#define BW_DMA_INT_INT12(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT12) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT13[13] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT13      (13U)      //!< Bit position for DMA_INT_INT13.
#define BM_DMA_INT_INT13      (0x00002000U)  //!< Bit mask for DMA_INT_INT13.
#define BS_DMA_INT_INT13      (1U)  //!< Bitfield size in bits for DMA_INT_INT13.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT13 field.
#define BR_DMA_INT_INT13()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT13))
#endif

//! @brief Format value for bitfield DMA_INT_INT13.
#define BF_DMA_INT_INT13(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT13), uint32_t) & BM_DMA_INT_INT13)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT13 field to a new value.
#define BW_DMA_INT_INT13(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT13) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT14[14] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT14      (14U)      //!< Bit position for DMA_INT_INT14.
#define BM_DMA_INT_INT14      (0x00004000U)  //!< Bit mask for DMA_INT_INT14.
#define BS_DMA_INT_INT14      (1U)  //!< Bitfield size in bits for DMA_INT_INT14.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT14 field.
#define BR_DMA_INT_INT14()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT14))
#endif

//! @brief Format value for bitfield DMA_INT_INT14.
#define BF_DMA_INT_INT14(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT14), uint32_t) & BM_DMA_INT_INT14)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT14 field to a new value.
#define BW_DMA_INT_INT14(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT14) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT15[15] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT15      (15U)      //!< Bit position for DMA_INT_INT15.
#define BM_DMA_INT_INT15      (0x00008000U)  //!< Bit mask for DMA_INT_INT15.
#define BS_DMA_INT_INT15      (1U)  //!< Bitfield size in bits for DMA_INT_INT15.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT15 field.
#define BR_DMA_INT_INT15()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT15))
#endif

//! @brief Format value for bitfield DMA_INT_INT15.
#define BF_DMA_INT_INT15(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT15), uint32_t) & BM_DMA_INT_INT15)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT15 field to a new value.
#define BW_DMA_INT_INT15(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT15) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT16[16] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT16      (16U)      //!< Bit position for DMA_INT_INT16.
#define BM_DMA_INT_INT16      (0x00010000U)  //!< Bit mask for DMA_INT_INT16.
#define BS_DMA_INT_INT16      (1U)  //!< Bitfield size in bits for DMA_INT_INT16.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT16 field.
#define BR_DMA_INT_INT16()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT16))
#endif

//! @brief Format value for bitfield DMA_INT_INT16.
#define BF_DMA_INT_INT16(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT16), uint32_t) & BM_DMA_INT_INT16)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT16 field to a new value.
#define BW_DMA_INT_INT16(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT16) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT17[17] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT17      (17U)      //!< Bit position for DMA_INT_INT17.
#define BM_DMA_INT_INT17      (0x00020000U)  //!< Bit mask for DMA_INT_INT17.
#define BS_DMA_INT_INT17      (1U)  //!< Bitfield size in bits for DMA_INT_INT17.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT17 field.
#define BR_DMA_INT_INT17()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT17))
#endif

//! @brief Format value for bitfield DMA_INT_INT17.
#define BF_DMA_INT_INT17(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT17), uint32_t) & BM_DMA_INT_INT17)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT17 field to a new value.
#define BW_DMA_INT_INT17(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT17) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT18[18] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT18      (18U)      //!< Bit position for DMA_INT_INT18.
#define BM_DMA_INT_INT18      (0x00040000U)  //!< Bit mask for DMA_INT_INT18.
#define BS_DMA_INT_INT18      (1U)  //!< Bitfield size in bits for DMA_INT_INT18.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT18 field.
#define BR_DMA_INT_INT18()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT18))
#endif

//! @brief Format value for bitfield DMA_INT_INT18.
#define BF_DMA_INT_INT18(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT18), uint32_t) & BM_DMA_INT_INT18)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT18 field to a new value.
#define BW_DMA_INT_INT18(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT18) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT19[19] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT19      (19U)      //!< Bit position for DMA_INT_INT19.
#define BM_DMA_INT_INT19      (0x00080000U)  //!< Bit mask for DMA_INT_INT19.
#define BS_DMA_INT_INT19      (1U)  //!< Bitfield size in bits for DMA_INT_INT19.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT19 field.
#define BR_DMA_INT_INT19()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT19))
#endif

//! @brief Format value for bitfield DMA_INT_INT19.
#define BF_DMA_INT_INT19(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT19), uint32_t) & BM_DMA_INT_INT19)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT19 field to a new value.
#define BW_DMA_INT_INT19(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT19) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT20[20] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT20      (20U)      //!< Bit position for DMA_INT_INT20.
#define BM_DMA_INT_INT20      (0x00100000U)  //!< Bit mask for DMA_INT_INT20.
#define BS_DMA_INT_INT20      (1U)  //!< Bitfield size in bits for DMA_INT_INT20.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT20 field.
#define BR_DMA_INT_INT20()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT20))
#endif

//! @brief Format value for bitfield DMA_INT_INT20.
#define BF_DMA_INT_INT20(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT20), uint32_t) & BM_DMA_INT_INT20)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT20 field to a new value.
#define BW_DMA_INT_INT20(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT20) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT21[21] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT21      (21U)      //!< Bit position for DMA_INT_INT21.
#define BM_DMA_INT_INT21      (0x00200000U)  //!< Bit mask for DMA_INT_INT21.
#define BS_DMA_INT_INT21      (1U)  //!< Bitfield size in bits for DMA_INT_INT21.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT21 field.
#define BR_DMA_INT_INT21()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT21))
#endif

//! @brief Format value for bitfield DMA_INT_INT21.
#define BF_DMA_INT_INT21(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT21), uint32_t) & BM_DMA_INT_INT21)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT21 field to a new value.
#define BW_DMA_INT_INT21(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT21) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT22[22] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT22      (22U)      //!< Bit position for DMA_INT_INT22.
#define BM_DMA_INT_INT22      (0x00400000U)  //!< Bit mask for DMA_INT_INT22.
#define BS_DMA_INT_INT22      (1U)  //!< Bitfield size in bits for DMA_INT_INT22.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT22 field.
#define BR_DMA_INT_INT22()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT22))
#endif

//! @brief Format value for bitfield DMA_INT_INT22.
#define BF_DMA_INT_INT22(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT22), uint32_t) & BM_DMA_INT_INT22)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT22 field to a new value.
#define BW_DMA_INT_INT22(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT22) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT23[23] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT23      (23U)      //!< Bit position for DMA_INT_INT23.
#define BM_DMA_INT_INT23      (0x00800000U)  //!< Bit mask for DMA_INT_INT23.
#define BS_DMA_INT_INT23      (1U)  //!< Bitfield size in bits for DMA_INT_INT23.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT23 field.
#define BR_DMA_INT_INT23()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT23))
#endif

//! @brief Format value for bitfield DMA_INT_INT23.
#define BF_DMA_INT_INT23(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT23), uint32_t) & BM_DMA_INT_INT23)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT23 field to a new value.
#define BW_DMA_INT_INT23(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT23) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT24[24] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT24      (24U)      //!< Bit position for DMA_INT_INT24.
#define BM_DMA_INT_INT24      (0x01000000U)  //!< Bit mask for DMA_INT_INT24.
#define BS_DMA_INT_INT24      (1U)  //!< Bitfield size in bits for DMA_INT_INT24.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT24 field.
#define BR_DMA_INT_INT24()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT24))
#endif

//! @brief Format value for bitfield DMA_INT_INT24.
#define BF_DMA_INT_INT24(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT24), uint32_t) & BM_DMA_INT_INT24)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT24 field to a new value.
#define BW_DMA_INT_INT24(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT24) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT25[25] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT25      (25U)      //!< Bit position for DMA_INT_INT25.
#define BM_DMA_INT_INT25      (0x02000000U)  //!< Bit mask for DMA_INT_INT25.
#define BS_DMA_INT_INT25      (1U)  //!< Bitfield size in bits for DMA_INT_INT25.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT25 field.
#define BR_DMA_INT_INT25()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT25))
#endif

//! @brief Format value for bitfield DMA_INT_INT25.
#define BF_DMA_INT_INT25(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT25), uint32_t) & BM_DMA_INT_INT25)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT25 field to a new value.
#define BW_DMA_INT_INT25(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT25) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT26[26] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT26      (26U)      //!< Bit position for DMA_INT_INT26.
#define BM_DMA_INT_INT26      (0x04000000U)  //!< Bit mask for DMA_INT_INT26.
#define BS_DMA_INT_INT26      (1U)  //!< Bitfield size in bits for DMA_INT_INT26.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT26 field.
#define BR_DMA_INT_INT26()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT26))
#endif

//! @brief Format value for bitfield DMA_INT_INT26.
#define BF_DMA_INT_INT26(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT26), uint32_t) & BM_DMA_INT_INT26)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT26 field to a new value.
#define BW_DMA_INT_INT26(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT26) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT27[27] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT27      (27U)      //!< Bit position for DMA_INT_INT27.
#define BM_DMA_INT_INT27      (0x08000000U)  //!< Bit mask for DMA_INT_INT27.
#define BS_DMA_INT_INT27      (1U)  //!< Bitfield size in bits for DMA_INT_INT27.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT27 field.
#define BR_DMA_INT_INT27()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT27))
#endif

//! @brief Format value for bitfield DMA_INT_INT27.
#define BF_DMA_INT_INT27(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT27), uint32_t) & BM_DMA_INT_INT27)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT27 field to a new value.
#define BW_DMA_INT_INT27(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT27) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT28[28] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT28      (28U)      //!< Bit position for DMA_INT_INT28.
#define BM_DMA_INT_INT28      (0x10000000U)  //!< Bit mask for DMA_INT_INT28.
#define BS_DMA_INT_INT28      (1U)  //!< Bitfield size in bits for DMA_INT_INT28.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT28 field.
#define BR_DMA_INT_INT28()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT28))
#endif

//! @brief Format value for bitfield DMA_INT_INT28.
#define BF_DMA_INT_INT28(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT28), uint32_t) & BM_DMA_INT_INT28)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT28 field to a new value.
#define BW_DMA_INT_INT28(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT28) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT29[29] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT29      (29U)      //!< Bit position for DMA_INT_INT29.
#define BM_DMA_INT_INT29      (0x20000000U)  //!< Bit mask for DMA_INT_INT29.
#define BS_DMA_INT_INT29      (1U)  //!< Bitfield size in bits for DMA_INT_INT29.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT29 field.
#define BR_DMA_INT_INT29()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT29))
#endif

//! @brief Format value for bitfield DMA_INT_INT29.
#define BF_DMA_INT_INT29(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT29), uint32_t) & BM_DMA_INT_INT29)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT29 field to a new value.
#define BW_DMA_INT_INT29(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT29) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT30[30] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT30      (30U)      //!< Bit position for DMA_INT_INT30.
#define BM_DMA_INT_INT30      (0x40000000U)  //!< Bit mask for DMA_INT_INT30.
#define BS_DMA_INT_INT30      (1U)  //!< Bitfield size in bits for DMA_INT_INT30.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT30 field.
#define BR_DMA_INT_INT30()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT30))
#endif

//! @brief Format value for bitfield DMA_INT_INT30.
#define BF_DMA_INT_INT30(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT30), uint32_t) & BM_DMA_INT_INT30)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT30 field to a new value.
#define BW_DMA_INT_INT30(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT30) = (v))
#endif
//@}

/*! @name Register DMA_INT, field INT31[31] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
//@{
#define BP_DMA_INT_INT31      (31U)      //!< Bit position for DMA_INT_INT31.
#define BM_DMA_INT_INT31      (0x80000000U)  //!< Bit mask for DMA_INT_INT31.
#define BS_DMA_INT_INT31      (1U)  //!< Bitfield size in bits for DMA_INT_INT31.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_INT_INT31 field.
#define BR_DMA_INT_INT31()   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT31))
#endif

//! @brief Format value for bitfield DMA_INT_INT31.
#define BF_DMA_INT_INT31(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_INT_INT31), uint32_t) & BM_DMA_INT_INT31)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT31 field to a new value.
#define BW_DMA_INT_INT31(v)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR, BP_DMA_INT_INT31) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_ERR - Error Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_ERR - Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERR provides a bit map for the 32 channels, signaling the presence of an error for each
 * channel. The eDMA engine signals the occurrence of an error condition by setting the appropriate
 * bit in this register. The outputs of this register are enabled by the contents of the EEI, then
 * logically summed across groups of 16 and 32 channels to form several group error interrupt
 * requests, which are then routed to the interrupt controller. During the execution of the
 * interrupt-service routine associated with any DMA errors, it is softwares responsibility to
 * clear the appropriate bit, negating the error-interrupt request. Typically, a write to the CERR
 * in the interrupt-service routine is used for this purpose. The normal DMA channel completion
 * indicators (setting the transfer control descriptor DONE flag and the possible assertion of an
 * interrupt request) are not affected when an error is detected. The contents of this register can
 * also be polled because a non-zero value indicates the presence of a channel error regardless of
 * the state of the EEI. The state of any given channels error indicators is affected by writes to
 * this register; it is also affected by writes to the CERR. On writes to the ERR, a one in any bit
 * position clears the corresponding channels error status. A zero in any bit position has no
 * affect on the corresponding channels current error status. The CERR is provided so the error
 * indicator for a single channel can easily be cleared.
 */
typedef union _hw_dma_err
{
    uint32_t U;
    struct _hw_dma_err_bitfields
    {
        uint32_t ERR0 : 1; //!< [0] Error In Channel 0
        uint32_t ERR1 : 1; //!< [1] Error In Channel 1
        uint32_t ERR2 : 1; //!< [2] Error In Channel 2
        uint32_t ERR3 : 1; //!< [3] Error In Channel 3
        uint32_t ERR4 : 1; //!< [4] Error In Channel 4
        uint32_t ERR5 : 1; //!< [5] Error In Channel 5
        uint32_t ERR6 : 1; //!< [6] Error In Channel 6
        uint32_t ERR7 : 1; //!< [7] Error In Channel 7
        uint32_t ERR8 : 1; //!< [8] Error In Channel 8
        uint32_t ERR9 : 1; //!< [9] Error In Channel 9
        uint32_t ERR10 : 1; //!< [10] Error In Channel 10
        uint32_t ERR11 : 1; //!< [11] Error In Channel 11
        uint32_t ERR12 : 1; //!< [12] Error In Channel 12
        uint32_t ERR13 : 1; //!< [13] Error In Channel 13
        uint32_t ERR14 : 1; //!< [14] Error In Channel 14
        uint32_t ERR15 : 1; //!< [15] Error In Channel 15
        uint32_t ERR16 : 1; //!< [16] Error In Channel 16
        uint32_t ERR17 : 1; //!< [17] Error In Channel 17
        uint32_t ERR18 : 1; //!< [18] Error In Channel 18
        uint32_t ERR19 : 1; //!< [19] Error In Channel 19
        uint32_t ERR20 : 1; //!< [20] Error In Channel 20
        uint32_t ERR21 : 1; //!< [21] Error In Channel 21
        uint32_t ERR22 : 1; //!< [22] Error In Channel 22
        uint32_t ERR23 : 1; //!< [23] Error In Channel 23
        uint32_t ERR24 : 1; //!< [24] Error In Channel 24
        uint32_t ERR25 : 1; //!< [25] Error In Channel 25
        uint32_t ERR26 : 1; //!< [26] Error In Channel 26
        uint32_t ERR27 : 1; //!< [27] Error In Channel 27
        uint32_t ERR28 : 1; //!< [28] Error In Channel 28
        uint32_t ERR29 : 1; //!< [29] Error In Channel 29
        uint32_t ERR30 : 1; //!< [30] Error In Channel 30
        uint32_t ERR31 : 1; //!< [31] Error In Channel 31
    } B;
} hw_dma_err_t;
#endif

/*!
 * @name Constants and macros for entire DMA_ERR register
 */
//@{
#define HW_DMA_ERR_ADDR      (REGS_DMA_BASE + 0x2cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_ERR           (*(__IO hw_dma_err_t *) HW_DMA_ERR_ADDR)
#define HW_DMA_ERR_RD()      (HW_DMA_ERR.U)
#define HW_DMA_ERR_WR(v)     (HW_DMA_ERR.U = (v))
#define HW_DMA_ERR_SET(v)    (HW_DMA_ERR_WR(HW_DMA_ERR_RD() |  (v)))
#define HW_DMA_ERR_CLR(v)    (HW_DMA_ERR_WR(HW_DMA_ERR_RD() & ~(v)))
#define HW_DMA_ERR_TOG(v)    (HW_DMA_ERR_WR(HW_DMA_ERR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_ERR bitfields
 */

/*! @name Register DMA_ERR, field ERR0[0] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR0      (0U)      //!< Bit position for DMA_ERR_ERR0.
#define BM_DMA_ERR_ERR0      (0x00000001U)  //!< Bit mask for DMA_ERR_ERR0.
#define BS_DMA_ERR_ERR0      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR0 field.
#define BR_DMA_ERR_ERR0()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR0))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR0.
#define BF_DMA_ERR_ERR0(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR0), uint32_t) & BM_DMA_ERR_ERR0)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR0 field to a new value.
#define BW_DMA_ERR_ERR0(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR0) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR1[1] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR1      (1U)      //!< Bit position for DMA_ERR_ERR1.
#define BM_DMA_ERR_ERR1      (0x00000002U)  //!< Bit mask for DMA_ERR_ERR1.
#define BS_DMA_ERR_ERR1      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR1 field.
#define BR_DMA_ERR_ERR1()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR1))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR1.
#define BF_DMA_ERR_ERR1(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR1), uint32_t) & BM_DMA_ERR_ERR1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR1 field to a new value.
#define BW_DMA_ERR_ERR1(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR1) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR2[2] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR2      (2U)      //!< Bit position for DMA_ERR_ERR2.
#define BM_DMA_ERR_ERR2      (0x00000004U)  //!< Bit mask for DMA_ERR_ERR2.
#define BS_DMA_ERR_ERR2      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR2 field.
#define BR_DMA_ERR_ERR2()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR2))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR2.
#define BF_DMA_ERR_ERR2(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR2), uint32_t) & BM_DMA_ERR_ERR2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR2 field to a new value.
#define BW_DMA_ERR_ERR2(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR2) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR3[3] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR3      (3U)      //!< Bit position for DMA_ERR_ERR3.
#define BM_DMA_ERR_ERR3      (0x00000008U)  //!< Bit mask for DMA_ERR_ERR3.
#define BS_DMA_ERR_ERR3      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR3.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR3 field.
#define BR_DMA_ERR_ERR3()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR3))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR3.
#define BF_DMA_ERR_ERR3(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR3), uint32_t) & BM_DMA_ERR_ERR3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR3 field to a new value.
#define BW_DMA_ERR_ERR3(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR3) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR4[4] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR4      (4U)      //!< Bit position for DMA_ERR_ERR4.
#define BM_DMA_ERR_ERR4      (0x00000010U)  //!< Bit mask for DMA_ERR_ERR4.
#define BS_DMA_ERR_ERR4      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR4.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR4 field.
#define BR_DMA_ERR_ERR4()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR4))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR4.
#define BF_DMA_ERR_ERR4(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR4), uint32_t) & BM_DMA_ERR_ERR4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR4 field to a new value.
#define BW_DMA_ERR_ERR4(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR4) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR5[5] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR5      (5U)      //!< Bit position for DMA_ERR_ERR5.
#define BM_DMA_ERR_ERR5      (0x00000020U)  //!< Bit mask for DMA_ERR_ERR5.
#define BS_DMA_ERR_ERR5      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR5.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR5 field.
#define BR_DMA_ERR_ERR5()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR5))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR5.
#define BF_DMA_ERR_ERR5(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR5), uint32_t) & BM_DMA_ERR_ERR5)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR5 field to a new value.
#define BW_DMA_ERR_ERR5(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR5) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR6[6] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR6      (6U)      //!< Bit position for DMA_ERR_ERR6.
#define BM_DMA_ERR_ERR6      (0x00000040U)  //!< Bit mask for DMA_ERR_ERR6.
#define BS_DMA_ERR_ERR6      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR6.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR6 field.
#define BR_DMA_ERR_ERR6()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR6))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR6.
#define BF_DMA_ERR_ERR6(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR6), uint32_t) & BM_DMA_ERR_ERR6)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR6 field to a new value.
#define BW_DMA_ERR_ERR6(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR6) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR7[7] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR7      (7U)      //!< Bit position for DMA_ERR_ERR7.
#define BM_DMA_ERR_ERR7      (0x00000080U)  //!< Bit mask for DMA_ERR_ERR7.
#define BS_DMA_ERR_ERR7      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR7.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR7 field.
#define BR_DMA_ERR_ERR7()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR7))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR7.
#define BF_DMA_ERR_ERR7(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR7), uint32_t) & BM_DMA_ERR_ERR7)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR7 field to a new value.
#define BW_DMA_ERR_ERR7(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR7) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR8[8] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR8      (8U)      //!< Bit position for DMA_ERR_ERR8.
#define BM_DMA_ERR_ERR8      (0x00000100U)  //!< Bit mask for DMA_ERR_ERR8.
#define BS_DMA_ERR_ERR8      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR8.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR8 field.
#define BR_DMA_ERR_ERR8()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR8))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR8.
#define BF_DMA_ERR_ERR8(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR8), uint32_t) & BM_DMA_ERR_ERR8)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR8 field to a new value.
#define BW_DMA_ERR_ERR8(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR8) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR9[9] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR9      (9U)      //!< Bit position for DMA_ERR_ERR9.
#define BM_DMA_ERR_ERR9      (0x00000200U)  //!< Bit mask for DMA_ERR_ERR9.
#define BS_DMA_ERR_ERR9      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR9.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR9 field.
#define BR_DMA_ERR_ERR9()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR9))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR9.
#define BF_DMA_ERR_ERR9(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR9), uint32_t) & BM_DMA_ERR_ERR9)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR9 field to a new value.
#define BW_DMA_ERR_ERR9(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR9) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR10[10] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR10      (10U)      //!< Bit position for DMA_ERR_ERR10.
#define BM_DMA_ERR_ERR10      (0x00000400U)  //!< Bit mask for DMA_ERR_ERR10.
#define BS_DMA_ERR_ERR10      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR10.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR10 field.
#define BR_DMA_ERR_ERR10()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR10))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR10.
#define BF_DMA_ERR_ERR10(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR10), uint32_t) & BM_DMA_ERR_ERR10)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR10 field to a new value.
#define BW_DMA_ERR_ERR10(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR10) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR11[11] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR11      (11U)      //!< Bit position for DMA_ERR_ERR11.
#define BM_DMA_ERR_ERR11      (0x00000800U)  //!< Bit mask for DMA_ERR_ERR11.
#define BS_DMA_ERR_ERR11      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR11.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR11 field.
#define BR_DMA_ERR_ERR11()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR11))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR11.
#define BF_DMA_ERR_ERR11(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR11), uint32_t) & BM_DMA_ERR_ERR11)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR11 field to a new value.
#define BW_DMA_ERR_ERR11(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR11) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR12[12] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR12      (12U)      //!< Bit position for DMA_ERR_ERR12.
#define BM_DMA_ERR_ERR12      (0x00001000U)  //!< Bit mask for DMA_ERR_ERR12.
#define BS_DMA_ERR_ERR12      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR12.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR12 field.
#define BR_DMA_ERR_ERR12()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR12))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR12.
#define BF_DMA_ERR_ERR12(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR12), uint32_t) & BM_DMA_ERR_ERR12)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR12 field to a new value.
#define BW_DMA_ERR_ERR12(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR12) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR13[13] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR13      (13U)      //!< Bit position for DMA_ERR_ERR13.
#define BM_DMA_ERR_ERR13      (0x00002000U)  //!< Bit mask for DMA_ERR_ERR13.
#define BS_DMA_ERR_ERR13      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR13.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR13 field.
#define BR_DMA_ERR_ERR13()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR13))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR13.
#define BF_DMA_ERR_ERR13(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR13), uint32_t) & BM_DMA_ERR_ERR13)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR13 field to a new value.
#define BW_DMA_ERR_ERR13(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR13) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR14[14] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR14      (14U)      //!< Bit position for DMA_ERR_ERR14.
#define BM_DMA_ERR_ERR14      (0x00004000U)  //!< Bit mask for DMA_ERR_ERR14.
#define BS_DMA_ERR_ERR14      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR14.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR14 field.
#define BR_DMA_ERR_ERR14()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR14))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR14.
#define BF_DMA_ERR_ERR14(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR14), uint32_t) & BM_DMA_ERR_ERR14)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR14 field to a new value.
#define BW_DMA_ERR_ERR14(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR14) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR15[15] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR15      (15U)      //!< Bit position for DMA_ERR_ERR15.
#define BM_DMA_ERR_ERR15      (0x00008000U)  //!< Bit mask for DMA_ERR_ERR15.
#define BS_DMA_ERR_ERR15      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR15.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR15 field.
#define BR_DMA_ERR_ERR15()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR15))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR15.
#define BF_DMA_ERR_ERR15(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR15), uint32_t) & BM_DMA_ERR_ERR15)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR15 field to a new value.
#define BW_DMA_ERR_ERR15(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR15) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR16[16] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR16      (16U)      //!< Bit position for DMA_ERR_ERR16.
#define BM_DMA_ERR_ERR16      (0x00010000U)  //!< Bit mask for DMA_ERR_ERR16.
#define BS_DMA_ERR_ERR16      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR16.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR16 field.
#define BR_DMA_ERR_ERR16()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR16))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR16.
#define BF_DMA_ERR_ERR16(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR16), uint32_t) & BM_DMA_ERR_ERR16)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR16 field to a new value.
#define BW_DMA_ERR_ERR16(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR16) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR17[17] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR17      (17U)      //!< Bit position for DMA_ERR_ERR17.
#define BM_DMA_ERR_ERR17      (0x00020000U)  //!< Bit mask for DMA_ERR_ERR17.
#define BS_DMA_ERR_ERR17      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR17.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR17 field.
#define BR_DMA_ERR_ERR17()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR17))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR17.
#define BF_DMA_ERR_ERR17(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR17), uint32_t) & BM_DMA_ERR_ERR17)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR17 field to a new value.
#define BW_DMA_ERR_ERR17(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR17) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR18[18] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR18      (18U)      //!< Bit position for DMA_ERR_ERR18.
#define BM_DMA_ERR_ERR18      (0x00040000U)  //!< Bit mask for DMA_ERR_ERR18.
#define BS_DMA_ERR_ERR18      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR18.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR18 field.
#define BR_DMA_ERR_ERR18()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR18))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR18.
#define BF_DMA_ERR_ERR18(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR18), uint32_t) & BM_DMA_ERR_ERR18)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR18 field to a new value.
#define BW_DMA_ERR_ERR18(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR18) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR19[19] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR19      (19U)      //!< Bit position for DMA_ERR_ERR19.
#define BM_DMA_ERR_ERR19      (0x00080000U)  //!< Bit mask for DMA_ERR_ERR19.
#define BS_DMA_ERR_ERR19      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR19.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR19 field.
#define BR_DMA_ERR_ERR19()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR19))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR19.
#define BF_DMA_ERR_ERR19(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR19), uint32_t) & BM_DMA_ERR_ERR19)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR19 field to a new value.
#define BW_DMA_ERR_ERR19(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR19) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR20[20] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR20      (20U)      //!< Bit position for DMA_ERR_ERR20.
#define BM_DMA_ERR_ERR20      (0x00100000U)  //!< Bit mask for DMA_ERR_ERR20.
#define BS_DMA_ERR_ERR20      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR20.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR20 field.
#define BR_DMA_ERR_ERR20()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR20))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR20.
#define BF_DMA_ERR_ERR20(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR20), uint32_t) & BM_DMA_ERR_ERR20)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR20 field to a new value.
#define BW_DMA_ERR_ERR20(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR20) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR21[21] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR21      (21U)      //!< Bit position for DMA_ERR_ERR21.
#define BM_DMA_ERR_ERR21      (0x00200000U)  //!< Bit mask for DMA_ERR_ERR21.
#define BS_DMA_ERR_ERR21      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR21.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR21 field.
#define BR_DMA_ERR_ERR21()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR21))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR21.
#define BF_DMA_ERR_ERR21(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR21), uint32_t) & BM_DMA_ERR_ERR21)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR21 field to a new value.
#define BW_DMA_ERR_ERR21(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR21) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR22[22] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR22      (22U)      //!< Bit position for DMA_ERR_ERR22.
#define BM_DMA_ERR_ERR22      (0x00400000U)  //!< Bit mask for DMA_ERR_ERR22.
#define BS_DMA_ERR_ERR22      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR22.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR22 field.
#define BR_DMA_ERR_ERR22()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR22))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR22.
#define BF_DMA_ERR_ERR22(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR22), uint32_t) & BM_DMA_ERR_ERR22)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR22 field to a new value.
#define BW_DMA_ERR_ERR22(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR22) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR23[23] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR23      (23U)      //!< Bit position for DMA_ERR_ERR23.
#define BM_DMA_ERR_ERR23      (0x00800000U)  //!< Bit mask for DMA_ERR_ERR23.
#define BS_DMA_ERR_ERR23      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR23.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR23 field.
#define BR_DMA_ERR_ERR23()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR23))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR23.
#define BF_DMA_ERR_ERR23(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR23), uint32_t) & BM_DMA_ERR_ERR23)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR23 field to a new value.
#define BW_DMA_ERR_ERR23(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR23) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR24[24] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR24      (24U)      //!< Bit position for DMA_ERR_ERR24.
#define BM_DMA_ERR_ERR24      (0x01000000U)  //!< Bit mask for DMA_ERR_ERR24.
#define BS_DMA_ERR_ERR24      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR24.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR24 field.
#define BR_DMA_ERR_ERR24()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR24))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR24.
#define BF_DMA_ERR_ERR24(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR24), uint32_t) & BM_DMA_ERR_ERR24)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR24 field to a new value.
#define BW_DMA_ERR_ERR24(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR24) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR25[25] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR25      (25U)      //!< Bit position for DMA_ERR_ERR25.
#define BM_DMA_ERR_ERR25      (0x02000000U)  //!< Bit mask for DMA_ERR_ERR25.
#define BS_DMA_ERR_ERR25      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR25.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR25 field.
#define BR_DMA_ERR_ERR25()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR25))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR25.
#define BF_DMA_ERR_ERR25(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR25), uint32_t) & BM_DMA_ERR_ERR25)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR25 field to a new value.
#define BW_DMA_ERR_ERR25(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR25) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR26[26] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR26      (26U)      //!< Bit position for DMA_ERR_ERR26.
#define BM_DMA_ERR_ERR26      (0x04000000U)  //!< Bit mask for DMA_ERR_ERR26.
#define BS_DMA_ERR_ERR26      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR26.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR26 field.
#define BR_DMA_ERR_ERR26()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR26))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR26.
#define BF_DMA_ERR_ERR26(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR26), uint32_t) & BM_DMA_ERR_ERR26)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR26 field to a new value.
#define BW_DMA_ERR_ERR26(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR26) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR27[27] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR27      (27U)      //!< Bit position for DMA_ERR_ERR27.
#define BM_DMA_ERR_ERR27      (0x08000000U)  //!< Bit mask for DMA_ERR_ERR27.
#define BS_DMA_ERR_ERR27      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR27.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR27 field.
#define BR_DMA_ERR_ERR27()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR27))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR27.
#define BF_DMA_ERR_ERR27(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR27), uint32_t) & BM_DMA_ERR_ERR27)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR27 field to a new value.
#define BW_DMA_ERR_ERR27(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR27) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR28[28] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR28      (28U)      //!< Bit position for DMA_ERR_ERR28.
#define BM_DMA_ERR_ERR28      (0x10000000U)  //!< Bit mask for DMA_ERR_ERR28.
#define BS_DMA_ERR_ERR28      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR28.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR28 field.
#define BR_DMA_ERR_ERR28()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR28))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR28.
#define BF_DMA_ERR_ERR28(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR28), uint32_t) & BM_DMA_ERR_ERR28)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR28 field to a new value.
#define BW_DMA_ERR_ERR28(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR28) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR29[29] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR29      (29U)      //!< Bit position for DMA_ERR_ERR29.
#define BM_DMA_ERR_ERR29      (0x20000000U)  //!< Bit mask for DMA_ERR_ERR29.
#define BS_DMA_ERR_ERR29      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR29.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR29 field.
#define BR_DMA_ERR_ERR29()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR29))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR29.
#define BF_DMA_ERR_ERR29(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR29), uint32_t) & BM_DMA_ERR_ERR29)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR29 field to a new value.
#define BW_DMA_ERR_ERR29(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR29) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR30[30] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR30      (30U)      //!< Bit position for DMA_ERR_ERR30.
#define BM_DMA_ERR_ERR30      (0x40000000U)  //!< Bit mask for DMA_ERR_ERR30.
#define BS_DMA_ERR_ERR30      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR30.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR30 field.
#define BR_DMA_ERR_ERR30()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR30))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR30.
#define BF_DMA_ERR_ERR30(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR30), uint32_t) & BM_DMA_ERR_ERR30)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR30 field to a new value.
#define BW_DMA_ERR_ERR30(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR30) = (v))
#endif
//@}

/*! @name Register DMA_ERR, field ERR31[31] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
//@{
#define BP_DMA_ERR_ERR31      (31U)      //!< Bit position for DMA_ERR_ERR31.
#define BM_DMA_ERR_ERR31      (0x80000000U)  //!< Bit mask for DMA_ERR_ERR31.
#define BS_DMA_ERR_ERR31      (1U)  //!< Bitfield size in bits for DMA_ERR_ERR31.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_ERR_ERR31 field.
#define BR_DMA_ERR_ERR31()   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR31))
#endif

//! @brief Format value for bitfield DMA_ERR_ERR31.
#define BF_DMA_ERR_ERR31(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_ERR_ERR31), uint32_t) & BM_DMA_ERR_ERR31)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR31 field to a new value.
#define BW_DMA_ERR_ERR31(v)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR, BP_DMA_ERR_ERR31) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_HRS - Hardware Request Status Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_HRS - Hardware Request Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The HRS register provides a bit map for the DMA channels, signaling the presence of a hardware
 * request for each channel. The hardware request status bits reflect the current state of the
 * register and qualified (via the ERQ fields) DMA request signals as seen by the DMAs arbitration
 * logic. This view into the hardware request signals may be used for debug purposes. These bits
 * reflect the state of the request as seen by the arbitration logic. Therefore, this status is
 * affected by the ERQ bits.
 */
typedef union _hw_dma_hrs
{
    uint32_t U;
    struct _hw_dma_hrs_bitfields
    {
        uint32_t HRS0 : 1; //!< [0] Hardware Request Status Channel 0
        uint32_t HRS1 : 1; //!< [1] Hardware Request Status Channel 1
        uint32_t HRS2 : 1; //!< [2] Hardware Request Status Channel 2
        uint32_t HRS3 : 1; //!< [3] Hardware Request Status Channel 3
        uint32_t HRS4 : 1; //!< [4] Hardware Request Status Channel 4
        uint32_t HRS5 : 1; //!< [5] Hardware Request Status Channel 5
        uint32_t HRS6 : 1; //!< [6] Hardware Request Status Channel 6
        uint32_t HRS7 : 1; //!< [7] Hardware Request Status Channel 7
        uint32_t HRS8 : 1; //!< [8] Hardware Request Status Channel 8
        uint32_t HRS9 : 1; //!< [9] Hardware Request Status Channel 9
        uint32_t HRS10 : 1; //!< [10] Hardware Request Status Channel 10
        uint32_t HRS11 : 1; //!< [11] Hardware Request Status Channel 11
        uint32_t HRS12 : 1; //!< [12] Hardware Request Status Channel 12
        uint32_t HRS13 : 1; //!< [13] Hardware Request Status Channel 13
        uint32_t HRS14 : 1; //!< [14] Hardware Request Status Channel 14
        uint32_t HRS15 : 1; //!< [15] Hardware Request Status Channel 15
        uint32_t HRS16 : 1; //!< [16] Hardware Request Status Channel 16
        uint32_t HRS17 : 1; //!< [17] Hardware Request Status Channel 17
        uint32_t HRS18 : 1; //!< [18] Hardware Request Status Channel 18
        uint32_t HRS19 : 1; //!< [19] Hardware Request Status Channel 19
        uint32_t HRS20 : 1; //!< [20] Hardware Request Status Channel 20
        uint32_t HRS21 : 1; //!< [21] Hardware Request Status Channel 21
        uint32_t HRS22 : 1; //!< [22] Hardware Request Status Channel 22
        uint32_t HRS23 : 1; //!< [23] Hardware Request Status Channel 23
        uint32_t HRS24 : 1; //!< [24] Hardware Request Status Channel 24
        uint32_t HRS25 : 1; //!< [25] Hardware Request Status Channel 25
        uint32_t HRS26 : 1; //!< [26] Hardware Request Status Channel 26
        uint32_t HRS27 : 1; //!< [27] Hardware Request Status Channel 27
        uint32_t HRS28 : 1; //!< [28] Hardware Request Status Channel 28
        uint32_t HRS29 : 1; //!< [29] Hardware Request Status Channel 29
        uint32_t HRS30 : 1; //!< [30] Hardware Request Status Channel 30
        uint32_t HRS31 : 1; //!< [31] Hardware Request Status Channel 31
    } B;
} hw_dma_hrs_t;
#endif

/*!
 * @name Constants and macros for entire DMA_HRS register
 */
//@{
#define HW_DMA_HRS_ADDR      (REGS_DMA_BASE + 0x34U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_HRS           (*(__IO hw_dma_hrs_t *) HW_DMA_HRS_ADDR)
#define HW_DMA_HRS_RD()      (HW_DMA_HRS.U)
#define HW_DMA_HRS_WR(v)     (HW_DMA_HRS.U = (v))
#define HW_DMA_HRS_SET(v)    (HW_DMA_HRS_WR(HW_DMA_HRS_RD() |  (v)))
#define HW_DMA_HRS_CLR(v)    (HW_DMA_HRS_WR(HW_DMA_HRS_RD() & ~(v)))
#define HW_DMA_HRS_TOG(v)    (HW_DMA_HRS_WR(HW_DMA_HRS_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_HRS bitfields
 */

/*! @name Register DMA_HRS, field HRS0[0] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS0      (0U)      //!< Bit position for DMA_HRS_HRS0.
#define BM_DMA_HRS_HRS0      (0x00000001U)  //!< Bit mask for DMA_HRS_HRS0.
#define BS_DMA_HRS_HRS0      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS0 field.
#define BR_DMA_HRS_HRS0()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS0))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS0.
#define BF_DMA_HRS_HRS0(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS0), uint32_t) & BM_DMA_HRS_HRS0)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS0 field to a new value.
#define BW_DMA_HRS_HRS0(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS0) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS1[1] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS1      (1U)      //!< Bit position for DMA_HRS_HRS1.
#define BM_DMA_HRS_HRS1      (0x00000002U)  //!< Bit mask for DMA_HRS_HRS1.
#define BS_DMA_HRS_HRS1      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS1 field.
#define BR_DMA_HRS_HRS1()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS1))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS1.
#define BF_DMA_HRS_HRS1(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS1), uint32_t) & BM_DMA_HRS_HRS1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS1 field to a new value.
#define BW_DMA_HRS_HRS1(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS1) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS2[2] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS2      (2U)      //!< Bit position for DMA_HRS_HRS2.
#define BM_DMA_HRS_HRS2      (0x00000004U)  //!< Bit mask for DMA_HRS_HRS2.
#define BS_DMA_HRS_HRS2      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS2 field.
#define BR_DMA_HRS_HRS2()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS2))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS2.
#define BF_DMA_HRS_HRS2(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS2), uint32_t) & BM_DMA_HRS_HRS2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS2 field to a new value.
#define BW_DMA_HRS_HRS2(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS2) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS3[3] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS3      (3U)      //!< Bit position for DMA_HRS_HRS3.
#define BM_DMA_HRS_HRS3      (0x00000008U)  //!< Bit mask for DMA_HRS_HRS3.
#define BS_DMA_HRS_HRS3      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS3.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS3 field.
#define BR_DMA_HRS_HRS3()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS3))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS3.
#define BF_DMA_HRS_HRS3(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS3), uint32_t) & BM_DMA_HRS_HRS3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS3 field to a new value.
#define BW_DMA_HRS_HRS3(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS3) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS4[4] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS4      (4U)      //!< Bit position for DMA_HRS_HRS4.
#define BM_DMA_HRS_HRS4      (0x00000010U)  //!< Bit mask for DMA_HRS_HRS4.
#define BS_DMA_HRS_HRS4      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS4.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS4 field.
#define BR_DMA_HRS_HRS4()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS4))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS4.
#define BF_DMA_HRS_HRS4(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS4), uint32_t) & BM_DMA_HRS_HRS4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS4 field to a new value.
#define BW_DMA_HRS_HRS4(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS4) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS5[5] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS5      (5U)      //!< Bit position for DMA_HRS_HRS5.
#define BM_DMA_HRS_HRS5      (0x00000020U)  //!< Bit mask for DMA_HRS_HRS5.
#define BS_DMA_HRS_HRS5      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS5.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS5 field.
#define BR_DMA_HRS_HRS5()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS5))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS5.
#define BF_DMA_HRS_HRS5(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS5), uint32_t) & BM_DMA_HRS_HRS5)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS5 field to a new value.
#define BW_DMA_HRS_HRS5(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS5) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS6[6] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS6      (6U)      //!< Bit position for DMA_HRS_HRS6.
#define BM_DMA_HRS_HRS6      (0x00000040U)  //!< Bit mask for DMA_HRS_HRS6.
#define BS_DMA_HRS_HRS6      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS6.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS6 field.
#define BR_DMA_HRS_HRS6()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS6))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS6.
#define BF_DMA_HRS_HRS6(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS6), uint32_t) & BM_DMA_HRS_HRS6)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS6 field to a new value.
#define BW_DMA_HRS_HRS6(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS6) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS7[7] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS7      (7U)      //!< Bit position for DMA_HRS_HRS7.
#define BM_DMA_HRS_HRS7      (0x00000080U)  //!< Bit mask for DMA_HRS_HRS7.
#define BS_DMA_HRS_HRS7      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS7.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS7 field.
#define BR_DMA_HRS_HRS7()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS7))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS7.
#define BF_DMA_HRS_HRS7(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS7), uint32_t) & BM_DMA_HRS_HRS7)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS7 field to a new value.
#define BW_DMA_HRS_HRS7(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS7) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS8[8] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS8      (8U)      //!< Bit position for DMA_HRS_HRS8.
#define BM_DMA_HRS_HRS8      (0x00000100U)  //!< Bit mask for DMA_HRS_HRS8.
#define BS_DMA_HRS_HRS8      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS8.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS8 field.
#define BR_DMA_HRS_HRS8()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS8))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS8.
#define BF_DMA_HRS_HRS8(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS8), uint32_t) & BM_DMA_HRS_HRS8)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS8 field to a new value.
#define BW_DMA_HRS_HRS8(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS8) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS9[9] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS9      (9U)      //!< Bit position for DMA_HRS_HRS9.
#define BM_DMA_HRS_HRS9      (0x00000200U)  //!< Bit mask for DMA_HRS_HRS9.
#define BS_DMA_HRS_HRS9      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS9.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS9 field.
#define BR_DMA_HRS_HRS9()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS9))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS9.
#define BF_DMA_HRS_HRS9(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS9), uint32_t) & BM_DMA_HRS_HRS9)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS9 field to a new value.
#define BW_DMA_HRS_HRS9(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS9) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS10[10] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS10      (10U)      //!< Bit position for DMA_HRS_HRS10.
#define BM_DMA_HRS_HRS10      (0x00000400U)  //!< Bit mask for DMA_HRS_HRS10.
#define BS_DMA_HRS_HRS10      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS10.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS10 field.
#define BR_DMA_HRS_HRS10()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS10))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS10.
#define BF_DMA_HRS_HRS10(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS10), uint32_t) & BM_DMA_HRS_HRS10)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS10 field to a new value.
#define BW_DMA_HRS_HRS10(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS10) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS11[11] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS11      (11U)      //!< Bit position for DMA_HRS_HRS11.
#define BM_DMA_HRS_HRS11      (0x00000800U)  //!< Bit mask for DMA_HRS_HRS11.
#define BS_DMA_HRS_HRS11      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS11.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS11 field.
#define BR_DMA_HRS_HRS11()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS11))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS11.
#define BF_DMA_HRS_HRS11(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS11), uint32_t) & BM_DMA_HRS_HRS11)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS11 field to a new value.
#define BW_DMA_HRS_HRS11(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS11) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS12[12] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS12      (12U)      //!< Bit position for DMA_HRS_HRS12.
#define BM_DMA_HRS_HRS12      (0x00001000U)  //!< Bit mask for DMA_HRS_HRS12.
#define BS_DMA_HRS_HRS12      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS12.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS12 field.
#define BR_DMA_HRS_HRS12()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS12))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS12.
#define BF_DMA_HRS_HRS12(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS12), uint32_t) & BM_DMA_HRS_HRS12)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS12 field to a new value.
#define BW_DMA_HRS_HRS12(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS12) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS13[13] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS13      (13U)      //!< Bit position for DMA_HRS_HRS13.
#define BM_DMA_HRS_HRS13      (0x00002000U)  //!< Bit mask for DMA_HRS_HRS13.
#define BS_DMA_HRS_HRS13      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS13.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS13 field.
#define BR_DMA_HRS_HRS13()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS13))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS13.
#define BF_DMA_HRS_HRS13(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS13), uint32_t) & BM_DMA_HRS_HRS13)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS13 field to a new value.
#define BW_DMA_HRS_HRS13(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS13) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS14[14] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS14      (14U)      //!< Bit position for DMA_HRS_HRS14.
#define BM_DMA_HRS_HRS14      (0x00004000U)  //!< Bit mask for DMA_HRS_HRS14.
#define BS_DMA_HRS_HRS14      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS14.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS14 field.
#define BR_DMA_HRS_HRS14()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS14))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS14.
#define BF_DMA_HRS_HRS14(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS14), uint32_t) & BM_DMA_HRS_HRS14)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS14 field to a new value.
#define BW_DMA_HRS_HRS14(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS14) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS15[15] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS15      (15U)      //!< Bit position for DMA_HRS_HRS15.
#define BM_DMA_HRS_HRS15      (0x00008000U)  //!< Bit mask for DMA_HRS_HRS15.
#define BS_DMA_HRS_HRS15      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS15.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS15 field.
#define BR_DMA_HRS_HRS15()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS15))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS15.
#define BF_DMA_HRS_HRS15(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS15), uint32_t) & BM_DMA_HRS_HRS15)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS15 field to a new value.
#define BW_DMA_HRS_HRS15(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS15) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS16[16] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS16      (16U)      //!< Bit position for DMA_HRS_HRS16.
#define BM_DMA_HRS_HRS16      (0x00010000U)  //!< Bit mask for DMA_HRS_HRS16.
#define BS_DMA_HRS_HRS16      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS16.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS16 field.
#define BR_DMA_HRS_HRS16()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS16))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS16.
#define BF_DMA_HRS_HRS16(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS16), uint32_t) & BM_DMA_HRS_HRS16)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS16 field to a new value.
#define BW_DMA_HRS_HRS16(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS16) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS17[17] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS17      (17U)      //!< Bit position for DMA_HRS_HRS17.
#define BM_DMA_HRS_HRS17      (0x00020000U)  //!< Bit mask for DMA_HRS_HRS17.
#define BS_DMA_HRS_HRS17      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS17.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS17 field.
#define BR_DMA_HRS_HRS17()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS17))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS17.
#define BF_DMA_HRS_HRS17(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS17), uint32_t) & BM_DMA_HRS_HRS17)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS17 field to a new value.
#define BW_DMA_HRS_HRS17(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS17) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS18[18] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS18      (18U)      //!< Bit position for DMA_HRS_HRS18.
#define BM_DMA_HRS_HRS18      (0x00040000U)  //!< Bit mask for DMA_HRS_HRS18.
#define BS_DMA_HRS_HRS18      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS18.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS18 field.
#define BR_DMA_HRS_HRS18()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS18))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS18.
#define BF_DMA_HRS_HRS18(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS18), uint32_t) & BM_DMA_HRS_HRS18)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS18 field to a new value.
#define BW_DMA_HRS_HRS18(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS18) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS19[19] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS19      (19U)      //!< Bit position for DMA_HRS_HRS19.
#define BM_DMA_HRS_HRS19      (0x00080000U)  //!< Bit mask for DMA_HRS_HRS19.
#define BS_DMA_HRS_HRS19      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS19.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS19 field.
#define BR_DMA_HRS_HRS19()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS19))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS19.
#define BF_DMA_HRS_HRS19(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS19), uint32_t) & BM_DMA_HRS_HRS19)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS19 field to a new value.
#define BW_DMA_HRS_HRS19(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS19) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS20[20] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS20      (20U)      //!< Bit position for DMA_HRS_HRS20.
#define BM_DMA_HRS_HRS20      (0x00100000U)  //!< Bit mask for DMA_HRS_HRS20.
#define BS_DMA_HRS_HRS20      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS20.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS20 field.
#define BR_DMA_HRS_HRS20()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS20))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS20.
#define BF_DMA_HRS_HRS20(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS20), uint32_t) & BM_DMA_HRS_HRS20)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS20 field to a new value.
#define BW_DMA_HRS_HRS20(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS20) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS21[21] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS21      (21U)      //!< Bit position for DMA_HRS_HRS21.
#define BM_DMA_HRS_HRS21      (0x00200000U)  //!< Bit mask for DMA_HRS_HRS21.
#define BS_DMA_HRS_HRS21      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS21.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS21 field.
#define BR_DMA_HRS_HRS21()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS21))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS21.
#define BF_DMA_HRS_HRS21(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS21), uint32_t) & BM_DMA_HRS_HRS21)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS21 field to a new value.
#define BW_DMA_HRS_HRS21(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS21) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS22[22] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS22      (22U)      //!< Bit position for DMA_HRS_HRS22.
#define BM_DMA_HRS_HRS22      (0x00400000U)  //!< Bit mask for DMA_HRS_HRS22.
#define BS_DMA_HRS_HRS22      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS22.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS22 field.
#define BR_DMA_HRS_HRS22()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS22))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS22.
#define BF_DMA_HRS_HRS22(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS22), uint32_t) & BM_DMA_HRS_HRS22)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS22 field to a new value.
#define BW_DMA_HRS_HRS22(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS22) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS23[23] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS23      (23U)      //!< Bit position for DMA_HRS_HRS23.
#define BM_DMA_HRS_HRS23      (0x00800000U)  //!< Bit mask for DMA_HRS_HRS23.
#define BS_DMA_HRS_HRS23      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS23.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS23 field.
#define BR_DMA_HRS_HRS23()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS23))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS23.
#define BF_DMA_HRS_HRS23(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS23), uint32_t) & BM_DMA_HRS_HRS23)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS23 field to a new value.
#define BW_DMA_HRS_HRS23(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS23) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS24[24] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS24      (24U)      //!< Bit position for DMA_HRS_HRS24.
#define BM_DMA_HRS_HRS24      (0x01000000U)  //!< Bit mask for DMA_HRS_HRS24.
#define BS_DMA_HRS_HRS24      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS24.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS24 field.
#define BR_DMA_HRS_HRS24()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS24))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS24.
#define BF_DMA_HRS_HRS24(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS24), uint32_t) & BM_DMA_HRS_HRS24)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS24 field to a new value.
#define BW_DMA_HRS_HRS24(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS24) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS25[25] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS25      (25U)      //!< Bit position for DMA_HRS_HRS25.
#define BM_DMA_HRS_HRS25      (0x02000000U)  //!< Bit mask for DMA_HRS_HRS25.
#define BS_DMA_HRS_HRS25      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS25.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS25 field.
#define BR_DMA_HRS_HRS25()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS25))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS25.
#define BF_DMA_HRS_HRS25(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS25), uint32_t) & BM_DMA_HRS_HRS25)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS25 field to a new value.
#define BW_DMA_HRS_HRS25(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS25) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS26[26] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS26      (26U)      //!< Bit position for DMA_HRS_HRS26.
#define BM_DMA_HRS_HRS26      (0x04000000U)  //!< Bit mask for DMA_HRS_HRS26.
#define BS_DMA_HRS_HRS26      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS26.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS26 field.
#define BR_DMA_HRS_HRS26()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS26))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS26.
#define BF_DMA_HRS_HRS26(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS26), uint32_t) & BM_DMA_HRS_HRS26)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS26 field to a new value.
#define BW_DMA_HRS_HRS26(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS26) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS27[27] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS27      (27U)      //!< Bit position for DMA_HRS_HRS27.
#define BM_DMA_HRS_HRS27      (0x08000000U)  //!< Bit mask for DMA_HRS_HRS27.
#define BS_DMA_HRS_HRS27      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS27.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS27 field.
#define BR_DMA_HRS_HRS27()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS27))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS27.
#define BF_DMA_HRS_HRS27(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS27), uint32_t) & BM_DMA_HRS_HRS27)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS27 field to a new value.
#define BW_DMA_HRS_HRS27(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS27) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS28[28] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS28      (28U)      //!< Bit position for DMA_HRS_HRS28.
#define BM_DMA_HRS_HRS28      (0x10000000U)  //!< Bit mask for DMA_HRS_HRS28.
#define BS_DMA_HRS_HRS28      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS28.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS28 field.
#define BR_DMA_HRS_HRS28()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS28))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS28.
#define BF_DMA_HRS_HRS28(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS28), uint32_t) & BM_DMA_HRS_HRS28)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS28 field to a new value.
#define BW_DMA_HRS_HRS28(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS28) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS29[29] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS29      (29U)      //!< Bit position for DMA_HRS_HRS29.
#define BM_DMA_HRS_HRS29      (0x20000000U)  //!< Bit mask for DMA_HRS_HRS29.
#define BS_DMA_HRS_HRS29      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS29.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS29 field.
#define BR_DMA_HRS_HRS29()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS29))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS29.
#define BF_DMA_HRS_HRS29(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS29), uint32_t) & BM_DMA_HRS_HRS29)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS29 field to a new value.
#define BW_DMA_HRS_HRS29(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS29) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS30[30] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS30      (30U)      //!< Bit position for DMA_HRS_HRS30.
#define BM_DMA_HRS_HRS30      (0x40000000U)  //!< Bit mask for DMA_HRS_HRS30.
#define BS_DMA_HRS_HRS30      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS30.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS30 field.
#define BR_DMA_HRS_HRS30()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS30))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS30.
#define BF_DMA_HRS_HRS30(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS30), uint32_t) & BM_DMA_HRS_HRS30)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS30 field to a new value.
#define BW_DMA_HRS_HRS30(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS30) = (v))
#endif
//@}

/*! @name Register DMA_HRS, field HRS31[31] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
//@{
#define BP_DMA_HRS_HRS31      (31U)      //!< Bit position for DMA_HRS_HRS31.
#define BM_DMA_HRS_HRS31      (0x80000000U)  //!< Bit mask for DMA_HRS_HRS31.
#define BS_DMA_HRS_HRS31      (1U)  //!< Bitfield size in bits for DMA_HRS_HRS31.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_HRS_HRS31 field.
#define BR_DMA_HRS_HRS31()   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS31))
#endif

//! @brief Format value for bitfield DMA_HRS_HRS31.
#define BF_DMA_HRS_HRS31(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_HRS_HRS31), uint32_t) & BM_DMA_HRS_HRS31)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HRS31 field to a new value.
#define BW_DMA_HRS_HRS31(v)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR, BP_DMA_HRS_HRS31) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI3 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI3 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri3
{
    uint8_t U;
    struct _hw_dma_dchpri3_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri3_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI3 register
 */
//@{
#define HW_DMA_DCHPRI3_ADDR      (REGS_DMA_BASE + 0x100U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI3           (*(__IO hw_dma_dchpri3_t *) HW_DMA_DCHPRI3_ADDR)
#define HW_DMA_DCHPRI3_RD()      (HW_DMA_DCHPRI3.U)
#define HW_DMA_DCHPRI3_WR(v)     (HW_DMA_DCHPRI3.U = (v))
#define HW_DMA_DCHPRI3_SET(v)    (HW_DMA_DCHPRI3_WR(HW_DMA_DCHPRI3_RD() |  (v)))
#define HW_DMA_DCHPRI3_CLR(v)    (HW_DMA_DCHPRI3_WR(HW_DMA_DCHPRI3_RD() & ~(v)))
#define HW_DMA_DCHPRI3_TOG(v)    (HW_DMA_DCHPRI3_WR(HW_DMA_DCHPRI3_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI3 bitfields
 */

/*! @name Register DMA_DCHPRI3, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI3_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI3_CHPRI.
#define BM_DMA_DCHPRI3_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI3_CHPRI.
#define BS_DMA_DCHPRI3_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI3_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI3_CHPRI field.
#define BR_DMA_DCHPRI3_CHPRI()   (HW_DMA_DCHPRI3.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI3_CHPRI.
#define BF_DMA_DCHPRI3_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI3_CHPRI), uint8_t) & BM_DMA_DCHPRI3_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI3_CHPRI(v)   (HW_DMA_DCHPRI3_WR((HW_DMA_DCHPRI3_RD() & ~BM_DMA_DCHPRI3_CHPRI) | BF_DMA_DCHPRI3_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI3, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI3_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI3_GRPPRI.
#define BM_DMA_DCHPRI3_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI3_GRPPRI.
#define BS_DMA_DCHPRI3_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI3_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI3_GRPPRI field.
#define BR_DMA_DCHPRI3_GRPPRI()   (HW_DMA_DCHPRI3.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI3, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI3_DPA      (6U)      //!< Bit position for DMA_DCHPRI3_DPA.
#define BM_DMA_DCHPRI3_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI3_DPA.
#define BS_DMA_DCHPRI3_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI3_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI3_DPA field.
#define BR_DMA_DCHPRI3_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI3_ADDR, BP_DMA_DCHPRI3_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI3_DPA.
#define BF_DMA_DCHPRI3_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI3_DPA), uint8_t) & BM_DMA_DCHPRI3_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI3_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI3_ADDR, BP_DMA_DCHPRI3_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI3, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI3_ECP      (7U)      //!< Bit position for DMA_DCHPRI3_ECP.
#define BM_DMA_DCHPRI3_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI3_ECP.
#define BS_DMA_DCHPRI3_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI3_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI3_ECP field.
#define BR_DMA_DCHPRI3_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI3_ADDR, BP_DMA_DCHPRI3_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI3_ECP.
#define BF_DMA_DCHPRI3_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI3_ECP), uint8_t) & BM_DMA_DCHPRI3_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI3_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI3_ADDR, BP_DMA_DCHPRI3_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI2 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI2 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri2
{
    uint8_t U;
    struct _hw_dma_dchpri2_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri2_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI2 register
 */
//@{
#define HW_DMA_DCHPRI2_ADDR      (REGS_DMA_BASE + 0x101U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI2           (*(__IO hw_dma_dchpri2_t *) HW_DMA_DCHPRI2_ADDR)
#define HW_DMA_DCHPRI2_RD()      (HW_DMA_DCHPRI2.U)
#define HW_DMA_DCHPRI2_WR(v)     (HW_DMA_DCHPRI2.U = (v))
#define HW_DMA_DCHPRI2_SET(v)    (HW_DMA_DCHPRI2_WR(HW_DMA_DCHPRI2_RD() |  (v)))
#define HW_DMA_DCHPRI2_CLR(v)    (HW_DMA_DCHPRI2_WR(HW_DMA_DCHPRI2_RD() & ~(v)))
#define HW_DMA_DCHPRI2_TOG(v)    (HW_DMA_DCHPRI2_WR(HW_DMA_DCHPRI2_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI2 bitfields
 */

/*! @name Register DMA_DCHPRI2, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI2_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI2_CHPRI.
#define BM_DMA_DCHPRI2_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI2_CHPRI.
#define BS_DMA_DCHPRI2_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI2_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI2_CHPRI field.
#define BR_DMA_DCHPRI2_CHPRI()   (HW_DMA_DCHPRI2.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI2_CHPRI.
#define BF_DMA_DCHPRI2_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI2_CHPRI), uint8_t) & BM_DMA_DCHPRI2_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI2_CHPRI(v)   (HW_DMA_DCHPRI2_WR((HW_DMA_DCHPRI2_RD() & ~BM_DMA_DCHPRI2_CHPRI) | BF_DMA_DCHPRI2_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI2, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI2_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI2_GRPPRI.
#define BM_DMA_DCHPRI2_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI2_GRPPRI.
#define BS_DMA_DCHPRI2_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI2_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI2_GRPPRI field.
#define BR_DMA_DCHPRI2_GRPPRI()   (HW_DMA_DCHPRI2.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI2, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI2_DPA      (6U)      //!< Bit position for DMA_DCHPRI2_DPA.
#define BM_DMA_DCHPRI2_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI2_DPA.
#define BS_DMA_DCHPRI2_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI2_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI2_DPA field.
#define BR_DMA_DCHPRI2_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI2_ADDR, BP_DMA_DCHPRI2_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI2_DPA.
#define BF_DMA_DCHPRI2_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI2_DPA), uint8_t) & BM_DMA_DCHPRI2_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI2_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI2_ADDR, BP_DMA_DCHPRI2_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI2, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI2_ECP      (7U)      //!< Bit position for DMA_DCHPRI2_ECP.
#define BM_DMA_DCHPRI2_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI2_ECP.
#define BS_DMA_DCHPRI2_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI2_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI2_ECP field.
#define BR_DMA_DCHPRI2_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI2_ADDR, BP_DMA_DCHPRI2_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI2_ECP.
#define BF_DMA_DCHPRI2_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI2_ECP), uint8_t) & BM_DMA_DCHPRI2_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI2_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI2_ADDR, BP_DMA_DCHPRI2_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI1 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI1 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri1
{
    uint8_t U;
    struct _hw_dma_dchpri1_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri1_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI1 register
 */
//@{
#define HW_DMA_DCHPRI1_ADDR      (REGS_DMA_BASE + 0x102U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI1           (*(__IO hw_dma_dchpri1_t *) HW_DMA_DCHPRI1_ADDR)
#define HW_DMA_DCHPRI1_RD()      (HW_DMA_DCHPRI1.U)
#define HW_DMA_DCHPRI1_WR(v)     (HW_DMA_DCHPRI1.U = (v))
#define HW_DMA_DCHPRI1_SET(v)    (HW_DMA_DCHPRI1_WR(HW_DMA_DCHPRI1_RD() |  (v)))
#define HW_DMA_DCHPRI1_CLR(v)    (HW_DMA_DCHPRI1_WR(HW_DMA_DCHPRI1_RD() & ~(v)))
#define HW_DMA_DCHPRI1_TOG(v)    (HW_DMA_DCHPRI1_WR(HW_DMA_DCHPRI1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI1 bitfields
 */

/*! @name Register DMA_DCHPRI1, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI1_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI1_CHPRI.
#define BM_DMA_DCHPRI1_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI1_CHPRI.
#define BS_DMA_DCHPRI1_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI1_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI1_CHPRI field.
#define BR_DMA_DCHPRI1_CHPRI()   (HW_DMA_DCHPRI1.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI1_CHPRI.
#define BF_DMA_DCHPRI1_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI1_CHPRI), uint8_t) & BM_DMA_DCHPRI1_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI1_CHPRI(v)   (HW_DMA_DCHPRI1_WR((HW_DMA_DCHPRI1_RD() & ~BM_DMA_DCHPRI1_CHPRI) | BF_DMA_DCHPRI1_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI1, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI1_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI1_GRPPRI.
#define BM_DMA_DCHPRI1_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI1_GRPPRI.
#define BS_DMA_DCHPRI1_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI1_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI1_GRPPRI field.
#define BR_DMA_DCHPRI1_GRPPRI()   (HW_DMA_DCHPRI1.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI1, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI1_DPA      (6U)      //!< Bit position for DMA_DCHPRI1_DPA.
#define BM_DMA_DCHPRI1_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI1_DPA.
#define BS_DMA_DCHPRI1_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI1_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI1_DPA field.
#define BR_DMA_DCHPRI1_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI1_ADDR, BP_DMA_DCHPRI1_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI1_DPA.
#define BF_DMA_DCHPRI1_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI1_DPA), uint8_t) & BM_DMA_DCHPRI1_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI1_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI1_ADDR, BP_DMA_DCHPRI1_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI1, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI1_ECP      (7U)      //!< Bit position for DMA_DCHPRI1_ECP.
#define BM_DMA_DCHPRI1_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI1_ECP.
#define BS_DMA_DCHPRI1_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI1_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI1_ECP field.
#define BR_DMA_DCHPRI1_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI1_ADDR, BP_DMA_DCHPRI1_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI1_ECP.
#define BF_DMA_DCHPRI1_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI1_ECP), uint8_t) & BM_DMA_DCHPRI1_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI1_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI1_ADDR, BP_DMA_DCHPRI1_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI0 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI0 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri0
{
    uint8_t U;
    struct _hw_dma_dchpri0_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri0_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI0 register
 */
//@{
#define HW_DMA_DCHPRI0_ADDR      (REGS_DMA_BASE + 0x103U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI0           (*(__IO hw_dma_dchpri0_t *) HW_DMA_DCHPRI0_ADDR)
#define HW_DMA_DCHPRI0_RD()      (HW_DMA_DCHPRI0.U)
#define HW_DMA_DCHPRI0_WR(v)     (HW_DMA_DCHPRI0.U = (v))
#define HW_DMA_DCHPRI0_SET(v)    (HW_DMA_DCHPRI0_WR(HW_DMA_DCHPRI0_RD() |  (v)))
#define HW_DMA_DCHPRI0_CLR(v)    (HW_DMA_DCHPRI0_WR(HW_DMA_DCHPRI0_RD() & ~(v)))
#define HW_DMA_DCHPRI0_TOG(v)    (HW_DMA_DCHPRI0_WR(HW_DMA_DCHPRI0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI0 bitfields
 */

/*! @name Register DMA_DCHPRI0, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI0_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI0_CHPRI.
#define BM_DMA_DCHPRI0_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI0_CHPRI.
#define BS_DMA_DCHPRI0_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI0_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI0_CHPRI field.
#define BR_DMA_DCHPRI0_CHPRI()   (HW_DMA_DCHPRI0.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI0_CHPRI.
#define BF_DMA_DCHPRI0_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI0_CHPRI), uint8_t) & BM_DMA_DCHPRI0_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI0_CHPRI(v)   (HW_DMA_DCHPRI0_WR((HW_DMA_DCHPRI0_RD() & ~BM_DMA_DCHPRI0_CHPRI) | BF_DMA_DCHPRI0_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI0, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI0_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI0_GRPPRI.
#define BM_DMA_DCHPRI0_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI0_GRPPRI.
#define BS_DMA_DCHPRI0_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI0_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI0_GRPPRI field.
#define BR_DMA_DCHPRI0_GRPPRI()   (HW_DMA_DCHPRI0.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI0, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI0_DPA      (6U)      //!< Bit position for DMA_DCHPRI0_DPA.
#define BM_DMA_DCHPRI0_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI0_DPA.
#define BS_DMA_DCHPRI0_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI0_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI0_DPA field.
#define BR_DMA_DCHPRI0_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI0_ADDR, BP_DMA_DCHPRI0_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI0_DPA.
#define BF_DMA_DCHPRI0_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI0_DPA), uint8_t) & BM_DMA_DCHPRI0_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI0_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI0_ADDR, BP_DMA_DCHPRI0_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI0, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI0_ECP      (7U)      //!< Bit position for DMA_DCHPRI0_ECP.
#define BM_DMA_DCHPRI0_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI0_ECP.
#define BS_DMA_DCHPRI0_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI0_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI0_ECP field.
#define BR_DMA_DCHPRI0_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI0_ADDR, BP_DMA_DCHPRI0_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI0_ECP.
#define BF_DMA_DCHPRI0_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI0_ECP), uint8_t) & BM_DMA_DCHPRI0_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI0_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI0_ADDR, BP_DMA_DCHPRI0_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI7 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI7 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri7
{
    uint8_t U;
    struct _hw_dma_dchpri7_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri7_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI7 register
 */
//@{
#define HW_DMA_DCHPRI7_ADDR      (REGS_DMA_BASE + 0x104U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI7           (*(__IO hw_dma_dchpri7_t *) HW_DMA_DCHPRI7_ADDR)
#define HW_DMA_DCHPRI7_RD()      (HW_DMA_DCHPRI7.U)
#define HW_DMA_DCHPRI7_WR(v)     (HW_DMA_DCHPRI7.U = (v))
#define HW_DMA_DCHPRI7_SET(v)    (HW_DMA_DCHPRI7_WR(HW_DMA_DCHPRI7_RD() |  (v)))
#define HW_DMA_DCHPRI7_CLR(v)    (HW_DMA_DCHPRI7_WR(HW_DMA_DCHPRI7_RD() & ~(v)))
#define HW_DMA_DCHPRI7_TOG(v)    (HW_DMA_DCHPRI7_WR(HW_DMA_DCHPRI7_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI7 bitfields
 */

/*! @name Register DMA_DCHPRI7, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI7_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI7_CHPRI.
#define BM_DMA_DCHPRI7_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI7_CHPRI.
#define BS_DMA_DCHPRI7_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI7_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI7_CHPRI field.
#define BR_DMA_DCHPRI7_CHPRI()   (HW_DMA_DCHPRI7.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI7_CHPRI.
#define BF_DMA_DCHPRI7_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI7_CHPRI), uint8_t) & BM_DMA_DCHPRI7_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI7_CHPRI(v)   (HW_DMA_DCHPRI7_WR((HW_DMA_DCHPRI7_RD() & ~BM_DMA_DCHPRI7_CHPRI) | BF_DMA_DCHPRI7_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI7, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI7_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI7_GRPPRI.
#define BM_DMA_DCHPRI7_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI7_GRPPRI.
#define BS_DMA_DCHPRI7_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI7_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI7_GRPPRI field.
#define BR_DMA_DCHPRI7_GRPPRI()   (HW_DMA_DCHPRI7.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI7, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI7_DPA      (6U)      //!< Bit position for DMA_DCHPRI7_DPA.
#define BM_DMA_DCHPRI7_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI7_DPA.
#define BS_DMA_DCHPRI7_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI7_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI7_DPA field.
#define BR_DMA_DCHPRI7_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI7_ADDR, BP_DMA_DCHPRI7_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI7_DPA.
#define BF_DMA_DCHPRI7_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI7_DPA), uint8_t) & BM_DMA_DCHPRI7_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI7_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI7_ADDR, BP_DMA_DCHPRI7_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI7, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI7_ECP      (7U)      //!< Bit position for DMA_DCHPRI7_ECP.
#define BM_DMA_DCHPRI7_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI7_ECP.
#define BS_DMA_DCHPRI7_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI7_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI7_ECP field.
#define BR_DMA_DCHPRI7_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI7_ADDR, BP_DMA_DCHPRI7_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI7_ECP.
#define BF_DMA_DCHPRI7_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI7_ECP), uint8_t) & BM_DMA_DCHPRI7_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI7_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI7_ADDR, BP_DMA_DCHPRI7_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI6 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI6 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri6
{
    uint8_t U;
    struct _hw_dma_dchpri6_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri6_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI6 register
 */
//@{
#define HW_DMA_DCHPRI6_ADDR      (REGS_DMA_BASE + 0x105U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI6           (*(__IO hw_dma_dchpri6_t *) HW_DMA_DCHPRI6_ADDR)
#define HW_DMA_DCHPRI6_RD()      (HW_DMA_DCHPRI6.U)
#define HW_DMA_DCHPRI6_WR(v)     (HW_DMA_DCHPRI6.U = (v))
#define HW_DMA_DCHPRI6_SET(v)    (HW_DMA_DCHPRI6_WR(HW_DMA_DCHPRI6_RD() |  (v)))
#define HW_DMA_DCHPRI6_CLR(v)    (HW_DMA_DCHPRI6_WR(HW_DMA_DCHPRI6_RD() & ~(v)))
#define HW_DMA_DCHPRI6_TOG(v)    (HW_DMA_DCHPRI6_WR(HW_DMA_DCHPRI6_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI6 bitfields
 */

/*! @name Register DMA_DCHPRI6, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI6_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI6_CHPRI.
#define BM_DMA_DCHPRI6_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI6_CHPRI.
#define BS_DMA_DCHPRI6_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI6_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI6_CHPRI field.
#define BR_DMA_DCHPRI6_CHPRI()   (HW_DMA_DCHPRI6.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI6_CHPRI.
#define BF_DMA_DCHPRI6_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI6_CHPRI), uint8_t) & BM_DMA_DCHPRI6_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI6_CHPRI(v)   (HW_DMA_DCHPRI6_WR((HW_DMA_DCHPRI6_RD() & ~BM_DMA_DCHPRI6_CHPRI) | BF_DMA_DCHPRI6_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI6, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI6_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI6_GRPPRI.
#define BM_DMA_DCHPRI6_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI6_GRPPRI.
#define BS_DMA_DCHPRI6_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI6_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI6_GRPPRI field.
#define BR_DMA_DCHPRI6_GRPPRI()   (HW_DMA_DCHPRI6.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI6, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI6_DPA      (6U)      //!< Bit position for DMA_DCHPRI6_DPA.
#define BM_DMA_DCHPRI6_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI6_DPA.
#define BS_DMA_DCHPRI6_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI6_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI6_DPA field.
#define BR_DMA_DCHPRI6_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI6_ADDR, BP_DMA_DCHPRI6_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI6_DPA.
#define BF_DMA_DCHPRI6_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI6_DPA), uint8_t) & BM_DMA_DCHPRI6_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI6_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI6_ADDR, BP_DMA_DCHPRI6_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI6, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI6_ECP      (7U)      //!< Bit position for DMA_DCHPRI6_ECP.
#define BM_DMA_DCHPRI6_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI6_ECP.
#define BS_DMA_DCHPRI6_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI6_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI6_ECP field.
#define BR_DMA_DCHPRI6_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI6_ADDR, BP_DMA_DCHPRI6_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI6_ECP.
#define BF_DMA_DCHPRI6_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI6_ECP), uint8_t) & BM_DMA_DCHPRI6_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI6_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI6_ADDR, BP_DMA_DCHPRI6_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI5 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI5 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri5
{
    uint8_t U;
    struct _hw_dma_dchpri5_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri5_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI5 register
 */
//@{
#define HW_DMA_DCHPRI5_ADDR      (REGS_DMA_BASE + 0x106U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI5           (*(__IO hw_dma_dchpri5_t *) HW_DMA_DCHPRI5_ADDR)
#define HW_DMA_DCHPRI5_RD()      (HW_DMA_DCHPRI5.U)
#define HW_DMA_DCHPRI5_WR(v)     (HW_DMA_DCHPRI5.U = (v))
#define HW_DMA_DCHPRI5_SET(v)    (HW_DMA_DCHPRI5_WR(HW_DMA_DCHPRI5_RD() |  (v)))
#define HW_DMA_DCHPRI5_CLR(v)    (HW_DMA_DCHPRI5_WR(HW_DMA_DCHPRI5_RD() & ~(v)))
#define HW_DMA_DCHPRI5_TOG(v)    (HW_DMA_DCHPRI5_WR(HW_DMA_DCHPRI5_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI5 bitfields
 */

/*! @name Register DMA_DCHPRI5, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI5_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI5_CHPRI.
#define BM_DMA_DCHPRI5_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI5_CHPRI.
#define BS_DMA_DCHPRI5_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI5_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI5_CHPRI field.
#define BR_DMA_DCHPRI5_CHPRI()   (HW_DMA_DCHPRI5.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI5_CHPRI.
#define BF_DMA_DCHPRI5_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI5_CHPRI), uint8_t) & BM_DMA_DCHPRI5_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI5_CHPRI(v)   (HW_DMA_DCHPRI5_WR((HW_DMA_DCHPRI5_RD() & ~BM_DMA_DCHPRI5_CHPRI) | BF_DMA_DCHPRI5_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI5, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI5_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI5_GRPPRI.
#define BM_DMA_DCHPRI5_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI5_GRPPRI.
#define BS_DMA_DCHPRI5_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI5_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI5_GRPPRI field.
#define BR_DMA_DCHPRI5_GRPPRI()   (HW_DMA_DCHPRI5.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI5, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI5_DPA      (6U)      //!< Bit position for DMA_DCHPRI5_DPA.
#define BM_DMA_DCHPRI5_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI5_DPA.
#define BS_DMA_DCHPRI5_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI5_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI5_DPA field.
#define BR_DMA_DCHPRI5_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI5_ADDR, BP_DMA_DCHPRI5_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI5_DPA.
#define BF_DMA_DCHPRI5_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI5_DPA), uint8_t) & BM_DMA_DCHPRI5_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI5_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI5_ADDR, BP_DMA_DCHPRI5_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI5, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI5_ECP      (7U)      //!< Bit position for DMA_DCHPRI5_ECP.
#define BM_DMA_DCHPRI5_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI5_ECP.
#define BS_DMA_DCHPRI5_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI5_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI5_ECP field.
#define BR_DMA_DCHPRI5_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI5_ADDR, BP_DMA_DCHPRI5_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI5_ECP.
#define BF_DMA_DCHPRI5_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI5_ECP), uint8_t) & BM_DMA_DCHPRI5_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI5_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI5_ADDR, BP_DMA_DCHPRI5_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI4 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI4 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri4
{
    uint8_t U;
    struct _hw_dma_dchpri4_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri4_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI4 register
 */
//@{
#define HW_DMA_DCHPRI4_ADDR      (REGS_DMA_BASE + 0x107U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI4           (*(__IO hw_dma_dchpri4_t *) HW_DMA_DCHPRI4_ADDR)
#define HW_DMA_DCHPRI4_RD()      (HW_DMA_DCHPRI4.U)
#define HW_DMA_DCHPRI4_WR(v)     (HW_DMA_DCHPRI4.U = (v))
#define HW_DMA_DCHPRI4_SET(v)    (HW_DMA_DCHPRI4_WR(HW_DMA_DCHPRI4_RD() |  (v)))
#define HW_DMA_DCHPRI4_CLR(v)    (HW_DMA_DCHPRI4_WR(HW_DMA_DCHPRI4_RD() & ~(v)))
#define HW_DMA_DCHPRI4_TOG(v)    (HW_DMA_DCHPRI4_WR(HW_DMA_DCHPRI4_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI4 bitfields
 */

/*! @name Register DMA_DCHPRI4, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI4_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI4_CHPRI.
#define BM_DMA_DCHPRI4_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI4_CHPRI.
#define BS_DMA_DCHPRI4_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI4_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI4_CHPRI field.
#define BR_DMA_DCHPRI4_CHPRI()   (HW_DMA_DCHPRI4.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI4_CHPRI.
#define BF_DMA_DCHPRI4_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI4_CHPRI), uint8_t) & BM_DMA_DCHPRI4_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI4_CHPRI(v)   (HW_DMA_DCHPRI4_WR((HW_DMA_DCHPRI4_RD() & ~BM_DMA_DCHPRI4_CHPRI) | BF_DMA_DCHPRI4_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI4, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI4_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI4_GRPPRI.
#define BM_DMA_DCHPRI4_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI4_GRPPRI.
#define BS_DMA_DCHPRI4_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI4_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI4_GRPPRI field.
#define BR_DMA_DCHPRI4_GRPPRI()   (HW_DMA_DCHPRI4.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI4, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI4_DPA      (6U)      //!< Bit position for DMA_DCHPRI4_DPA.
#define BM_DMA_DCHPRI4_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI4_DPA.
#define BS_DMA_DCHPRI4_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI4_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI4_DPA field.
#define BR_DMA_DCHPRI4_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI4_ADDR, BP_DMA_DCHPRI4_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI4_DPA.
#define BF_DMA_DCHPRI4_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI4_DPA), uint8_t) & BM_DMA_DCHPRI4_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI4_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI4_ADDR, BP_DMA_DCHPRI4_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI4, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI4_ECP      (7U)      //!< Bit position for DMA_DCHPRI4_ECP.
#define BM_DMA_DCHPRI4_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI4_ECP.
#define BS_DMA_DCHPRI4_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI4_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI4_ECP field.
#define BR_DMA_DCHPRI4_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI4_ADDR, BP_DMA_DCHPRI4_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI4_ECP.
#define BF_DMA_DCHPRI4_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI4_ECP), uint8_t) & BM_DMA_DCHPRI4_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI4_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI4_ADDR, BP_DMA_DCHPRI4_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI11 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI11 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri11
{
    uint8_t U;
    struct _hw_dma_dchpri11_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri11_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI11 register
 */
//@{
#define HW_DMA_DCHPRI11_ADDR      (REGS_DMA_BASE + 0x108U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI11           (*(__IO hw_dma_dchpri11_t *) HW_DMA_DCHPRI11_ADDR)
#define HW_DMA_DCHPRI11_RD()      (HW_DMA_DCHPRI11.U)
#define HW_DMA_DCHPRI11_WR(v)     (HW_DMA_DCHPRI11.U = (v))
#define HW_DMA_DCHPRI11_SET(v)    (HW_DMA_DCHPRI11_WR(HW_DMA_DCHPRI11_RD() |  (v)))
#define HW_DMA_DCHPRI11_CLR(v)    (HW_DMA_DCHPRI11_WR(HW_DMA_DCHPRI11_RD() & ~(v)))
#define HW_DMA_DCHPRI11_TOG(v)    (HW_DMA_DCHPRI11_WR(HW_DMA_DCHPRI11_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI11 bitfields
 */

/*! @name Register DMA_DCHPRI11, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI11_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI11_CHPRI.
#define BM_DMA_DCHPRI11_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI11_CHPRI.
#define BS_DMA_DCHPRI11_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI11_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI11_CHPRI field.
#define BR_DMA_DCHPRI11_CHPRI()   (HW_DMA_DCHPRI11.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI11_CHPRI.
#define BF_DMA_DCHPRI11_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI11_CHPRI), uint8_t) & BM_DMA_DCHPRI11_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI11_CHPRI(v)   (HW_DMA_DCHPRI11_WR((HW_DMA_DCHPRI11_RD() & ~BM_DMA_DCHPRI11_CHPRI) | BF_DMA_DCHPRI11_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI11, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI11_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI11_GRPPRI.
#define BM_DMA_DCHPRI11_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI11_GRPPRI.
#define BS_DMA_DCHPRI11_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI11_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI11_GRPPRI field.
#define BR_DMA_DCHPRI11_GRPPRI()   (HW_DMA_DCHPRI11.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI11, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI11_DPA      (6U)      //!< Bit position for DMA_DCHPRI11_DPA.
#define BM_DMA_DCHPRI11_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI11_DPA.
#define BS_DMA_DCHPRI11_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI11_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI11_DPA field.
#define BR_DMA_DCHPRI11_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI11_ADDR, BP_DMA_DCHPRI11_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI11_DPA.
#define BF_DMA_DCHPRI11_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI11_DPA), uint8_t) & BM_DMA_DCHPRI11_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI11_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI11_ADDR, BP_DMA_DCHPRI11_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI11, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI11_ECP      (7U)      //!< Bit position for DMA_DCHPRI11_ECP.
#define BM_DMA_DCHPRI11_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI11_ECP.
#define BS_DMA_DCHPRI11_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI11_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI11_ECP field.
#define BR_DMA_DCHPRI11_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI11_ADDR, BP_DMA_DCHPRI11_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI11_ECP.
#define BF_DMA_DCHPRI11_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI11_ECP), uint8_t) & BM_DMA_DCHPRI11_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI11_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI11_ADDR, BP_DMA_DCHPRI11_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI10 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI10 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri10
{
    uint8_t U;
    struct _hw_dma_dchpri10_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri10_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI10 register
 */
//@{
#define HW_DMA_DCHPRI10_ADDR      (REGS_DMA_BASE + 0x109U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI10           (*(__IO hw_dma_dchpri10_t *) HW_DMA_DCHPRI10_ADDR)
#define HW_DMA_DCHPRI10_RD()      (HW_DMA_DCHPRI10.U)
#define HW_DMA_DCHPRI10_WR(v)     (HW_DMA_DCHPRI10.U = (v))
#define HW_DMA_DCHPRI10_SET(v)    (HW_DMA_DCHPRI10_WR(HW_DMA_DCHPRI10_RD() |  (v)))
#define HW_DMA_DCHPRI10_CLR(v)    (HW_DMA_DCHPRI10_WR(HW_DMA_DCHPRI10_RD() & ~(v)))
#define HW_DMA_DCHPRI10_TOG(v)    (HW_DMA_DCHPRI10_WR(HW_DMA_DCHPRI10_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI10 bitfields
 */

/*! @name Register DMA_DCHPRI10, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI10_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI10_CHPRI.
#define BM_DMA_DCHPRI10_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI10_CHPRI.
#define BS_DMA_DCHPRI10_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI10_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI10_CHPRI field.
#define BR_DMA_DCHPRI10_CHPRI()   (HW_DMA_DCHPRI10.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI10_CHPRI.
#define BF_DMA_DCHPRI10_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI10_CHPRI), uint8_t) & BM_DMA_DCHPRI10_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI10_CHPRI(v)   (HW_DMA_DCHPRI10_WR((HW_DMA_DCHPRI10_RD() & ~BM_DMA_DCHPRI10_CHPRI) | BF_DMA_DCHPRI10_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI10, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI10_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI10_GRPPRI.
#define BM_DMA_DCHPRI10_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI10_GRPPRI.
#define BS_DMA_DCHPRI10_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI10_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI10_GRPPRI field.
#define BR_DMA_DCHPRI10_GRPPRI()   (HW_DMA_DCHPRI10.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI10, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI10_DPA      (6U)      //!< Bit position for DMA_DCHPRI10_DPA.
#define BM_DMA_DCHPRI10_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI10_DPA.
#define BS_DMA_DCHPRI10_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI10_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI10_DPA field.
#define BR_DMA_DCHPRI10_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI10_ADDR, BP_DMA_DCHPRI10_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI10_DPA.
#define BF_DMA_DCHPRI10_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI10_DPA), uint8_t) & BM_DMA_DCHPRI10_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI10_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI10_ADDR, BP_DMA_DCHPRI10_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI10, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI10_ECP      (7U)      //!< Bit position for DMA_DCHPRI10_ECP.
#define BM_DMA_DCHPRI10_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI10_ECP.
#define BS_DMA_DCHPRI10_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI10_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI10_ECP field.
#define BR_DMA_DCHPRI10_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI10_ADDR, BP_DMA_DCHPRI10_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI10_ECP.
#define BF_DMA_DCHPRI10_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI10_ECP), uint8_t) & BM_DMA_DCHPRI10_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI10_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI10_ADDR, BP_DMA_DCHPRI10_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI9 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI9 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri9
{
    uint8_t U;
    struct _hw_dma_dchpri9_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri9_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI9 register
 */
//@{
#define HW_DMA_DCHPRI9_ADDR      (REGS_DMA_BASE + 0x10aU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI9           (*(__IO hw_dma_dchpri9_t *) HW_DMA_DCHPRI9_ADDR)
#define HW_DMA_DCHPRI9_RD()      (HW_DMA_DCHPRI9.U)
#define HW_DMA_DCHPRI9_WR(v)     (HW_DMA_DCHPRI9.U = (v))
#define HW_DMA_DCHPRI9_SET(v)    (HW_DMA_DCHPRI9_WR(HW_DMA_DCHPRI9_RD() |  (v)))
#define HW_DMA_DCHPRI9_CLR(v)    (HW_DMA_DCHPRI9_WR(HW_DMA_DCHPRI9_RD() & ~(v)))
#define HW_DMA_DCHPRI9_TOG(v)    (HW_DMA_DCHPRI9_WR(HW_DMA_DCHPRI9_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI9 bitfields
 */

/*! @name Register DMA_DCHPRI9, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI9_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI9_CHPRI.
#define BM_DMA_DCHPRI9_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI9_CHPRI.
#define BS_DMA_DCHPRI9_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI9_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI9_CHPRI field.
#define BR_DMA_DCHPRI9_CHPRI()   (HW_DMA_DCHPRI9.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI9_CHPRI.
#define BF_DMA_DCHPRI9_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI9_CHPRI), uint8_t) & BM_DMA_DCHPRI9_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI9_CHPRI(v)   (HW_DMA_DCHPRI9_WR((HW_DMA_DCHPRI9_RD() & ~BM_DMA_DCHPRI9_CHPRI) | BF_DMA_DCHPRI9_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI9, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI9_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI9_GRPPRI.
#define BM_DMA_DCHPRI9_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI9_GRPPRI.
#define BS_DMA_DCHPRI9_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI9_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI9_GRPPRI field.
#define BR_DMA_DCHPRI9_GRPPRI()   (HW_DMA_DCHPRI9.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI9, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI9_DPA      (6U)      //!< Bit position for DMA_DCHPRI9_DPA.
#define BM_DMA_DCHPRI9_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI9_DPA.
#define BS_DMA_DCHPRI9_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI9_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI9_DPA field.
#define BR_DMA_DCHPRI9_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI9_ADDR, BP_DMA_DCHPRI9_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI9_DPA.
#define BF_DMA_DCHPRI9_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI9_DPA), uint8_t) & BM_DMA_DCHPRI9_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI9_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI9_ADDR, BP_DMA_DCHPRI9_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI9, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI9_ECP      (7U)      //!< Bit position for DMA_DCHPRI9_ECP.
#define BM_DMA_DCHPRI9_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI9_ECP.
#define BS_DMA_DCHPRI9_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI9_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI9_ECP field.
#define BR_DMA_DCHPRI9_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI9_ADDR, BP_DMA_DCHPRI9_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI9_ECP.
#define BF_DMA_DCHPRI9_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI9_ECP), uint8_t) & BM_DMA_DCHPRI9_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI9_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI9_ADDR, BP_DMA_DCHPRI9_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI8 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI8 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri8
{
    uint8_t U;
    struct _hw_dma_dchpri8_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri8_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI8 register
 */
//@{
#define HW_DMA_DCHPRI8_ADDR      (REGS_DMA_BASE + 0x10bU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI8           (*(__IO hw_dma_dchpri8_t *) HW_DMA_DCHPRI8_ADDR)
#define HW_DMA_DCHPRI8_RD()      (HW_DMA_DCHPRI8.U)
#define HW_DMA_DCHPRI8_WR(v)     (HW_DMA_DCHPRI8.U = (v))
#define HW_DMA_DCHPRI8_SET(v)    (HW_DMA_DCHPRI8_WR(HW_DMA_DCHPRI8_RD() |  (v)))
#define HW_DMA_DCHPRI8_CLR(v)    (HW_DMA_DCHPRI8_WR(HW_DMA_DCHPRI8_RD() & ~(v)))
#define HW_DMA_DCHPRI8_TOG(v)    (HW_DMA_DCHPRI8_WR(HW_DMA_DCHPRI8_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI8 bitfields
 */

/*! @name Register DMA_DCHPRI8, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI8_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI8_CHPRI.
#define BM_DMA_DCHPRI8_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI8_CHPRI.
#define BS_DMA_DCHPRI8_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI8_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI8_CHPRI field.
#define BR_DMA_DCHPRI8_CHPRI()   (HW_DMA_DCHPRI8.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI8_CHPRI.
#define BF_DMA_DCHPRI8_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI8_CHPRI), uint8_t) & BM_DMA_DCHPRI8_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI8_CHPRI(v)   (HW_DMA_DCHPRI8_WR((HW_DMA_DCHPRI8_RD() & ~BM_DMA_DCHPRI8_CHPRI) | BF_DMA_DCHPRI8_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI8, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI8_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI8_GRPPRI.
#define BM_DMA_DCHPRI8_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI8_GRPPRI.
#define BS_DMA_DCHPRI8_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI8_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI8_GRPPRI field.
#define BR_DMA_DCHPRI8_GRPPRI()   (HW_DMA_DCHPRI8.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI8, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI8_DPA      (6U)      //!< Bit position for DMA_DCHPRI8_DPA.
#define BM_DMA_DCHPRI8_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI8_DPA.
#define BS_DMA_DCHPRI8_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI8_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI8_DPA field.
#define BR_DMA_DCHPRI8_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI8_ADDR, BP_DMA_DCHPRI8_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI8_DPA.
#define BF_DMA_DCHPRI8_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI8_DPA), uint8_t) & BM_DMA_DCHPRI8_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI8_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI8_ADDR, BP_DMA_DCHPRI8_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI8, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI8_ECP      (7U)      //!< Bit position for DMA_DCHPRI8_ECP.
#define BM_DMA_DCHPRI8_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI8_ECP.
#define BS_DMA_DCHPRI8_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI8_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI8_ECP field.
#define BR_DMA_DCHPRI8_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI8_ADDR, BP_DMA_DCHPRI8_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI8_ECP.
#define BF_DMA_DCHPRI8_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI8_ECP), uint8_t) & BM_DMA_DCHPRI8_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI8_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI8_ADDR, BP_DMA_DCHPRI8_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI15 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI15 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri15
{
    uint8_t U;
    struct _hw_dma_dchpri15_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri15_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI15 register
 */
//@{
#define HW_DMA_DCHPRI15_ADDR      (REGS_DMA_BASE + 0x10cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI15           (*(__IO hw_dma_dchpri15_t *) HW_DMA_DCHPRI15_ADDR)
#define HW_DMA_DCHPRI15_RD()      (HW_DMA_DCHPRI15.U)
#define HW_DMA_DCHPRI15_WR(v)     (HW_DMA_DCHPRI15.U = (v))
#define HW_DMA_DCHPRI15_SET(v)    (HW_DMA_DCHPRI15_WR(HW_DMA_DCHPRI15_RD() |  (v)))
#define HW_DMA_DCHPRI15_CLR(v)    (HW_DMA_DCHPRI15_WR(HW_DMA_DCHPRI15_RD() & ~(v)))
#define HW_DMA_DCHPRI15_TOG(v)    (HW_DMA_DCHPRI15_WR(HW_DMA_DCHPRI15_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI15 bitfields
 */

/*! @name Register DMA_DCHPRI15, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI15_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI15_CHPRI.
#define BM_DMA_DCHPRI15_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI15_CHPRI.
#define BS_DMA_DCHPRI15_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI15_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI15_CHPRI field.
#define BR_DMA_DCHPRI15_CHPRI()   (HW_DMA_DCHPRI15.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI15_CHPRI.
#define BF_DMA_DCHPRI15_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI15_CHPRI), uint8_t) & BM_DMA_DCHPRI15_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI15_CHPRI(v)   (HW_DMA_DCHPRI15_WR((HW_DMA_DCHPRI15_RD() & ~BM_DMA_DCHPRI15_CHPRI) | BF_DMA_DCHPRI15_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI15, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI15_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI15_GRPPRI.
#define BM_DMA_DCHPRI15_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI15_GRPPRI.
#define BS_DMA_DCHPRI15_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI15_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI15_GRPPRI field.
#define BR_DMA_DCHPRI15_GRPPRI()   (HW_DMA_DCHPRI15.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI15, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI15_DPA      (6U)      //!< Bit position for DMA_DCHPRI15_DPA.
#define BM_DMA_DCHPRI15_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI15_DPA.
#define BS_DMA_DCHPRI15_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI15_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI15_DPA field.
#define BR_DMA_DCHPRI15_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI15_ADDR, BP_DMA_DCHPRI15_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI15_DPA.
#define BF_DMA_DCHPRI15_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI15_DPA), uint8_t) & BM_DMA_DCHPRI15_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI15_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI15_ADDR, BP_DMA_DCHPRI15_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI15, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI15_ECP      (7U)      //!< Bit position for DMA_DCHPRI15_ECP.
#define BM_DMA_DCHPRI15_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI15_ECP.
#define BS_DMA_DCHPRI15_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI15_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI15_ECP field.
#define BR_DMA_DCHPRI15_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI15_ADDR, BP_DMA_DCHPRI15_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI15_ECP.
#define BF_DMA_DCHPRI15_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI15_ECP), uint8_t) & BM_DMA_DCHPRI15_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI15_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI15_ADDR, BP_DMA_DCHPRI15_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI14 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI14 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri14
{
    uint8_t U;
    struct _hw_dma_dchpri14_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri14_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI14 register
 */
//@{
#define HW_DMA_DCHPRI14_ADDR      (REGS_DMA_BASE + 0x10dU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI14           (*(__IO hw_dma_dchpri14_t *) HW_DMA_DCHPRI14_ADDR)
#define HW_DMA_DCHPRI14_RD()      (HW_DMA_DCHPRI14.U)
#define HW_DMA_DCHPRI14_WR(v)     (HW_DMA_DCHPRI14.U = (v))
#define HW_DMA_DCHPRI14_SET(v)    (HW_DMA_DCHPRI14_WR(HW_DMA_DCHPRI14_RD() |  (v)))
#define HW_DMA_DCHPRI14_CLR(v)    (HW_DMA_DCHPRI14_WR(HW_DMA_DCHPRI14_RD() & ~(v)))
#define HW_DMA_DCHPRI14_TOG(v)    (HW_DMA_DCHPRI14_WR(HW_DMA_DCHPRI14_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI14 bitfields
 */

/*! @name Register DMA_DCHPRI14, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI14_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI14_CHPRI.
#define BM_DMA_DCHPRI14_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI14_CHPRI.
#define BS_DMA_DCHPRI14_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI14_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI14_CHPRI field.
#define BR_DMA_DCHPRI14_CHPRI()   (HW_DMA_DCHPRI14.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI14_CHPRI.
#define BF_DMA_DCHPRI14_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI14_CHPRI), uint8_t) & BM_DMA_DCHPRI14_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI14_CHPRI(v)   (HW_DMA_DCHPRI14_WR((HW_DMA_DCHPRI14_RD() & ~BM_DMA_DCHPRI14_CHPRI) | BF_DMA_DCHPRI14_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI14, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI14_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI14_GRPPRI.
#define BM_DMA_DCHPRI14_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI14_GRPPRI.
#define BS_DMA_DCHPRI14_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI14_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI14_GRPPRI field.
#define BR_DMA_DCHPRI14_GRPPRI()   (HW_DMA_DCHPRI14.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI14, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI14_DPA      (6U)      //!< Bit position for DMA_DCHPRI14_DPA.
#define BM_DMA_DCHPRI14_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI14_DPA.
#define BS_DMA_DCHPRI14_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI14_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI14_DPA field.
#define BR_DMA_DCHPRI14_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI14_ADDR, BP_DMA_DCHPRI14_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI14_DPA.
#define BF_DMA_DCHPRI14_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI14_DPA), uint8_t) & BM_DMA_DCHPRI14_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI14_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI14_ADDR, BP_DMA_DCHPRI14_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI14, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI14_ECP      (7U)      //!< Bit position for DMA_DCHPRI14_ECP.
#define BM_DMA_DCHPRI14_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI14_ECP.
#define BS_DMA_DCHPRI14_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI14_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI14_ECP field.
#define BR_DMA_DCHPRI14_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI14_ADDR, BP_DMA_DCHPRI14_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI14_ECP.
#define BF_DMA_DCHPRI14_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI14_ECP), uint8_t) & BM_DMA_DCHPRI14_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI14_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI14_ADDR, BP_DMA_DCHPRI14_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI13 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI13 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri13
{
    uint8_t U;
    struct _hw_dma_dchpri13_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri13_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI13 register
 */
//@{
#define HW_DMA_DCHPRI13_ADDR      (REGS_DMA_BASE + 0x10eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI13           (*(__IO hw_dma_dchpri13_t *) HW_DMA_DCHPRI13_ADDR)
#define HW_DMA_DCHPRI13_RD()      (HW_DMA_DCHPRI13.U)
#define HW_DMA_DCHPRI13_WR(v)     (HW_DMA_DCHPRI13.U = (v))
#define HW_DMA_DCHPRI13_SET(v)    (HW_DMA_DCHPRI13_WR(HW_DMA_DCHPRI13_RD() |  (v)))
#define HW_DMA_DCHPRI13_CLR(v)    (HW_DMA_DCHPRI13_WR(HW_DMA_DCHPRI13_RD() & ~(v)))
#define HW_DMA_DCHPRI13_TOG(v)    (HW_DMA_DCHPRI13_WR(HW_DMA_DCHPRI13_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI13 bitfields
 */

/*! @name Register DMA_DCHPRI13, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI13_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI13_CHPRI.
#define BM_DMA_DCHPRI13_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI13_CHPRI.
#define BS_DMA_DCHPRI13_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI13_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI13_CHPRI field.
#define BR_DMA_DCHPRI13_CHPRI()   (HW_DMA_DCHPRI13.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI13_CHPRI.
#define BF_DMA_DCHPRI13_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI13_CHPRI), uint8_t) & BM_DMA_DCHPRI13_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI13_CHPRI(v)   (HW_DMA_DCHPRI13_WR((HW_DMA_DCHPRI13_RD() & ~BM_DMA_DCHPRI13_CHPRI) | BF_DMA_DCHPRI13_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI13, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI13_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI13_GRPPRI.
#define BM_DMA_DCHPRI13_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI13_GRPPRI.
#define BS_DMA_DCHPRI13_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI13_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI13_GRPPRI field.
#define BR_DMA_DCHPRI13_GRPPRI()   (HW_DMA_DCHPRI13.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI13, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI13_DPA      (6U)      //!< Bit position for DMA_DCHPRI13_DPA.
#define BM_DMA_DCHPRI13_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI13_DPA.
#define BS_DMA_DCHPRI13_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI13_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI13_DPA field.
#define BR_DMA_DCHPRI13_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI13_ADDR, BP_DMA_DCHPRI13_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI13_DPA.
#define BF_DMA_DCHPRI13_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI13_DPA), uint8_t) & BM_DMA_DCHPRI13_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI13_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI13_ADDR, BP_DMA_DCHPRI13_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI13, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI13_ECP      (7U)      //!< Bit position for DMA_DCHPRI13_ECP.
#define BM_DMA_DCHPRI13_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI13_ECP.
#define BS_DMA_DCHPRI13_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI13_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI13_ECP field.
#define BR_DMA_DCHPRI13_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI13_ADDR, BP_DMA_DCHPRI13_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI13_ECP.
#define BF_DMA_DCHPRI13_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI13_ECP), uint8_t) & BM_DMA_DCHPRI13_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI13_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI13_ADDR, BP_DMA_DCHPRI13_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI12 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI12 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri12
{
    uint8_t U;
    struct _hw_dma_dchpri12_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri12_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI12 register
 */
//@{
#define HW_DMA_DCHPRI12_ADDR      (REGS_DMA_BASE + 0x10fU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI12           (*(__IO hw_dma_dchpri12_t *) HW_DMA_DCHPRI12_ADDR)
#define HW_DMA_DCHPRI12_RD()      (HW_DMA_DCHPRI12.U)
#define HW_DMA_DCHPRI12_WR(v)     (HW_DMA_DCHPRI12.U = (v))
#define HW_DMA_DCHPRI12_SET(v)    (HW_DMA_DCHPRI12_WR(HW_DMA_DCHPRI12_RD() |  (v)))
#define HW_DMA_DCHPRI12_CLR(v)    (HW_DMA_DCHPRI12_WR(HW_DMA_DCHPRI12_RD() & ~(v)))
#define HW_DMA_DCHPRI12_TOG(v)    (HW_DMA_DCHPRI12_WR(HW_DMA_DCHPRI12_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI12 bitfields
 */

/*! @name Register DMA_DCHPRI12, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI12_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI12_CHPRI.
#define BM_DMA_DCHPRI12_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI12_CHPRI.
#define BS_DMA_DCHPRI12_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI12_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI12_CHPRI field.
#define BR_DMA_DCHPRI12_CHPRI()   (HW_DMA_DCHPRI12.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI12_CHPRI.
#define BF_DMA_DCHPRI12_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI12_CHPRI), uint8_t) & BM_DMA_DCHPRI12_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI12_CHPRI(v)   (HW_DMA_DCHPRI12_WR((HW_DMA_DCHPRI12_RD() & ~BM_DMA_DCHPRI12_CHPRI) | BF_DMA_DCHPRI12_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI12, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI12_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI12_GRPPRI.
#define BM_DMA_DCHPRI12_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI12_GRPPRI.
#define BS_DMA_DCHPRI12_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI12_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI12_GRPPRI field.
#define BR_DMA_DCHPRI12_GRPPRI()   (HW_DMA_DCHPRI12.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI12, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI12_DPA      (6U)      //!< Bit position for DMA_DCHPRI12_DPA.
#define BM_DMA_DCHPRI12_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI12_DPA.
#define BS_DMA_DCHPRI12_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI12_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI12_DPA field.
#define BR_DMA_DCHPRI12_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI12_ADDR, BP_DMA_DCHPRI12_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI12_DPA.
#define BF_DMA_DCHPRI12_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI12_DPA), uint8_t) & BM_DMA_DCHPRI12_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI12_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI12_ADDR, BP_DMA_DCHPRI12_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI12, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI12_ECP      (7U)      //!< Bit position for DMA_DCHPRI12_ECP.
#define BM_DMA_DCHPRI12_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI12_ECP.
#define BS_DMA_DCHPRI12_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI12_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI12_ECP field.
#define BR_DMA_DCHPRI12_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI12_ADDR, BP_DMA_DCHPRI12_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI12_ECP.
#define BF_DMA_DCHPRI12_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI12_ECP), uint8_t) & BM_DMA_DCHPRI12_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI12_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI12_ADDR, BP_DMA_DCHPRI12_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI19 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI19 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri19
{
    uint8_t U;
    struct _hw_dma_dchpri19_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri19_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI19 register
 */
//@{
#define HW_DMA_DCHPRI19_ADDR      (REGS_DMA_BASE + 0x110U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI19           (*(__IO hw_dma_dchpri19_t *) HW_DMA_DCHPRI19_ADDR)
#define HW_DMA_DCHPRI19_RD()      (HW_DMA_DCHPRI19.U)
#define HW_DMA_DCHPRI19_WR(v)     (HW_DMA_DCHPRI19.U = (v))
#define HW_DMA_DCHPRI19_SET(v)    (HW_DMA_DCHPRI19_WR(HW_DMA_DCHPRI19_RD() |  (v)))
#define HW_DMA_DCHPRI19_CLR(v)    (HW_DMA_DCHPRI19_WR(HW_DMA_DCHPRI19_RD() & ~(v)))
#define HW_DMA_DCHPRI19_TOG(v)    (HW_DMA_DCHPRI19_WR(HW_DMA_DCHPRI19_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI19 bitfields
 */

/*! @name Register DMA_DCHPRI19, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI19_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI19_CHPRI.
#define BM_DMA_DCHPRI19_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI19_CHPRI.
#define BS_DMA_DCHPRI19_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI19_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI19_CHPRI field.
#define BR_DMA_DCHPRI19_CHPRI()   (HW_DMA_DCHPRI19.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI19_CHPRI.
#define BF_DMA_DCHPRI19_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI19_CHPRI), uint8_t) & BM_DMA_DCHPRI19_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI19_CHPRI(v)   (HW_DMA_DCHPRI19_WR((HW_DMA_DCHPRI19_RD() & ~BM_DMA_DCHPRI19_CHPRI) | BF_DMA_DCHPRI19_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI19, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI19_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI19_GRPPRI.
#define BM_DMA_DCHPRI19_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI19_GRPPRI.
#define BS_DMA_DCHPRI19_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI19_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI19_GRPPRI field.
#define BR_DMA_DCHPRI19_GRPPRI()   (HW_DMA_DCHPRI19.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI19, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI19_DPA      (6U)      //!< Bit position for DMA_DCHPRI19_DPA.
#define BM_DMA_DCHPRI19_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI19_DPA.
#define BS_DMA_DCHPRI19_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI19_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI19_DPA field.
#define BR_DMA_DCHPRI19_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI19_ADDR, BP_DMA_DCHPRI19_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI19_DPA.
#define BF_DMA_DCHPRI19_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI19_DPA), uint8_t) & BM_DMA_DCHPRI19_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI19_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI19_ADDR, BP_DMA_DCHPRI19_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI19, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI19_ECP      (7U)      //!< Bit position for DMA_DCHPRI19_ECP.
#define BM_DMA_DCHPRI19_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI19_ECP.
#define BS_DMA_DCHPRI19_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI19_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI19_ECP field.
#define BR_DMA_DCHPRI19_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI19_ADDR, BP_DMA_DCHPRI19_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI19_ECP.
#define BF_DMA_DCHPRI19_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI19_ECP), uint8_t) & BM_DMA_DCHPRI19_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI19_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI19_ADDR, BP_DMA_DCHPRI19_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI18 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI18 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri18
{
    uint8_t U;
    struct _hw_dma_dchpri18_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri18_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI18 register
 */
//@{
#define HW_DMA_DCHPRI18_ADDR      (REGS_DMA_BASE + 0x111U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI18           (*(__IO hw_dma_dchpri18_t *) HW_DMA_DCHPRI18_ADDR)
#define HW_DMA_DCHPRI18_RD()      (HW_DMA_DCHPRI18.U)
#define HW_DMA_DCHPRI18_WR(v)     (HW_DMA_DCHPRI18.U = (v))
#define HW_DMA_DCHPRI18_SET(v)    (HW_DMA_DCHPRI18_WR(HW_DMA_DCHPRI18_RD() |  (v)))
#define HW_DMA_DCHPRI18_CLR(v)    (HW_DMA_DCHPRI18_WR(HW_DMA_DCHPRI18_RD() & ~(v)))
#define HW_DMA_DCHPRI18_TOG(v)    (HW_DMA_DCHPRI18_WR(HW_DMA_DCHPRI18_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI18 bitfields
 */

/*! @name Register DMA_DCHPRI18, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI18_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI18_CHPRI.
#define BM_DMA_DCHPRI18_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI18_CHPRI.
#define BS_DMA_DCHPRI18_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI18_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI18_CHPRI field.
#define BR_DMA_DCHPRI18_CHPRI()   (HW_DMA_DCHPRI18.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI18_CHPRI.
#define BF_DMA_DCHPRI18_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI18_CHPRI), uint8_t) & BM_DMA_DCHPRI18_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI18_CHPRI(v)   (HW_DMA_DCHPRI18_WR((HW_DMA_DCHPRI18_RD() & ~BM_DMA_DCHPRI18_CHPRI) | BF_DMA_DCHPRI18_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI18, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI18_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI18_GRPPRI.
#define BM_DMA_DCHPRI18_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI18_GRPPRI.
#define BS_DMA_DCHPRI18_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI18_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI18_GRPPRI field.
#define BR_DMA_DCHPRI18_GRPPRI()   (HW_DMA_DCHPRI18.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI18, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI18_DPA      (6U)      //!< Bit position for DMA_DCHPRI18_DPA.
#define BM_DMA_DCHPRI18_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI18_DPA.
#define BS_DMA_DCHPRI18_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI18_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI18_DPA field.
#define BR_DMA_DCHPRI18_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI18_ADDR, BP_DMA_DCHPRI18_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI18_DPA.
#define BF_DMA_DCHPRI18_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI18_DPA), uint8_t) & BM_DMA_DCHPRI18_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI18_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI18_ADDR, BP_DMA_DCHPRI18_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI18, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI18_ECP      (7U)      //!< Bit position for DMA_DCHPRI18_ECP.
#define BM_DMA_DCHPRI18_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI18_ECP.
#define BS_DMA_DCHPRI18_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI18_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI18_ECP field.
#define BR_DMA_DCHPRI18_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI18_ADDR, BP_DMA_DCHPRI18_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI18_ECP.
#define BF_DMA_DCHPRI18_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI18_ECP), uint8_t) & BM_DMA_DCHPRI18_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI18_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI18_ADDR, BP_DMA_DCHPRI18_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI17 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI17 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri17
{
    uint8_t U;
    struct _hw_dma_dchpri17_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri17_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI17 register
 */
//@{
#define HW_DMA_DCHPRI17_ADDR      (REGS_DMA_BASE + 0x112U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI17           (*(__IO hw_dma_dchpri17_t *) HW_DMA_DCHPRI17_ADDR)
#define HW_DMA_DCHPRI17_RD()      (HW_DMA_DCHPRI17.U)
#define HW_DMA_DCHPRI17_WR(v)     (HW_DMA_DCHPRI17.U = (v))
#define HW_DMA_DCHPRI17_SET(v)    (HW_DMA_DCHPRI17_WR(HW_DMA_DCHPRI17_RD() |  (v)))
#define HW_DMA_DCHPRI17_CLR(v)    (HW_DMA_DCHPRI17_WR(HW_DMA_DCHPRI17_RD() & ~(v)))
#define HW_DMA_DCHPRI17_TOG(v)    (HW_DMA_DCHPRI17_WR(HW_DMA_DCHPRI17_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI17 bitfields
 */

/*! @name Register DMA_DCHPRI17, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI17_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI17_CHPRI.
#define BM_DMA_DCHPRI17_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI17_CHPRI.
#define BS_DMA_DCHPRI17_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI17_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI17_CHPRI field.
#define BR_DMA_DCHPRI17_CHPRI()   (HW_DMA_DCHPRI17.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI17_CHPRI.
#define BF_DMA_DCHPRI17_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI17_CHPRI), uint8_t) & BM_DMA_DCHPRI17_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI17_CHPRI(v)   (HW_DMA_DCHPRI17_WR((HW_DMA_DCHPRI17_RD() & ~BM_DMA_DCHPRI17_CHPRI) | BF_DMA_DCHPRI17_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI17, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI17_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI17_GRPPRI.
#define BM_DMA_DCHPRI17_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI17_GRPPRI.
#define BS_DMA_DCHPRI17_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI17_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI17_GRPPRI field.
#define BR_DMA_DCHPRI17_GRPPRI()   (HW_DMA_DCHPRI17.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI17, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI17_DPA      (6U)      //!< Bit position for DMA_DCHPRI17_DPA.
#define BM_DMA_DCHPRI17_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI17_DPA.
#define BS_DMA_DCHPRI17_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI17_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI17_DPA field.
#define BR_DMA_DCHPRI17_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI17_ADDR, BP_DMA_DCHPRI17_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI17_DPA.
#define BF_DMA_DCHPRI17_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI17_DPA), uint8_t) & BM_DMA_DCHPRI17_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI17_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI17_ADDR, BP_DMA_DCHPRI17_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI17, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI17_ECP      (7U)      //!< Bit position for DMA_DCHPRI17_ECP.
#define BM_DMA_DCHPRI17_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI17_ECP.
#define BS_DMA_DCHPRI17_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI17_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI17_ECP field.
#define BR_DMA_DCHPRI17_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI17_ADDR, BP_DMA_DCHPRI17_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI17_ECP.
#define BF_DMA_DCHPRI17_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI17_ECP), uint8_t) & BM_DMA_DCHPRI17_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI17_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI17_ADDR, BP_DMA_DCHPRI17_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI16 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI16 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri16
{
    uint8_t U;
    struct _hw_dma_dchpri16_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri16_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI16 register
 */
//@{
#define HW_DMA_DCHPRI16_ADDR      (REGS_DMA_BASE + 0x113U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI16           (*(__IO hw_dma_dchpri16_t *) HW_DMA_DCHPRI16_ADDR)
#define HW_DMA_DCHPRI16_RD()      (HW_DMA_DCHPRI16.U)
#define HW_DMA_DCHPRI16_WR(v)     (HW_DMA_DCHPRI16.U = (v))
#define HW_DMA_DCHPRI16_SET(v)    (HW_DMA_DCHPRI16_WR(HW_DMA_DCHPRI16_RD() |  (v)))
#define HW_DMA_DCHPRI16_CLR(v)    (HW_DMA_DCHPRI16_WR(HW_DMA_DCHPRI16_RD() & ~(v)))
#define HW_DMA_DCHPRI16_TOG(v)    (HW_DMA_DCHPRI16_WR(HW_DMA_DCHPRI16_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI16 bitfields
 */

/*! @name Register DMA_DCHPRI16, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI16_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI16_CHPRI.
#define BM_DMA_DCHPRI16_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI16_CHPRI.
#define BS_DMA_DCHPRI16_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI16_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI16_CHPRI field.
#define BR_DMA_DCHPRI16_CHPRI()   (HW_DMA_DCHPRI16.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI16_CHPRI.
#define BF_DMA_DCHPRI16_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI16_CHPRI), uint8_t) & BM_DMA_DCHPRI16_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI16_CHPRI(v)   (HW_DMA_DCHPRI16_WR((HW_DMA_DCHPRI16_RD() & ~BM_DMA_DCHPRI16_CHPRI) | BF_DMA_DCHPRI16_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI16, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI16_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI16_GRPPRI.
#define BM_DMA_DCHPRI16_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI16_GRPPRI.
#define BS_DMA_DCHPRI16_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI16_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI16_GRPPRI field.
#define BR_DMA_DCHPRI16_GRPPRI()   (HW_DMA_DCHPRI16.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI16, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI16_DPA      (6U)      //!< Bit position for DMA_DCHPRI16_DPA.
#define BM_DMA_DCHPRI16_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI16_DPA.
#define BS_DMA_DCHPRI16_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI16_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI16_DPA field.
#define BR_DMA_DCHPRI16_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI16_ADDR, BP_DMA_DCHPRI16_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI16_DPA.
#define BF_DMA_DCHPRI16_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI16_DPA), uint8_t) & BM_DMA_DCHPRI16_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI16_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI16_ADDR, BP_DMA_DCHPRI16_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI16, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI16_ECP      (7U)      //!< Bit position for DMA_DCHPRI16_ECP.
#define BM_DMA_DCHPRI16_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI16_ECP.
#define BS_DMA_DCHPRI16_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI16_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI16_ECP field.
#define BR_DMA_DCHPRI16_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI16_ADDR, BP_DMA_DCHPRI16_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI16_ECP.
#define BF_DMA_DCHPRI16_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI16_ECP), uint8_t) & BM_DMA_DCHPRI16_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI16_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI16_ADDR, BP_DMA_DCHPRI16_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI23 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI23 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri23
{
    uint8_t U;
    struct _hw_dma_dchpri23_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri23_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI23 register
 */
//@{
#define HW_DMA_DCHPRI23_ADDR      (REGS_DMA_BASE + 0x114U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI23           (*(__IO hw_dma_dchpri23_t *) HW_DMA_DCHPRI23_ADDR)
#define HW_DMA_DCHPRI23_RD()      (HW_DMA_DCHPRI23.U)
#define HW_DMA_DCHPRI23_WR(v)     (HW_DMA_DCHPRI23.U = (v))
#define HW_DMA_DCHPRI23_SET(v)    (HW_DMA_DCHPRI23_WR(HW_DMA_DCHPRI23_RD() |  (v)))
#define HW_DMA_DCHPRI23_CLR(v)    (HW_DMA_DCHPRI23_WR(HW_DMA_DCHPRI23_RD() & ~(v)))
#define HW_DMA_DCHPRI23_TOG(v)    (HW_DMA_DCHPRI23_WR(HW_DMA_DCHPRI23_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI23 bitfields
 */

/*! @name Register DMA_DCHPRI23, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI23_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI23_CHPRI.
#define BM_DMA_DCHPRI23_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI23_CHPRI.
#define BS_DMA_DCHPRI23_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI23_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI23_CHPRI field.
#define BR_DMA_DCHPRI23_CHPRI()   (HW_DMA_DCHPRI23.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI23_CHPRI.
#define BF_DMA_DCHPRI23_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI23_CHPRI), uint8_t) & BM_DMA_DCHPRI23_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI23_CHPRI(v)   (HW_DMA_DCHPRI23_WR((HW_DMA_DCHPRI23_RD() & ~BM_DMA_DCHPRI23_CHPRI) | BF_DMA_DCHPRI23_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI23, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI23_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI23_GRPPRI.
#define BM_DMA_DCHPRI23_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI23_GRPPRI.
#define BS_DMA_DCHPRI23_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI23_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI23_GRPPRI field.
#define BR_DMA_DCHPRI23_GRPPRI()   (HW_DMA_DCHPRI23.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI23, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI23_DPA      (6U)      //!< Bit position for DMA_DCHPRI23_DPA.
#define BM_DMA_DCHPRI23_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI23_DPA.
#define BS_DMA_DCHPRI23_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI23_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI23_DPA field.
#define BR_DMA_DCHPRI23_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI23_ADDR, BP_DMA_DCHPRI23_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI23_DPA.
#define BF_DMA_DCHPRI23_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI23_DPA), uint8_t) & BM_DMA_DCHPRI23_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI23_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI23_ADDR, BP_DMA_DCHPRI23_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI23, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI23_ECP      (7U)      //!< Bit position for DMA_DCHPRI23_ECP.
#define BM_DMA_DCHPRI23_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI23_ECP.
#define BS_DMA_DCHPRI23_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI23_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI23_ECP field.
#define BR_DMA_DCHPRI23_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI23_ADDR, BP_DMA_DCHPRI23_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI23_ECP.
#define BF_DMA_DCHPRI23_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI23_ECP), uint8_t) & BM_DMA_DCHPRI23_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI23_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI23_ADDR, BP_DMA_DCHPRI23_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI22 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI22 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri22
{
    uint8_t U;
    struct _hw_dma_dchpri22_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri22_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI22 register
 */
//@{
#define HW_DMA_DCHPRI22_ADDR      (REGS_DMA_BASE + 0x115U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI22           (*(__IO hw_dma_dchpri22_t *) HW_DMA_DCHPRI22_ADDR)
#define HW_DMA_DCHPRI22_RD()      (HW_DMA_DCHPRI22.U)
#define HW_DMA_DCHPRI22_WR(v)     (HW_DMA_DCHPRI22.U = (v))
#define HW_DMA_DCHPRI22_SET(v)    (HW_DMA_DCHPRI22_WR(HW_DMA_DCHPRI22_RD() |  (v)))
#define HW_DMA_DCHPRI22_CLR(v)    (HW_DMA_DCHPRI22_WR(HW_DMA_DCHPRI22_RD() & ~(v)))
#define HW_DMA_DCHPRI22_TOG(v)    (HW_DMA_DCHPRI22_WR(HW_DMA_DCHPRI22_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI22 bitfields
 */

/*! @name Register DMA_DCHPRI22, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI22_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI22_CHPRI.
#define BM_DMA_DCHPRI22_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI22_CHPRI.
#define BS_DMA_DCHPRI22_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI22_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI22_CHPRI field.
#define BR_DMA_DCHPRI22_CHPRI()   (HW_DMA_DCHPRI22.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI22_CHPRI.
#define BF_DMA_DCHPRI22_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI22_CHPRI), uint8_t) & BM_DMA_DCHPRI22_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI22_CHPRI(v)   (HW_DMA_DCHPRI22_WR((HW_DMA_DCHPRI22_RD() & ~BM_DMA_DCHPRI22_CHPRI) | BF_DMA_DCHPRI22_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI22, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI22_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI22_GRPPRI.
#define BM_DMA_DCHPRI22_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI22_GRPPRI.
#define BS_DMA_DCHPRI22_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI22_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI22_GRPPRI field.
#define BR_DMA_DCHPRI22_GRPPRI()   (HW_DMA_DCHPRI22.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI22, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI22_DPA      (6U)      //!< Bit position for DMA_DCHPRI22_DPA.
#define BM_DMA_DCHPRI22_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI22_DPA.
#define BS_DMA_DCHPRI22_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI22_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI22_DPA field.
#define BR_DMA_DCHPRI22_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI22_ADDR, BP_DMA_DCHPRI22_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI22_DPA.
#define BF_DMA_DCHPRI22_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI22_DPA), uint8_t) & BM_DMA_DCHPRI22_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI22_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI22_ADDR, BP_DMA_DCHPRI22_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI22, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI22_ECP      (7U)      //!< Bit position for DMA_DCHPRI22_ECP.
#define BM_DMA_DCHPRI22_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI22_ECP.
#define BS_DMA_DCHPRI22_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI22_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI22_ECP field.
#define BR_DMA_DCHPRI22_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI22_ADDR, BP_DMA_DCHPRI22_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI22_ECP.
#define BF_DMA_DCHPRI22_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI22_ECP), uint8_t) & BM_DMA_DCHPRI22_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI22_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI22_ADDR, BP_DMA_DCHPRI22_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI21 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI21 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri21
{
    uint8_t U;
    struct _hw_dma_dchpri21_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri21_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI21 register
 */
//@{
#define HW_DMA_DCHPRI21_ADDR      (REGS_DMA_BASE + 0x116U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI21           (*(__IO hw_dma_dchpri21_t *) HW_DMA_DCHPRI21_ADDR)
#define HW_DMA_DCHPRI21_RD()      (HW_DMA_DCHPRI21.U)
#define HW_DMA_DCHPRI21_WR(v)     (HW_DMA_DCHPRI21.U = (v))
#define HW_DMA_DCHPRI21_SET(v)    (HW_DMA_DCHPRI21_WR(HW_DMA_DCHPRI21_RD() |  (v)))
#define HW_DMA_DCHPRI21_CLR(v)    (HW_DMA_DCHPRI21_WR(HW_DMA_DCHPRI21_RD() & ~(v)))
#define HW_DMA_DCHPRI21_TOG(v)    (HW_DMA_DCHPRI21_WR(HW_DMA_DCHPRI21_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI21 bitfields
 */

/*! @name Register DMA_DCHPRI21, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI21_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI21_CHPRI.
#define BM_DMA_DCHPRI21_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI21_CHPRI.
#define BS_DMA_DCHPRI21_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI21_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI21_CHPRI field.
#define BR_DMA_DCHPRI21_CHPRI()   (HW_DMA_DCHPRI21.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI21_CHPRI.
#define BF_DMA_DCHPRI21_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI21_CHPRI), uint8_t) & BM_DMA_DCHPRI21_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI21_CHPRI(v)   (HW_DMA_DCHPRI21_WR((HW_DMA_DCHPRI21_RD() & ~BM_DMA_DCHPRI21_CHPRI) | BF_DMA_DCHPRI21_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI21, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI21_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI21_GRPPRI.
#define BM_DMA_DCHPRI21_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI21_GRPPRI.
#define BS_DMA_DCHPRI21_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI21_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI21_GRPPRI field.
#define BR_DMA_DCHPRI21_GRPPRI()   (HW_DMA_DCHPRI21.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI21, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI21_DPA      (6U)      //!< Bit position for DMA_DCHPRI21_DPA.
#define BM_DMA_DCHPRI21_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI21_DPA.
#define BS_DMA_DCHPRI21_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI21_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI21_DPA field.
#define BR_DMA_DCHPRI21_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI21_ADDR, BP_DMA_DCHPRI21_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI21_DPA.
#define BF_DMA_DCHPRI21_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI21_DPA), uint8_t) & BM_DMA_DCHPRI21_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI21_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI21_ADDR, BP_DMA_DCHPRI21_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI21, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI21_ECP      (7U)      //!< Bit position for DMA_DCHPRI21_ECP.
#define BM_DMA_DCHPRI21_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI21_ECP.
#define BS_DMA_DCHPRI21_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI21_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI21_ECP field.
#define BR_DMA_DCHPRI21_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI21_ADDR, BP_DMA_DCHPRI21_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI21_ECP.
#define BF_DMA_DCHPRI21_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI21_ECP), uint8_t) & BM_DMA_DCHPRI21_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI21_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI21_ADDR, BP_DMA_DCHPRI21_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI20 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI20 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri20
{
    uint8_t U;
    struct _hw_dma_dchpri20_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri20_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI20 register
 */
//@{
#define HW_DMA_DCHPRI20_ADDR      (REGS_DMA_BASE + 0x117U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI20           (*(__IO hw_dma_dchpri20_t *) HW_DMA_DCHPRI20_ADDR)
#define HW_DMA_DCHPRI20_RD()      (HW_DMA_DCHPRI20.U)
#define HW_DMA_DCHPRI20_WR(v)     (HW_DMA_DCHPRI20.U = (v))
#define HW_DMA_DCHPRI20_SET(v)    (HW_DMA_DCHPRI20_WR(HW_DMA_DCHPRI20_RD() |  (v)))
#define HW_DMA_DCHPRI20_CLR(v)    (HW_DMA_DCHPRI20_WR(HW_DMA_DCHPRI20_RD() & ~(v)))
#define HW_DMA_DCHPRI20_TOG(v)    (HW_DMA_DCHPRI20_WR(HW_DMA_DCHPRI20_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI20 bitfields
 */

/*! @name Register DMA_DCHPRI20, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI20_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI20_CHPRI.
#define BM_DMA_DCHPRI20_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI20_CHPRI.
#define BS_DMA_DCHPRI20_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI20_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI20_CHPRI field.
#define BR_DMA_DCHPRI20_CHPRI()   (HW_DMA_DCHPRI20.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI20_CHPRI.
#define BF_DMA_DCHPRI20_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI20_CHPRI), uint8_t) & BM_DMA_DCHPRI20_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI20_CHPRI(v)   (HW_DMA_DCHPRI20_WR((HW_DMA_DCHPRI20_RD() & ~BM_DMA_DCHPRI20_CHPRI) | BF_DMA_DCHPRI20_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI20, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI20_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI20_GRPPRI.
#define BM_DMA_DCHPRI20_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI20_GRPPRI.
#define BS_DMA_DCHPRI20_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI20_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI20_GRPPRI field.
#define BR_DMA_DCHPRI20_GRPPRI()   (HW_DMA_DCHPRI20.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI20, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI20_DPA      (6U)      //!< Bit position for DMA_DCHPRI20_DPA.
#define BM_DMA_DCHPRI20_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI20_DPA.
#define BS_DMA_DCHPRI20_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI20_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI20_DPA field.
#define BR_DMA_DCHPRI20_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI20_ADDR, BP_DMA_DCHPRI20_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI20_DPA.
#define BF_DMA_DCHPRI20_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI20_DPA), uint8_t) & BM_DMA_DCHPRI20_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI20_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI20_ADDR, BP_DMA_DCHPRI20_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI20, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI20_ECP      (7U)      //!< Bit position for DMA_DCHPRI20_ECP.
#define BM_DMA_DCHPRI20_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI20_ECP.
#define BS_DMA_DCHPRI20_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI20_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI20_ECP field.
#define BR_DMA_DCHPRI20_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI20_ADDR, BP_DMA_DCHPRI20_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI20_ECP.
#define BF_DMA_DCHPRI20_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI20_ECP), uint8_t) & BM_DMA_DCHPRI20_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI20_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI20_ADDR, BP_DMA_DCHPRI20_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI27 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI27 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri27
{
    uint8_t U;
    struct _hw_dma_dchpri27_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri27_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI27 register
 */
//@{
#define HW_DMA_DCHPRI27_ADDR      (REGS_DMA_BASE + 0x118U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI27           (*(__IO hw_dma_dchpri27_t *) HW_DMA_DCHPRI27_ADDR)
#define HW_DMA_DCHPRI27_RD()      (HW_DMA_DCHPRI27.U)
#define HW_DMA_DCHPRI27_WR(v)     (HW_DMA_DCHPRI27.U = (v))
#define HW_DMA_DCHPRI27_SET(v)    (HW_DMA_DCHPRI27_WR(HW_DMA_DCHPRI27_RD() |  (v)))
#define HW_DMA_DCHPRI27_CLR(v)    (HW_DMA_DCHPRI27_WR(HW_DMA_DCHPRI27_RD() & ~(v)))
#define HW_DMA_DCHPRI27_TOG(v)    (HW_DMA_DCHPRI27_WR(HW_DMA_DCHPRI27_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI27 bitfields
 */

/*! @name Register DMA_DCHPRI27, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI27_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI27_CHPRI.
#define BM_DMA_DCHPRI27_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI27_CHPRI.
#define BS_DMA_DCHPRI27_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI27_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI27_CHPRI field.
#define BR_DMA_DCHPRI27_CHPRI()   (HW_DMA_DCHPRI27.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI27_CHPRI.
#define BF_DMA_DCHPRI27_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI27_CHPRI), uint8_t) & BM_DMA_DCHPRI27_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI27_CHPRI(v)   (HW_DMA_DCHPRI27_WR((HW_DMA_DCHPRI27_RD() & ~BM_DMA_DCHPRI27_CHPRI) | BF_DMA_DCHPRI27_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI27, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI27_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI27_GRPPRI.
#define BM_DMA_DCHPRI27_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI27_GRPPRI.
#define BS_DMA_DCHPRI27_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI27_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI27_GRPPRI field.
#define BR_DMA_DCHPRI27_GRPPRI()   (HW_DMA_DCHPRI27.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI27, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI27_DPA      (6U)      //!< Bit position for DMA_DCHPRI27_DPA.
#define BM_DMA_DCHPRI27_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI27_DPA.
#define BS_DMA_DCHPRI27_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI27_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI27_DPA field.
#define BR_DMA_DCHPRI27_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI27_ADDR, BP_DMA_DCHPRI27_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI27_DPA.
#define BF_DMA_DCHPRI27_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI27_DPA), uint8_t) & BM_DMA_DCHPRI27_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI27_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI27_ADDR, BP_DMA_DCHPRI27_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI27, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI27_ECP      (7U)      //!< Bit position for DMA_DCHPRI27_ECP.
#define BM_DMA_DCHPRI27_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI27_ECP.
#define BS_DMA_DCHPRI27_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI27_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI27_ECP field.
#define BR_DMA_DCHPRI27_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI27_ADDR, BP_DMA_DCHPRI27_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI27_ECP.
#define BF_DMA_DCHPRI27_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI27_ECP), uint8_t) & BM_DMA_DCHPRI27_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI27_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI27_ADDR, BP_DMA_DCHPRI27_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI26 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI26 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri26
{
    uint8_t U;
    struct _hw_dma_dchpri26_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri26_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI26 register
 */
//@{
#define HW_DMA_DCHPRI26_ADDR      (REGS_DMA_BASE + 0x119U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI26           (*(__IO hw_dma_dchpri26_t *) HW_DMA_DCHPRI26_ADDR)
#define HW_DMA_DCHPRI26_RD()      (HW_DMA_DCHPRI26.U)
#define HW_DMA_DCHPRI26_WR(v)     (HW_DMA_DCHPRI26.U = (v))
#define HW_DMA_DCHPRI26_SET(v)    (HW_DMA_DCHPRI26_WR(HW_DMA_DCHPRI26_RD() |  (v)))
#define HW_DMA_DCHPRI26_CLR(v)    (HW_DMA_DCHPRI26_WR(HW_DMA_DCHPRI26_RD() & ~(v)))
#define HW_DMA_DCHPRI26_TOG(v)    (HW_DMA_DCHPRI26_WR(HW_DMA_DCHPRI26_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI26 bitfields
 */

/*! @name Register DMA_DCHPRI26, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI26_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI26_CHPRI.
#define BM_DMA_DCHPRI26_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI26_CHPRI.
#define BS_DMA_DCHPRI26_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI26_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI26_CHPRI field.
#define BR_DMA_DCHPRI26_CHPRI()   (HW_DMA_DCHPRI26.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI26_CHPRI.
#define BF_DMA_DCHPRI26_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI26_CHPRI), uint8_t) & BM_DMA_DCHPRI26_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI26_CHPRI(v)   (HW_DMA_DCHPRI26_WR((HW_DMA_DCHPRI26_RD() & ~BM_DMA_DCHPRI26_CHPRI) | BF_DMA_DCHPRI26_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI26, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI26_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI26_GRPPRI.
#define BM_DMA_DCHPRI26_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI26_GRPPRI.
#define BS_DMA_DCHPRI26_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI26_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI26_GRPPRI field.
#define BR_DMA_DCHPRI26_GRPPRI()   (HW_DMA_DCHPRI26.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI26, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI26_DPA      (6U)      //!< Bit position for DMA_DCHPRI26_DPA.
#define BM_DMA_DCHPRI26_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI26_DPA.
#define BS_DMA_DCHPRI26_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI26_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI26_DPA field.
#define BR_DMA_DCHPRI26_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI26_ADDR, BP_DMA_DCHPRI26_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI26_DPA.
#define BF_DMA_DCHPRI26_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI26_DPA), uint8_t) & BM_DMA_DCHPRI26_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI26_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI26_ADDR, BP_DMA_DCHPRI26_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI26, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI26_ECP      (7U)      //!< Bit position for DMA_DCHPRI26_ECP.
#define BM_DMA_DCHPRI26_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI26_ECP.
#define BS_DMA_DCHPRI26_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI26_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI26_ECP field.
#define BR_DMA_DCHPRI26_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI26_ADDR, BP_DMA_DCHPRI26_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI26_ECP.
#define BF_DMA_DCHPRI26_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI26_ECP), uint8_t) & BM_DMA_DCHPRI26_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI26_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI26_ADDR, BP_DMA_DCHPRI26_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI25 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI25 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri25
{
    uint8_t U;
    struct _hw_dma_dchpri25_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri25_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI25 register
 */
//@{
#define HW_DMA_DCHPRI25_ADDR      (REGS_DMA_BASE + 0x11aU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI25           (*(__IO hw_dma_dchpri25_t *) HW_DMA_DCHPRI25_ADDR)
#define HW_DMA_DCHPRI25_RD()      (HW_DMA_DCHPRI25.U)
#define HW_DMA_DCHPRI25_WR(v)     (HW_DMA_DCHPRI25.U = (v))
#define HW_DMA_DCHPRI25_SET(v)    (HW_DMA_DCHPRI25_WR(HW_DMA_DCHPRI25_RD() |  (v)))
#define HW_DMA_DCHPRI25_CLR(v)    (HW_DMA_DCHPRI25_WR(HW_DMA_DCHPRI25_RD() & ~(v)))
#define HW_DMA_DCHPRI25_TOG(v)    (HW_DMA_DCHPRI25_WR(HW_DMA_DCHPRI25_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI25 bitfields
 */

/*! @name Register DMA_DCHPRI25, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI25_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI25_CHPRI.
#define BM_DMA_DCHPRI25_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI25_CHPRI.
#define BS_DMA_DCHPRI25_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI25_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI25_CHPRI field.
#define BR_DMA_DCHPRI25_CHPRI()   (HW_DMA_DCHPRI25.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI25_CHPRI.
#define BF_DMA_DCHPRI25_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI25_CHPRI), uint8_t) & BM_DMA_DCHPRI25_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI25_CHPRI(v)   (HW_DMA_DCHPRI25_WR((HW_DMA_DCHPRI25_RD() & ~BM_DMA_DCHPRI25_CHPRI) | BF_DMA_DCHPRI25_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI25, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI25_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI25_GRPPRI.
#define BM_DMA_DCHPRI25_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI25_GRPPRI.
#define BS_DMA_DCHPRI25_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI25_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI25_GRPPRI field.
#define BR_DMA_DCHPRI25_GRPPRI()   (HW_DMA_DCHPRI25.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI25, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI25_DPA      (6U)      //!< Bit position for DMA_DCHPRI25_DPA.
#define BM_DMA_DCHPRI25_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI25_DPA.
#define BS_DMA_DCHPRI25_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI25_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI25_DPA field.
#define BR_DMA_DCHPRI25_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI25_ADDR, BP_DMA_DCHPRI25_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI25_DPA.
#define BF_DMA_DCHPRI25_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI25_DPA), uint8_t) & BM_DMA_DCHPRI25_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI25_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI25_ADDR, BP_DMA_DCHPRI25_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI25, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI25_ECP      (7U)      //!< Bit position for DMA_DCHPRI25_ECP.
#define BM_DMA_DCHPRI25_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI25_ECP.
#define BS_DMA_DCHPRI25_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI25_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI25_ECP field.
#define BR_DMA_DCHPRI25_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI25_ADDR, BP_DMA_DCHPRI25_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI25_ECP.
#define BF_DMA_DCHPRI25_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI25_ECP), uint8_t) & BM_DMA_DCHPRI25_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI25_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI25_ADDR, BP_DMA_DCHPRI25_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI24 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI24 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri24
{
    uint8_t U;
    struct _hw_dma_dchpri24_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri24_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI24 register
 */
//@{
#define HW_DMA_DCHPRI24_ADDR      (REGS_DMA_BASE + 0x11bU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI24           (*(__IO hw_dma_dchpri24_t *) HW_DMA_DCHPRI24_ADDR)
#define HW_DMA_DCHPRI24_RD()      (HW_DMA_DCHPRI24.U)
#define HW_DMA_DCHPRI24_WR(v)     (HW_DMA_DCHPRI24.U = (v))
#define HW_DMA_DCHPRI24_SET(v)    (HW_DMA_DCHPRI24_WR(HW_DMA_DCHPRI24_RD() |  (v)))
#define HW_DMA_DCHPRI24_CLR(v)    (HW_DMA_DCHPRI24_WR(HW_DMA_DCHPRI24_RD() & ~(v)))
#define HW_DMA_DCHPRI24_TOG(v)    (HW_DMA_DCHPRI24_WR(HW_DMA_DCHPRI24_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI24 bitfields
 */

/*! @name Register DMA_DCHPRI24, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI24_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI24_CHPRI.
#define BM_DMA_DCHPRI24_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI24_CHPRI.
#define BS_DMA_DCHPRI24_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI24_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI24_CHPRI field.
#define BR_DMA_DCHPRI24_CHPRI()   (HW_DMA_DCHPRI24.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI24_CHPRI.
#define BF_DMA_DCHPRI24_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI24_CHPRI), uint8_t) & BM_DMA_DCHPRI24_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI24_CHPRI(v)   (HW_DMA_DCHPRI24_WR((HW_DMA_DCHPRI24_RD() & ~BM_DMA_DCHPRI24_CHPRI) | BF_DMA_DCHPRI24_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI24, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI24_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI24_GRPPRI.
#define BM_DMA_DCHPRI24_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI24_GRPPRI.
#define BS_DMA_DCHPRI24_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI24_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI24_GRPPRI field.
#define BR_DMA_DCHPRI24_GRPPRI()   (HW_DMA_DCHPRI24.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI24, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI24_DPA      (6U)      //!< Bit position for DMA_DCHPRI24_DPA.
#define BM_DMA_DCHPRI24_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI24_DPA.
#define BS_DMA_DCHPRI24_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI24_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI24_DPA field.
#define BR_DMA_DCHPRI24_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI24_ADDR, BP_DMA_DCHPRI24_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI24_DPA.
#define BF_DMA_DCHPRI24_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI24_DPA), uint8_t) & BM_DMA_DCHPRI24_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI24_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI24_ADDR, BP_DMA_DCHPRI24_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI24, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI24_ECP      (7U)      //!< Bit position for DMA_DCHPRI24_ECP.
#define BM_DMA_DCHPRI24_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI24_ECP.
#define BS_DMA_DCHPRI24_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI24_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI24_ECP field.
#define BR_DMA_DCHPRI24_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI24_ADDR, BP_DMA_DCHPRI24_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI24_ECP.
#define BF_DMA_DCHPRI24_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI24_ECP), uint8_t) & BM_DMA_DCHPRI24_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI24_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI24_ADDR, BP_DMA_DCHPRI24_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI31 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI31 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri31
{
    uint8_t U;
    struct _hw_dma_dchpri31_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri31_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI31 register
 */
//@{
#define HW_DMA_DCHPRI31_ADDR      (REGS_DMA_BASE + 0x11cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI31           (*(__IO hw_dma_dchpri31_t *) HW_DMA_DCHPRI31_ADDR)
#define HW_DMA_DCHPRI31_RD()      (HW_DMA_DCHPRI31.U)
#define HW_DMA_DCHPRI31_WR(v)     (HW_DMA_DCHPRI31.U = (v))
#define HW_DMA_DCHPRI31_SET(v)    (HW_DMA_DCHPRI31_WR(HW_DMA_DCHPRI31_RD() |  (v)))
#define HW_DMA_DCHPRI31_CLR(v)    (HW_DMA_DCHPRI31_WR(HW_DMA_DCHPRI31_RD() & ~(v)))
#define HW_DMA_DCHPRI31_TOG(v)    (HW_DMA_DCHPRI31_WR(HW_DMA_DCHPRI31_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI31 bitfields
 */

/*! @name Register DMA_DCHPRI31, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI31_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI31_CHPRI.
#define BM_DMA_DCHPRI31_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI31_CHPRI.
#define BS_DMA_DCHPRI31_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI31_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI31_CHPRI field.
#define BR_DMA_DCHPRI31_CHPRI()   (HW_DMA_DCHPRI31.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI31_CHPRI.
#define BF_DMA_DCHPRI31_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI31_CHPRI), uint8_t) & BM_DMA_DCHPRI31_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI31_CHPRI(v)   (HW_DMA_DCHPRI31_WR((HW_DMA_DCHPRI31_RD() & ~BM_DMA_DCHPRI31_CHPRI) | BF_DMA_DCHPRI31_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI31, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI31_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI31_GRPPRI.
#define BM_DMA_DCHPRI31_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI31_GRPPRI.
#define BS_DMA_DCHPRI31_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI31_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI31_GRPPRI field.
#define BR_DMA_DCHPRI31_GRPPRI()   (HW_DMA_DCHPRI31.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI31, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI31_DPA      (6U)      //!< Bit position for DMA_DCHPRI31_DPA.
#define BM_DMA_DCHPRI31_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI31_DPA.
#define BS_DMA_DCHPRI31_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI31_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI31_DPA field.
#define BR_DMA_DCHPRI31_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI31_ADDR, BP_DMA_DCHPRI31_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI31_DPA.
#define BF_DMA_DCHPRI31_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI31_DPA), uint8_t) & BM_DMA_DCHPRI31_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI31_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI31_ADDR, BP_DMA_DCHPRI31_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI31, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI31_ECP      (7U)      //!< Bit position for DMA_DCHPRI31_ECP.
#define BM_DMA_DCHPRI31_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI31_ECP.
#define BS_DMA_DCHPRI31_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI31_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI31_ECP field.
#define BR_DMA_DCHPRI31_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI31_ADDR, BP_DMA_DCHPRI31_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI31_ECP.
#define BF_DMA_DCHPRI31_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI31_ECP), uint8_t) & BM_DMA_DCHPRI31_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI31_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI31_ADDR, BP_DMA_DCHPRI31_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI30 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI30 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri30
{
    uint8_t U;
    struct _hw_dma_dchpri30_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri30_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI30 register
 */
//@{
#define HW_DMA_DCHPRI30_ADDR      (REGS_DMA_BASE + 0x11dU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI30           (*(__IO hw_dma_dchpri30_t *) HW_DMA_DCHPRI30_ADDR)
#define HW_DMA_DCHPRI30_RD()      (HW_DMA_DCHPRI30.U)
#define HW_DMA_DCHPRI30_WR(v)     (HW_DMA_DCHPRI30.U = (v))
#define HW_DMA_DCHPRI30_SET(v)    (HW_DMA_DCHPRI30_WR(HW_DMA_DCHPRI30_RD() |  (v)))
#define HW_DMA_DCHPRI30_CLR(v)    (HW_DMA_DCHPRI30_WR(HW_DMA_DCHPRI30_RD() & ~(v)))
#define HW_DMA_DCHPRI30_TOG(v)    (HW_DMA_DCHPRI30_WR(HW_DMA_DCHPRI30_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI30 bitfields
 */

/*! @name Register DMA_DCHPRI30, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI30_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI30_CHPRI.
#define BM_DMA_DCHPRI30_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI30_CHPRI.
#define BS_DMA_DCHPRI30_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI30_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI30_CHPRI field.
#define BR_DMA_DCHPRI30_CHPRI()   (HW_DMA_DCHPRI30.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI30_CHPRI.
#define BF_DMA_DCHPRI30_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI30_CHPRI), uint8_t) & BM_DMA_DCHPRI30_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI30_CHPRI(v)   (HW_DMA_DCHPRI30_WR((HW_DMA_DCHPRI30_RD() & ~BM_DMA_DCHPRI30_CHPRI) | BF_DMA_DCHPRI30_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI30, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI30_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI30_GRPPRI.
#define BM_DMA_DCHPRI30_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI30_GRPPRI.
#define BS_DMA_DCHPRI30_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI30_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI30_GRPPRI field.
#define BR_DMA_DCHPRI30_GRPPRI()   (HW_DMA_DCHPRI30.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI30, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI30_DPA      (6U)      //!< Bit position for DMA_DCHPRI30_DPA.
#define BM_DMA_DCHPRI30_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI30_DPA.
#define BS_DMA_DCHPRI30_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI30_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI30_DPA field.
#define BR_DMA_DCHPRI30_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI30_ADDR, BP_DMA_DCHPRI30_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI30_DPA.
#define BF_DMA_DCHPRI30_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI30_DPA), uint8_t) & BM_DMA_DCHPRI30_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI30_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI30_ADDR, BP_DMA_DCHPRI30_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI30, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI30_ECP      (7U)      //!< Bit position for DMA_DCHPRI30_ECP.
#define BM_DMA_DCHPRI30_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI30_ECP.
#define BS_DMA_DCHPRI30_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI30_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI30_ECP field.
#define BR_DMA_DCHPRI30_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI30_ADDR, BP_DMA_DCHPRI30_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI30_ECP.
#define BF_DMA_DCHPRI30_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI30_ECP), uint8_t) & BM_DMA_DCHPRI30_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI30_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI30_ADDR, BP_DMA_DCHPRI30_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI29 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI29 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri29
{
    uint8_t U;
    struct _hw_dma_dchpri29_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri29_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI29 register
 */
//@{
#define HW_DMA_DCHPRI29_ADDR      (REGS_DMA_BASE + 0x11eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI29           (*(__IO hw_dma_dchpri29_t *) HW_DMA_DCHPRI29_ADDR)
#define HW_DMA_DCHPRI29_RD()      (HW_DMA_DCHPRI29.U)
#define HW_DMA_DCHPRI29_WR(v)     (HW_DMA_DCHPRI29.U = (v))
#define HW_DMA_DCHPRI29_SET(v)    (HW_DMA_DCHPRI29_WR(HW_DMA_DCHPRI29_RD() |  (v)))
#define HW_DMA_DCHPRI29_CLR(v)    (HW_DMA_DCHPRI29_WR(HW_DMA_DCHPRI29_RD() & ~(v)))
#define HW_DMA_DCHPRI29_TOG(v)    (HW_DMA_DCHPRI29_WR(HW_DMA_DCHPRI29_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI29 bitfields
 */

/*! @name Register DMA_DCHPRI29, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI29_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI29_CHPRI.
#define BM_DMA_DCHPRI29_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI29_CHPRI.
#define BS_DMA_DCHPRI29_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI29_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI29_CHPRI field.
#define BR_DMA_DCHPRI29_CHPRI()   (HW_DMA_DCHPRI29.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI29_CHPRI.
#define BF_DMA_DCHPRI29_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI29_CHPRI), uint8_t) & BM_DMA_DCHPRI29_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI29_CHPRI(v)   (HW_DMA_DCHPRI29_WR((HW_DMA_DCHPRI29_RD() & ~BM_DMA_DCHPRI29_CHPRI) | BF_DMA_DCHPRI29_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI29, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI29_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI29_GRPPRI.
#define BM_DMA_DCHPRI29_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI29_GRPPRI.
#define BS_DMA_DCHPRI29_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI29_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI29_GRPPRI field.
#define BR_DMA_DCHPRI29_GRPPRI()   (HW_DMA_DCHPRI29.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI29, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI29_DPA      (6U)      //!< Bit position for DMA_DCHPRI29_DPA.
#define BM_DMA_DCHPRI29_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI29_DPA.
#define BS_DMA_DCHPRI29_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI29_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI29_DPA field.
#define BR_DMA_DCHPRI29_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI29_ADDR, BP_DMA_DCHPRI29_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI29_DPA.
#define BF_DMA_DCHPRI29_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI29_DPA), uint8_t) & BM_DMA_DCHPRI29_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI29_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI29_ADDR, BP_DMA_DCHPRI29_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI29, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI29_ECP      (7U)      //!< Bit position for DMA_DCHPRI29_ECP.
#define BM_DMA_DCHPRI29_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI29_ECP.
#define BS_DMA_DCHPRI29_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI29_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI29_ECP field.
#define BR_DMA_DCHPRI29_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI29_ADDR, BP_DMA_DCHPRI29_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI29_ECP.
#define BF_DMA_DCHPRI29_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI29_ECP), uint8_t) & BM_DMA_DCHPRI29_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI29_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI29_ADDR, BP_DMA_DCHPRI29_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_DCHPRI28 - Channel n Priority Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_DCHPRI28 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the contents of these
 * registers define the unique priorities associated with each channel within a group . The channel
 * priorities are evaluated by numeric value; for example, 0 is the lowest priority, 1 is the next
 * higher priority, then 2, 3, etc. Software must program the channel priorities with unique values;
 * otherwise, a configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn register reflect the current
 * priority level of the group of channels in which the corresponding channel resides. GRPPRI bits
 * are not affected by writes to the DCHPRIn registers. The group priority is assigned in the DMA
 * control register.
 */
typedef union _hw_dma_dchpri28
{
    uint8_t U;
    struct _hw_dma_dchpri28_bitfields
    {
        uint8_t CHPRI : 4; //!< [3:0] Channel n Arbitration Priority
        uint8_t GRPPRI : 2; //!< [5:4] Channel n Current Group Priority
        uint8_t DPA : 1; //!< [6] Disable preempt ability. This bit resets to zero.
        uint8_t ECP : 1; //!< [7] Enable Channel Preemption. This bit resets to zero.
    } B;
} hw_dma_dchpri28_t;
#endif

/*!
 * @name Constants and macros for entire DMA_DCHPRI28 register
 */
//@{
#define HW_DMA_DCHPRI28_ADDR      (REGS_DMA_BASE + 0x11fU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_DCHPRI28           (*(__IO hw_dma_dchpri28_t *) HW_DMA_DCHPRI28_ADDR)
#define HW_DMA_DCHPRI28_RD()      (HW_DMA_DCHPRI28.U)
#define HW_DMA_DCHPRI28_WR(v)     (HW_DMA_DCHPRI28.U = (v))
#define HW_DMA_DCHPRI28_SET(v)    (HW_DMA_DCHPRI28_WR(HW_DMA_DCHPRI28_RD() |  (v)))
#define HW_DMA_DCHPRI28_CLR(v)    (HW_DMA_DCHPRI28_WR(HW_DMA_DCHPRI28_RD() & ~(v)))
#define HW_DMA_DCHPRI28_TOG(v)    (HW_DMA_DCHPRI28_WR(HW_DMA_DCHPRI28_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_DCHPRI28 bitfields
 */

/*! @name Register DMA_DCHPRI28, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for the group and channel
 * priority fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b01111.
 */
//@{
#define BP_DMA_DCHPRI28_CHPRI      (0U)      //!< Bit position for DMA_DCHPRI28_CHPRI.
#define BM_DMA_DCHPRI28_CHPRI      (0x0fU)  //!< Bit mask for DMA_DCHPRI28_CHPRI.
#define BS_DMA_DCHPRI28_CHPRI      (4U)  //!< Bitfield size in bits for DMA_DCHPRI28_CHPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI28_CHPRI field.
#define BR_DMA_DCHPRI28_CHPRI()   (HW_DMA_DCHPRI28.B.CHPRI)
#endif

//! @brief Format value for bitfield DMA_DCHPRI28_CHPRI.
#define BF_DMA_DCHPRI28_CHPRI(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI28_CHPRI), uint8_t) & BM_DMA_DCHPRI28_CHPRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHPRI field to a new value.
#define BW_DMA_DCHPRI28_CHPRI(v)   (HW_DMA_DCHPRI28_WR((HW_DMA_DCHPRI28_RD() & ~BM_DMA_DCHPRI28_CHPRI) | BF_DMA_DCHPRI28_CHPRI(v)))
#endif
//@}

/*! @name Register DMA_DCHPRI28, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration is enabled. These
 * two bits are read only; writes are ignored. Reset value for the group and channel priority
 * fields, GRPPRI and CHPRI, is equal to the corresponding channel number for each priority
 * register, i.e., DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
//@{
#define BP_DMA_DCHPRI28_GRPPRI      (4U)      //!< Bit position for DMA_DCHPRI28_GRPPRI.
#define BM_DMA_DCHPRI28_GRPPRI      (0x30U)  //!< Bit mask for DMA_DCHPRI28_GRPPRI.
#define BS_DMA_DCHPRI28_GRPPRI      (2U)  //!< Bitfield size in bits for DMA_DCHPRI28_GRPPRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI28_GRPPRI field.
#define BR_DMA_DCHPRI28_GRPPRI()   (HW_DMA_DCHPRI28.B.GRPPRI)
#endif
//@}

/*! @name Register DMA_DCHPRI28, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
//@{
#define BP_DMA_DCHPRI28_DPA      (6U)      //!< Bit position for DMA_DCHPRI28_DPA.
#define BM_DMA_DCHPRI28_DPA      (0x40U)  //!< Bit mask for DMA_DCHPRI28_DPA.
#define BS_DMA_DCHPRI28_DPA      (1U)  //!< Bitfield size in bits for DMA_DCHPRI28_DPA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI28_DPA field.
#define BR_DMA_DCHPRI28_DPA()   (BITBAND_ACCESS8(HW_DMA_DCHPRI28_ADDR, BP_DMA_DCHPRI28_DPA))
#endif

//! @brief Format value for bitfield DMA_DCHPRI28_DPA.
#define BF_DMA_DCHPRI28_DPA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI28_DPA), uint8_t) & BM_DMA_DCHPRI28_DPA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPA field to a new value.
#define BW_DMA_DCHPRI28_DPA(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI28_ADDR, BP_DMA_DCHPRI28_DPA) = (v))
#endif
//@}

/*! @name Register DMA_DCHPRI28, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channels service request
 * - 1 - Channel n can be temporarily suspended by the service request of a higher priority channel
 */
//@{
#define BP_DMA_DCHPRI28_ECP      (7U)      //!< Bit position for DMA_DCHPRI28_ECP.
#define BM_DMA_DCHPRI28_ECP      (0x80U)  //!< Bit mask for DMA_DCHPRI28_ECP.
#define BS_DMA_DCHPRI28_ECP      (1U)  //!< Bitfield size in bits for DMA_DCHPRI28_ECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_DCHPRI28_ECP field.
#define BR_DMA_DCHPRI28_ECP()   (BITBAND_ACCESS8(HW_DMA_DCHPRI28_ADDR, BP_DMA_DCHPRI28_ECP))
#endif

//! @brief Format value for bitfield DMA_DCHPRI28_ECP.
#define BF_DMA_DCHPRI28_ECP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_DMA_DCHPRI28_ECP), uint8_t) & BM_DMA_DCHPRI28_ECP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECP field to a new value.
#define BW_DMA_DCHPRI28_ECP(v)   (BITBAND_ACCESS8(HW_DMA_DCHPRI28_ADDR, BP_DMA_DCHPRI28_ECP) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd0_saddr
{
    uint32_t U;
    struct _hw_dma_tcd0_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd0_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_SADDR register
 */
//@{
#define HW_DMA_TCD0_SADDR_ADDR      (REGS_DMA_BASE + 0x1000U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_SADDR           (*(__IO hw_dma_tcd0_saddr_t *) HW_DMA_TCD0_SADDR_ADDR)
#define HW_DMA_TCD0_SADDR_RD()      (HW_DMA_TCD0_SADDR.U)
#define HW_DMA_TCD0_SADDR_WR(v)     (HW_DMA_TCD0_SADDR.U = (v))
#define HW_DMA_TCD0_SADDR_SET(v)    (HW_DMA_TCD0_SADDR_WR(HW_DMA_TCD0_SADDR_RD() |  (v)))
#define HW_DMA_TCD0_SADDR_CLR(v)    (HW_DMA_TCD0_SADDR_WR(HW_DMA_TCD0_SADDR_RD() & ~(v)))
#define HW_DMA_TCD0_SADDR_TOG(v)    (HW_DMA_TCD0_SADDR_WR(HW_DMA_TCD0_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_SADDR bitfields
 */

/*! @name Register DMA_TCD0_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD0_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD0_SADDR_SADDR.
#define BM_DMA_TCD0_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD0_SADDR_SADDR.
#define BS_DMA_TCD0_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD0_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_SADDR_SADDR field.
#define BR_DMA_TCD0_SADDR_SADDR()   (HW_DMA_TCD0_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD0_SADDR_SADDR.
#define BF_DMA_TCD0_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_SADDR_SADDR), uint32_t) & BM_DMA_TCD0_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD0_SADDR_SADDR(v)   (HW_DMA_TCD0_SADDR_WR((HW_DMA_TCD0_SADDR_RD() & ~BM_DMA_TCD0_SADDR_SADDR) | BF_DMA_TCD0_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd0_soff
{
    uint16_t U;
    struct _hw_dma_tcd0_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd0_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_SOFF register
 */
//@{
#define HW_DMA_TCD0_SOFF_ADDR      (REGS_DMA_BASE + 0x1004U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_SOFF           (*(__IO hw_dma_tcd0_soff_t *) HW_DMA_TCD0_SOFF_ADDR)
#define HW_DMA_TCD0_SOFF_RD()      (HW_DMA_TCD0_SOFF.U)
#define HW_DMA_TCD0_SOFF_WR(v)     (HW_DMA_TCD0_SOFF.U = (v))
#define HW_DMA_TCD0_SOFF_SET(v)    (HW_DMA_TCD0_SOFF_WR(HW_DMA_TCD0_SOFF_RD() |  (v)))
#define HW_DMA_TCD0_SOFF_CLR(v)    (HW_DMA_TCD0_SOFF_WR(HW_DMA_TCD0_SOFF_RD() & ~(v)))
#define HW_DMA_TCD0_SOFF_TOG(v)    (HW_DMA_TCD0_SOFF_WR(HW_DMA_TCD0_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_SOFF bitfields
 */

/*! @name Register DMA_TCD0_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD0_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD0_SOFF_SOFF.
#define BM_DMA_TCD0_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD0_SOFF_SOFF.
#define BS_DMA_TCD0_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD0_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_SOFF_SOFF field.
#define BR_DMA_TCD0_SOFF_SOFF()   (HW_DMA_TCD0_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD0_SOFF_SOFF.
#define BF_DMA_TCD0_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_SOFF_SOFF), uint16_t) & BM_DMA_TCD0_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD0_SOFF_SOFF(v)   (HW_DMA_TCD0_SOFF_WR((HW_DMA_TCD0_SOFF_RD() & ~BM_DMA_TCD0_SOFF_SOFF) | BF_DMA_TCD0_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd0_attr
{
    uint16_t U;
    struct _hw_dma_tcd0_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd0_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_ATTR register
 */
//@{
#define HW_DMA_TCD0_ATTR_ADDR      (REGS_DMA_BASE + 0x1006U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_ATTR           (*(__IO hw_dma_tcd0_attr_t *) HW_DMA_TCD0_ATTR_ADDR)
#define HW_DMA_TCD0_ATTR_RD()      (HW_DMA_TCD0_ATTR.U)
#define HW_DMA_TCD0_ATTR_WR(v)     (HW_DMA_TCD0_ATTR.U = (v))
#define HW_DMA_TCD0_ATTR_SET(v)    (HW_DMA_TCD0_ATTR_WR(HW_DMA_TCD0_ATTR_RD() |  (v)))
#define HW_DMA_TCD0_ATTR_CLR(v)    (HW_DMA_TCD0_ATTR_WR(HW_DMA_TCD0_ATTR_RD() & ~(v)))
#define HW_DMA_TCD0_ATTR_TOG(v)    (HW_DMA_TCD0_ATTR_WR(HW_DMA_TCD0_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_ATTR bitfields
 */

/*! @name Register DMA_TCD0_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD0_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD0_ATTR_DSIZE.
#define BM_DMA_TCD0_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD0_ATTR_DSIZE.
#define BS_DMA_TCD0_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD0_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_ATTR_DSIZE field.
#define BR_DMA_TCD0_ATTR_DSIZE()   (HW_DMA_TCD0_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD0_ATTR_DSIZE.
#define BF_DMA_TCD0_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_ATTR_DSIZE), uint16_t) & BM_DMA_TCD0_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD0_ATTR_DSIZE(v)   (HW_DMA_TCD0_ATTR_WR((HW_DMA_TCD0_ATTR_RD() & ~BM_DMA_TCD0_ATTR_DSIZE) | BF_DMA_TCD0_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD0_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD0_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD0_ATTR_DMOD.
#define BM_DMA_TCD0_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD0_ATTR_DMOD.
#define BS_DMA_TCD0_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD0_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_ATTR_DMOD field.
#define BR_DMA_TCD0_ATTR_DMOD()   (HW_DMA_TCD0_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD0_ATTR_DMOD.
#define BF_DMA_TCD0_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_ATTR_DMOD), uint16_t) & BM_DMA_TCD0_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD0_ATTR_DMOD(v)   (HW_DMA_TCD0_ATTR_WR((HW_DMA_TCD0_ATTR_RD() & ~BM_DMA_TCD0_ATTR_DMOD) | BF_DMA_TCD0_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD0_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD0_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD0_ATTR_SSIZE.
#define BM_DMA_TCD0_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD0_ATTR_SSIZE.
#define BS_DMA_TCD0_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD0_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_ATTR_SSIZE field.
#define BR_DMA_TCD0_ATTR_SSIZE()   (HW_DMA_TCD0_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD0_ATTR_SSIZE.
#define BF_DMA_TCD0_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_ATTR_SSIZE), uint16_t) & BM_DMA_TCD0_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD0_ATTR_SSIZE(v)   (HW_DMA_TCD0_ATTR_WR((HW_DMA_TCD0_ATTR_RD() & ~BM_DMA_TCD0_ATTR_SSIZE) | BF_DMA_TCD0_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD0_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD0_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD0_ATTR_SMOD.
#define BM_DMA_TCD0_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD0_ATTR_SMOD.
#define BS_DMA_TCD0_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD0_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_ATTR_SMOD field.
#define BR_DMA_TCD0_ATTR_SMOD()   (HW_DMA_TCD0_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD0_ATTR_SMOD.
#define BF_DMA_TCD0_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_ATTR_SMOD), uint16_t) & BM_DMA_TCD0_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD0_ATTR_SMOD(v)   (HW_DMA_TCD0_ATTR_WR((HW_DMA_TCD0_ATTR_RD() & ~BM_DMA_TCD0_ATTR_SMOD) | BF_DMA_TCD0_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd0_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd0_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd0_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD0_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1008U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_NBYTES_MLNO           (*(__IO hw_dma_tcd0_nbytes_mlno_t *) HW_DMA_TCD0_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD0_NBYTES_MLNO_RD()      (HW_DMA_TCD0_NBYTES_MLNO.U)
#define HW_DMA_TCD0_NBYTES_MLNO_WR(v)     (HW_DMA_TCD0_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD0_NBYTES_MLNO_SET(v)    (HW_DMA_TCD0_NBYTES_MLNO_WR(HW_DMA_TCD0_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD0_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD0_NBYTES_MLNO_WR(HW_DMA_TCD0_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD0_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD0_NBYTES_MLNO_WR(HW_DMA_TCD0_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD0_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD0_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD0_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD0_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD0_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD0_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD0_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD0_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD0_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD0_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD0_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD0_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD0_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD0_NBYTES_MLNO_WR((HW_DMA_TCD0_NBYTES_MLNO_RD() & ~BM_DMA_TCD0_NBYTES_MLNO_NBYTES) | BF_DMA_TCD0_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd0_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd0_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd0_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD0_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1008U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd0_nbytes_mloffno_t *) HW_DMA_TCD0_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD0_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD0_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD0_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD0_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD0_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD0_NBYTES_MLOFFNO_WR(HW_DMA_TCD0_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD0_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD0_NBYTES_MLOFFNO_WR(HW_DMA_TCD0_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD0_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD0_NBYTES_MLOFFNO_WR(HW_DMA_TCD0_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD0_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD0_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD0_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD0_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD0_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD0_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD0_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD0_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD0_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD0_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD0_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD0_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD0_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD0_NBYTES_MLOFFNO_WR((HW_DMA_TCD0_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD0_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD0_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD0_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD0_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD0_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD0_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD0_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD0_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD0_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD0_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD0_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD0_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD0_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD0_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD0_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD0_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD0_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD0_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD0_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD0_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD0_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD0_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD0_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD0_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD0_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD0_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD0_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD0_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD0_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD0_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD0_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD0_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD0_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd0_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd0_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd0_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD0_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1008U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd0_nbytes_mloffyes_t *) HW_DMA_TCD0_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD0_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD0_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD0_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD0_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD0_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD0_NBYTES_MLOFFYES_WR(HW_DMA_TCD0_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD0_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD0_NBYTES_MLOFFYES_WR(HW_DMA_TCD0_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD0_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD0_NBYTES_MLOFFYES_WR(HW_DMA_TCD0_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD0_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD0_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD0_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD0_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD0_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD0_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD0_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD0_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD0_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD0_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD0_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD0_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD0_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD0_NBYTES_MLOFFYES_WR((HW_DMA_TCD0_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD0_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD0_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD0_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD0_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD0_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD0_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD0_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD0_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD0_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD0_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD0_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD0_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD0_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD0_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD0_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD0_NBYTES_MLOFFYES_WR((HW_DMA_TCD0_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD0_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD0_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD0_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD0_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD0_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD0_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD0_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD0_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD0_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD0_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD0_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD0_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD0_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD0_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD0_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD0_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD0_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD0_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD0_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD0_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD0_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD0_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD0_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD0_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD0_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD0_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD0_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD0_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD0_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD0_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD0_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD0_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD0_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd0_slast
{
    uint32_t U;
    struct _hw_dma_tcd0_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd0_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_SLAST register
 */
//@{
#define HW_DMA_TCD0_SLAST_ADDR      (REGS_DMA_BASE + 0x100cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_SLAST           (*(__IO hw_dma_tcd0_slast_t *) HW_DMA_TCD0_SLAST_ADDR)
#define HW_DMA_TCD0_SLAST_RD()      (HW_DMA_TCD0_SLAST.U)
#define HW_DMA_TCD0_SLAST_WR(v)     (HW_DMA_TCD0_SLAST.U = (v))
#define HW_DMA_TCD0_SLAST_SET(v)    (HW_DMA_TCD0_SLAST_WR(HW_DMA_TCD0_SLAST_RD() |  (v)))
#define HW_DMA_TCD0_SLAST_CLR(v)    (HW_DMA_TCD0_SLAST_WR(HW_DMA_TCD0_SLAST_RD() & ~(v)))
#define HW_DMA_TCD0_SLAST_TOG(v)    (HW_DMA_TCD0_SLAST_WR(HW_DMA_TCD0_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_SLAST bitfields
 */

/*! @name Register DMA_TCD0_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD0_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD0_SLAST_SLAST.
#define BM_DMA_TCD0_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD0_SLAST_SLAST.
#define BS_DMA_TCD0_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD0_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_SLAST_SLAST field.
#define BR_DMA_TCD0_SLAST_SLAST()   (HW_DMA_TCD0_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD0_SLAST_SLAST.
#define BF_DMA_TCD0_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_SLAST_SLAST), uint32_t) & BM_DMA_TCD0_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD0_SLAST_SLAST(v)   (HW_DMA_TCD0_SLAST_WR((HW_DMA_TCD0_SLAST_RD() & ~BM_DMA_TCD0_SLAST_SLAST) | BF_DMA_TCD0_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd0_daddr
{
    uint32_t U;
    struct _hw_dma_tcd0_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd0_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_DADDR register
 */
//@{
#define HW_DMA_TCD0_DADDR_ADDR      (REGS_DMA_BASE + 0x1010U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_DADDR           (*(__IO hw_dma_tcd0_daddr_t *) HW_DMA_TCD0_DADDR_ADDR)
#define HW_DMA_TCD0_DADDR_RD()      (HW_DMA_TCD0_DADDR.U)
#define HW_DMA_TCD0_DADDR_WR(v)     (HW_DMA_TCD0_DADDR.U = (v))
#define HW_DMA_TCD0_DADDR_SET(v)    (HW_DMA_TCD0_DADDR_WR(HW_DMA_TCD0_DADDR_RD() |  (v)))
#define HW_DMA_TCD0_DADDR_CLR(v)    (HW_DMA_TCD0_DADDR_WR(HW_DMA_TCD0_DADDR_RD() & ~(v)))
#define HW_DMA_TCD0_DADDR_TOG(v)    (HW_DMA_TCD0_DADDR_WR(HW_DMA_TCD0_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_DADDR bitfields
 */

/*! @name Register DMA_TCD0_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD0_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD0_DADDR_DADDR.
#define BM_DMA_TCD0_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD0_DADDR_DADDR.
#define BS_DMA_TCD0_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD0_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_DADDR_DADDR field.
#define BR_DMA_TCD0_DADDR_DADDR()   (HW_DMA_TCD0_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD0_DADDR_DADDR.
#define BF_DMA_TCD0_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_DADDR_DADDR), uint32_t) & BM_DMA_TCD0_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD0_DADDR_DADDR(v)   (HW_DMA_TCD0_DADDR_WR((HW_DMA_TCD0_DADDR_RD() & ~BM_DMA_TCD0_DADDR_DADDR) | BF_DMA_TCD0_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd0_doff
{
    uint16_t U;
    struct _hw_dma_tcd0_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd0_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_DOFF register
 */
//@{
#define HW_DMA_TCD0_DOFF_ADDR      (REGS_DMA_BASE + 0x1014U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_DOFF           (*(__IO hw_dma_tcd0_doff_t *) HW_DMA_TCD0_DOFF_ADDR)
#define HW_DMA_TCD0_DOFF_RD()      (HW_DMA_TCD0_DOFF.U)
#define HW_DMA_TCD0_DOFF_WR(v)     (HW_DMA_TCD0_DOFF.U = (v))
#define HW_DMA_TCD0_DOFF_SET(v)    (HW_DMA_TCD0_DOFF_WR(HW_DMA_TCD0_DOFF_RD() |  (v)))
#define HW_DMA_TCD0_DOFF_CLR(v)    (HW_DMA_TCD0_DOFF_WR(HW_DMA_TCD0_DOFF_RD() & ~(v)))
#define HW_DMA_TCD0_DOFF_TOG(v)    (HW_DMA_TCD0_DOFF_WR(HW_DMA_TCD0_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_DOFF bitfields
 */

/*! @name Register DMA_TCD0_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD0_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD0_DOFF_DOFF.
#define BM_DMA_TCD0_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD0_DOFF_DOFF.
#define BS_DMA_TCD0_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD0_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_DOFF_DOFF field.
#define BR_DMA_TCD0_DOFF_DOFF()   (HW_DMA_TCD0_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD0_DOFF_DOFF.
#define BF_DMA_TCD0_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_DOFF_DOFF), uint16_t) & BM_DMA_TCD0_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD0_DOFF_DOFF(v)   (HW_DMA_TCD0_DOFF_WR((HW_DMA_TCD0_DOFF_RD() & ~BM_DMA_TCD0_DOFF_DOFF) | BF_DMA_TCD0_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd0_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd0_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd0_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD0_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1016U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_CITER_ELINKYES           (*(__IO hw_dma_tcd0_citer_elinkyes_t *) HW_DMA_TCD0_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD0_CITER_ELINKYES_RD()      (HW_DMA_TCD0_CITER_ELINKYES.U)
#define HW_DMA_TCD0_CITER_ELINKYES_WR(v)     (HW_DMA_TCD0_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD0_CITER_ELINKYES_SET(v)    (HW_DMA_TCD0_CITER_ELINKYES_WR(HW_DMA_TCD0_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD0_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD0_CITER_ELINKYES_WR(HW_DMA_TCD0_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD0_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD0_CITER_ELINKYES_WR(HW_DMA_TCD0_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD0_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD0_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD0_CITER_ELINKYES_CITER.
#define BM_DMA_TCD0_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD0_CITER_ELINKYES_CITER.
#define BS_DMA_TCD0_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD0_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD0_CITER_ELINKYES_CITER()   (HW_DMA_TCD0_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD0_CITER_ELINKYES_CITER.
#define BF_DMA_TCD0_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD0_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD0_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD0_CITER_ELINKYES_WR((HW_DMA_TCD0_CITER_ELINKYES_RD() & ~BM_DMA_TCD0_CITER_ELINKYES_CITER) | BF_DMA_TCD0_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD0_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD0_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD0_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD0_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD0_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD0_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD0_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD0_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD0_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD0_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD0_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD0_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD0_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD0_CITER_ELINKYES_WR((HW_DMA_TCD0_CITER_ELINKYES_RD() & ~BM_DMA_TCD0_CITER_ELINKYES_LINKCH) | BF_DMA_TCD0_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD0_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD0_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD0_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD0_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD0_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD0_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD0_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD0_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD0_CITER_ELINKYES_ADDR, BP_DMA_TCD0_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD0_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD0_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD0_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD0_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CITER_ELINKYES_ADDR, BP_DMA_TCD0_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd0_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd0_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd0_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD0_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1016U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_CITER_ELINKNO           (*(__IO hw_dma_tcd0_citer_elinkno_t *) HW_DMA_TCD0_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD0_CITER_ELINKNO_RD()      (HW_DMA_TCD0_CITER_ELINKNO.U)
#define HW_DMA_TCD0_CITER_ELINKNO_WR(v)     (HW_DMA_TCD0_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD0_CITER_ELINKNO_SET(v)    (HW_DMA_TCD0_CITER_ELINKNO_WR(HW_DMA_TCD0_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD0_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD0_CITER_ELINKNO_WR(HW_DMA_TCD0_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD0_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD0_CITER_ELINKNO_WR(HW_DMA_TCD0_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD0_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD0_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD0_CITER_ELINKNO_CITER.
#define BM_DMA_TCD0_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD0_CITER_ELINKNO_CITER.
#define BS_DMA_TCD0_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD0_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD0_CITER_ELINKNO_CITER()   (HW_DMA_TCD0_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD0_CITER_ELINKNO_CITER.
#define BF_DMA_TCD0_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD0_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD0_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD0_CITER_ELINKNO_WR((HW_DMA_TCD0_CITER_ELINKNO_RD() & ~BM_DMA_TCD0_CITER_ELINKNO_CITER) | BF_DMA_TCD0_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD0_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD0_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD0_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD0_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD0_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD0_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD0_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD0_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD0_CITER_ELINKNO_ADDR, BP_DMA_TCD0_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD0_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD0_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD0_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD0_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CITER_ELINKNO_ADDR, BP_DMA_TCD0_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd0_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd0_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd0_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_DLASTSGA register
 */
//@{
#define HW_DMA_TCD0_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1018U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_DLASTSGA           (*(__IO hw_dma_tcd0_dlastsga_t *) HW_DMA_TCD0_DLASTSGA_ADDR)
#define HW_DMA_TCD0_DLASTSGA_RD()      (HW_DMA_TCD0_DLASTSGA.U)
#define HW_DMA_TCD0_DLASTSGA_WR(v)     (HW_DMA_TCD0_DLASTSGA.U = (v))
#define HW_DMA_TCD0_DLASTSGA_SET(v)    (HW_DMA_TCD0_DLASTSGA_WR(HW_DMA_TCD0_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD0_DLASTSGA_CLR(v)    (HW_DMA_TCD0_DLASTSGA_WR(HW_DMA_TCD0_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD0_DLASTSGA_TOG(v)    (HW_DMA_TCD0_DLASTSGA_WR(HW_DMA_TCD0_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD0_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD0_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD0_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD0_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD0_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD0_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD0_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD0_DLASTSGA_DLASTSGA()   (HW_DMA_TCD0_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD0_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD0_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD0_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD0_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD0_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD0_DLASTSGA_WR((HW_DMA_TCD0_DLASTSGA_RD() & ~BM_DMA_TCD0_DLASTSGA_DLASTSGA) | BF_DMA_TCD0_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd0_csr
{
    uint16_t U;
    struct _hw_dma_tcd0_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd0_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_CSR register
 */
//@{
#define HW_DMA_TCD0_CSR_ADDR      (REGS_DMA_BASE + 0x101cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_CSR           (*(__IO hw_dma_tcd0_csr_t *) HW_DMA_TCD0_CSR_ADDR)
#define HW_DMA_TCD0_CSR_RD()      (HW_DMA_TCD0_CSR.U)
#define HW_DMA_TCD0_CSR_WR(v)     (HW_DMA_TCD0_CSR.U = (v))
#define HW_DMA_TCD0_CSR_SET(v)    (HW_DMA_TCD0_CSR_WR(HW_DMA_TCD0_CSR_RD() |  (v)))
#define HW_DMA_TCD0_CSR_CLR(v)    (HW_DMA_TCD0_CSR_WR(HW_DMA_TCD0_CSR_RD() & ~(v)))
#define HW_DMA_TCD0_CSR_TOG(v)    (HW_DMA_TCD0_CSR_WR(HW_DMA_TCD0_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_CSR bitfields
 */

/*! @name Register DMA_TCD0_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD0_CSR_START      (0U)      //!< Bit position for DMA_TCD0_CSR_START.
#define BM_DMA_TCD0_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD0_CSR_START.
#define BS_DMA_TCD0_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD0_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_START field.
#define BR_DMA_TCD0_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_START.
#define BF_DMA_TCD0_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_START), uint16_t) & BM_DMA_TCD0_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD0_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD0_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD0_CSR_INTMAJOR.
#define BM_DMA_TCD0_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD0_CSR_INTMAJOR.
#define BS_DMA_TCD0_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD0_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_INTMAJOR field.
#define BR_DMA_TCD0_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_INTMAJOR.
#define BF_DMA_TCD0_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD0_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD0_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD0_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD0_CSR_INTHALF.
#define BM_DMA_TCD0_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD0_CSR_INTHALF.
#define BS_DMA_TCD0_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD0_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_INTHALF field.
#define BR_DMA_TCD0_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_INTHALF.
#define BF_DMA_TCD0_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_INTHALF), uint16_t) & BM_DMA_TCD0_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD0_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD0_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD0_CSR_DREQ.
#define BM_DMA_TCD0_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD0_CSR_DREQ.
#define BS_DMA_TCD0_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD0_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_DREQ field.
#define BR_DMA_TCD0_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_DREQ.
#define BF_DMA_TCD0_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_DREQ), uint16_t) & BM_DMA_TCD0_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD0_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD0_CSR_ESG      (4U)      //!< Bit position for DMA_TCD0_CSR_ESG.
#define BM_DMA_TCD0_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD0_CSR_ESG.
#define BS_DMA_TCD0_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD0_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_ESG field.
#define BR_DMA_TCD0_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_ESG.
#define BF_DMA_TCD0_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_ESG), uint16_t) & BM_DMA_TCD0_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD0_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD0_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD0_CSR_MAJORELINK.
#define BM_DMA_TCD0_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD0_CSR_MAJORELINK.
#define BS_DMA_TCD0_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD0_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_MAJORELINK field.
#define BR_DMA_TCD0_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_MAJORELINK.
#define BF_DMA_TCD0_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD0_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD0_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD0_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD0_CSR_ACTIVE.
#define BM_DMA_TCD0_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD0_CSR_ACTIVE.
#define BS_DMA_TCD0_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD0_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_ACTIVE field.
#define BR_DMA_TCD0_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_ACTIVE.
#define BF_DMA_TCD0_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_ACTIVE), uint16_t) & BM_DMA_TCD0_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD0_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD0_CSR_DONE      (7U)      //!< Bit position for DMA_TCD0_CSR_DONE.
#define BM_DMA_TCD0_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD0_CSR_DONE.
#define BS_DMA_TCD0_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD0_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_DONE field.
#define BR_DMA_TCD0_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_DONE.
#define BF_DMA_TCD0_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_DONE), uint16_t) & BM_DMA_TCD0_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD0_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_CSR_ADDR, BP_DMA_TCD0_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD0_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD0_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD0_CSR_MAJORLINKCH.
#define BM_DMA_TCD0_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD0_CSR_MAJORLINKCH.
#define BS_DMA_TCD0_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD0_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_MAJORLINKCH field.
#define BR_DMA_TCD0_CSR_MAJORLINKCH()   (HW_DMA_TCD0_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_MAJORLINKCH.
#define BF_DMA_TCD0_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD0_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD0_CSR_MAJORLINKCH(v)   (HW_DMA_TCD0_CSR_WR((HW_DMA_TCD0_CSR_RD() & ~BM_DMA_TCD0_CSR_MAJORLINKCH) | BF_DMA_TCD0_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD0_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD0_CSR_BWC      (14U)      //!< Bit position for DMA_TCD0_CSR_BWC.
#define BM_DMA_TCD0_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD0_CSR_BWC.
#define BS_DMA_TCD0_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD0_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_CSR_BWC field.
#define BR_DMA_TCD0_CSR_BWC()   (HW_DMA_TCD0_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD0_CSR_BWC.
#define BF_DMA_TCD0_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_CSR_BWC), uint16_t) & BM_DMA_TCD0_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD0_CSR_BWC(v)   (HW_DMA_TCD0_CSR_WR((HW_DMA_TCD0_CSR_RD() & ~BM_DMA_TCD0_CSR_BWC) | BF_DMA_TCD0_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd0_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd0_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd0_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD0_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x101eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_BITER_ELINKYES           (*(__IO hw_dma_tcd0_biter_elinkyes_t *) HW_DMA_TCD0_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD0_BITER_ELINKYES_RD()      (HW_DMA_TCD0_BITER_ELINKYES.U)
#define HW_DMA_TCD0_BITER_ELINKYES_WR(v)     (HW_DMA_TCD0_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD0_BITER_ELINKYES_SET(v)    (HW_DMA_TCD0_BITER_ELINKYES_WR(HW_DMA_TCD0_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD0_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD0_BITER_ELINKYES_WR(HW_DMA_TCD0_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD0_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD0_BITER_ELINKYES_WR(HW_DMA_TCD0_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD0_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD0_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD0_BITER_ELINKYES_BITER.
#define BM_DMA_TCD0_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD0_BITER_ELINKYES_BITER.
#define BS_DMA_TCD0_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD0_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD0_BITER_ELINKYES_BITER()   (HW_DMA_TCD0_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD0_BITER_ELINKYES_BITER.
#define BF_DMA_TCD0_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD0_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD0_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD0_BITER_ELINKYES_WR((HW_DMA_TCD0_BITER_ELINKYES_RD() & ~BM_DMA_TCD0_BITER_ELINKYES_BITER) | BF_DMA_TCD0_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD0_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD0_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD0_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD0_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD0_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD0_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD0_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD0_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD0_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD0_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD0_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD0_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD0_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD0_BITER_ELINKYES_WR((HW_DMA_TCD0_BITER_ELINKYES_RD() & ~BM_DMA_TCD0_BITER_ELINKYES_LINKCH) | BF_DMA_TCD0_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD0_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD0_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD0_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD0_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD0_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD0_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD0_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD0_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD0_BITER_ELINKYES_ADDR, BP_DMA_TCD0_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD0_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD0_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD0_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD0_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_BITER_ELINKYES_ADDR, BP_DMA_TCD0_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD0_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD0_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd0_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd0_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd0_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD0_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD0_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x101eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD0_BITER_ELINKNO           (*(__IO hw_dma_tcd0_biter_elinkno_t *) HW_DMA_TCD0_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD0_BITER_ELINKNO_RD()      (HW_DMA_TCD0_BITER_ELINKNO.U)
#define HW_DMA_TCD0_BITER_ELINKNO_WR(v)     (HW_DMA_TCD0_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD0_BITER_ELINKNO_SET(v)    (HW_DMA_TCD0_BITER_ELINKNO_WR(HW_DMA_TCD0_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD0_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD0_BITER_ELINKNO_WR(HW_DMA_TCD0_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD0_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD0_BITER_ELINKNO_WR(HW_DMA_TCD0_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD0_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD0_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD0_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD0_BITER_ELINKNO_BITER.
#define BM_DMA_TCD0_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD0_BITER_ELINKNO_BITER.
#define BS_DMA_TCD0_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD0_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD0_BITER_ELINKNO_BITER()   (HW_DMA_TCD0_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD0_BITER_ELINKNO_BITER.
#define BF_DMA_TCD0_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD0_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD0_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD0_BITER_ELINKNO_WR((HW_DMA_TCD0_BITER_ELINKNO_RD() & ~BM_DMA_TCD0_BITER_ELINKNO_BITER) | BF_DMA_TCD0_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD0_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD0_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD0_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD0_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD0_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD0_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD0_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD0_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD0_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD0_BITER_ELINKNO_ADDR, BP_DMA_TCD0_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD0_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD0_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD0_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD0_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD0_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD0_BITER_ELINKNO_ADDR, BP_DMA_TCD0_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd1_saddr
{
    uint32_t U;
    struct _hw_dma_tcd1_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd1_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_SADDR register
 */
//@{
#define HW_DMA_TCD1_SADDR_ADDR      (REGS_DMA_BASE + 0x1020U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_SADDR           (*(__IO hw_dma_tcd1_saddr_t *) HW_DMA_TCD1_SADDR_ADDR)
#define HW_DMA_TCD1_SADDR_RD()      (HW_DMA_TCD1_SADDR.U)
#define HW_DMA_TCD1_SADDR_WR(v)     (HW_DMA_TCD1_SADDR.U = (v))
#define HW_DMA_TCD1_SADDR_SET(v)    (HW_DMA_TCD1_SADDR_WR(HW_DMA_TCD1_SADDR_RD() |  (v)))
#define HW_DMA_TCD1_SADDR_CLR(v)    (HW_DMA_TCD1_SADDR_WR(HW_DMA_TCD1_SADDR_RD() & ~(v)))
#define HW_DMA_TCD1_SADDR_TOG(v)    (HW_DMA_TCD1_SADDR_WR(HW_DMA_TCD1_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_SADDR bitfields
 */

/*! @name Register DMA_TCD1_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD1_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD1_SADDR_SADDR.
#define BM_DMA_TCD1_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD1_SADDR_SADDR.
#define BS_DMA_TCD1_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD1_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_SADDR_SADDR field.
#define BR_DMA_TCD1_SADDR_SADDR()   (HW_DMA_TCD1_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD1_SADDR_SADDR.
#define BF_DMA_TCD1_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_SADDR_SADDR), uint32_t) & BM_DMA_TCD1_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD1_SADDR_SADDR(v)   (HW_DMA_TCD1_SADDR_WR((HW_DMA_TCD1_SADDR_RD() & ~BM_DMA_TCD1_SADDR_SADDR) | BF_DMA_TCD1_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd1_soff
{
    uint16_t U;
    struct _hw_dma_tcd1_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd1_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_SOFF register
 */
//@{
#define HW_DMA_TCD1_SOFF_ADDR      (REGS_DMA_BASE + 0x1024U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_SOFF           (*(__IO hw_dma_tcd1_soff_t *) HW_DMA_TCD1_SOFF_ADDR)
#define HW_DMA_TCD1_SOFF_RD()      (HW_DMA_TCD1_SOFF.U)
#define HW_DMA_TCD1_SOFF_WR(v)     (HW_DMA_TCD1_SOFF.U = (v))
#define HW_DMA_TCD1_SOFF_SET(v)    (HW_DMA_TCD1_SOFF_WR(HW_DMA_TCD1_SOFF_RD() |  (v)))
#define HW_DMA_TCD1_SOFF_CLR(v)    (HW_DMA_TCD1_SOFF_WR(HW_DMA_TCD1_SOFF_RD() & ~(v)))
#define HW_DMA_TCD1_SOFF_TOG(v)    (HW_DMA_TCD1_SOFF_WR(HW_DMA_TCD1_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_SOFF bitfields
 */

/*! @name Register DMA_TCD1_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD1_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD1_SOFF_SOFF.
#define BM_DMA_TCD1_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD1_SOFF_SOFF.
#define BS_DMA_TCD1_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD1_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_SOFF_SOFF field.
#define BR_DMA_TCD1_SOFF_SOFF()   (HW_DMA_TCD1_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD1_SOFF_SOFF.
#define BF_DMA_TCD1_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_SOFF_SOFF), uint16_t) & BM_DMA_TCD1_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD1_SOFF_SOFF(v)   (HW_DMA_TCD1_SOFF_WR((HW_DMA_TCD1_SOFF_RD() & ~BM_DMA_TCD1_SOFF_SOFF) | BF_DMA_TCD1_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd1_attr
{
    uint16_t U;
    struct _hw_dma_tcd1_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd1_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_ATTR register
 */
//@{
#define HW_DMA_TCD1_ATTR_ADDR      (REGS_DMA_BASE + 0x1026U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_ATTR           (*(__IO hw_dma_tcd1_attr_t *) HW_DMA_TCD1_ATTR_ADDR)
#define HW_DMA_TCD1_ATTR_RD()      (HW_DMA_TCD1_ATTR.U)
#define HW_DMA_TCD1_ATTR_WR(v)     (HW_DMA_TCD1_ATTR.U = (v))
#define HW_DMA_TCD1_ATTR_SET(v)    (HW_DMA_TCD1_ATTR_WR(HW_DMA_TCD1_ATTR_RD() |  (v)))
#define HW_DMA_TCD1_ATTR_CLR(v)    (HW_DMA_TCD1_ATTR_WR(HW_DMA_TCD1_ATTR_RD() & ~(v)))
#define HW_DMA_TCD1_ATTR_TOG(v)    (HW_DMA_TCD1_ATTR_WR(HW_DMA_TCD1_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_ATTR bitfields
 */

/*! @name Register DMA_TCD1_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD1_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD1_ATTR_DSIZE.
#define BM_DMA_TCD1_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD1_ATTR_DSIZE.
#define BS_DMA_TCD1_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD1_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_ATTR_DSIZE field.
#define BR_DMA_TCD1_ATTR_DSIZE()   (HW_DMA_TCD1_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD1_ATTR_DSIZE.
#define BF_DMA_TCD1_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_ATTR_DSIZE), uint16_t) & BM_DMA_TCD1_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD1_ATTR_DSIZE(v)   (HW_DMA_TCD1_ATTR_WR((HW_DMA_TCD1_ATTR_RD() & ~BM_DMA_TCD1_ATTR_DSIZE) | BF_DMA_TCD1_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD1_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD1_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD1_ATTR_DMOD.
#define BM_DMA_TCD1_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD1_ATTR_DMOD.
#define BS_DMA_TCD1_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD1_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_ATTR_DMOD field.
#define BR_DMA_TCD1_ATTR_DMOD()   (HW_DMA_TCD1_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD1_ATTR_DMOD.
#define BF_DMA_TCD1_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_ATTR_DMOD), uint16_t) & BM_DMA_TCD1_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD1_ATTR_DMOD(v)   (HW_DMA_TCD1_ATTR_WR((HW_DMA_TCD1_ATTR_RD() & ~BM_DMA_TCD1_ATTR_DMOD) | BF_DMA_TCD1_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD1_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD1_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD1_ATTR_SSIZE.
#define BM_DMA_TCD1_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD1_ATTR_SSIZE.
#define BS_DMA_TCD1_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD1_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_ATTR_SSIZE field.
#define BR_DMA_TCD1_ATTR_SSIZE()   (HW_DMA_TCD1_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD1_ATTR_SSIZE.
#define BF_DMA_TCD1_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_ATTR_SSIZE), uint16_t) & BM_DMA_TCD1_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD1_ATTR_SSIZE(v)   (HW_DMA_TCD1_ATTR_WR((HW_DMA_TCD1_ATTR_RD() & ~BM_DMA_TCD1_ATTR_SSIZE) | BF_DMA_TCD1_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD1_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD1_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD1_ATTR_SMOD.
#define BM_DMA_TCD1_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD1_ATTR_SMOD.
#define BS_DMA_TCD1_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD1_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_ATTR_SMOD field.
#define BR_DMA_TCD1_ATTR_SMOD()   (HW_DMA_TCD1_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD1_ATTR_SMOD.
#define BF_DMA_TCD1_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_ATTR_SMOD), uint16_t) & BM_DMA_TCD1_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD1_ATTR_SMOD(v)   (HW_DMA_TCD1_ATTR_WR((HW_DMA_TCD1_ATTR_RD() & ~BM_DMA_TCD1_ATTR_SMOD) | BF_DMA_TCD1_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd1_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd1_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd1_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD1_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1028U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_NBYTES_MLNO           (*(__IO hw_dma_tcd1_nbytes_mlno_t *) HW_DMA_TCD1_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD1_NBYTES_MLNO_RD()      (HW_DMA_TCD1_NBYTES_MLNO.U)
#define HW_DMA_TCD1_NBYTES_MLNO_WR(v)     (HW_DMA_TCD1_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD1_NBYTES_MLNO_SET(v)    (HW_DMA_TCD1_NBYTES_MLNO_WR(HW_DMA_TCD1_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD1_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD1_NBYTES_MLNO_WR(HW_DMA_TCD1_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD1_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD1_NBYTES_MLNO_WR(HW_DMA_TCD1_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD1_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD1_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD1_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD1_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD1_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD1_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD1_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD1_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD1_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD1_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD1_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD1_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD1_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD1_NBYTES_MLNO_WR((HW_DMA_TCD1_NBYTES_MLNO_RD() & ~BM_DMA_TCD1_NBYTES_MLNO_NBYTES) | BF_DMA_TCD1_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd1_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd1_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd1_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD1_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1028U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd1_nbytes_mloffno_t *) HW_DMA_TCD1_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD1_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD1_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD1_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD1_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD1_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD1_NBYTES_MLOFFNO_WR(HW_DMA_TCD1_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD1_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD1_NBYTES_MLOFFNO_WR(HW_DMA_TCD1_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD1_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD1_NBYTES_MLOFFNO_WR(HW_DMA_TCD1_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD1_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD1_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD1_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD1_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD1_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD1_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD1_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD1_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD1_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD1_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD1_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD1_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD1_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD1_NBYTES_MLOFFNO_WR((HW_DMA_TCD1_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD1_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD1_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD1_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD1_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD1_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD1_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD1_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD1_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD1_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD1_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD1_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD1_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD1_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD1_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD1_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD1_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD1_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD1_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD1_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD1_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD1_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD1_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD1_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD1_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD1_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD1_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD1_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD1_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD1_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD1_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD1_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD1_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD1_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd1_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd1_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd1_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD1_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1028U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd1_nbytes_mloffyes_t *) HW_DMA_TCD1_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD1_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD1_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD1_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD1_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD1_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD1_NBYTES_MLOFFYES_WR(HW_DMA_TCD1_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD1_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD1_NBYTES_MLOFFYES_WR(HW_DMA_TCD1_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD1_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD1_NBYTES_MLOFFYES_WR(HW_DMA_TCD1_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD1_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD1_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD1_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD1_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD1_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD1_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD1_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD1_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD1_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD1_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD1_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD1_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD1_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD1_NBYTES_MLOFFYES_WR((HW_DMA_TCD1_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD1_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD1_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD1_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD1_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD1_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD1_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD1_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD1_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD1_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD1_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD1_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD1_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD1_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD1_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD1_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD1_NBYTES_MLOFFYES_WR((HW_DMA_TCD1_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD1_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD1_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD1_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD1_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD1_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD1_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD1_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD1_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD1_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD1_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD1_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD1_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD1_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD1_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD1_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD1_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD1_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD1_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD1_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD1_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD1_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD1_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD1_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD1_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD1_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD1_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD1_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD1_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD1_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD1_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD1_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD1_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD1_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd1_slast
{
    uint32_t U;
    struct _hw_dma_tcd1_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd1_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_SLAST register
 */
//@{
#define HW_DMA_TCD1_SLAST_ADDR      (REGS_DMA_BASE + 0x102cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_SLAST           (*(__IO hw_dma_tcd1_slast_t *) HW_DMA_TCD1_SLAST_ADDR)
#define HW_DMA_TCD1_SLAST_RD()      (HW_DMA_TCD1_SLAST.U)
#define HW_DMA_TCD1_SLAST_WR(v)     (HW_DMA_TCD1_SLAST.U = (v))
#define HW_DMA_TCD1_SLAST_SET(v)    (HW_DMA_TCD1_SLAST_WR(HW_DMA_TCD1_SLAST_RD() |  (v)))
#define HW_DMA_TCD1_SLAST_CLR(v)    (HW_DMA_TCD1_SLAST_WR(HW_DMA_TCD1_SLAST_RD() & ~(v)))
#define HW_DMA_TCD1_SLAST_TOG(v)    (HW_DMA_TCD1_SLAST_WR(HW_DMA_TCD1_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_SLAST bitfields
 */

/*! @name Register DMA_TCD1_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD1_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD1_SLAST_SLAST.
#define BM_DMA_TCD1_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD1_SLAST_SLAST.
#define BS_DMA_TCD1_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD1_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_SLAST_SLAST field.
#define BR_DMA_TCD1_SLAST_SLAST()   (HW_DMA_TCD1_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD1_SLAST_SLAST.
#define BF_DMA_TCD1_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_SLAST_SLAST), uint32_t) & BM_DMA_TCD1_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD1_SLAST_SLAST(v)   (HW_DMA_TCD1_SLAST_WR((HW_DMA_TCD1_SLAST_RD() & ~BM_DMA_TCD1_SLAST_SLAST) | BF_DMA_TCD1_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd1_daddr
{
    uint32_t U;
    struct _hw_dma_tcd1_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd1_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_DADDR register
 */
//@{
#define HW_DMA_TCD1_DADDR_ADDR      (REGS_DMA_BASE + 0x1030U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_DADDR           (*(__IO hw_dma_tcd1_daddr_t *) HW_DMA_TCD1_DADDR_ADDR)
#define HW_DMA_TCD1_DADDR_RD()      (HW_DMA_TCD1_DADDR.U)
#define HW_DMA_TCD1_DADDR_WR(v)     (HW_DMA_TCD1_DADDR.U = (v))
#define HW_DMA_TCD1_DADDR_SET(v)    (HW_DMA_TCD1_DADDR_WR(HW_DMA_TCD1_DADDR_RD() |  (v)))
#define HW_DMA_TCD1_DADDR_CLR(v)    (HW_DMA_TCD1_DADDR_WR(HW_DMA_TCD1_DADDR_RD() & ~(v)))
#define HW_DMA_TCD1_DADDR_TOG(v)    (HW_DMA_TCD1_DADDR_WR(HW_DMA_TCD1_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_DADDR bitfields
 */

/*! @name Register DMA_TCD1_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD1_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD1_DADDR_DADDR.
#define BM_DMA_TCD1_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD1_DADDR_DADDR.
#define BS_DMA_TCD1_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD1_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_DADDR_DADDR field.
#define BR_DMA_TCD1_DADDR_DADDR()   (HW_DMA_TCD1_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD1_DADDR_DADDR.
#define BF_DMA_TCD1_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_DADDR_DADDR), uint32_t) & BM_DMA_TCD1_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD1_DADDR_DADDR(v)   (HW_DMA_TCD1_DADDR_WR((HW_DMA_TCD1_DADDR_RD() & ~BM_DMA_TCD1_DADDR_DADDR) | BF_DMA_TCD1_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd1_doff
{
    uint16_t U;
    struct _hw_dma_tcd1_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd1_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_DOFF register
 */
//@{
#define HW_DMA_TCD1_DOFF_ADDR      (REGS_DMA_BASE + 0x1034U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_DOFF           (*(__IO hw_dma_tcd1_doff_t *) HW_DMA_TCD1_DOFF_ADDR)
#define HW_DMA_TCD1_DOFF_RD()      (HW_DMA_TCD1_DOFF.U)
#define HW_DMA_TCD1_DOFF_WR(v)     (HW_DMA_TCD1_DOFF.U = (v))
#define HW_DMA_TCD1_DOFF_SET(v)    (HW_DMA_TCD1_DOFF_WR(HW_DMA_TCD1_DOFF_RD() |  (v)))
#define HW_DMA_TCD1_DOFF_CLR(v)    (HW_DMA_TCD1_DOFF_WR(HW_DMA_TCD1_DOFF_RD() & ~(v)))
#define HW_DMA_TCD1_DOFF_TOG(v)    (HW_DMA_TCD1_DOFF_WR(HW_DMA_TCD1_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_DOFF bitfields
 */

/*! @name Register DMA_TCD1_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD1_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD1_DOFF_DOFF.
#define BM_DMA_TCD1_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD1_DOFF_DOFF.
#define BS_DMA_TCD1_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD1_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_DOFF_DOFF field.
#define BR_DMA_TCD1_DOFF_DOFF()   (HW_DMA_TCD1_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD1_DOFF_DOFF.
#define BF_DMA_TCD1_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_DOFF_DOFF), uint16_t) & BM_DMA_TCD1_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD1_DOFF_DOFF(v)   (HW_DMA_TCD1_DOFF_WR((HW_DMA_TCD1_DOFF_RD() & ~BM_DMA_TCD1_DOFF_DOFF) | BF_DMA_TCD1_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd1_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd1_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd1_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD1_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1036U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_CITER_ELINKYES           (*(__IO hw_dma_tcd1_citer_elinkyes_t *) HW_DMA_TCD1_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD1_CITER_ELINKYES_RD()      (HW_DMA_TCD1_CITER_ELINKYES.U)
#define HW_DMA_TCD1_CITER_ELINKYES_WR(v)     (HW_DMA_TCD1_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD1_CITER_ELINKYES_SET(v)    (HW_DMA_TCD1_CITER_ELINKYES_WR(HW_DMA_TCD1_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD1_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD1_CITER_ELINKYES_WR(HW_DMA_TCD1_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD1_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD1_CITER_ELINKYES_WR(HW_DMA_TCD1_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD1_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD1_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD1_CITER_ELINKYES_CITER.
#define BM_DMA_TCD1_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD1_CITER_ELINKYES_CITER.
#define BS_DMA_TCD1_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD1_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD1_CITER_ELINKYES_CITER()   (HW_DMA_TCD1_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD1_CITER_ELINKYES_CITER.
#define BF_DMA_TCD1_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD1_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD1_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD1_CITER_ELINKYES_WR((HW_DMA_TCD1_CITER_ELINKYES_RD() & ~BM_DMA_TCD1_CITER_ELINKYES_CITER) | BF_DMA_TCD1_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD1_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD1_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD1_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD1_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD1_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD1_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD1_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD1_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD1_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD1_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD1_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD1_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD1_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD1_CITER_ELINKYES_WR((HW_DMA_TCD1_CITER_ELINKYES_RD() & ~BM_DMA_TCD1_CITER_ELINKYES_LINKCH) | BF_DMA_TCD1_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD1_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD1_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD1_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD1_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD1_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD1_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD1_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD1_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD1_CITER_ELINKYES_ADDR, BP_DMA_TCD1_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD1_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD1_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD1_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD1_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CITER_ELINKYES_ADDR, BP_DMA_TCD1_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd1_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd1_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd1_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD1_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1036U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_CITER_ELINKNO           (*(__IO hw_dma_tcd1_citer_elinkno_t *) HW_DMA_TCD1_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD1_CITER_ELINKNO_RD()      (HW_DMA_TCD1_CITER_ELINKNO.U)
#define HW_DMA_TCD1_CITER_ELINKNO_WR(v)     (HW_DMA_TCD1_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD1_CITER_ELINKNO_SET(v)    (HW_DMA_TCD1_CITER_ELINKNO_WR(HW_DMA_TCD1_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD1_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD1_CITER_ELINKNO_WR(HW_DMA_TCD1_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD1_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD1_CITER_ELINKNO_WR(HW_DMA_TCD1_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD1_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD1_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD1_CITER_ELINKNO_CITER.
#define BM_DMA_TCD1_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD1_CITER_ELINKNO_CITER.
#define BS_DMA_TCD1_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD1_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD1_CITER_ELINKNO_CITER()   (HW_DMA_TCD1_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD1_CITER_ELINKNO_CITER.
#define BF_DMA_TCD1_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD1_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD1_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD1_CITER_ELINKNO_WR((HW_DMA_TCD1_CITER_ELINKNO_RD() & ~BM_DMA_TCD1_CITER_ELINKNO_CITER) | BF_DMA_TCD1_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD1_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD1_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD1_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD1_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD1_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD1_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD1_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD1_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD1_CITER_ELINKNO_ADDR, BP_DMA_TCD1_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD1_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD1_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD1_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD1_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CITER_ELINKNO_ADDR, BP_DMA_TCD1_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd1_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd1_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd1_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_DLASTSGA register
 */
//@{
#define HW_DMA_TCD1_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1038U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_DLASTSGA           (*(__IO hw_dma_tcd1_dlastsga_t *) HW_DMA_TCD1_DLASTSGA_ADDR)
#define HW_DMA_TCD1_DLASTSGA_RD()      (HW_DMA_TCD1_DLASTSGA.U)
#define HW_DMA_TCD1_DLASTSGA_WR(v)     (HW_DMA_TCD1_DLASTSGA.U = (v))
#define HW_DMA_TCD1_DLASTSGA_SET(v)    (HW_DMA_TCD1_DLASTSGA_WR(HW_DMA_TCD1_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD1_DLASTSGA_CLR(v)    (HW_DMA_TCD1_DLASTSGA_WR(HW_DMA_TCD1_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD1_DLASTSGA_TOG(v)    (HW_DMA_TCD1_DLASTSGA_WR(HW_DMA_TCD1_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD1_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD1_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD1_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD1_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD1_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD1_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD1_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD1_DLASTSGA_DLASTSGA()   (HW_DMA_TCD1_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD1_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD1_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD1_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD1_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD1_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD1_DLASTSGA_WR((HW_DMA_TCD1_DLASTSGA_RD() & ~BM_DMA_TCD1_DLASTSGA_DLASTSGA) | BF_DMA_TCD1_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd1_csr
{
    uint16_t U;
    struct _hw_dma_tcd1_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd1_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_CSR register
 */
//@{
#define HW_DMA_TCD1_CSR_ADDR      (REGS_DMA_BASE + 0x103cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_CSR           (*(__IO hw_dma_tcd1_csr_t *) HW_DMA_TCD1_CSR_ADDR)
#define HW_DMA_TCD1_CSR_RD()      (HW_DMA_TCD1_CSR.U)
#define HW_DMA_TCD1_CSR_WR(v)     (HW_DMA_TCD1_CSR.U = (v))
#define HW_DMA_TCD1_CSR_SET(v)    (HW_DMA_TCD1_CSR_WR(HW_DMA_TCD1_CSR_RD() |  (v)))
#define HW_DMA_TCD1_CSR_CLR(v)    (HW_DMA_TCD1_CSR_WR(HW_DMA_TCD1_CSR_RD() & ~(v)))
#define HW_DMA_TCD1_CSR_TOG(v)    (HW_DMA_TCD1_CSR_WR(HW_DMA_TCD1_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_CSR bitfields
 */

/*! @name Register DMA_TCD1_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD1_CSR_START      (0U)      //!< Bit position for DMA_TCD1_CSR_START.
#define BM_DMA_TCD1_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD1_CSR_START.
#define BS_DMA_TCD1_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD1_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_START field.
#define BR_DMA_TCD1_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_START.
#define BF_DMA_TCD1_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_START), uint16_t) & BM_DMA_TCD1_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD1_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD1_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD1_CSR_INTMAJOR.
#define BM_DMA_TCD1_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD1_CSR_INTMAJOR.
#define BS_DMA_TCD1_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD1_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_INTMAJOR field.
#define BR_DMA_TCD1_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_INTMAJOR.
#define BF_DMA_TCD1_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD1_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD1_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD1_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD1_CSR_INTHALF.
#define BM_DMA_TCD1_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD1_CSR_INTHALF.
#define BS_DMA_TCD1_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD1_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_INTHALF field.
#define BR_DMA_TCD1_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_INTHALF.
#define BF_DMA_TCD1_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_INTHALF), uint16_t) & BM_DMA_TCD1_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD1_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD1_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD1_CSR_DREQ.
#define BM_DMA_TCD1_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD1_CSR_DREQ.
#define BS_DMA_TCD1_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD1_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_DREQ field.
#define BR_DMA_TCD1_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_DREQ.
#define BF_DMA_TCD1_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_DREQ), uint16_t) & BM_DMA_TCD1_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD1_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD1_CSR_ESG      (4U)      //!< Bit position for DMA_TCD1_CSR_ESG.
#define BM_DMA_TCD1_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD1_CSR_ESG.
#define BS_DMA_TCD1_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD1_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_ESG field.
#define BR_DMA_TCD1_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_ESG.
#define BF_DMA_TCD1_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_ESG), uint16_t) & BM_DMA_TCD1_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD1_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD1_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD1_CSR_MAJORELINK.
#define BM_DMA_TCD1_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD1_CSR_MAJORELINK.
#define BS_DMA_TCD1_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD1_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_MAJORELINK field.
#define BR_DMA_TCD1_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_MAJORELINK.
#define BF_DMA_TCD1_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD1_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD1_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD1_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD1_CSR_ACTIVE.
#define BM_DMA_TCD1_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD1_CSR_ACTIVE.
#define BS_DMA_TCD1_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD1_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_ACTIVE field.
#define BR_DMA_TCD1_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_ACTIVE.
#define BF_DMA_TCD1_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_ACTIVE), uint16_t) & BM_DMA_TCD1_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD1_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD1_CSR_DONE      (7U)      //!< Bit position for DMA_TCD1_CSR_DONE.
#define BM_DMA_TCD1_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD1_CSR_DONE.
#define BS_DMA_TCD1_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD1_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_DONE field.
#define BR_DMA_TCD1_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_DONE.
#define BF_DMA_TCD1_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_DONE), uint16_t) & BM_DMA_TCD1_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD1_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_CSR_ADDR, BP_DMA_TCD1_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD1_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD1_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD1_CSR_MAJORLINKCH.
#define BM_DMA_TCD1_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD1_CSR_MAJORLINKCH.
#define BS_DMA_TCD1_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD1_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_MAJORLINKCH field.
#define BR_DMA_TCD1_CSR_MAJORLINKCH()   (HW_DMA_TCD1_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_MAJORLINKCH.
#define BF_DMA_TCD1_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD1_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD1_CSR_MAJORLINKCH(v)   (HW_DMA_TCD1_CSR_WR((HW_DMA_TCD1_CSR_RD() & ~BM_DMA_TCD1_CSR_MAJORLINKCH) | BF_DMA_TCD1_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD1_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD1_CSR_BWC      (14U)      //!< Bit position for DMA_TCD1_CSR_BWC.
#define BM_DMA_TCD1_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD1_CSR_BWC.
#define BS_DMA_TCD1_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD1_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_CSR_BWC field.
#define BR_DMA_TCD1_CSR_BWC()   (HW_DMA_TCD1_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD1_CSR_BWC.
#define BF_DMA_TCD1_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_CSR_BWC), uint16_t) & BM_DMA_TCD1_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD1_CSR_BWC(v)   (HW_DMA_TCD1_CSR_WR((HW_DMA_TCD1_CSR_RD() & ~BM_DMA_TCD1_CSR_BWC) | BF_DMA_TCD1_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd1_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd1_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd1_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD1_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x103eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_BITER_ELINKYES           (*(__IO hw_dma_tcd1_biter_elinkyes_t *) HW_DMA_TCD1_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD1_BITER_ELINKYES_RD()      (HW_DMA_TCD1_BITER_ELINKYES.U)
#define HW_DMA_TCD1_BITER_ELINKYES_WR(v)     (HW_DMA_TCD1_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD1_BITER_ELINKYES_SET(v)    (HW_DMA_TCD1_BITER_ELINKYES_WR(HW_DMA_TCD1_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD1_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD1_BITER_ELINKYES_WR(HW_DMA_TCD1_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD1_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD1_BITER_ELINKYES_WR(HW_DMA_TCD1_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD1_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD1_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD1_BITER_ELINKYES_BITER.
#define BM_DMA_TCD1_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD1_BITER_ELINKYES_BITER.
#define BS_DMA_TCD1_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD1_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD1_BITER_ELINKYES_BITER()   (HW_DMA_TCD1_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD1_BITER_ELINKYES_BITER.
#define BF_DMA_TCD1_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD1_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD1_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD1_BITER_ELINKYES_WR((HW_DMA_TCD1_BITER_ELINKYES_RD() & ~BM_DMA_TCD1_BITER_ELINKYES_BITER) | BF_DMA_TCD1_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD1_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD1_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD1_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD1_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD1_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD1_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD1_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD1_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD1_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD1_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD1_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD1_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD1_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD1_BITER_ELINKYES_WR((HW_DMA_TCD1_BITER_ELINKYES_RD() & ~BM_DMA_TCD1_BITER_ELINKYES_LINKCH) | BF_DMA_TCD1_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD1_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD1_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD1_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD1_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD1_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD1_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD1_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD1_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD1_BITER_ELINKYES_ADDR, BP_DMA_TCD1_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD1_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD1_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD1_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD1_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_BITER_ELINKYES_ADDR, BP_DMA_TCD1_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD1_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD1_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd1_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd1_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd1_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD1_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD1_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x103eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD1_BITER_ELINKNO           (*(__IO hw_dma_tcd1_biter_elinkno_t *) HW_DMA_TCD1_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD1_BITER_ELINKNO_RD()      (HW_DMA_TCD1_BITER_ELINKNO.U)
#define HW_DMA_TCD1_BITER_ELINKNO_WR(v)     (HW_DMA_TCD1_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD1_BITER_ELINKNO_SET(v)    (HW_DMA_TCD1_BITER_ELINKNO_WR(HW_DMA_TCD1_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD1_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD1_BITER_ELINKNO_WR(HW_DMA_TCD1_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD1_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD1_BITER_ELINKNO_WR(HW_DMA_TCD1_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD1_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD1_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD1_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD1_BITER_ELINKNO_BITER.
#define BM_DMA_TCD1_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD1_BITER_ELINKNO_BITER.
#define BS_DMA_TCD1_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD1_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD1_BITER_ELINKNO_BITER()   (HW_DMA_TCD1_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD1_BITER_ELINKNO_BITER.
#define BF_DMA_TCD1_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD1_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD1_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD1_BITER_ELINKNO_WR((HW_DMA_TCD1_BITER_ELINKNO_RD() & ~BM_DMA_TCD1_BITER_ELINKNO_BITER) | BF_DMA_TCD1_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD1_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD1_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD1_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD1_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD1_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD1_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD1_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD1_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD1_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD1_BITER_ELINKNO_ADDR, BP_DMA_TCD1_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD1_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD1_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD1_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD1_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD1_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD1_BITER_ELINKNO_ADDR, BP_DMA_TCD1_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd2_saddr
{
    uint32_t U;
    struct _hw_dma_tcd2_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd2_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_SADDR register
 */
//@{
#define HW_DMA_TCD2_SADDR_ADDR      (REGS_DMA_BASE + 0x1040U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_SADDR           (*(__IO hw_dma_tcd2_saddr_t *) HW_DMA_TCD2_SADDR_ADDR)
#define HW_DMA_TCD2_SADDR_RD()      (HW_DMA_TCD2_SADDR.U)
#define HW_DMA_TCD2_SADDR_WR(v)     (HW_DMA_TCD2_SADDR.U = (v))
#define HW_DMA_TCD2_SADDR_SET(v)    (HW_DMA_TCD2_SADDR_WR(HW_DMA_TCD2_SADDR_RD() |  (v)))
#define HW_DMA_TCD2_SADDR_CLR(v)    (HW_DMA_TCD2_SADDR_WR(HW_DMA_TCD2_SADDR_RD() & ~(v)))
#define HW_DMA_TCD2_SADDR_TOG(v)    (HW_DMA_TCD2_SADDR_WR(HW_DMA_TCD2_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_SADDR bitfields
 */

/*! @name Register DMA_TCD2_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD2_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD2_SADDR_SADDR.
#define BM_DMA_TCD2_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD2_SADDR_SADDR.
#define BS_DMA_TCD2_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD2_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_SADDR_SADDR field.
#define BR_DMA_TCD2_SADDR_SADDR()   (HW_DMA_TCD2_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD2_SADDR_SADDR.
#define BF_DMA_TCD2_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_SADDR_SADDR), uint32_t) & BM_DMA_TCD2_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD2_SADDR_SADDR(v)   (HW_DMA_TCD2_SADDR_WR((HW_DMA_TCD2_SADDR_RD() & ~BM_DMA_TCD2_SADDR_SADDR) | BF_DMA_TCD2_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd2_soff
{
    uint16_t U;
    struct _hw_dma_tcd2_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd2_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_SOFF register
 */
//@{
#define HW_DMA_TCD2_SOFF_ADDR      (REGS_DMA_BASE + 0x1044U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_SOFF           (*(__IO hw_dma_tcd2_soff_t *) HW_DMA_TCD2_SOFF_ADDR)
#define HW_DMA_TCD2_SOFF_RD()      (HW_DMA_TCD2_SOFF.U)
#define HW_DMA_TCD2_SOFF_WR(v)     (HW_DMA_TCD2_SOFF.U = (v))
#define HW_DMA_TCD2_SOFF_SET(v)    (HW_DMA_TCD2_SOFF_WR(HW_DMA_TCD2_SOFF_RD() |  (v)))
#define HW_DMA_TCD2_SOFF_CLR(v)    (HW_DMA_TCD2_SOFF_WR(HW_DMA_TCD2_SOFF_RD() & ~(v)))
#define HW_DMA_TCD2_SOFF_TOG(v)    (HW_DMA_TCD2_SOFF_WR(HW_DMA_TCD2_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_SOFF bitfields
 */

/*! @name Register DMA_TCD2_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD2_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD2_SOFF_SOFF.
#define BM_DMA_TCD2_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD2_SOFF_SOFF.
#define BS_DMA_TCD2_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD2_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_SOFF_SOFF field.
#define BR_DMA_TCD2_SOFF_SOFF()   (HW_DMA_TCD2_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD2_SOFF_SOFF.
#define BF_DMA_TCD2_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_SOFF_SOFF), uint16_t) & BM_DMA_TCD2_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD2_SOFF_SOFF(v)   (HW_DMA_TCD2_SOFF_WR((HW_DMA_TCD2_SOFF_RD() & ~BM_DMA_TCD2_SOFF_SOFF) | BF_DMA_TCD2_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd2_attr
{
    uint16_t U;
    struct _hw_dma_tcd2_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd2_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_ATTR register
 */
//@{
#define HW_DMA_TCD2_ATTR_ADDR      (REGS_DMA_BASE + 0x1046U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_ATTR           (*(__IO hw_dma_tcd2_attr_t *) HW_DMA_TCD2_ATTR_ADDR)
#define HW_DMA_TCD2_ATTR_RD()      (HW_DMA_TCD2_ATTR.U)
#define HW_DMA_TCD2_ATTR_WR(v)     (HW_DMA_TCD2_ATTR.U = (v))
#define HW_DMA_TCD2_ATTR_SET(v)    (HW_DMA_TCD2_ATTR_WR(HW_DMA_TCD2_ATTR_RD() |  (v)))
#define HW_DMA_TCD2_ATTR_CLR(v)    (HW_DMA_TCD2_ATTR_WR(HW_DMA_TCD2_ATTR_RD() & ~(v)))
#define HW_DMA_TCD2_ATTR_TOG(v)    (HW_DMA_TCD2_ATTR_WR(HW_DMA_TCD2_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_ATTR bitfields
 */

/*! @name Register DMA_TCD2_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD2_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD2_ATTR_DSIZE.
#define BM_DMA_TCD2_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD2_ATTR_DSIZE.
#define BS_DMA_TCD2_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD2_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_ATTR_DSIZE field.
#define BR_DMA_TCD2_ATTR_DSIZE()   (HW_DMA_TCD2_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD2_ATTR_DSIZE.
#define BF_DMA_TCD2_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_ATTR_DSIZE), uint16_t) & BM_DMA_TCD2_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD2_ATTR_DSIZE(v)   (HW_DMA_TCD2_ATTR_WR((HW_DMA_TCD2_ATTR_RD() & ~BM_DMA_TCD2_ATTR_DSIZE) | BF_DMA_TCD2_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD2_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD2_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD2_ATTR_DMOD.
#define BM_DMA_TCD2_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD2_ATTR_DMOD.
#define BS_DMA_TCD2_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD2_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_ATTR_DMOD field.
#define BR_DMA_TCD2_ATTR_DMOD()   (HW_DMA_TCD2_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD2_ATTR_DMOD.
#define BF_DMA_TCD2_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_ATTR_DMOD), uint16_t) & BM_DMA_TCD2_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD2_ATTR_DMOD(v)   (HW_DMA_TCD2_ATTR_WR((HW_DMA_TCD2_ATTR_RD() & ~BM_DMA_TCD2_ATTR_DMOD) | BF_DMA_TCD2_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD2_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD2_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD2_ATTR_SSIZE.
#define BM_DMA_TCD2_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD2_ATTR_SSIZE.
#define BS_DMA_TCD2_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD2_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_ATTR_SSIZE field.
#define BR_DMA_TCD2_ATTR_SSIZE()   (HW_DMA_TCD2_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD2_ATTR_SSIZE.
#define BF_DMA_TCD2_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_ATTR_SSIZE), uint16_t) & BM_DMA_TCD2_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD2_ATTR_SSIZE(v)   (HW_DMA_TCD2_ATTR_WR((HW_DMA_TCD2_ATTR_RD() & ~BM_DMA_TCD2_ATTR_SSIZE) | BF_DMA_TCD2_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD2_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD2_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD2_ATTR_SMOD.
#define BM_DMA_TCD2_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD2_ATTR_SMOD.
#define BS_DMA_TCD2_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD2_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_ATTR_SMOD field.
#define BR_DMA_TCD2_ATTR_SMOD()   (HW_DMA_TCD2_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD2_ATTR_SMOD.
#define BF_DMA_TCD2_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_ATTR_SMOD), uint16_t) & BM_DMA_TCD2_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD2_ATTR_SMOD(v)   (HW_DMA_TCD2_ATTR_WR((HW_DMA_TCD2_ATTR_RD() & ~BM_DMA_TCD2_ATTR_SMOD) | BF_DMA_TCD2_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd2_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd2_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd2_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD2_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1048U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_NBYTES_MLNO           (*(__IO hw_dma_tcd2_nbytes_mlno_t *) HW_DMA_TCD2_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD2_NBYTES_MLNO_RD()      (HW_DMA_TCD2_NBYTES_MLNO.U)
#define HW_DMA_TCD2_NBYTES_MLNO_WR(v)     (HW_DMA_TCD2_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD2_NBYTES_MLNO_SET(v)    (HW_DMA_TCD2_NBYTES_MLNO_WR(HW_DMA_TCD2_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD2_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD2_NBYTES_MLNO_WR(HW_DMA_TCD2_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD2_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD2_NBYTES_MLNO_WR(HW_DMA_TCD2_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD2_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD2_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD2_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD2_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD2_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD2_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD2_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD2_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD2_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD2_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD2_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD2_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD2_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD2_NBYTES_MLNO_WR((HW_DMA_TCD2_NBYTES_MLNO_RD() & ~BM_DMA_TCD2_NBYTES_MLNO_NBYTES) | BF_DMA_TCD2_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd2_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd2_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd2_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD2_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1048U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd2_nbytes_mloffno_t *) HW_DMA_TCD2_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD2_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD2_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD2_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD2_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD2_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD2_NBYTES_MLOFFNO_WR(HW_DMA_TCD2_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD2_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD2_NBYTES_MLOFFNO_WR(HW_DMA_TCD2_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD2_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD2_NBYTES_MLOFFNO_WR(HW_DMA_TCD2_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD2_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD2_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD2_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD2_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD2_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD2_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD2_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD2_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD2_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD2_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD2_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD2_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD2_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD2_NBYTES_MLOFFNO_WR((HW_DMA_TCD2_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD2_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD2_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD2_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD2_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD2_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD2_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD2_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD2_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD2_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD2_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD2_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD2_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD2_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD2_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD2_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD2_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD2_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD2_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD2_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD2_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD2_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD2_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD2_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD2_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD2_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD2_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD2_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD2_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD2_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD2_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD2_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD2_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD2_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd2_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd2_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd2_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD2_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1048U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd2_nbytes_mloffyes_t *) HW_DMA_TCD2_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD2_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD2_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD2_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD2_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD2_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD2_NBYTES_MLOFFYES_WR(HW_DMA_TCD2_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD2_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD2_NBYTES_MLOFFYES_WR(HW_DMA_TCD2_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD2_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD2_NBYTES_MLOFFYES_WR(HW_DMA_TCD2_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD2_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD2_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD2_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD2_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD2_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD2_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD2_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD2_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD2_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD2_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD2_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD2_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD2_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD2_NBYTES_MLOFFYES_WR((HW_DMA_TCD2_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD2_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD2_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD2_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD2_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD2_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD2_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD2_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD2_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD2_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD2_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD2_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD2_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD2_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD2_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD2_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD2_NBYTES_MLOFFYES_WR((HW_DMA_TCD2_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD2_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD2_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD2_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD2_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD2_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD2_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD2_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD2_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD2_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD2_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD2_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD2_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD2_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD2_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD2_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD2_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD2_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD2_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD2_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD2_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD2_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD2_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD2_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD2_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD2_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD2_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD2_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD2_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD2_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD2_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD2_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD2_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD2_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd2_slast
{
    uint32_t U;
    struct _hw_dma_tcd2_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd2_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_SLAST register
 */
//@{
#define HW_DMA_TCD2_SLAST_ADDR      (REGS_DMA_BASE + 0x104cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_SLAST           (*(__IO hw_dma_tcd2_slast_t *) HW_DMA_TCD2_SLAST_ADDR)
#define HW_DMA_TCD2_SLAST_RD()      (HW_DMA_TCD2_SLAST.U)
#define HW_DMA_TCD2_SLAST_WR(v)     (HW_DMA_TCD2_SLAST.U = (v))
#define HW_DMA_TCD2_SLAST_SET(v)    (HW_DMA_TCD2_SLAST_WR(HW_DMA_TCD2_SLAST_RD() |  (v)))
#define HW_DMA_TCD2_SLAST_CLR(v)    (HW_DMA_TCD2_SLAST_WR(HW_DMA_TCD2_SLAST_RD() & ~(v)))
#define HW_DMA_TCD2_SLAST_TOG(v)    (HW_DMA_TCD2_SLAST_WR(HW_DMA_TCD2_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_SLAST bitfields
 */

/*! @name Register DMA_TCD2_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD2_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD2_SLAST_SLAST.
#define BM_DMA_TCD2_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD2_SLAST_SLAST.
#define BS_DMA_TCD2_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD2_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_SLAST_SLAST field.
#define BR_DMA_TCD2_SLAST_SLAST()   (HW_DMA_TCD2_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD2_SLAST_SLAST.
#define BF_DMA_TCD2_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_SLAST_SLAST), uint32_t) & BM_DMA_TCD2_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD2_SLAST_SLAST(v)   (HW_DMA_TCD2_SLAST_WR((HW_DMA_TCD2_SLAST_RD() & ~BM_DMA_TCD2_SLAST_SLAST) | BF_DMA_TCD2_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd2_daddr
{
    uint32_t U;
    struct _hw_dma_tcd2_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd2_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_DADDR register
 */
//@{
#define HW_DMA_TCD2_DADDR_ADDR      (REGS_DMA_BASE + 0x1050U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_DADDR           (*(__IO hw_dma_tcd2_daddr_t *) HW_DMA_TCD2_DADDR_ADDR)
#define HW_DMA_TCD2_DADDR_RD()      (HW_DMA_TCD2_DADDR.U)
#define HW_DMA_TCD2_DADDR_WR(v)     (HW_DMA_TCD2_DADDR.U = (v))
#define HW_DMA_TCD2_DADDR_SET(v)    (HW_DMA_TCD2_DADDR_WR(HW_DMA_TCD2_DADDR_RD() |  (v)))
#define HW_DMA_TCD2_DADDR_CLR(v)    (HW_DMA_TCD2_DADDR_WR(HW_DMA_TCD2_DADDR_RD() & ~(v)))
#define HW_DMA_TCD2_DADDR_TOG(v)    (HW_DMA_TCD2_DADDR_WR(HW_DMA_TCD2_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_DADDR bitfields
 */

/*! @name Register DMA_TCD2_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD2_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD2_DADDR_DADDR.
#define BM_DMA_TCD2_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD2_DADDR_DADDR.
#define BS_DMA_TCD2_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD2_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_DADDR_DADDR field.
#define BR_DMA_TCD2_DADDR_DADDR()   (HW_DMA_TCD2_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD2_DADDR_DADDR.
#define BF_DMA_TCD2_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_DADDR_DADDR), uint32_t) & BM_DMA_TCD2_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD2_DADDR_DADDR(v)   (HW_DMA_TCD2_DADDR_WR((HW_DMA_TCD2_DADDR_RD() & ~BM_DMA_TCD2_DADDR_DADDR) | BF_DMA_TCD2_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd2_doff
{
    uint16_t U;
    struct _hw_dma_tcd2_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd2_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_DOFF register
 */
//@{
#define HW_DMA_TCD2_DOFF_ADDR      (REGS_DMA_BASE + 0x1054U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_DOFF           (*(__IO hw_dma_tcd2_doff_t *) HW_DMA_TCD2_DOFF_ADDR)
#define HW_DMA_TCD2_DOFF_RD()      (HW_DMA_TCD2_DOFF.U)
#define HW_DMA_TCD2_DOFF_WR(v)     (HW_DMA_TCD2_DOFF.U = (v))
#define HW_DMA_TCD2_DOFF_SET(v)    (HW_DMA_TCD2_DOFF_WR(HW_DMA_TCD2_DOFF_RD() |  (v)))
#define HW_DMA_TCD2_DOFF_CLR(v)    (HW_DMA_TCD2_DOFF_WR(HW_DMA_TCD2_DOFF_RD() & ~(v)))
#define HW_DMA_TCD2_DOFF_TOG(v)    (HW_DMA_TCD2_DOFF_WR(HW_DMA_TCD2_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_DOFF bitfields
 */

/*! @name Register DMA_TCD2_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD2_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD2_DOFF_DOFF.
#define BM_DMA_TCD2_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD2_DOFF_DOFF.
#define BS_DMA_TCD2_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD2_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_DOFF_DOFF field.
#define BR_DMA_TCD2_DOFF_DOFF()   (HW_DMA_TCD2_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD2_DOFF_DOFF.
#define BF_DMA_TCD2_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_DOFF_DOFF), uint16_t) & BM_DMA_TCD2_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD2_DOFF_DOFF(v)   (HW_DMA_TCD2_DOFF_WR((HW_DMA_TCD2_DOFF_RD() & ~BM_DMA_TCD2_DOFF_DOFF) | BF_DMA_TCD2_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd2_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd2_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd2_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD2_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1056U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_CITER_ELINKYES           (*(__IO hw_dma_tcd2_citer_elinkyes_t *) HW_DMA_TCD2_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD2_CITER_ELINKYES_RD()      (HW_DMA_TCD2_CITER_ELINKYES.U)
#define HW_DMA_TCD2_CITER_ELINKYES_WR(v)     (HW_DMA_TCD2_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD2_CITER_ELINKYES_SET(v)    (HW_DMA_TCD2_CITER_ELINKYES_WR(HW_DMA_TCD2_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD2_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD2_CITER_ELINKYES_WR(HW_DMA_TCD2_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD2_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD2_CITER_ELINKYES_WR(HW_DMA_TCD2_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD2_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD2_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD2_CITER_ELINKYES_CITER.
#define BM_DMA_TCD2_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD2_CITER_ELINKYES_CITER.
#define BS_DMA_TCD2_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD2_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD2_CITER_ELINKYES_CITER()   (HW_DMA_TCD2_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD2_CITER_ELINKYES_CITER.
#define BF_DMA_TCD2_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD2_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD2_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD2_CITER_ELINKYES_WR((HW_DMA_TCD2_CITER_ELINKYES_RD() & ~BM_DMA_TCD2_CITER_ELINKYES_CITER) | BF_DMA_TCD2_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD2_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD2_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD2_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD2_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD2_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD2_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD2_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD2_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD2_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD2_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD2_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD2_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD2_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD2_CITER_ELINKYES_WR((HW_DMA_TCD2_CITER_ELINKYES_RD() & ~BM_DMA_TCD2_CITER_ELINKYES_LINKCH) | BF_DMA_TCD2_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD2_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD2_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD2_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD2_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD2_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD2_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD2_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD2_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD2_CITER_ELINKYES_ADDR, BP_DMA_TCD2_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD2_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD2_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD2_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD2_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CITER_ELINKYES_ADDR, BP_DMA_TCD2_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd2_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd2_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd2_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD2_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1056U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_CITER_ELINKNO           (*(__IO hw_dma_tcd2_citer_elinkno_t *) HW_DMA_TCD2_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD2_CITER_ELINKNO_RD()      (HW_DMA_TCD2_CITER_ELINKNO.U)
#define HW_DMA_TCD2_CITER_ELINKNO_WR(v)     (HW_DMA_TCD2_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD2_CITER_ELINKNO_SET(v)    (HW_DMA_TCD2_CITER_ELINKNO_WR(HW_DMA_TCD2_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD2_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD2_CITER_ELINKNO_WR(HW_DMA_TCD2_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD2_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD2_CITER_ELINKNO_WR(HW_DMA_TCD2_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD2_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD2_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD2_CITER_ELINKNO_CITER.
#define BM_DMA_TCD2_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD2_CITER_ELINKNO_CITER.
#define BS_DMA_TCD2_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD2_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD2_CITER_ELINKNO_CITER()   (HW_DMA_TCD2_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD2_CITER_ELINKNO_CITER.
#define BF_DMA_TCD2_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD2_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD2_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD2_CITER_ELINKNO_WR((HW_DMA_TCD2_CITER_ELINKNO_RD() & ~BM_DMA_TCD2_CITER_ELINKNO_CITER) | BF_DMA_TCD2_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD2_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD2_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD2_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD2_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD2_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD2_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD2_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD2_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD2_CITER_ELINKNO_ADDR, BP_DMA_TCD2_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD2_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD2_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD2_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD2_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CITER_ELINKNO_ADDR, BP_DMA_TCD2_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd2_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd2_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd2_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_DLASTSGA register
 */
//@{
#define HW_DMA_TCD2_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1058U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_DLASTSGA           (*(__IO hw_dma_tcd2_dlastsga_t *) HW_DMA_TCD2_DLASTSGA_ADDR)
#define HW_DMA_TCD2_DLASTSGA_RD()      (HW_DMA_TCD2_DLASTSGA.U)
#define HW_DMA_TCD2_DLASTSGA_WR(v)     (HW_DMA_TCD2_DLASTSGA.U = (v))
#define HW_DMA_TCD2_DLASTSGA_SET(v)    (HW_DMA_TCD2_DLASTSGA_WR(HW_DMA_TCD2_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD2_DLASTSGA_CLR(v)    (HW_DMA_TCD2_DLASTSGA_WR(HW_DMA_TCD2_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD2_DLASTSGA_TOG(v)    (HW_DMA_TCD2_DLASTSGA_WR(HW_DMA_TCD2_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD2_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD2_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD2_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD2_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD2_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD2_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD2_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD2_DLASTSGA_DLASTSGA()   (HW_DMA_TCD2_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD2_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD2_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD2_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD2_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD2_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD2_DLASTSGA_WR((HW_DMA_TCD2_DLASTSGA_RD() & ~BM_DMA_TCD2_DLASTSGA_DLASTSGA) | BF_DMA_TCD2_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd2_csr
{
    uint16_t U;
    struct _hw_dma_tcd2_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd2_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_CSR register
 */
//@{
#define HW_DMA_TCD2_CSR_ADDR      (REGS_DMA_BASE + 0x105cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_CSR           (*(__IO hw_dma_tcd2_csr_t *) HW_DMA_TCD2_CSR_ADDR)
#define HW_DMA_TCD2_CSR_RD()      (HW_DMA_TCD2_CSR.U)
#define HW_DMA_TCD2_CSR_WR(v)     (HW_DMA_TCD2_CSR.U = (v))
#define HW_DMA_TCD2_CSR_SET(v)    (HW_DMA_TCD2_CSR_WR(HW_DMA_TCD2_CSR_RD() |  (v)))
#define HW_DMA_TCD2_CSR_CLR(v)    (HW_DMA_TCD2_CSR_WR(HW_DMA_TCD2_CSR_RD() & ~(v)))
#define HW_DMA_TCD2_CSR_TOG(v)    (HW_DMA_TCD2_CSR_WR(HW_DMA_TCD2_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_CSR bitfields
 */

/*! @name Register DMA_TCD2_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD2_CSR_START      (0U)      //!< Bit position for DMA_TCD2_CSR_START.
#define BM_DMA_TCD2_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD2_CSR_START.
#define BS_DMA_TCD2_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD2_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_START field.
#define BR_DMA_TCD2_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_START.
#define BF_DMA_TCD2_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_START), uint16_t) & BM_DMA_TCD2_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD2_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD2_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD2_CSR_INTMAJOR.
#define BM_DMA_TCD2_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD2_CSR_INTMAJOR.
#define BS_DMA_TCD2_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD2_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_INTMAJOR field.
#define BR_DMA_TCD2_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_INTMAJOR.
#define BF_DMA_TCD2_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD2_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD2_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD2_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD2_CSR_INTHALF.
#define BM_DMA_TCD2_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD2_CSR_INTHALF.
#define BS_DMA_TCD2_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD2_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_INTHALF field.
#define BR_DMA_TCD2_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_INTHALF.
#define BF_DMA_TCD2_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_INTHALF), uint16_t) & BM_DMA_TCD2_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD2_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD2_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD2_CSR_DREQ.
#define BM_DMA_TCD2_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD2_CSR_DREQ.
#define BS_DMA_TCD2_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD2_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_DREQ field.
#define BR_DMA_TCD2_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_DREQ.
#define BF_DMA_TCD2_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_DREQ), uint16_t) & BM_DMA_TCD2_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD2_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD2_CSR_ESG      (4U)      //!< Bit position for DMA_TCD2_CSR_ESG.
#define BM_DMA_TCD2_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD2_CSR_ESG.
#define BS_DMA_TCD2_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD2_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_ESG field.
#define BR_DMA_TCD2_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_ESG.
#define BF_DMA_TCD2_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_ESG), uint16_t) & BM_DMA_TCD2_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD2_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD2_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD2_CSR_MAJORELINK.
#define BM_DMA_TCD2_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD2_CSR_MAJORELINK.
#define BS_DMA_TCD2_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD2_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_MAJORELINK field.
#define BR_DMA_TCD2_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_MAJORELINK.
#define BF_DMA_TCD2_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD2_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD2_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD2_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD2_CSR_ACTIVE.
#define BM_DMA_TCD2_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD2_CSR_ACTIVE.
#define BS_DMA_TCD2_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD2_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_ACTIVE field.
#define BR_DMA_TCD2_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_ACTIVE.
#define BF_DMA_TCD2_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_ACTIVE), uint16_t) & BM_DMA_TCD2_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD2_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD2_CSR_DONE      (7U)      //!< Bit position for DMA_TCD2_CSR_DONE.
#define BM_DMA_TCD2_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD2_CSR_DONE.
#define BS_DMA_TCD2_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD2_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_DONE field.
#define BR_DMA_TCD2_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_DONE.
#define BF_DMA_TCD2_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_DONE), uint16_t) & BM_DMA_TCD2_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD2_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_CSR_ADDR, BP_DMA_TCD2_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD2_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD2_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD2_CSR_MAJORLINKCH.
#define BM_DMA_TCD2_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD2_CSR_MAJORLINKCH.
#define BS_DMA_TCD2_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD2_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_MAJORLINKCH field.
#define BR_DMA_TCD2_CSR_MAJORLINKCH()   (HW_DMA_TCD2_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_MAJORLINKCH.
#define BF_DMA_TCD2_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD2_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD2_CSR_MAJORLINKCH(v)   (HW_DMA_TCD2_CSR_WR((HW_DMA_TCD2_CSR_RD() & ~BM_DMA_TCD2_CSR_MAJORLINKCH) | BF_DMA_TCD2_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD2_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD2_CSR_BWC      (14U)      //!< Bit position for DMA_TCD2_CSR_BWC.
#define BM_DMA_TCD2_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD2_CSR_BWC.
#define BS_DMA_TCD2_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD2_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_CSR_BWC field.
#define BR_DMA_TCD2_CSR_BWC()   (HW_DMA_TCD2_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD2_CSR_BWC.
#define BF_DMA_TCD2_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_CSR_BWC), uint16_t) & BM_DMA_TCD2_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD2_CSR_BWC(v)   (HW_DMA_TCD2_CSR_WR((HW_DMA_TCD2_CSR_RD() & ~BM_DMA_TCD2_CSR_BWC) | BF_DMA_TCD2_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd2_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd2_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd2_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD2_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x105eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_BITER_ELINKYES           (*(__IO hw_dma_tcd2_biter_elinkyes_t *) HW_DMA_TCD2_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD2_BITER_ELINKYES_RD()      (HW_DMA_TCD2_BITER_ELINKYES.U)
#define HW_DMA_TCD2_BITER_ELINKYES_WR(v)     (HW_DMA_TCD2_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD2_BITER_ELINKYES_SET(v)    (HW_DMA_TCD2_BITER_ELINKYES_WR(HW_DMA_TCD2_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD2_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD2_BITER_ELINKYES_WR(HW_DMA_TCD2_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD2_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD2_BITER_ELINKYES_WR(HW_DMA_TCD2_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD2_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD2_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD2_BITER_ELINKYES_BITER.
#define BM_DMA_TCD2_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD2_BITER_ELINKYES_BITER.
#define BS_DMA_TCD2_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD2_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD2_BITER_ELINKYES_BITER()   (HW_DMA_TCD2_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD2_BITER_ELINKYES_BITER.
#define BF_DMA_TCD2_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD2_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD2_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD2_BITER_ELINKYES_WR((HW_DMA_TCD2_BITER_ELINKYES_RD() & ~BM_DMA_TCD2_BITER_ELINKYES_BITER) | BF_DMA_TCD2_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD2_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD2_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD2_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD2_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD2_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD2_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD2_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD2_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD2_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD2_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD2_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD2_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD2_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD2_BITER_ELINKYES_WR((HW_DMA_TCD2_BITER_ELINKYES_RD() & ~BM_DMA_TCD2_BITER_ELINKYES_LINKCH) | BF_DMA_TCD2_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD2_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD2_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD2_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD2_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD2_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD2_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD2_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD2_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD2_BITER_ELINKYES_ADDR, BP_DMA_TCD2_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD2_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD2_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD2_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD2_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_BITER_ELINKYES_ADDR, BP_DMA_TCD2_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD2_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD2_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd2_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd2_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd2_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD2_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD2_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x105eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD2_BITER_ELINKNO           (*(__IO hw_dma_tcd2_biter_elinkno_t *) HW_DMA_TCD2_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD2_BITER_ELINKNO_RD()      (HW_DMA_TCD2_BITER_ELINKNO.U)
#define HW_DMA_TCD2_BITER_ELINKNO_WR(v)     (HW_DMA_TCD2_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD2_BITER_ELINKNO_SET(v)    (HW_DMA_TCD2_BITER_ELINKNO_WR(HW_DMA_TCD2_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD2_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD2_BITER_ELINKNO_WR(HW_DMA_TCD2_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD2_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD2_BITER_ELINKNO_WR(HW_DMA_TCD2_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD2_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD2_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD2_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD2_BITER_ELINKNO_BITER.
#define BM_DMA_TCD2_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD2_BITER_ELINKNO_BITER.
#define BS_DMA_TCD2_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD2_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD2_BITER_ELINKNO_BITER()   (HW_DMA_TCD2_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD2_BITER_ELINKNO_BITER.
#define BF_DMA_TCD2_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD2_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD2_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD2_BITER_ELINKNO_WR((HW_DMA_TCD2_BITER_ELINKNO_RD() & ~BM_DMA_TCD2_BITER_ELINKNO_BITER) | BF_DMA_TCD2_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD2_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD2_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD2_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD2_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD2_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD2_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD2_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD2_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD2_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD2_BITER_ELINKNO_ADDR, BP_DMA_TCD2_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD2_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD2_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD2_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD2_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD2_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD2_BITER_ELINKNO_ADDR, BP_DMA_TCD2_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd3_saddr
{
    uint32_t U;
    struct _hw_dma_tcd3_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd3_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_SADDR register
 */
//@{
#define HW_DMA_TCD3_SADDR_ADDR      (REGS_DMA_BASE + 0x1060U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_SADDR           (*(__IO hw_dma_tcd3_saddr_t *) HW_DMA_TCD3_SADDR_ADDR)
#define HW_DMA_TCD3_SADDR_RD()      (HW_DMA_TCD3_SADDR.U)
#define HW_DMA_TCD3_SADDR_WR(v)     (HW_DMA_TCD3_SADDR.U = (v))
#define HW_DMA_TCD3_SADDR_SET(v)    (HW_DMA_TCD3_SADDR_WR(HW_DMA_TCD3_SADDR_RD() |  (v)))
#define HW_DMA_TCD3_SADDR_CLR(v)    (HW_DMA_TCD3_SADDR_WR(HW_DMA_TCD3_SADDR_RD() & ~(v)))
#define HW_DMA_TCD3_SADDR_TOG(v)    (HW_DMA_TCD3_SADDR_WR(HW_DMA_TCD3_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_SADDR bitfields
 */

/*! @name Register DMA_TCD3_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD3_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD3_SADDR_SADDR.
#define BM_DMA_TCD3_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD3_SADDR_SADDR.
#define BS_DMA_TCD3_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD3_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_SADDR_SADDR field.
#define BR_DMA_TCD3_SADDR_SADDR()   (HW_DMA_TCD3_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD3_SADDR_SADDR.
#define BF_DMA_TCD3_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_SADDR_SADDR), uint32_t) & BM_DMA_TCD3_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD3_SADDR_SADDR(v)   (HW_DMA_TCD3_SADDR_WR((HW_DMA_TCD3_SADDR_RD() & ~BM_DMA_TCD3_SADDR_SADDR) | BF_DMA_TCD3_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd3_soff
{
    uint16_t U;
    struct _hw_dma_tcd3_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd3_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_SOFF register
 */
//@{
#define HW_DMA_TCD3_SOFF_ADDR      (REGS_DMA_BASE + 0x1064U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_SOFF           (*(__IO hw_dma_tcd3_soff_t *) HW_DMA_TCD3_SOFF_ADDR)
#define HW_DMA_TCD3_SOFF_RD()      (HW_DMA_TCD3_SOFF.U)
#define HW_DMA_TCD3_SOFF_WR(v)     (HW_DMA_TCD3_SOFF.U = (v))
#define HW_DMA_TCD3_SOFF_SET(v)    (HW_DMA_TCD3_SOFF_WR(HW_DMA_TCD3_SOFF_RD() |  (v)))
#define HW_DMA_TCD3_SOFF_CLR(v)    (HW_DMA_TCD3_SOFF_WR(HW_DMA_TCD3_SOFF_RD() & ~(v)))
#define HW_DMA_TCD3_SOFF_TOG(v)    (HW_DMA_TCD3_SOFF_WR(HW_DMA_TCD3_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_SOFF bitfields
 */

/*! @name Register DMA_TCD3_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD3_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD3_SOFF_SOFF.
#define BM_DMA_TCD3_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD3_SOFF_SOFF.
#define BS_DMA_TCD3_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD3_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_SOFF_SOFF field.
#define BR_DMA_TCD3_SOFF_SOFF()   (HW_DMA_TCD3_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD3_SOFF_SOFF.
#define BF_DMA_TCD3_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_SOFF_SOFF), uint16_t) & BM_DMA_TCD3_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD3_SOFF_SOFF(v)   (HW_DMA_TCD3_SOFF_WR((HW_DMA_TCD3_SOFF_RD() & ~BM_DMA_TCD3_SOFF_SOFF) | BF_DMA_TCD3_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd3_attr
{
    uint16_t U;
    struct _hw_dma_tcd3_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd3_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_ATTR register
 */
//@{
#define HW_DMA_TCD3_ATTR_ADDR      (REGS_DMA_BASE + 0x1066U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_ATTR           (*(__IO hw_dma_tcd3_attr_t *) HW_DMA_TCD3_ATTR_ADDR)
#define HW_DMA_TCD3_ATTR_RD()      (HW_DMA_TCD3_ATTR.U)
#define HW_DMA_TCD3_ATTR_WR(v)     (HW_DMA_TCD3_ATTR.U = (v))
#define HW_DMA_TCD3_ATTR_SET(v)    (HW_DMA_TCD3_ATTR_WR(HW_DMA_TCD3_ATTR_RD() |  (v)))
#define HW_DMA_TCD3_ATTR_CLR(v)    (HW_DMA_TCD3_ATTR_WR(HW_DMA_TCD3_ATTR_RD() & ~(v)))
#define HW_DMA_TCD3_ATTR_TOG(v)    (HW_DMA_TCD3_ATTR_WR(HW_DMA_TCD3_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_ATTR bitfields
 */

/*! @name Register DMA_TCD3_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD3_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD3_ATTR_DSIZE.
#define BM_DMA_TCD3_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD3_ATTR_DSIZE.
#define BS_DMA_TCD3_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD3_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_ATTR_DSIZE field.
#define BR_DMA_TCD3_ATTR_DSIZE()   (HW_DMA_TCD3_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD3_ATTR_DSIZE.
#define BF_DMA_TCD3_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_ATTR_DSIZE), uint16_t) & BM_DMA_TCD3_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD3_ATTR_DSIZE(v)   (HW_DMA_TCD3_ATTR_WR((HW_DMA_TCD3_ATTR_RD() & ~BM_DMA_TCD3_ATTR_DSIZE) | BF_DMA_TCD3_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD3_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD3_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD3_ATTR_DMOD.
#define BM_DMA_TCD3_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD3_ATTR_DMOD.
#define BS_DMA_TCD3_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD3_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_ATTR_DMOD field.
#define BR_DMA_TCD3_ATTR_DMOD()   (HW_DMA_TCD3_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD3_ATTR_DMOD.
#define BF_DMA_TCD3_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_ATTR_DMOD), uint16_t) & BM_DMA_TCD3_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD3_ATTR_DMOD(v)   (HW_DMA_TCD3_ATTR_WR((HW_DMA_TCD3_ATTR_RD() & ~BM_DMA_TCD3_ATTR_DMOD) | BF_DMA_TCD3_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD3_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD3_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD3_ATTR_SSIZE.
#define BM_DMA_TCD3_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD3_ATTR_SSIZE.
#define BS_DMA_TCD3_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD3_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_ATTR_SSIZE field.
#define BR_DMA_TCD3_ATTR_SSIZE()   (HW_DMA_TCD3_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD3_ATTR_SSIZE.
#define BF_DMA_TCD3_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_ATTR_SSIZE), uint16_t) & BM_DMA_TCD3_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD3_ATTR_SSIZE(v)   (HW_DMA_TCD3_ATTR_WR((HW_DMA_TCD3_ATTR_RD() & ~BM_DMA_TCD3_ATTR_SSIZE) | BF_DMA_TCD3_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD3_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD3_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD3_ATTR_SMOD.
#define BM_DMA_TCD3_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD3_ATTR_SMOD.
#define BS_DMA_TCD3_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD3_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_ATTR_SMOD field.
#define BR_DMA_TCD3_ATTR_SMOD()   (HW_DMA_TCD3_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD3_ATTR_SMOD.
#define BF_DMA_TCD3_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_ATTR_SMOD), uint16_t) & BM_DMA_TCD3_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD3_ATTR_SMOD(v)   (HW_DMA_TCD3_ATTR_WR((HW_DMA_TCD3_ATTR_RD() & ~BM_DMA_TCD3_ATTR_SMOD) | BF_DMA_TCD3_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd3_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd3_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd3_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD3_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1068U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_NBYTES_MLNO           (*(__IO hw_dma_tcd3_nbytes_mlno_t *) HW_DMA_TCD3_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD3_NBYTES_MLNO_RD()      (HW_DMA_TCD3_NBYTES_MLNO.U)
#define HW_DMA_TCD3_NBYTES_MLNO_WR(v)     (HW_DMA_TCD3_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD3_NBYTES_MLNO_SET(v)    (HW_DMA_TCD3_NBYTES_MLNO_WR(HW_DMA_TCD3_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD3_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD3_NBYTES_MLNO_WR(HW_DMA_TCD3_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD3_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD3_NBYTES_MLNO_WR(HW_DMA_TCD3_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD3_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD3_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD3_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD3_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD3_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD3_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD3_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD3_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD3_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD3_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD3_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD3_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD3_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD3_NBYTES_MLNO_WR((HW_DMA_TCD3_NBYTES_MLNO_RD() & ~BM_DMA_TCD3_NBYTES_MLNO_NBYTES) | BF_DMA_TCD3_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd3_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd3_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd3_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD3_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1068U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd3_nbytes_mloffno_t *) HW_DMA_TCD3_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD3_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD3_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD3_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD3_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD3_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD3_NBYTES_MLOFFNO_WR(HW_DMA_TCD3_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD3_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD3_NBYTES_MLOFFNO_WR(HW_DMA_TCD3_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD3_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD3_NBYTES_MLOFFNO_WR(HW_DMA_TCD3_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD3_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD3_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD3_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD3_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD3_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD3_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD3_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD3_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD3_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD3_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD3_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD3_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD3_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD3_NBYTES_MLOFFNO_WR((HW_DMA_TCD3_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD3_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD3_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD3_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD3_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD3_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD3_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD3_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD3_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD3_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD3_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD3_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD3_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD3_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD3_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD3_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD3_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD3_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD3_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD3_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD3_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD3_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD3_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD3_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD3_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD3_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD3_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD3_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD3_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD3_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD3_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD3_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD3_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD3_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd3_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd3_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd3_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD3_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1068U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd3_nbytes_mloffyes_t *) HW_DMA_TCD3_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD3_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD3_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD3_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD3_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD3_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD3_NBYTES_MLOFFYES_WR(HW_DMA_TCD3_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD3_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD3_NBYTES_MLOFFYES_WR(HW_DMA_TCD3_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD3_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD3_NBYTES_MLOFFYES_WR(HW_DMA_TCD3_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD3_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD3_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD3_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD3_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD3_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD3_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD3_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD3_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD3_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD3_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD3_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD3_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD3_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD3_NBYTES_MLOFFYES_WR((HW_DMA_TCD3_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD3_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD3_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD3_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD3_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD3_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD3_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD3_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD3_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD3_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD3_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD3_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD3_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD3_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD3_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD3_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD3_NBYTES_MLOFFYES_WR((HW_DMA_TCD3_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD3_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD3_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD3_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD3_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD3_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD3_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD3_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD3_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD3_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD3_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD3_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD3_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD3_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD3_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD3_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD3_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD3_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD3_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD3_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD3_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD3_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD3_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD3_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD3_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD3_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD3_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD3_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD3_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD3_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD3_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD3_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD3_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD3_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd3_slast
{
    uint32_t U;
    struct _hw_dma_tcd3_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd3_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_SLAST register
 */
//@{
#define HW_DMA_TCD3_SLAST_ADDR      (REGS_DMA_BASE + 0x106cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_SLAST           (*(__IO hw_dma_tcd3_slast_t *) HW_DMA_TCD3_SLAST_ADDR)
#define HW_DMA_TCD3_SLAST_RD()      (HW_DMA_TCD3_SLAST.U)
#define HW_DMA_TCD3_SLAST_WR(v)     (HW_DMA_TCD3_SLAST.U = (v))
#define HW_DMA_TCD3_SLAST_SET(v)    (HW_DMA_TCD3_SLAST_WR(HW_DMA_TCD3_SLAST_RD() |  (v)))
#define HW_DMA_TCD3_SLAST_CLR(v)    (HW_DMA_TCD3_SLAST_WR(HW_DMA_TCD3_SLAST_RD() & ~(v)))
#define HW_DMA_TCD3_SLAST_TOG(v)    (HW_DMA_TCD3_SLAST_WR(HW_DMA_TCD3_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_SLAST bitfields
 */

/*! @name Register DMA_TCD3_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD3_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD3_SLAST_SLAST.
#define BM_DMA_TCD3_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD3_SLAST_SLAST.
#define BS_DMA_TCD3_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD3_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_SLAST_SLAST field.
#define BR_DMA_TCD3_SLAST_SLAST()   (HW_DMA_TCD3_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD3_SLAST_SLAST.
#define BF_DMA_TCD3_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_SLAST_SLAST), uint32_t) & BM_DMA_TCD3_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD3_SLAST_SLAST(v)   (HW_DMA_TCD3_SLAST_WR((HW_DMA_TCD3_SLAST_RD() & ~BM_DMA_TCD3_SLAST_SLAST) | BF_DMA_TCD3_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd3_daddr
{
    uint32_t U;
    struct _hw_dma_tcd3_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd3_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_DADDR register
 */
//@{
#define HW_DMA_TCD3_DADDR_ADDR      (REGS_DMA_BASE + 0x1070U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_DADDR           (*(__IO hw_dma_tcd3_daddr_t *) HW_DMA_TCD3_DADDR_ADDR)
#define HW_DMA_TCD3_DADDR_RD()      (HW_DMA_TCD3_DADDR.U)
#define HW_DMA_TCD3_DADDR_WR(v)     (HW_DMA_TCD3_DADDR.U = (v))
#define HW_DMA_TCD3_DADDR_SET(v)    (HW_DMA_TCD3_DADDR_WR(HW_DMA_TCD3_DADDR_RD() |  (v)))
#define HW_DMA_TCD3_DADDR_CLR(v)    (HW_DMA_TCD3_DADDR_WR(HW_DMA_TCD3_DADDR_RD() & ~(v)))
#define HW_DMA_TCD3_DADDR_TOG(v)    (HW_DMA_TCD3_DADDR_WR(HW_DMA_TCD3_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_DADDR bitfields
 */

/*! @name Register DMA_TCD3_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD3_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD3_DADDR_DADDR.
#define BM_DMA_TCD3_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD3_DADDR_DADDR.
#define BS_DMA_TCD3_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD3_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_DADDR_DADDR field.
#define BR_DMA_TCD3_DADDR_DADDR()   (HW_DMA_TCD3_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD3_DADDR_DADDR.
#define BF_DMA_TCD3_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_DADDR_DADDR), uint32_t) & BM_DMA_TCD3_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD3_DADDR_DADDR(v)   (HW_DMA_TCD3_DADDR_WR((HW_DMA_TCD3_DADDR_RD() & ~BM_DMA_TCD3_DADDR_DADDR) | BF_DMA_TCD3_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd3_doff
{
    uint16_t U;
    struct _hw_dma_tcd3_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd3_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_DOFF register
 */
//@{
#define HW_DMA_TCD3_DOFF_ADDR      (REGS_DMA_BASE + 0x1074U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_DOFF           (*(__IO hw_dma_tcd3_doff_t *) HW_DMA_TCD3_DOFF_ADDR)
#define HW_DMA_TCD3_DOFF_RD()      (HW_DMA_TCD3_DOFF.U)
#define HW_DMA_TCD3_DOFF_WR(v)     (HW_DMA_TCD3_DOFF.U = (v))
#define HW_DMA_TCD3_DOFF_SET(v)    (HW_DMA_TCD3_DOFF_WR(HW_DMA_TCD3_DOFF_RD() |  (v)))
#define HW_DMA_TCD3_DOFF_CLR(v)    (HW_DMA_TCD3_DOFF_WR(HW_DMA_TCD3_DOFF_RD() & ~(v)))
#define HW_DMA_TCD3_DOFF_TOG(v)    (HW_DMA_TCD3_DOFF_WR(HW_DMA_TCD3_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_DOFF bitfields
 */

/*! @name Register DMA_TCD3_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD3_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD3_DOFF_DOFF.
#define BM_DMA_TCD3_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD3_DOFF_DOFF.
#define BS_DMA_TCD3_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD3_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_DOFF_DOFF field.
#define BR_DMA_TCD3_DOFF_DOFF()   (HW_DMA_TCD3_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD3_DOFF_DOFF.
#define BF_DMA_TCD3_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_DOFF_DOFF), uint16_t) & BM_DMA_TCD3_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD3_DOFF_DOFF(v)   (HW_DMA_TCD3_DOFF_WR((HW_DMA_TCD3_DOFF_RD() & ~BM_DMA_TCD3_DOFF_DOFF) | BF_DMA_TCD3_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd3_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd3_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd3_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD3_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1076U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_CITER_ELINKYES           (*(__IO hw_dma_tcd3_citer_elinkyes_t *) HW_DMA_TCD3_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD3_CITER_ELINKYES_RD()      (HW_DMA_TCD3_CITER_ELINKYES.U)
#define HW_DMA_TCD3_CITER_ELINKYES_WR(v)     (HW_DMA_TCD3_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD3_CITER_ELINKYES_SET(v)    (HW_DMA_TCD3_CITER_ELINKYES_WR(HW_DMA_TCD3_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD3_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD3_CITER_ELINKYES_WR(HW_DMA_TCD3_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD3_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD3_CITER_ELINKYES_WR(HW_DMA_TCD3_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD3_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD3_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD3_CITER_ELINKYES_CITER.
#define BM_DMA_TCD3_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD3_CITER_ELINKYES_CITER.
#define BS_DMA_TCD3_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD3_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD3_CITER_ELINKYES_CITER()   (HW_DMA_TCD3_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD3_CITER_ELINKYES_CITER.
#define BF_DMA_TCD3_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD3_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD3_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD3_CITER_ELINKYES_WR((HW_DMA_TCD3_CITER_ELINKYES_RD() & ~BM_DMA_TCD3_CITER_ELINKYES_CITER) | BF_DMA_TCD3_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD3_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD3_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD3_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD3_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD3_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD3_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD3_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD3_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD3_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD3_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD3_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD3_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD3_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD3_CITER_ELINKYES_WR((HW_DMA_TCD3_CITER_ELINKYES_RD() & ~BM_DMA_TCD3_CITER_ELINKYES_LINKCH) | BF_DMA_TCD3_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD3_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD3_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD3_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD3_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD3_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD3_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD3_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD3_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD3_CITER_ELINKYES_ADDR, BP_DMA_TCD3_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD3_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD3_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD3_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD3_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CITER_ELINKYES_ADDR, BP_DMA_TCD3_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd3_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd3_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd3_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD3_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1076U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_CITER_ELINKNO           (*(__IO hw_dma_tcd3_citer_elinkno_t *) HW_DMA_TCD3_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD3_CITER_ELINKNO_RD()      (HW_DMA_TCD3_CITER_ELINKNO.U)
#define HW_DMA_TCD3_CITER_ELINKNO_WR(v)     (HW_DMA_TCD3_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD3_CITER_ELINKNO_SET(v)    (HW_DMA_TCD3_CITER_ELINKNO_WR(HW_DMA_TCD3_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD3_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD3_CITER_ELINKNO_WR(HW_DMA_TCD3_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD3_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD3_CITER_ELINKNO_WR(HW_DMA_TCD3_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD3_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD3_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD3_CITER_ELINKNO_CITER.
#define BM_DMA_TCD3_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD3_CITER_ELINKNO_CITER.
#define BS_DMA_TCD3_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD3_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD3_CITER_ELINKNO_CITER()   (HW_DMA_TCD3_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD3_CITER_ELINKNO_CITER.
#define BF_DMA_TCD3_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD3_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD3_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD3_CITER_ELINKNO_WR((HW_DMA_TCD3_CITER_ELINKNO_RD() & ~BM_DMA_TCD3_CITER_ELINKNO_CITER) | BF_DMA_TCD3_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD3_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD3_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD3_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD3_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD3_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD3_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD3_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD3_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD3_CITER_ELINKNO_ADDR, BP_DMA_TCD3_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD3_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD3_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD3_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD3_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CITER_ELINKNO_ADDR, BP_DMA_TCD3_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd3_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd3_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd3_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_DLASTSGA register
 */
//@{
#define HW_DMA_TCD3_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1078U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_DLASTSGA           (*(__IO hw_dma_tcd3_dlastsga_t *) HW_DMA_TCD3_DLASTSGA_ADDR)
#define HW_DMA_TCD3_DLASTSGA_RD()      (HW_DMA_TCD3_DLASTSGA.U)
#define HW_DMA_TCD3_DLASTSGA_WR(v)     (HW_DMA_TCD3_DLASTSGA.U = (v))
#define HW_DMA_TCD3_DLASTSGA_SET(v)    (HW_DMA_TCD3_DLASTSGA_WR(HW_DMA_TCD3_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD3_DLASTSGA_CLR(v)    (HW_DMA_TCD3_DLASTSGA_WR(HW_DMA_TCD3_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD3_DLASTSGA_TOG(v)    (HW_DMA_TCD3_DLASTSGA_WR(HW_DMA_TCD3_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD3_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD3_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD3_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD3_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD3_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD3_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD3_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD3_DLASTSGA_DLASTSGA()   (HW_DMA_TCD3_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD3_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD3_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD3_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD3_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD3_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD3_DLASTSGA_WR((HW_DMA_TCD3_DLASTSGA_RD() & ~BM_DMA_TCD3_DLASTSGA_DLASTSGA) | BF_DMA_TCD3_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd3_csr
{
    uint16_t U;
    struct _hw_dma_tcd3_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd3_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_CSR register
 */
//@{
#define HW_DMA_TCD3_CSR_ADDR      (REGS_DMA_BASE + 0x107cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_CSR           (*(__IO hw_dma_tcd3_csr_t *) HW_DMA_TCD3_CSR_ADDR)
#define HW_DMA_TCD3_CSR_RD()      (HW_DMA_TCD3_CSR.U)
#define HW_DMA_TCD3_CSR_WR(v)     (HW_DMA_TCD3_CSR.U = (v))
#define HW_DMA_TCD3_CSR_SET(v)    (HW_DMA_TCD3_CSR_WR(HW_DMA_TCD3_CSR_RD() |  (v)))
#define HW_DMA_TCD3_CSR_CLR(v)    (HW_DMA_TCD3_CSR_WR(HW_DMA_TCD3_CSR_RD() & ~(v)))
#define HW_DMA_TCD3_CSR_TOG(v)    (HW_DMA_TCD3_CSR_WR(HW_DMA_TCD3_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_CSR bitfields
 */

/*! @name Register DMA_TCD3_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD3_CSR_START      (0U)      //!< Bit position for DMA_TCD3_CSR_START.
#define BM_DMA_TCD3_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD3_CSR_START.
#define BS_DMA_TCD3_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD3_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_START field.
#define BR_DMA_TCD3_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_START.
#define BF_DMA_TCD3_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_START), uint16_t) & BM_DMA_TCD3_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD3_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD3_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD3_CSR_INTMAJOR.
#define BM_DMA_TCD3_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD3_CSR_INTMAJOR.
#define BS_DMA_TCD3_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD3_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_INTMAJOR field.
#define BR_DMA_TCD3_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_INTMAJOR.
#define BF_DMA_TCD3_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD3_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD3_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD3_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD3_CSR_INTHALF.
#define BM_DMA_TCD3_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD3_CSR_INTHALF.
#define BS_DMA_TCD3_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD3_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_INTHALF field.
#define BR_DMA_TCD3_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_INTHALF.
#define BF_DMA_TCD3_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_INTHALF), uint16_t) & BM_DMA_TCD3_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD3_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD3_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD3_CSR_DREQ.
#define BM_DMA_TCD3_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD3_CSR_DREQ.
#define BS_DMA_TCD3_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD3_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_DREQ field.
#define BR_DMA_TCD3_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_DREQ.
#define BF_DMA_TCD3_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_DREQ), uint16_t) & BM_DMA_TCD3_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD3_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD3_CSR_ESG      (4U)      //!< Bit position for DMA_TCD3_CSR_ESG.
#define BM_DMA_TCD3_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD3_CSR_ESG.
#define BS_DMA_TCD3_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD3_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_ESG field.
#define BR_DMA_TCD3_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_ESG.
#define BF_DMA_TCD3_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_ESG), uint16_t) & BM_DMA_TCD3_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD3_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD3_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD3_CSR_MAJORELINK.
#define BM_DMA_TCD3_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD3_CSR_MAJORELINK.
#define BS_DMA_TCD3_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD3_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_MAJORELINK field.
#define BR_DMA_TCD3_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_MAJORELINK.
#define BF_DMA_TCD3_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD3_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD3_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD3_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD3_CSR_ACTIVE.
#define BM_DMA_TCD3_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD3_CSR_ACTIVE.
#define BS_DMA_TCD3_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD3_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_ACTIVE field.
#define BR_DMA_TCD3_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_ACTIVE.
#define BF_DMA_TCD3_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_ACTIVE), uint16_t) & BM_DMA_TCD3_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD3_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD3_CSR_DONE      (7U)      //!< Bit position for DMA_TCD3_CSR_DONE.
#define BM_DMA_TCD3_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD3_CSR_DONE.
#define BS_DMA_TCD3_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD3_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_DONE field.
#define BR_DMA_TCD3_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_DONE.
#define BF_DMA_TCD3_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_DONE), uint16_t) & BM_DMA_TCD3_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD3_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_CSR_ADDR, BP_DMA_TCD3_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD3_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD3_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD3_CSR_MAJORLINKCH.
#define BM_DMA_TCD3_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD3_CSR_MAJORLINKCH.
#define BS_DMA_TCD3_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD3_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_MAJORLINKCH field.
#define BR_DMA_TCD3_CSR_MAJORLINKCH()   (HW_DMA_TCD3_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_MAJORLINKCH.
#define BF_DMA_TCD3_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD3_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD3_CSR_MAJORLINKCH(v)   (HW_DMA_TCD3_CSR_WR((HW_DMA_TCD3_CSR_RD() & ~BM_DMA_TCD3_CSR_MAJORLINKCH) | BF_DMA_TCD3_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD3_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD3_CSR_BWC      (14U)      //!< Bit position for DMA_TCD3_CSR_BWC.
#define BM_DMA_TCD3_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD3_CSR_BWC.
#define BS_DMA_TCD3_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD3_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_CSR_BWC field.
#define BR_DMA_TCD3_CSR_BWC()   (HW_DMA_TCD3_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD3_CSR_BWC.
#define BF_DMA_TCD3_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_CSR_BWC), uint16_t) & BM_DMA_TCD3_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD3_CSR_BWC(v)   (HW_DMA_TCD3_CSR_WR((HW_DMA_TCD3_CSR_RD() & ~BM_DMA_TCD3_CSR_BWC) | BF_DMA_TCD3_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd3_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd3_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd3_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD3_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x107eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_BITER_ELINKYES           (*(__IO hw_dma_tcd3_biter_elinkyes_t *) HW_DMA_TCD3_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD3_BITER_ELINKYES_RD()      (HW_DMA_TCD3_BITER_ELINKYES.U)
#define HW_DMA_TCD3_BITER_ELINKYES_WR(v)     (HW_DMA_TCD3_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD3_BITER_ELINKYES_SET(v)    (HW_DMA_TCD3_BITER_ELINKYES_WR(HW_DMA_TCD3_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD3_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD3_BITER_ELINKYES_WR(HW_DMA_TCD3_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD3_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD3_BITER_ELINKYES_WR(HW_DMA_TCD3_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD3_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD3_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD3_BITER_ELINKYES_BITER.
#define BM_DMA_TCD3_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD3_BITER_ELINKYES_BITER.
#define BS_DMA_TCD3_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD3_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD3_BITER_ELINKYES_BITER()   (HW_DMA_TCD3_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD3_BITER_ELINKYES_BITER.
#define BF_DMA_TCD3_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD3_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD3_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD3_BITER_ELINKYES_WR((HW_DMA_TCD3_BITER_ELINKYES_RD() & ~BM_DMA_TCD3_BITER_ELINKYES_BITER) | BF_DMA_TCD3_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD3_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD3_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD3_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD3_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD3_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD3_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD3_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD3_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD3_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD3_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD3_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD3_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD3_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD3_BITER_ELINKYES_WR((HW_DMA_TCD3_BITER_ELINKYES_RD() & ~BM_DMA_TCD3_BITER_ELINKYES_LINKCH) | BF_DMA_TCD3_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD3_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD3_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD3_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD3_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD3_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD3_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD3_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD3_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD3_BITER_ELINKYES_ADDR, BP_DMA_TCD3_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD3_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD3_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD3_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD3_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_BITER_ELINKYES_ADDR, BP_DMA_TCD3_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD3_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD3_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd3_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd3_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd3_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD3_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD3_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x107eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD3_BITER_ELINKNO           (*(__IO hw_dma_tcd3_biter_elinkno_t *) HW_DMA_TCD3_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD3_BITER_ELINKNO_RD()      (HW_DMA_TCD3_BITER_ELINKNO.U)
#define HW_DMA_TCD3_BITER_ELINKNO_WR(v)     (HW_DMA_TCD3_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD3_BITER_ELINKNO_SET(v)    (HW_DMA_TCD3_BITER_ELINKNO_WR(HW_DMA_TCD3_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD3_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD3_BITER_ELINKNO_WR(HW_DMA_TCD3_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD3_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD3_BITER_ELINKNO_WR(HW_DMA_TCD3_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD3_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD3_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD3_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD3_BITER_ELINKNO_BITER.
#define BM_DMA_TCD3_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD3_BITER_ELINKNO_BITER.
#define BS_DMA_TCD3_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD3_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD3_BITER_ELINKNO_BITER()   (HW_DMA_TCD3_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD3_BITER_ELINKNO_BITER.
#define BF_DMA_TCD3_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD3_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD3_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD3_BITER_ELINKNO_WR((HW_DMA_TCD3_BITER_ELINKNO_RD() & ~BM_DMA_TCD3_BITER_ELINKNO_BITER) | BF_DMA_TCD3_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD3_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD3_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD3_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD3_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD3_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD3_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD3_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD3_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD3_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD3_BITER_ELINKNO_ADDR, BP_DMA_TCD3_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD3_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD3_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD3_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD3_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD3_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD3_BITER_ELINKNO_ADDR, BP_DMA_TCD3_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd4_saddr
{
    uint32_t U;
    struct _hw_dma_tcd4_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd4_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_SADDR register
 */
//@{
#define HW_DMA_TCD4_SADDR_ADDR      (REGS_DMA_BASE + 0x1080U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_SADDR           (*(__IO hw_dma_tcd4_saddr_t *) HW_DMA_TCD4_SADDR_ADDR)
#define HW_DMA_TCD4_SADDR_RD()      (HW_DMA_TCD4_SADDR.U)
#define HW_DMA_TCD4_SADDR_WR(v)     (HW_DMA_TCD4_SADDR.U = (v))
#define HW_DMA_TCD4_SADDR_SET(v)    (HW_DMA_TCD4_SADDR_WR(HW_DMA_TCD4_SADDR_RD() |  (v)))
#define HW_DMA_TCD4_SADDR_CLR(v)    (HW_DMA_TCD4_SADDR_WR(HW_DMA_TCD4_SADDR_RD() & ~(v)))
#define HW_DMA_TCD4_SADDR_TOG(v)    (HW_DMA_TCD4_SADDR_WR(HW_DMA_TCD4_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_SADDR bitfields
 */

/*! @name Register DMA_TCD4_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD4_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD4_SADDR_SADDR.
#define BM_DMA_TCD4_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD4_SADDR_SADDR.
#define BS_DMA_TCD4_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD4_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_SADDR_SADDR field.
#define BR_DMA_TCD4_SADDR_SADDR()   (HW_DMA_TCD4_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD4_SADDR_SADDR.
#define BF_DMA_TCD4_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_SADDR_SADDR), uint32_t) & BM_DMA_TCD4_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD4_SADDR_SADDR(v)   (HW_DMA_TCD4_SADDR_WR((HW_DMA_TCD4_SADDR_RD() & ~BM_DMA_TCD4_SADDR_SADDR) | BF_DMA_TCD4_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd4_soff
{
    uint16_t U;
    struct _hw_dma_tcd4_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd4_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_SOFF register
 */
//@{
#define HW_DMA_TCD4_SOFF_ADDR      (REGS_DMA_BASE + 0x1084U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_SOFF           (*(__IO hw_dma_tcd4_soff_t *) HW_DMA_TCD4_SOFF_ADDR)
#define HW_DMA_TCD4_SOFF_RD()      (HW_DMA_TCD4_SOFF.U)
#define HW_DMA_TCD4_SOFF_WR(v)     (HW_DMA_TCD4_SOFF.U = (v))
#define HW_DMA_TCD4_SOFF_SET(v)    (HW_DMA_TCD4_SOFF_WR(HW_DMA_TCD4_SOFF_RD() |  (v)))
#define HW_DMA_TCD4_SOFF_CLR(v)    (HW_DMA_TCD4_SOFF_WR(HW_DMA_TCD4_SOFF_RD() & ~(v)))
#define HW_DMA_TCD4_SOFF_TOG(v)    (HW_DMA_TCD4_SOFF_WR(HW_DMA_TCD4_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_SOFF bitfields
 */

/*! @name Register DMA_TCD4_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD4_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD4_SOFF_SOFF.
#define BM_DMA_TCD4_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD4_SOFF_SOFF.
#define BS_DMA_TCD4_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD4_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_SOFF_SOFF field.
#define BR_DMA_TCD4_SOFF_SOFF()   (HW_DMA_TCD4_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD4_SOFF_SOFF.
#define BF_DMA_TCD4_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_SOFF_SOFF), uint16_t) & BM_DMA_TCD4_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD4_SOFF_SOFF(v)   (HW_DMA_TCD4_SOFF_WR((HW_DMA_TCD4_SOFF_RD() & ~BM_DMA_TCD4_SOFF_SOFF) | BF_DMA_TCD4_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd4_attr
{
    uint16_t U;
    struct _hw_dma_tcd4_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd4_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_ATTR register
 */
//@{
#define HW_DMA_TCD4_ATTR_ADDR      (REGS_DMA_BASE + 0x1086U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_ATTR           (*(__IO hw_dma_tcd4_attr_t *) HW_DMA_TCD4_ATTR_ADDR)
#define HW_DMA_TCD4_ATTR_RD()      (HW_DMA_TCD4_ATTR.U)
#define HW_DMA_TCD4_ATTR_WR(v)     (HW_DMA_TCD4_ATTR.U = (v))
#define HW_DMA_TCD4_ATTR_SET(v)    (HW_DMA_TCD4_ATTR_WR(HW_DMA_TCD4_ATTR_RD() |  (v)))
#define HW_DMA_TCD4_ATTR_CLR(v)    (HW_DMA_TCD4_ATTR_WR(HW_DMA_TCD4_ATTR_RD() & ~(v)))
#define HW_DMA_TCD4_ATTR_TOG(v)    (HW_DMA_TCD4_ATTR_WR(HW_DMA_TCD4_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_ATTR bitfields
 */

/*! @name Register DMA_TCD4_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD4_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD4_ATTR_DSIZE.
#define BM_DMA_TCD4_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD4_ATTR_DSIZE.
#define BS_DMA_TCD4_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD4_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_ATTR_DSIZE field.
#define BR_DMA_TCD4_ATTR_DSIZE()   (HW_DMA_TCD4_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD4_ATTR_DSIZE.
#define BF_DMA_TCD4_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_ATTR_DSIZE), uint16_t) & BM_DMA_TCD4_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD4_ATTR_DSIZE(v)   (HW_DMA_TCD4_ATTR_WR((HW_DMA_TCD4_ATTR_RD() & ~BM_DMA_TCD4_ATTR_DSIZE) | BF_DMA_TCD4_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD4_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD4_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD4_ATTR_DMOD.
#define BM_DMA_TCD4_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD4_ATTR_DMOD.
#define BS_DMA_TCD4_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD4_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_ATTR_DMOD field.
#define BR_DMA_TCD4_ATTR_DMOD()   (HW_DMA_TCD4_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD4_ATTR_DMOD.
#define BF_DMA_TCD4_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_ATTR_DMOD), uint16_t) & BM_DMA_TCD4_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD4_ATTR_DMOD(v)   (HW_DMA_TCD4_ATTR_WR((HW_DMA_TCD4_ATTR_RD() & ~BM_DMA_TCD4_ATTR_DMOD) | BF_DMA_TCD4_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD4_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD4_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD4_ATTR_SSIZE.
#define BM_DMA_TCD4_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD4_ATTR_SSIZE.
#define BS_DMA_TCD4_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD4_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_ATTR_SSIZE field.
#define BR_DMA_TCD4_ATTR_SSIZE()   (HW_DMA_TCD4_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD4_ATTR_SSIZE.
#define BF_DMA_TCD4_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_ATTR_SSIZE), uint16_t) & BM_DMA_TCD4_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD4_ATTR_SSIZE(v)   (HW_DMA_TCD4_ATTR_WR((HW_DMA_TCD4_ATTR_RD() & ~BM_DMA_TCD4_ATTR_SSIZE) | BF_DMA_TCD4_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD4_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD4_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD4_ATTR_SMOD.
#define BM_DMA_TCD4_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD4_ATTR_SMOD.
#define BS_DMA_TCD4_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD4_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_ATTR_SMOD field.
#define BR_DMA_TCD4_ATTR_SMOD()   (HW_DMA_TCD4_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD4_ATTR_SMOD.
#define BF_DMA_TCD4_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_ATTR_SMOD), uint16_t) & BM_DMA_TCD4_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD4_ATTR_SMOD(v)   (HW_DMA_TCD4_ATTR_WR((HW_DMA_TCD4_ATTR_RD() & ~BM_DMA_TCD4_ATTR_SMOD) | BF_DMA_TCD4_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd4_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd4_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd4_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD4_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1088U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_NBYTES_MLNO           (*(__IO hw_dma_tcd4_nbytes_mlno_t *) HW_DMA_TCD4_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD4_NBYTES_MLNO_RD()      (HW_DMA_TCD4_NBYTES_MLNO.U)
#define HW_DMA_TCD4_NBYTES_MLNO_WR(v)     (HW_DMA_TCD4_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD4_NBYTES_MLNO_SET(v)    (HW_DMA_TCD4_NBYTES_MLNO_WR(HW_DMA_TCD4_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD4_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD4_NBYTES_MLNO_WR(HW_DMA_TCD4_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD4_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD4_NBYTES_MLNO_WR(HW_DMA_TCD4_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD4_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD4_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD4_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD4_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD4_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD4_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD4_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD4_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD4_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD4_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD4_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD4_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD4_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD4_NBYTES_MLNO_WR((HW_DMA_TCD4_NBYTES_MLNO_RD() & ~BM_DMA_TCD4_NBYTES_MLNO_NBYTES) | BF_DMA_TCD4_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd4_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd4_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd4_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD4_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1088U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd4_nbytes_mloffno_t *) HW_DMA_TCD4_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD4_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD4_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD4_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD4_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD4_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD4_NBYTES_MLOFFNO_WR(HW_DMA_TCD4_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD4_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD4_NBYTES_MLOFFNO_WR(HW_DMA_TCD4_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD4_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD4_NBYTES_MLOFFNO_WR(HW_DMA_TCD4_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD4_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD4_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD4_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD4_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD4_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD4_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD4_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD4_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD4_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD4_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD4_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD4_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD4_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD4_NBYTES_MLOFFNO_WR((HW_DMA_TCD4_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD4_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD4_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD4_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD4_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD4_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD4_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD4_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD4_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD4_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD4_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD4_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD4_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD4_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD4_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD4_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD4_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD4_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD4_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD4_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD4_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD4_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD4_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD4_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD4_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD4_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD4_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD4_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD4_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD4_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD4_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD4_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD4_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD4_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd4_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd4_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd4_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD4_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1088U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd4_nbytes_mloffyes_t *) HW_DMA_TCD4_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD4_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD4_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD4_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD4_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD4_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD4_NBYTES_MLOFFYES_WR(HW_DMA_TCD4_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD4_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD4_NBYTES_MLOFFYES_WR(HW_DMA_TCD4_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD4_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD4_NBYTES_MLOFFYES_WR(HW_DMA_TCD4_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD4_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD4_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD4_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD4_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD4_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD4_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD4_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD4_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD4_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD4_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD4_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD4_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD4_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD4_NBYTES_MLOFFYES_WR((HW_DMA_TCD4_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD4_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD4_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD4_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD4_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD4_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD4_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD4_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD4_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD4_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD4_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD4_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD4_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD4_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD4_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD4_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD4_NBYTES_MLOFFYES_WR((HW_DMA_TCD4_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD4_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD4_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD4_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD4_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD4_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD4_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD4_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD4_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD4_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD4_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD4_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD4_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD4_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD4_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD4_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD4_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD4_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD4_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD4_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD4_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD4_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD4_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD4_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD4_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD4_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD4_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD4_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD4_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD4_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD4_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD4_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD4_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD4_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd4_slast
{
    uint32_t U;
    struct _hw_dma_tcd4_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd4_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_SLAST register
 */
//@{
#define HW_DMA_TCD4_SLAST_ADDR      (REGS_DMA_BASE + 0x108cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_SLAST           (*(__IO hw_dma_tcd4_slast_t *) HW_DMA_TCD4_SLAST_ADDR)
#define HW_DMA_TCD4_SLAST_RD()      (HW_DMA_TCD4_SLAST.U)
#define HW_DMA_TCD4_SLAST_WR(v)     (HW_DMA_TCD4_SLAST.U = (v))
#define HW_DMA_TCD4_SLAST_SET(v)    (HW_DMA_TCD4_SLAST_WR(HW_DMA_TCD4_SLAST_RD() |  (v)))
#define HW_DMA_TCD4_SLAST_CLR(v)    (HW_DMA_TCD4_SLAST_WR(HW_DMA_TCD4_SLAST_RD() & ~(v)))
#define HW_DMA_TCD4_SLAST_TOG(v)    (HW_DMA_TCD4_SLAST_WR(HW_DMA_TCD4_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_SLAST bitfields
 */

/*! @name Register DMA_TCD4_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD4_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD4_SLAST_SLAST.
#define BM_DMA_TCD4_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD4_SLAST_SLAST.
#define BS_DMA_TCD4_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD4_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_SLAST_SLAST field.
#define BR_DMA_TCD4_SLAST_SLAST()   (HW_DMA_TCD4_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD4_SLAST_SLAST.
#define BF_DMA_TCD4_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_SLAST_SLAST), uint32_t) & BM_DMA_TCD4_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD4_SLAST_SLAST(v)   (HW_DMA_TCD4_SLAST_WR((HW_DMA_TCD4_SLAST_RD() & ~BM_DMA_TCD4_SLAST_SLAST) | BF_DMA_TCD4_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd4_daddr
{
    uint32_t U;
    struct _hw_dma_tcd4_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd4_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_DADDR register
 */
//@{
#define HW_DMA_TCD4_DADDR_ADDR      (REGS_DMA_BASE + 0x1090U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_DADDR           (*(__IO hw_dma_tcd4_daddr_t *) HW_DMA_TCD4_DADDR_ADDR)
#define HW_DMA_TCD4_DADDR_RD()      (HW_DMA_TCD4_DADDR.U)
#define HW_DMA_TCD4_DADDR_WR(v)     (HW_DMA_TCD4_DADDR.U = (v))
#define HW_DMA_TCD4_DADDR_SET(v)    (HW_DMA_TCD4_DADDR_WR(HW_DMA_TCD4_DADDR_RD() |  (v)))
#define HW_DMA_TCD4_DADDR_CLR(v)    (HW_DMA_TCD4_DADDR_WR(HW_DMA_TCD4_DADDR_RD() & ~(v)))
#define HW_DMA_TCD4_DADDR_TOG(v)    (HW_DMA_TCD4_DADDR_WR(HW_DMA_TCD4_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_DADDR bitfields
 */

/*! @name Register DMA_TCD4_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD4_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD4_DADDR_DADDR.
#define BM_DMA_TCD4_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD4_DADDR_DADDR.
#define BS_DMA_TCD4_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD4_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_DADDR_DADDR field.
#define BR_DMA_TCD4_DADDR_DADDR()   (HW_DMA_TCD4_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD4_DADDR_DADDR.
#define BF_DMA_TCD4_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_DADDR_DADDR), uint32_t) & BM_DMA_TCD4_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD4_DADDR_DADDR(v)   (HW_DMA_TCD4_DADDR_WR((HW_DMA_TCD4_DADDR_RD() & ~BM_DMA_TCD4_DADDR_DADDR) | BF_DMA_TCD4_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd4_doff
{
    uint16_t U;
    struct _hw_dma_tcd4_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd4_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_DOFF register
 */
//@{
#define HW_DMA_TCD4_DOFF_ADDR      (REGS_DMA_BASE + 0x1094U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_DOFF           (*(__IO hw_dma_tcd4_doff_t *) HW_DMA_TCD4_DOFF_ADDR)
#define HW_DMA_TCD4_DOFF_RD()      (HW_DMA_TCD4_DOFF.U)
#define HW_DMA_TCD4_DOFF_WR(v)     (HW_DMA_TCD4_DOFF.U = (v))
#define HW_DMA_TCD4_DOFF_SET(v)    (HW_DMA_TCD4_DOFF_WR(HW_DMA_TCD4_DOFF_RD() |  (v)))
#define HW_DMA_TCD4_DOFF_CLR(v)    (HW_DMA_TCD4_DOFF_WR(HW_DMA_TCD4_DOFF_RD() & ~(v)))
#define HW_DMA_TCD4_DOFF_TOG(v)    (HW_DMA_TCD4_DOFF_WR(HW_DMA_TCD4_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_DOFF bitfields
 */

/*! @name Register DMA_TCD4_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD4_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD4_DOFF_DOFF.
#define BM_DMA_TCD4_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD4_DOFF_DOFF.
#define BS_DMA_TCD4_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD4_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_DOFF_DOFF field.
#define BR_DMA_TCD4_DOFF_DOFF()   (HW_DMA_TCD4_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD4_DOFF_DOFF.
#define BF_DMA_TCD4_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_DOFF_DOFF), uint16_t) & BM_DMA_TCD4_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD4_DOFF_DOFF(v)   (HW_DMA_TCD4_DOFF_WR((HW_DMA_TCD4_DOFF_RD() & ~BM_DMA_TCD4_DOFF_DOFF) | BF_DMA_TCD4_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd4_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd4_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd4_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD4_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1096U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_CITER_ELINKYES           (*(__IO hw_dma_tcd4_citer_elinkyes_t *) HW_DMA_TCD4_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD4_CITER_ELINKYES_RD()      (HW_DMA_TCD4_CITER_ELINKYES.U)
#define HW_DMA_TCD4_CITER_ELINKYES_WR(v)     (HW_DMA_TCD4_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD4_CITER_ELINKYES_SET(v)    (HW_DMA_TCD4_CITER_ELINKYES_WR(HW_DMA_TCD4_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD4_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD4_CITER_ELINKYES_WR(HW_DMA_TCD4_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD4_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD4_CITER_ELINKYES_WR(HW_DMA_TCD4_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD4_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD4_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD4_CITER_ELINKYES_CITER.
#define BM_DMA_TCD4_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD4_CITER_ELINKYES_CITER.
#define BS_DMA_TCD4_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD4_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD4_CITER_ELINKYES_CITER()   (HW_DMA_TCD4_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD4_CITER_ELINKYES_CITER.
#define BF_DMA_TCD4_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD4_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD4_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD4_CITER_ELINKYES_WR((HW_DMA_TCD4_CITER_ELINKYES_RD() & ~BM_DMA_TCD4_CITER_ELINKYES_CITER) | BF_DMA_TCD4_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD4_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD4_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD4_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD4_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD4_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD4_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD4_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD4_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD4_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD4_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD4_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD4_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD4_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD4_CITER_ELINKYES_WR((HW_DMA_TCD4_CITER_ELINKYES_RD() & ~BM_DMA_TCD4_CITER_ELINKYES_LINKCH) | BF_DMA_TCD4_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD4_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD4_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD4_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD4_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD4_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD4_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD4_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD4_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD4_CITER_ELINKYES_ADDR, BP_DMA_TCD4_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD4_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD4_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD4_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD4_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CITER_ELINKYES_ADDR, BP_DMA_TCD4_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd4_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd4_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd4_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD4_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1096U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_CITER_ELINKNO           (*(__IO hw_dma_tcd4_citer_elinkno_t *) HW_DMA_TCD4_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD4_CITER_ELINKNO_RD()      (HW_DMA_TCD4_CITER_ELINKNO.U)
#define HW_DMA_TCD4_CITER_ELINKNO_WR(v)     (HW_DMA_TCD4_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD4_CITER_ELINKNO_SET(v)    (HW_DMA_TCD4_CITER_ELINKNO_WR(HW_DMA_TCD4_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD4_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD4_CITER_ELINKNO_WR(HW_DMA_TCD4_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD4_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD4_CITER_ELINKNO_WR(HW_DMA_TCD4_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD4_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD4_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD4_CITER_ELINKNO_CITER.
#define BM_DMA_TCD4_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD4_CITER_ELINKNO_CITER.
#define BS_DMA_TCD4_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD4_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD4_CITER_ELINKNO_CITER()   (HW_DMA_TCD4_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD4_CITER_ELINKNO_CITER.
#define BF_DMA_TCD4_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD4_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD4_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD4_CITER_ELINKNO_WR((HW_DMA_TCD4_CITER_ELINKNO_RD() & ~BM_DMA_TCD4_CITER_ELINKNO_CITER) | BF_DMA_TCD4_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD4_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD4_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD4_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD4_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD4_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD4_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD4_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD4_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD4_CITER_ELINKNO_ADDR, BP_DMA_TCD4_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD4_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD4_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD4_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD4_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CITER_ELINKNO_ADDR, BP_DMA_TCD4_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd4_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd4_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd4_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_DLASTSGA register
 */
//@{
#define HW_DMA_TCD4_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1098U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_DLASTSGA           (*(__IO hw_dma_tcd4_dlastsga_t *) HW_DMA_TCD4_DLASTSGA_ADDR)
#define HW_DMA_TCD4_DLASTSGA_RD()      (HW_DMA_TCD4_DLASTSGA.U)
#define HW_DMA_TCD4_DLASTSGA_WR(v)     (HW_DMA_TCD4_DLASTSGA.U = (v))
#define HW_DMA_TCD4_DLASTSGA_SET(v)    (HW_DMA_TCD4_DLASTSGA_WR(HW_DMA_TCD4_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD4_DLASTSGA_CLR(v)    (HW_DMA_TCD4_DLASTSGA_WR(HW_DMA_TCD4_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD4_DLASTSGA_TOG(v)    (HW_DMA_TCD4_DLASTSGA_WR(HW_DMA_TCD4_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD4_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD4_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD4_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD4_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD4_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD4_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD4_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD4_DLASTSGA_DLASTSGA()   (HW_DMA_TCD4_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD4_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD4_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD4_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD4_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD4_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD4_DLASTSGA_WR((HW_DMA_TCD4_DLASTSGA_RD() & ~BM_DMA_TCD4_DLASTSGA_DLASTSGA) | BF_DMA_TCD4_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd4_csr
{
    uint16_t U;
    struct _hw_dma_tcd4_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd4_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_CSR register
 */
//@{
#define HW_DMA_TCD4_CSR_ADDR      (REGS_DMA_BASE + 0x109cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_CSR           (*(__IO hw_dma_tcd4_csr_t *) HW_DMA_TCD4_CSR_ADDR)
#define HW_DMA_TCD4_CSR_RD()      (HW_DMA_TCD4_CSR.U)
#define HW_DMA_TCD4_CSR_WR(v)     (HW_DMA_TCD4_CSR.U = (v))
#define HW_DMA_TCD4_CSR_SET(v)    (HW_DMA_TCD4_CSR_WR(HW_DMA_TCD4_CSR_RD() |  (v)))
#define HW_DMA_TCD4_CSR_CLR(v)    (HW_DMA_TCD4_CSR_WR(HW_DMA_TCD4_CSR_RD() & ~(v)))
#define HW_DMA_TCD4_CSR_TOG(v)    (HW_DMA_TCD4_CSR_WR(HW_DMA_TCD4_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_CSR bitfields
 */

/*! @name Register DMA_TCD4_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD4_CSR_START      (0U)      //!< Bit position for DMA_TCD4_CSR_START.
#define BM_DMA_TCD4_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD4_CSR_START.
#define BS_DMA_TCD4_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD4_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_START field.
#define BR_DMA_TCD4_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_START.
#define BF_DMA_TCD4_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_START), uint16_t) & BM_DMA_TCD4_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD4_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD4_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD4_CSR_INTMAJOR.
#define BM_DMA_TCD4_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD4_CSR_INTMAJOR.
#define BS_DMA_TCD4_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD4_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_INTMAJOR field.
#define BR_DMA_TCD4_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_INTMAJOR.
#define BF_DMA_TCD4_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD4_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD4_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD4_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD4_CSR_INTHALF.
#define BM_DMA_TCD4_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD4_CSR_INTHALF.
#define BS_DMA_TCD4_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD4_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_INTHALF field.
#define BR_DMA_TCD4_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_INTHALF.
#define BF_DMA_TCD4_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_INTHALF), uint16_t) & BM_DMA_TCD4_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD4_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD4_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD4_CSR_DREQ.
#define BM_DMA_TCD4_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD4_CSR_DREQ.
#define BS_DMA_TCD4_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD4_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_DREQ field.
#define BR_DMA_TCD4_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_DREQ.
#define BF_DMA_TCD4_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_DREQ), uint16_t) & BM_DMA_TCD4_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD4_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD4_CSR_ESG      (4U)      //!< Bit position for DMA_TCD4_CSR_ESG.
#define BM_DMA_TCD4_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD4_CSR_ESG.
#define BS_DMA_TCD4_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD4_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_ESG field.
#define BR_DMA_TCD4_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_ESG.
#define BF_DMA_TCD4_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_ESG), uint16_t) & BM_DMA_TCD4_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD4_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD4_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD4_CSR_MAJORELINK.
#define BM_DMA_TCD4_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD4_CSR_MAJORELINK.
#define BS_DMA_TCD4_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD4_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_MAJORELINK field.
#define BR_DMA_TCD4_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_MAJORELINK.
#define BF_DMA_TCD4_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD4_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD4_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD4_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD4_CSR_ACTIVE.
#define BM_DMA_TCD4_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD4_CSR_ACTIVE.
#define BS_DMA_TCD4_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD4_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_ACTIVE field.
#define BR_DMA_TCD4_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_ACTIVE.
#define BF_DMA_TCD4_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_ACTIVE), uint16_t) & BM_DMA_TCD4_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD4_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD4_CSR_DONE      (7U)      //!< Bit position for DMA_TCD4_CSR_DONE.
#define BM_DMA_TCD4_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD4_CSR_DONE.
#define BS_DMA_TCD4_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD4_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_DONE field.
#define BR_DMA_TCD4_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_DONE.
#define BF_DMA_TCD4_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_DONE), uint16_t) & BM_DMA_TCD4_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD4_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_CSR_ADDR, BP_DMA_TCD4_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD4_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD4_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD4_CSR_MAJORLINKCH.
#define BM_DMA_TCD4_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD4_CSR_MAJORLINKCH.
#define BS_DMA_TCD4_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD4_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_MAJORLINKCH field.
#define BR_DMA_TCD4_CSR_MAJORLINKCH()   (HW_DMA_TCD4_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_MAJORLINKCH.
#define BF_DMA_TCD4_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD4_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD4_CSR_MAJORLINKCH(v)   (HW_DMA_TCD4_CSR_WR((HW_DMA_TCD4_CSR_RD() & ~BM_DMA_TCD4_CSR_MAJORLINKCH) | BF_DMA_TCD4_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD4_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD4_CSR_BWC      (14U)      //!< Bit position for DMA_TCD4_CSR_BWC.
#define BM_DMA_TCD4_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD4_CSR_BWC.
#define BS_DMA_TCD4_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD4_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_CSR_BWC field.
#define BR_DMA_TCD4_CSR_BWC()   (HW_DMA_TCD4_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD4_CSR_BWC.
#define BF_DMA_TCD4_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_CSR_BWC), uint16_t) & BM_DMA_TCD4_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD4_CSR_BWC(v)   (HW_DMA_TCD4_CSR_WR((HW_DMA_TCD4_CSR_RD() & ~BM_DMA_TCD4_CSR_BWC) | BF_DMA_TCD4_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd4_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd4_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd4_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD4_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x109eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_BITER_ELINKYES           (*(__IO hw_dma_tcd4_biter_elinkyes_t *) HW_DMA_TCD4_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD4_BITER_ELINKYES_RD()      (HW_DMA_TCD4_BITER_ELINKYES.U)
#define HW_DMA_TCD4_BITER_ELINKYES_WR(v)     (HW_DMA_TCD4_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD4_BITER_ELINKYES_SET(v)    (HW_DMA_TCD4_BITER_ELINKYES_WR(HW_DMA_TCD4_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD4_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD4_BITER_ELINKYES_WR(HW_DMA_TCD4_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD4_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD4_BITER_ELINKYES_WR(HW_DMA_TCD4_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD4_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD4_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD4_BITER_ELINKYES_BITER.
#define BM_DMA_TCD4_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD4_BITER_ELINKYES_BITER.
#define BS_DMA_TCD4_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD4_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD4_BITER_ELINKYES_BITER()   (HW_DMA_TCD4_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD4_BITER_ELINKYES_BITER.
#define BF_DMA_TCD4_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD4_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD4_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD4_BITER_ELINKYES_WR((HW_DMA_TCD4_BITER_ELINKYES_RD() & ~BM_DMA_TCD4_BITER_ELINKYES_BITER) | BF_DMA_TCD4_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD4_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD4_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD4_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD4_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD4_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD4_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD4_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD4_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD4_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD4_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD4_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD4_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD4_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD4_BITER_ELINKYES_WR((HW_DMA_TCD4_BITER_ELINKYES_RD() & ~BM_DMA_TCD4_BITER_ELINKYES_LINKCH) | BF_DMA_TCD4_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD4_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD4_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD4_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD4_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD4_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD4_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD4_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD4_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD4_BITER_ELINKYES_ADDR, BP_DMA_TCD4_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD4_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD4_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD4_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD4_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_BITER_ELINKYES_ADDR, BP_DMA_TCD4_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD4_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD4_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd4_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd4_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd4_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD4_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD4_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x109eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD4_BITER_ELINKNO           (*(__IO hw_dma_tcd4_biter_elinkno_t *) HW_DMA_TCD4_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD4_BITER_ELINKNO_RD()      (HW_DMA_TCD4_BITER_ELINKNO.U)
#define HW_DMA_TCD4_BITER_ELINKNO_WR(v)     (HW_DMA_TCD4_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD4_BITER_ELINKNO_SET(v)    (HW_DMA_TCD4_BITER_ELINKNO_WR(HW_DMA_TCD4_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD4_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD4_BITER_ELINKNO_WR(HW_DMA_TCD4_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD4_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD4_BITER_ELINKNO_WR(HW_DMA_TCD4_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD4_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD4_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD4_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD4_BITER_ELINKNO_BITER.
#define BM_DMA_TCD4_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD4_BITER_ELINKNO_BITER.
#define BS_DMA_TCD4_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD4_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD4_BITER_ELINKNO_BITER()   (HW_DMA_TCD4_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD4_BITER_ELINKNO_BITER.
#define BF_DMA_TCD4_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD4_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD4_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD4_BITER_ELINKNO_WR((HW_DMA_TCD4_BITER_ELINKNO_RD() & ~BM_DMA_TCD4_BITER_ELINKNO_BITER) | BF_DMA_TCD4_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD4_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD4_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD4_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD4_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD4_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD4_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD4_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD4_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD4_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD4_BITER_ELINKNO_ADDR, BP_DMA_TCD4_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD4_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD4_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD4_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD4_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD4_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD4_BITER_ELINKNO_ADDR, BP_DMA_TCD4_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd5_saddr
{
    uint32_t U;
    struct _hw_dma_tcd5_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd5_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_SADDR register
 */
//@{
#define HW_DMA_TCD5_SADDR_ADDR      (REGS_DMA_BASE + 0x10a0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_SADDR           (*(__IO hw_dma_tcd5_saddr_t *) HW_DMA_TCD5_SADDR_ADDR)
#define HW_DMA_TCD5_SADDR_RD()      (HW_DMA_TCD5_SADDR.U)
#define HW_DMA_TCD5_SADDR_WR(v)     (HW_DMA_TCD5_SADDR.U = (v))
#define HW_DMA_TCD5_SADDR_SET(v)    (HW_DMA_TCD5_SADDR_WR(HW_DMA_TCD5_SADDR_RD() |  (v)))
#define HW_DMA_TCD5_SADDR_CLR(v)    (HW_DMA_TCD5_SADDR_WR(HW_DMA_TCD5_SADDR_RD() & ~(v)))
#define HW_DMA_TCD5_SADDR_TOG(v)    (HW_DMA_TCD5_SADDR_WR(HW_DMA_TCD5_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_SADDR bitfields
 */

/*! @name Register DMA_TCD5_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD5_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD5_SADDR_SADDR.
#define BM_DMA_TCD5_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD5_SADDR_SADDR.
#define BS_DMA_TCD5_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD5_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_SADDR_SADDR field.
#define BR_DMA_TCD5_SADDR_SADDR()   (HW_DMA_TCD5_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD5_SADDR_SADDR.
#define BF_DMA_TCD5_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_SADDR_SADDR), uint32_t) & BM_DMA_TCD5_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD5_SADDR_SADDR(v)   (HW_DMA_TCD5_SADDR_WR((HW_DMA_TCD5_SADDR_RD() & ~BM_DMA_TCD5_SADDR_SADDR) | BF_DMA_TCD5_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd5_soff
{
    uint16_t U;
    struct _hw_dma_tcd5_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd5_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_SOFF register
 */
//@{
#define HW_DMA_TCD5_SOFF_ADDR      (REGS_DMA_BASE + 0x10a4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_SOFF           (*(__IO hw_dma_tcd5_soff_t *) HW_DMA_TCD5_SOFF_ADDR)
#define HW_DMA_TCD5_SOFF_RD()      (HW_DMA_TCD5_SOFF.U)
#define HW_DMA_TCD5_SOFF_WR(v)     (HW_DMA_TCD5_SOFF.U = (v))
#define HW_DMA_TCD5_SOFF_SET(v)    (HW_DMA_TCD5_SOFF_WR(HW_DMA_TCD5_SOFF_RD() |  (v)))
#define HW_DMA_TCD5_SOFF_CLR(v)    (HW_DMA_TCD5_SOFF_WR(HW_DMA_TCD5_SOFF_RD() & ~(v)))
#define HW_DMA_TCD5_SOFF_TOG(v)    (HW_DMA_TCD5_SOFF_WR(HW_DMA_TCD5_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_SOFF bitfields
 */

/*! @name Register DMA_TCD5_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD5_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD5_SOFF_SOFF.
#define BM_DMA_TCD5_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD5_SOFF_SOFF.
#define BS_DMA_TCD5_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD5_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_SOFF_SOFF field.
#define BR_DMA_TCD5_SOFF_SOFF()   (HW_DMA_TCD5_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD5_SOFF_SOFF.
#define BF_DMA_TCD5_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_SOFF_SOFF), uint16_t) & BM_DMA_TCD5_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD5_SOFF_SOFF(v)   (HW_DMA_TCD5_SOFF_WR((HW_DMA_TCD5_SOFF_RD() & ~BM_DMA_TCD5_SOFF_SOFF) | BF_DMA_TCD5_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd5_attr
{
    uint16_t U;
    struct _hw_dma_tcd5_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd5_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_ATTR register
 */
//@{
#define HW_DMA_TCD5_ATTR_ADDR      (REGS_DMA_BASE + 0x10a6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_ATTR           (*(__IO hw_dma_tcd5_attr_t *) HW_DMA_TCD5_ATTR_ADDR)
#define HW_DMA_TCD5_ATTR_RD()      (HW_DMA_TCD5_ATTR.U)
#define HW_DMA_TCD5_ATTR_WR(v)     (HW_DMA_TCD5_ATTR.U = (v))
#define HW_DMA_TCD5_ATTR_SET(v)    (HW_DMA_TCD5_ATTR_WR(HW_DMA_TCD5_ATTR_RD() |  (v)))
#define HW_DMA_TCD5_ATTR_CLR(v)    (HW_DMA_TCD5_ATTR_WR(HW_DMA_TCD5_ATTR_RD() & ~(v)))
#define HW_DMA_TCD5_ATTR_TOG(v)    (HW_DMA_TCD5_ATTR_WR(HW_DMA_TCD5_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_ATTR bitfields
 */

/*! @name Register DMA_TCD5_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD5_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD5_ATTR_DSIZE.
#define BM_DMA_TCD5_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD5_ATTR_DSIZE.
#define BS_DMA_TCD5_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD5_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_ATTR_DSIZE field.
#define BR_DMA_TCD5_ATTR_DSIZE()   (HW_DMA_TCD5_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD5_ATTR_DSIZE.
#define BF_DMA_TCD5_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_ATTR_DSIZE), uint16_t) & BM_DMA_TCD5_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD5_ATTR_DSIZE(v)   (HW_DMA_TCD5_ATTR_WR((HW_DMA_TCD5_ATTR_RD() & ~BM_DMA_TCD5_ATTR_DSIZE) | BF_DMA_TCD5_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD5_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD5_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD5_ATTR_DMOD.
#define BM_DMA_TCD5_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD5_ATTR_DMOD.
#define BS_DMA_TCD5_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD5_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_ATTR_DMOD field.
#define BR_DMA_TCD5_ATTR_DMOD()   (HW_DMA_TCD5_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD5_ATTR_DMOD.
#define BF_DMA_TCD5_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_ATTR_DMOD), uint16_t) & BM_DMA_TCD5_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD5_ATTR_DMOD(v)   (HW_DMA_TCD5_ATTR_WR((HW_DMA_TCD5_ATTR_RD() & ~BM_DMA_TCD5_ATTR_DMOD) | BF_DMA_TCD5_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD5_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD5_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD5_ATTR_SSIZE.
#define BM_DMA_TCD5_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD5_ATTR_SSIZE.
#define BS_DMA_TCD5_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD5_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_ATTR_SSIZE field.
#define BR_DMA_TCD5_ATTR_SSIZE()   (HW_DMA_TCD5_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD5_ATTR_SSIZE.
#define BF_DMA_TCD5_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_ATTR_SSIZE), uint16_t) & BM_DMA_TCD5_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD5_ATTR_SSIZE(v)   (HW_DMA_TCD5_ATTR_WR((HW_DMA_TCD5_ATTR_RD() & ~BM_DMA_TCD5_ATTR_SSIZE) | BF_DMA_TCD5_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD5_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD5_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD5_ATTR_SMOD.
#define BM_DMA_TCD5_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD5_ATTR_SMOD.
#define BS_DMA_TCD5_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD5_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_ATTR_SMOD field.
#define BR_DMA_TCD5_ATTR_SMOD()   (HW_DMA_TCD5_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD5_ATTR_SMOD.
#define BF_DMA_TCD5_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_ATTR_SMOD), uint16_t) & BM_DMA_TCD5_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD5_ATTR_SMOD(v)   (HW_DMA_TCD5_ATTR_WR((HW_DMA_TCD5_ATTR_RD() & ~BM_DMA_TCD5_ATTR_SMOD) | BF_DMA_TCD5_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd5_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd5_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd5_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD5_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x10a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_NBYTES_MLNO           (*(__IO hw_dma_tcd5_nbytes_mlno_t *) HW_DMA_TCD5_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD5_NBYTES_MLNO_RD()      (HW_DMA_TCD5_NBYTES_MLNO.U)
#define HW_DMA_TCD5_NBYTES_MLNO_WR(v)     (HW_DMA_TCD5_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD5_NBYTES_MLNO_SET(v)    (HW_DMA_TCD5_NBYTES_MLNO_WR(HW_DMA_TCD5_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD5_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD5_NBYTES_MLNO_WR(HW_DMA_TCD5_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD5_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD5_NBYTES_MLNO_WR(HW_DMA_TCD5_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD5_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD5_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD5_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD5_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD5_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD5_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD5_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD5_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD5_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD5_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD5_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD5_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD5_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD5_NBYTES_MLNO_WR((HW_DMA_TCD5_NBYTES_MLNO_RD() & ~BM_DMA_TCD5_NBYTES_MLNO_NBYTES) | BF_DMA_TCD5_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd5_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd5_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd5_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD5_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x10a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd5_nbytes_mloffno_t *) HW_DMA_TCD5_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD5_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD5_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD5_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD5_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD5_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD5_NBYTES_MLOFFNO_WR(HW_DMA_TCD5_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD5_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD5_NBYTES_MLOFFNO_WR(HW_DMA_TCD5_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD5_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD5_NBYTES_MLOFFNO_WR(HW_DMA_TCD5_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD5_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD5_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD5_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD5_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD5_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD5_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD5_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD5_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD5_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD5_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD5_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD5_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD5_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD5_NBYTES_MLOFFNO_WR((HW_DMA_TCD5_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD5_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD5_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD5_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD5_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD5_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD5_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD5_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD5_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD5_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD5_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD5_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD5_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD5_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD5_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD5_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD5_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD5_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD5_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD5_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD5_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD5_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD5_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD5_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD5_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD5_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD5_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD5_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD5_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD5_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD5_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD5_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD5_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD5_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd5_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd5_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd5_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD5_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x10a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd5_nbytes_mloffyes_t *) HW_DMA_TCD5_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD5_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD5_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD5_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD5_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD5_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD5_NBYTES_MLOFFYES_WR(HW_DMA_TCD5_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD5_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD5_NBYTES_MLOFFYES_WR(HW_DMA_TCD5_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD5_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD5_NBYTES_MLOFFYES_WR(HW_DMA_TCD5_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD5_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD5_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD5_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD5_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD5_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD5_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD5_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD5_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD5_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD5_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD5_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD5_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD5_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD5_NBYTES_MLOFFYES_WR((HW_DMA_TCD5_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD5_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD5_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD5_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD5_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD5_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD5_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD5_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD5_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD5_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD5_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD5_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD5_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD5_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD5_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD5_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD5_NBYTES_MLOFFYES_WR((HW_DMA_TCD5_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD5_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD5_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD5_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD5_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD5_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD5_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD5_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD5_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD5_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD5_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD5_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD5_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD5_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD5_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD5_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD5_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD5_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD5_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD5_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD5_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD5_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD5_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD5_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD5_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD5_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD5_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD5_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD5_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD5_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD5_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD5_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD5_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD5_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd5_slast
{
    uint32_t U;
    struct _hw_dma_tcd5_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd5_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_SLAST register
 */
//@{
#define HW_DMA_TCD5_SLAST_ADDR      (REGS_DMA_BASE + 0x10acU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_SLAST           (*(__IO hw_dma_tcd5_slast_t *) HW_DMA_TCD5_SLAST_ADDR)
#define HW_DMA_TCD5_SLAST_RD()      (HW_DMA_TCD5_SLAST.U)
#define HW_DMA_TCD5_SLAST_WR(v)     (HW_DMA_TCD5_SLAST.U = (v))
#define HW_DMA_TCD5_SLAST_SET(v)    (HW_DMA_TCD5_SLAST_WR(HW_DMA_TCD5_SLAST_RD() |  (v)))
#define HW_DMA_TCD5_SLAST_CLR(v)    (HW_DMA_TCD5_SLAST_WR(HW_DMA_TCD5_SLAST_RD() & ~(v)))
#define HW_DMA_TCD5_SLAST_TOG(v)    (HW_DMA_TCD5_SLAST_WR(HW_DMA_TCD5_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_SLAST bitfields
 */

/*! @name Register DMA_TCD5_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD5_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD5_SLAST_SLAST.
#define BM_DMA_TCD5_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD5_SLAST_SLAST.
#define BS_DMA_TCD5_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD5_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_SLAST_SLAST field.
#define BR_DMA_TCD5_SLAST_SLAST()   (HW_DMA_TCD5_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD5_SLAST_SLAST.
#define BF_DMA_TCD5_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_SLAST_SLAST), uint32_t) & BM_DMA_TCD5_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD5_SLAST_SLAST(v)   (HW_DMA_TCD5_SLAST_WR((HW_DMA_TCD5_SLAST_RD() & ~BM_DMA_TCD5_SLAST_SLAST) | BF_DMA_TCD5_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd5_daddr
{
    uint32_t U;
    struct _hw_dma_tcd5_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd5_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_DADDR register
 */
//@{
#define HW_DMA_TCD5_DADDR_ADDR      (REGS_DMA_BASE + 0x10b0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_DADDR           (*(__IO hw_dma_tcd5_daddr_t *) HW_DMA_TCD5_DADDR_ADDR)
#define HW_DMA_TCD5_DADDR_RD()      (HW_DMA_TCD5_DADDR.U)
#define HW_DMA_TCD5_DADDR_WR(v)     (HW_DMA_TCD5_DADDR.U = (v))
#define HW_DMA_TCD5_DADDR_SET(v)    (HW_DMA_TCD5_DADDR_WR(HW_DMA_TCD5_DADDR_RD() |  (v)))
#define HW_DMA_TCD5_DADDR_CLR(v)    (HW_DMA_TCD5_DADDR_WR(HW_DMA_TCD5_DADDR_RD() & ~(v)))
#define HW_DMA_TCD5_DADDR_TOG(v)    (HW_DMA_TCD5_DADDR_WR(HW_DMA_TCD5_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_DADDR bitfields
 */

/*! @name Register DMA_TCD5_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD5_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD5_DADDR_DADDR.
#define BM_DMA_TCD5_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD5_DADDR_DADDR.
#define BS_DMA_TCD5_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD5_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_DADDR_DADDR field.
#define BR_DMA_TCD5_DADDR_DADDR()   (HW_DMA_TCD5_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD5_DADDR_DADDR.
#define BF_DMA_TCD5_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_DADDR_DADDR), uint32_t) & BM_DMA_TCD5_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD5_DADDR_DADDR(v)   (HW_DMA_TCD5_DADDR_WR((HW_DMA_TCD5_DADDR_RD() & ~BM_DMA_TCD5_DADDR_DADDR) | BF_DMA_TCD5_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd5_doff
{
    uint16_t U;
    struct _hw_dma_tcd5_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd5_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_DOFF register
 */
//@{
#define HW_DMA_TCD5_DOFF_ADDR      (REGS_DMA_BASE + 0x10b4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_DOFF           (*(__IO hw_dma_tcd5_doff_t *) HW_DMA_TCD5_DOFF_ADDR)
#define HW_DMA_TCD5_DOFF_RD()      (HW_DMA_TCD5_DOFF.U)
#define HW_DMA_TCD5_DOFF_WR(v)     (HW_DMA_TCD5_DOFF.U = (v))
#define HW_DMA_TCD5_DOFF_SET(v)    (HW_DMA_TCD5_DOFF_WR(HW_DMA_TCD5_DOFF_RD() |  (v)))
#define HW_DMA_TCD5_DOFF_CLR(v)    (HW_DMA_TCD5_DOFF_WR(HW_DMA_TCD5_DOFF_RD() & ~(v)))
#define HW_DMA_TCD5_DOFF_TOG(v)    (HW_DMA_TCD5_DOFF_WR(HW_DMA_TCD5_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_DOFF bitfields
 */

/*! @name Register DMA_TCD5_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD5_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD5_DOFF_DOFF.
#define BM_DMA_TCD5_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD5_DOFF_DOFF.
#define BS_DMA_TCD5_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD5_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_DOFF_DOFF field.
#define BR_DMA_TCD5_DOFF_DOFF()   (HW_DMA_TCD5_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD5_DOFF_DOFF.
#define BF_DMA_TCD5_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_DOFF_DOFF), uint16_t) & BM_DMA_TCD5_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD5_DOFF_DOFF(v)   (HW_DMA_TCD5_DOFF_WR((HW_DMA_TCD5_DOFF_RD() & ~BM_DMA_TCD5_DOFF_DOFF) | BF_DMA_TCD5_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd5_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd5_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd5_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD5_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x10b6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_CITER_ELINKYES           (*(__IO hw_dma_tcd5_citer_elinkyes_t *) HW_DMA_TCD5_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD5_CITER_ELINKYES_RD()      (HW_DMA_TCD5_CITER_ELINKYES.U)
#define HW_DMA_TCD5_CITER_ELINKYES_WR(v)     (HW_DMA_TCD5_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD5_CITER_ELINKYES_SET(v)    (HW_DMA_TCD5_CITER_ELINKYES_WR(HW_DMA_TCD5_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD5_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD5_CITER_ELINKYES_WR(HW_DMA_TCD5_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD5_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD5_CITER_ELINKYES_WR(HW_DMA_TCD5_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD5_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD5_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD5_CITER_ELINKYES_CITER.
#define BM_DMA_TCD5_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD5_CITER_ELINKYES_CITER.
#define BS_DMA_TCD5_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD5_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD5_CITER_ELINKYES_CITER()   (HW_DMA_TCD5_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD5_CITER_ELINKYES_CITER.
#define BF_DMA_TCD5_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD5_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD5_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD5_CITER_ELINKYES_WR((HW_DMA_TCD5_CITER_ELINKYES_RD() & ~BM_DMA_TCD5_CITER_ELINKYES_CITER) | BF_DMA_TCD5_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD5_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD5_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD5_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD5_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD5_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD5_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD5_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD5_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD5_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD5_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD5_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD5_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD5_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD5_CITER_ELINKYES_WR((HW_DMA_TCD5_CITER_ELINKYES_RD() & ~BM_DMA_TCD5_CITER_ELINKYES_LINKCH) | BF_DMA_TCD5_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD5_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD5_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD5_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD5_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD5_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD5_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD5_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD5_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD5_CITER_ELINKYES_ADDR, BP_DMA_TCD5_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD5_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD5_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD5_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD5_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CITER_ELINKYES_ADDR, BP_DMA_TCD5_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd5_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd5_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd5_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD5_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x10b6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_CITER_ELINKNO           (*(__IO hw_dma_tcd5_citer_elinkno_t *) HW_DMA_TCD5_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD5_CITER_ELINKNO_RD()      (HW_DMA_TCD5_CITER_ELINKNO.U)
#define HW_DMA_TCD5_CITER_ELINKNO_WR(v)     (HW_DMA_TCD5_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD5_CITER_ELINKNO_SET(v)    (HW_DMA_TCD5_CITER_ELINKNO_WR(HW_DMA_TCD5_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD5_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD5_CITER_ELINKNO_WR(HW_DMA_TCD5_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD5_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD5_CITER_ELINKNO_WR(HW_DMA_TCD5_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD5_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD5_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD5_CITER_ELINKNO_CITER.
#define BM_DMA_TCD5_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD5_CITER_ELINKNO_CITER.
#define BS_DMA_TCD5_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD5_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD5_CITER_ELINKNO_CITER()   (HW_DMA_TCD5_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD5_CITER_ELINKNO_CITER.
#define BF_DMA_TCD5_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD5_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD5_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD5_CITER_ELINKNO_WR((HW_DMA_TCD5_CITER_ELINKNO_RD() & ~BM_DMA_TCD5_CITER_ELINKNO_CITER) | BF_DMA_TCD5_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD5_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD5_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD5_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD5_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD5_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD5_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD5_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD5_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD5_CITER_ELINKNO_ADDR, BP_DMA_TCD5_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD5_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD5_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD5_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD5_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CITER_ELINKNO_ADDR, BP_DMA_TCD5_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd5_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd5_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd5_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_DLASTSGA register
 */
//@{
#define HW_DMA_TCD5_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x10b8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_DLASTSGA           (*(__IO hw_dma_tcd5_dlastsga_t *) HW_DMA_TCD5_DLASTSGA_ADDR)
#define HW_DMA_TCD5_DLASTSGA_RD()      (HW_DMA_TCD5_DLASTSGA.U)
#define HW_DMA_TCD5_DLASTSGA_WR(v)     (HW_DMA_TCD5_DLASTSGA.U = (v))
#define HW_DMA_TCD5_DLASTSGA_SET(v)    (HW_DMA_TCD5_DLASTSGA_WR(HW_DMA_TCD5_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD5_DLASTSGA_CLR(v)    (HW_DMA_TCD5_DLASTSGA_WR(HW_DMA_TCD5_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD5_DLASTSGA_TOG(v)    (HW_DMA_TCD5_DLASTSGA_WR(HW_DMA_TCD5_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD5_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD5_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD5_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD5_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD5_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD5_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD5_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD5_DLASTSGA_DLASTSGA()   (HW_DMA_TCD5_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD5_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD5_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD5_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD5_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD5_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD5_DLASTSGA_WR((HW_DMA_TCD5_DLASTSGA_RD() & ~BM_DMA_TCD5_DLASTSGA_DLASTSGA) | BF_DMA_TCD5_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd5_csr
{
    uint16_t U;
    struct _hw_dma_tcd5_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd5_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_CSR register
 */
//@{
#define HW_DMA_TCD5_CSR_ADDR      (REGS_DMA_BASE + 0x10bcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_CSR           (*(__IO hw_dma_tcd5_csr_t *) HW_DMA_TCD5_CSR_ADDR)
#define HW_DMA_TCD5_CSR_RD()      (HW_DMA_TCD5_CSR.U)
#define HW_DMA_TCD5_CSR_WR(v)     (HW_DMA_TCD5_CSR.U = (v))
#define HW_DMA_TCD5_CSR_SET(v)    (HW_DMA_TCD5_CSR_WR(HW_DMA_TCD5_CSR_RD() |  (v)))
#define HW_DMA_TCD5_CSR_CLR(v)    (HW_DMA_TCD5_CSR_WR(HW_DMA_TCD5_CSR_RD() & ~(v)))
#define HW_DMA_TCD5_CSR_TOG(v)    (HW_DMA_TCD5_CSR_WR(HW_DMA_TCD5_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_CSR bitfields
 */

/*! @name Register DMA_TCD5_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD5_CSR_START      (0U)      //!< Bit position for DMA_TCD5_CSR_START.
#define BM_DMA_TCD5_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD5_CSR_START.
#define BS_DMA_TCD5_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD5_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_START field.
#define BR_DMA_TCD5_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_START.
#define BF_DMA_TCD5_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_START), uint16_t) & BM_DMA_TCD5_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD5_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD5_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD5_CSR_INTMAJOR.
#define BM_DMA_TCD5_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD5_CSR_INTMAJOR.
#define BS_DMA_TCD5_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD5_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_INTMAJOR field.
#define BR_DMA_TCD5_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_INTMAJOR.
#define BF_DMA_TCD5_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD5_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD5_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD5_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD5_CSR_INTHALF.
#define BM_DMA_TCD5_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD5_CSR_INTHALF.
#define BS_DMA_TCD5_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD5_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_INTHALF field.
#define BR_DMA_TCD5_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_INTHALF.
#define BF_DMA_TCD5_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_INTHALF), uint16_t) & BM_DMA_TCD5_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD5_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD5_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD5_CSR_DREQ.
#define BM_DMA_TCD5_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD5_CSR_DREQ.
#define BS_DMA_TCD5_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD5_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_DREQ field.
#define BR_DMA_TCD5_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_DREQ.
#define BF_DMA_TCD5_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_DREQ), uint16_t) & BM_DMA_TCD5_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD5_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD5_CSR_ESG      (4U)      //!< Bit position for DMA_TCD5_CSR_ESG.
#define BM_DMA_TCD5_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD5_CSR_ESG.
#define BS_DMA_TCD5_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD5_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_ESG field.
#define BR_DMA_TCD5_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_ESG.
#define BF_DMA_TCD5_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_ESG), uint16_t) & BM_DMA_TCD5_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD5_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD5_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD5_CSR_MAJORELINK.
#define BM_DMA_TCD5_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD5_CSR_MAJORELINK.
#define BS_DMA_TCD5_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD5_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_MAJORELINK field.
#define BR_DMA_TCD5_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_MAJORELINK.
#define BF_DMA_TCD5_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD5_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD5_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD5_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD5_CSR_ACTIVE.
#define BM_DMA_TCD5_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD5_CSR_ACTIVE.
#define BS_DMA_TCD5_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD5_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_ACTIVE field.
#define BR_DMA_TCD5_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_ACTIVE.
#define BF_DMA_TCD5_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_ACTIVE), uint16_t) & BM_DMA_TCD5_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD5_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD5_CSR_DONE      (7U)      //!< Bit position for DMA_TCD5_CSR_DONE.
#define BM_DMA_TCD5_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD5_CSR_DONE.
#define BS_DMA_TCD5_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD5_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_DONE field.
#define BR_DMA_TCD5_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_DONE.
#define BF_DMA_TCD5_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_DONE), uint16_t) & BM_DMA_TCD5_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD5_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_CSR_ADDR, BP_DMA_TCD5_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD5_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD5_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD5_CSR_MAJORLINKCH.
#define BM_DMA_TCD5_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD5_CSR_MAJORLINKCH.
#define BS_DMA_TCD5_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD5_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_MAJORLINKCH field.
#define BR_DMA_TCD5_CSR_MAJORLINKCH()   (HW_DMA_TCD5_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_MAJORLINKCH.
#define BF_DMA_TCD5_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD5_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD5_CSR_MAJORLINKCH(v)   (HW_DMA_TCD5_CSR_WR((HW_DMA_TCD5_CSR_RD() & ~BM_DMA_TCD5_CSR_MAJORLINKCH) | BF_DMA_TCD5_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD5_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD5_CSR_BWC      (14U)      //!< Bit position for DMA_TCD5_CSR_BWC.
#define BM_DMA_TCD5_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD5_CSR_BWC.
#define BS_DMA_TCD5_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD5_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_CSR_BWC field.
#define BR_DMA_TCD5_CSR_BWC()   (HW_DMA_TCD5_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD5_CSR_BWC.
#define BF_DMA_TCD5_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_CSR_BWC), uint16_t) & BM_DMA_TCD5_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD5_CSR_BWC(v)   (HW_DMA_TCD5_CSR_WR((HW_DMA_TCD5_CSR_RD() & ~BM_DMA_TCD5_CSR_BWC) | BF_DMA_TCD5_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd5_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd5_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd5_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD5_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x10beU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_BITER_ELINKYES           (*(__IO hw_dma_tcd5_biter_elinkyes_t *) HW_DMA_TCD5_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD5_BITER_ELINKYES_RD()      (HW_DMA_TCD5_BITER_ELINKYES.U)
#define HW_DMA_TCD5_BITER_ELINKYES_WR(v)     (HW_DMA_TCD5_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD5_BITER_ELINKYES_SET(v)    (HW_DMA_TCD5_BITER_ELINKYES_WR(HW_DMA_TCD5_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD5_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD5_BITER_ELINKYES_WR(HW_DMA_TCD5_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD5_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD5_BITER_ELINKYES_WR(HW_DMA_TCD5_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD5_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD5_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD5_BITER_ELINKYES_BITER.
#define BM_DMA_TCD5_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD5_BITER_ELINKYES_BITER.
#define BS_DMA_TCD5_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD5_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD5_BITER_ELINKYES_BITER()   (HW_DMA_TCD5_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD5_BITER_ELINKYES_BITER.
#define BF_DMA_TCD5_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD5_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD5_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD5_BITER_ELINKYES_WR((HW_DMA_TCD5_BITER_ELINKYES_RD() & ~BM_DMA_TCD5_BITER_ELINKYES_BITER) | BF_DMA_TCD5_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD5_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD5_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD5_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD5_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD5_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD5_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD5_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD5_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD5_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD5_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD5_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD5_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD5_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD5_BITER_ELINKYES_WR((HW_DMA_TCD5_BITER_ELINKYES_RD() & ~BM_DMA_TCD5_BITER_ELINKYES_LINKCH) | BF_DMA_TCD5_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD5_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD5_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD5_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD5_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD5_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD5_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD5_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD5_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD5_BITER_ELINKYES_ADDR, BP_DMA_TCD5_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD5_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD5_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD5_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD5_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_BITER_ELINKYES_ADDR, BP_DMA_TCD5_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD5_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD5_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd5_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd5_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd5_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD5_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD5_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x10beU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD5_BITER_ELINKNO           (*(__IO hw_dma_tcd5_biter_elinkno_t *) HW_DMA_TCD5_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD5_BITER_ELINKNO_RD()      (HW_DMA_TCD5_BITER_ELINKNO.U)
#define HW_DMA_TCD5_BITER_ELINKNO_WR(v)     (HW_DMA_TCD5_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD5_BITER_ELINKNO_SET(v)    (HW_DMA_TCD5_BITER_ELINKNO_WR(HW_DMA_TCD5_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD5_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD5_BITER_ELINKNO_WR(HW_DMA_TCD5_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD5_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD5_BITER_ELINKNO_WR(HW_DMA_TCD5_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD5_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD5_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD5_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD5_BITER_ELINKNO_BITER.
#define BM_DMA_TCD5_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD5_BITER_ELINKNO_BITER.
#define BS_DMA_TCD5_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD5_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD5_BITER_ELINKNO_BITER()   (HW_DMA_TCD5_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD5_BITER_ELINKNO_BITER.
#define BF_DMA_TCD5_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD5_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD5_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD5_BITER_ELINKNO_WR((HW_DMA_TCD5_BITER_ELINKNO_RD() & ~BM_DMA_TCD5_BITER_ELINKNO_BITER) | BF_DMA_TCD5_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD5_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD5_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD5_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD5_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD5_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD5_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD5_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD5_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD5_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD5_BITER_ELINKNO_ADDR, BP_DMA_TCD5_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD5_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD5_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD5_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD5_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD5_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD5_BITER_ELINKNO_ADDR, BP_DMA_TCD5_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd6_saddr
{
    uint32_t U;
    struct _hw_dma_tcd6_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd6_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_SADDR register
 */
//@{
#define HW_DMA_TCD6_SADDR_ADDR      (REGS_DMA_BASE + 0x10c0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_SADDR           (*(__IO hw_dma_tcd6_saddr_t *) HW_DMA_TCD6_SADDR_ADDR)
#define HW_DMA_TCD6_SADDR_RD()      (HW_DMA_TCD6_SADDR.U)
#define HW_DMA_TCD6_SADDR_WR(v)     (HW_DMA_TCD6_SADDR.U = (v))
#define HW_DMA_TCD6_SADDR_SET(v)    (HW_DMA_TCD6_SADDR_WR(HW_DMA_TCD6_SADDR_RD() |  (v)))
#define HW_DMA_TCD6_SADDR_CLR(v)    (HW_DMA_TCD6_SADDR_WR(HW_DMA_TCD6_SADDR_RD() & ~(v)))
#define HW_DMA_TCD6_SADDR_TOG(v)    (HW_DMA_TCD6_SADDR_WR(HW_DMA_TCD6_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_SADDR bitfields
 */

/*! @name Register DMA_TCD6_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD6_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD6_SADDR_SADDR.
#define BM_DMA_TCD6_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD6_SADDR_SADDR.
#define BS_DMA_TCD6_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD6_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_SADDR_SADDR field.
#define BR_DMA_TCD6_SADDR_SADDR()   (HW_DMA_TCD6_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD6_SADDR_SADDR.
#define BF_DMA_TCD6_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_SADDR_SADDR), uint32_t) & BM_DMA_TCD6_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD6_SADDR_SADDR(v)   (HW_DMA_TCD6_SADDR_WR((HW_DMA_TCD6_SADDR_RD() & ~BM_DMA_TCD6_SADDR_SADDR) | BF_DMA_TCD6_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd6_soff
{
    uint16_t U;
    struct _hw_dma_tcd6_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd6_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_SOFF register
 */
//@{
#define HW_DMA_TCD6_SOFF_ADDR      (REGS_DMA_BASE + 0x10c4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_SOFF           (*(__IO hw_dma_tcd6_soff_t *) HW_DMA_TCD6_SOFF_ADDR)
#define HW_DMA_TCD6_SOFF_RD()      (HW_DMA_TCD6_SOFF.U)
#define HW_DMA_TCD6_SOFF_WR(v)     (HW_DMA_TCD6_SOFF.U = (v))
#define HW_DMA_TCD6_SOFF_SET(v)    (HW_DMA_TCD6_SOFF_WR(HW_DMA_TCD6_SOFF_RD() |  (v)))
#define HW_DMA_TCD6_SOFF_CLR(v)    (HW_DMA_TCD6_SOFF_WR(HW_DMA_TCD6_SOFF_RD() & ~(v)))
#define HW_DMA_TCD6_SOFF_TOG(v)    (HW_DMA_TCD6_SOFF_WR(HW_DMA_TCD6_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_SOFF bitfields
 */

/*! @name Register DMA_TCD6_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD6_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD6_SOFF_SOFF.
#define BM_DMA_TCD6_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD6_SOFF_SOFF.
#define BS_DMA_TCD6_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD6_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_SOFF_SOFF field.
#define BR_DMA_TCD6_SOFF_SOFF()   (HW_DMA_TCD6_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD6_SOFF_SOFF.
#define BF_DMA_TCD6_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_SOFF_SOFF), uint16_t) & BM_DMA_TCD6_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD6_SOFF_SOFF(v)   (HW_DMA_TCD6_SOFF_WR((HW_DMA_TCD6_SOFF_RD() & ~BM_DMA_TCD6_SOFF_SOFF) | BF_DMA_TCD6_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd6_attr
{
    uint16_t U;
    struct _hw_dma_tcd6_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd6_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_ATTR register
 */
//@{
#define HW_DMA_TCD6_ATTR_ADDR      (REGS_DMA_BASE + 0x10c6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_ATTR           (*(__IO hw_dma_tcd6_attr_t *) HW_DMA_TCD6_ATTR_ADDR)
#define HW_DMA_TCD6_ATTR_RD()      (HW_DMA_TCD6_ATTR.U)
#define HW_DMA_TCD6_ATTR_WR(v)     (HW_DMA_TCD6_ATTR.U = (v))
#define HW_DMA_TCD6_ATTR_SET(v)    (HW_DMA_TCD6_ATTR_WR(HW_DMA_TCD6_ATTR_RD() |  (v)))
#define HW_DMA_TCD6_ATTR_CLR(v)    (HW_DMA_TCD6_ATTR_WR(HW_DMA_TCD6_ATTR_RD() & ~(v)))
#define HW_DMA_TCD6_ATTR_TOG(v)    (HW_DMA_TCD6_ATTR_WR(HW_DMA_TCD6_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_ATTR bitfields
 */

/*! @name Register DMA_TCD6_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD6_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD6_ATTR_DSIZE.
#define BM_DMA_TCD6_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD6_ATTR_DSIZE.
#define BS_DMA_TCD6_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD6_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_ATTR_DSIZE field.
#define BR_DMA_TCD6_ATTR_DSIZE()   (HW_DMA_TCD6_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD6_ATTR_DSIZE.
#define BF_DMA_TCD6_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_ATTR_DSIZE), uint16_t) & BM_DMA_TCD6_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD6_ATTR_DSIZE(v)   (HW_DMA_TCD6_ATTR_WR((HW_DMA_TCD6_ATTR_RD() & ~BM_DMA_TCD6_ATTR_DSIZE) | BF_DMA_TCD6_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD6_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD6_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD6_ATTR_DMOD.
#define BM_DMA_TCD6_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD6_ATTR_DMOD.
#define BS_DMA_TCD6_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD6_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_ATTR_DMOD field.
#define BR_DMA_TCD6_ATTR_DMOD()   (HW_DMA_TCD6_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD6_ATTR_DMOD.
#define BF_DMA_TCD6_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_ATTR_DMOD), uint16_t) & BM_DMA_TCD6_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD6_ATTR_DMOD(v)   (HW_DMA_TCD6_ATTR_WR((HW_DMA_TCD6_ATTR_RD() & ~BM_DMA_TCD6_ATTR_DMOD) | BF_DMA_TCD6_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD6_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD6_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD6_ATTR_SSIZE.
#define BM_DMA_TCD6_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD6_ATTR_SSIZE.
#define BS_DMA_TCD6_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD6_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_ATTR_SSIZE field.
#define BR_DMA_TCD6_ATTR_SSIZE()   (HW_DMA_TCD6_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD6_ATTR_SSIZE.
#define BF_DMA_TCD6_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_ATTR_SSIZE), uint16_t) & BM_DMA_TCD6_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD6_ATTR_SSIZE(v)   (HW_DMA_TCD6_ATTR_WR((HW_DMA_TCD6_ATTR_RD() & ~BM_DMA_TCD6_ATTR_SSIZE) | BF_DMA_TCD6_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD6_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD6_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD6_ATTR_SMOD.
#define BM_DMA_TCD6_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD6_ATTR_SMOD.
#define BS_DMA_TCD6_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD6_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_ATTR_SMOD field.
#define BR_DMA_TCD6_ATTR_SMOD()   (HW_DMA_TCD6_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD6_ATTR_SMOD.
#define BF_DMA_TCD6_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_ATTR_SMOD), uint16_t) & BM_DMA_TCD6_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD6_ATTR_SMOD(v)   (HW_DMA_TCD6_ATTR_WR((HW_DMA_TCD6_ATTR_RD() & ~BM_DMA_TCD6_ATTR_SMOD) | BF_DMA_TCD6_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd6_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd6_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd6_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD6_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x10c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_NBYTES_MLNO           (*(__IO hw_dma_tcd6_nbytes_mlno_t *) HW_DMA_TCD6_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD6_NBYTES_MLNO_RD()      (HW_DMA_TCD6_NBYTES_MLNO.U)
#define HW_DMA_TCD6_NBYTES_MLNO_WR(v)     (HW_DMA_TCD6_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD6_NBYTES_MLNO_SET(v)    (HW_DMA_TCD6_NBYTES_MLNO_WR(HW_DMA_TCD6_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD6_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD6_NBYTES_MLNO_WR(HW_DMA_TCD6_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD6_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD6_NBYTES_MLNO_WR(HW_DMA_TCD6_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD6_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD6_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD6_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD6_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD6_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD6_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD6_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD6_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD6_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD6_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD6_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD6_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD6_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD6_NBYTES_MLNO_WR((HW_DMA_TCD6_NBYTES_MLNO_RD() & ~BM_DMA_TCD6_NBYTES_MLNO_NBYTES) | BF_DMA_TCD6_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd6_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd6_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd6_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD6_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x10c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd6_nbytes_mloffno_t *) HW_DMA_TCD6_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD6_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD6_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD6_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD6_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD6_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD6_NBYTES_MLOFFNO_WR(HW_DMA_TCD6_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD6_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD6_NBYTES_MLOFFNO_WR(HW_DMA_TCD6_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD6_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD6_NBYTES_MLOFFNO_WR(HW_DMA_TCD6_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD6_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD6_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD6_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD6_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD6_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD6_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD6_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD6_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD6_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD6_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD6_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD6_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD6_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD6_NBYTES_MLOFFNO_WR((HW_DMA_TCD6_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD6_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD6_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD6_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD6_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD6_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD6_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD6_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD6_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD6_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD6_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD6_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD6_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD6_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD6_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD6_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD6_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD6_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD6_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD6_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD6_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD6_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD6_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD6_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD6_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD6_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD6_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD6_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD6_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD6_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD6_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD6_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD6_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD6_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd6_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd6_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd6_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD6_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x10c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd6_nbytes_mloffyes_t *) HW_DMA_TCD6_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD6_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD6_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD6_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD6_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD6_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD6_NBYTES_MLOFFYES_WR(HW_DMA_TCD6_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD6_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD6_NBYTES_MLOFFYES_WR(HW_DMA_TCD6_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD6_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD6_NBYTES_MLOFFYES_WR(HW_DMA_TCD6_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD6_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD6_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD6_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD6_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD6_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD6_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD6_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD6_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD6_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD6_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD6_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD6_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD6_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD6_NBYTES_MLOFFYES_WR((HW_DMA_TCD6_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD6_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD6_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD6_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD6_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD6_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD6_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD6_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD6_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD6_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD6_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD6_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD6_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD6_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD6_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD6_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD6_NBYTES_MLOFFYES_WR((HW_DMA_TCD6_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD6_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD6_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD6_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD6_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD6_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD6_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD6_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD6_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD6_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD6_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD6_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD6_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD6_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD6_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD6_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD6_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD6_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD6_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD6_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD6_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD6_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD6_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD6_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD6_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD6_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD6_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD6_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD6_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD6_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD6_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD6_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD6_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD6_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd6_slast
{
    uint32_t U;
    struct _hw_dma_tcd6_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd6_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_SLAST register
 */
//@{
#define HW_DMA_TCD6_SLAST_ADDR      (REGS_DMA_BASE + 0x10ccU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_SLAST           (*(__IO hw_dma_tcd6_slast_t *) HW_DMA_TCD6_SLAST_ADDR)
#define HW_DMA_TCD6_SLAST_RD()      (HW_DMA_TCD6_SLAST.U)
#define HW_DMA_TCD6_SLAST_WR(v)     (HW_DMA_TCD6_SLAST.U = (v))
#define HW_DMA_TCD6_SLAST_SET(v)    (HW_DMA_TCD6_SLAST_WR(HW_DMA_TCD6_SLAST_RD() |  (v)))
#define HW_DMA_TCD6_SLAST_CLR(v)    (HW_DMA_TCD6_SLAST_WR(HW_DMA_TCD6_SLAST_RD() & ~(v)))
#define HW_DMA_TCD6_SLAST_TOG(v)    (HW_DMA_TCD6_SLAST_WR(HW_DMA_TCD6_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_SLAST bitfields
 */

/*! @name Register DMA_TCD6_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD6_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD6_SLAST_SLAST.
#define BM_DMA_TCD6_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD6_SLAST_SLAST.
#define BS_DMA_TCD6_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD6_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_SLAST_SLAST field.
#define BR_DMA_TCD6_SLAST_SLAST()   (HW_DMA_TCD6_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD6_SLAST_SLAST.
#define BF_DMA_TCD6_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_SLAST_SLAST), uint32_t) & BM_DMA_TCD6_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD6_SLAST_SLAST(v)   (HW_DMA_TCD6_SLAST_WR((HW_DMA_TCD6_SLAST_RD() & ~BM_DMA_TCD6_SLAST_SLAST) | BF_DMA_TCD6_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd6_daddr
{
    uint32_t U;
    struct _hw_dma_tcd6_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd6_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_DADDR register
 */
//@{
#define HW_DMA_TCD6_DADDR_ADDR      (REGS_DMA_BASE + 0x10d0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_DADDR           (*(__IO hw_dma_tcd6_daddr_t *) HW_DMA_TCD6_DADDR_ADDR)
#define HW_DMA_TCD6_DADDR_RD()      (HW_DMA_TCD6_DADDR.U)
#define HW_DMA_TCD6_DADDR_WR(v)     (HW_DMA_TCD6_DADDR.U = (v))
#define HW_DMA_TCD6_DADDR_SET(v)    (HW_DMA_TCD6_DADDR_WR(HW_DMA_TCD6_DADDR_RD() |  (v)))
#define HW_DMA_TCD6_DADDR_CLR(v)    (HW_DMA_TCD6_DADDR_WR(HW_DMA_TCD6_DADDR_RD() & ~(v)))
#define HW_DMA_TCD6_DADDR_TOG(v)    (HW_DMA_TCD6_DADDR_WR(HW_DMA_TCD6_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_DADDR bitfields
 */

/*! @name Register DMA_TCD6_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD6_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD6_DADDR_DADDR.
#define BM_DMA_TCD6_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD6_DADDR_DADDR.
#define BS_DMA_TCD6_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD6_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_DADDR_DADDR field.
#define BR_DMA_TCD6_DADDR_DADDR()   (HW_DMA_TCD6_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD6_DADDR_DADDR.
#define BF_DMA_TCD6_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_DADDR_DADDR), uint32_t) & BM_DMA_TCD6_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD6_DADDR_DADDR(v)   (HW_DMA_TCD6_DADDR_WR((HW_DMA_TCD6_DADDR_RD() & ~BM_DMA_TCD6_DADDR_DADDR) | BF_DMA_TCD6_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd6_doff
{
    uint16_t U;
    struct _hw_dma_tcd6_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd6_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_DOFF register
 */
//@{
#define HW_DMA_TCD6_DOFF_ADDR      (REGS_DMA_BASE + 0x10d4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_DOFF           (*(__IO hw_dma_tcd6_doff_t *) HW_DMA_TCD6_DOFF_ADDR)
#define HW_DMA_TCD6_DOFF_RD()      (HW_DMA_TCD6_DOFF.U)
#define HW_DMA_TCD6_DOFF_WR(v)     (HW_DMA_TCD6_DOFF.U = (v))
#define HW_DMA_TCD6_DOFF_SET(v)    (HW_DMA_TCD6_DOFF_WR(HW_DMA_TCD6_DOFF_RD() |  (v)))
#define HW_DMA_TCD6_DOFF_CLR(v)    (HW_DMA_TCD6_DOFF_WR(HW_DMA_TCD6_DOFF_RD() & ~(v)))
#define HW_DMA_TCD6_DOFF_TOG(v)    (HW_DMA_TCD6_DOFF_WR(HW_DMA_TCD6_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_DOFF bitfields
 */

/*! @name Register DMA_TCD6_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD6_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD6_DOFF_DOFF.
#define BM_DMA_TCD6_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD6_DOFF_DOFF.
#define BS_DMA_TCD6_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD6_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_DOFF_DOFF field.
#define BR_DMA_TCD6_DOFF_DOFF()   (HW_DMA_TCD6_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD6_DOFF_DOFF.
#define BF_DMA_TCD6_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_DOFF_DOFF), uint16_t) & BM_DMA_TCD6_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD6_DOFF_DOFF(v)   (HW_DMA_TCD6_DOFF_WR((HW_DMA_TCD6_DOFF_RD() & ~BM_DMA_TCD6_DOFF_DOFF) | BF_DMA_TCD6_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd6_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd6_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd6_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD6_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x10d6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_CITER_ELINKYES           (*(__IO hw_dma_tcd6_citer_elinkyes_t *) HW_DMA_TCD6_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD6_CITER_ELINKYES_RD()      (HW_DMA_TCD6_CITER_ELINKYES.U)
#define HW_DMA_TCD6_CITER_ELINKYES_WR(v)     (HW_DMA_TCD6_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD6_CITER_ELINKYES_SET(v)    (HW_DMA_TCD6_CITER_ELINKYES_WR(HW_DMA_TCD6_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD6_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD6_CITER_ELINKYES_WR(HW_DMA_TCD6_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD6_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD6_CITER_ELINKYES_WR(HW_DMA_TCD6_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD6_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD6_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD6_CITER_ELINKYES_CITER.
#define BM_DMA_TCD6_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD6_CITER_ELINKYES_CITER.
#define BS_DMA_TCD6_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD6_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD6_CITER_ELINKYES_CITER()   (HW_DMA_TCD6_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD6_CITER_ELINKYES_CITER.
#define BF_DMA_TCD6_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD6_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD6_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD6_CITER_ELINKYES_WR((HW_DMA_TCD6_CITER_ELINKYES_RD() & ~BM_DMA_TCD6_CITER_ELINKYES_CITER) | BF_DMA_TCD6_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD6_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD6_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD6_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD6_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD6_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD6_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD6_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD6_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD6_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD6_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD6_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD6_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD6_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD6_CITER_ELINKYES_WR((HW_DMA_TCD6_CITER_ELINKYES_RD() & ~BM_DMA_TCD6_CITER_ELINKYES_LINKCH) | BF_DMA_TCD6_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD6_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD6_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD6_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD6_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD6_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD6_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD6_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD6_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD6_CITER_ELINKYES_ADDR, BP_DMA_TCD6_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD6_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD6_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD6_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD6_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CITER_ELINKYES_ADDR, BP_DMA_TCD6_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd6_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd6_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd6_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD6_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x10d6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_CITER_ELINKNO           (*(__IO hw_dma_tcd6_citer_elinkno_t *) HW_DMA_TCD6_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD6_CITER_ELINKNO_RD()      (HW_DMA_TCD6_CITER_ELINKNO.U)
#define HW_DMA_TCD6_CITER_ELINKNO_WR(v)     (HW_DMA_TCD6_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD6_CITER_ELINKNO_SET(v)    (HW_DMA_TCD6_CITER_ELINKNO_WR(HW_DMA_TCD6_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD6_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD6_CITER_ELINKNO_WR(HW_DMA_TCD6_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD6_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD6_CITER_ELINKNO_WR(HW_DMA_TCD6_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD6_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD6_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD6_CITER_ELINKNO_CITER.
#define BM_DMA_TCD6_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD6_CITER_ELINKNO_CITER.
#define BS_DMA_TCD6_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD6_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD6_CITER_ELINKNO_CITER()   (HW_DMA_TCD6_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD6_CITER_ELINKNO_CITER.
#define BF_DMA_TCD6_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD6_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD6_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD6_CITER_ELINKNO_WR((HW_DMA_TCD6_CITER_ELINKNO_RD() & ~BM_DMA_TCD6_CITER_ELINKNO_CITER) | BF_DMA_TCD6_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD6_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD6_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD6_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD6_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD6_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD6_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD6_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD6_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD6_CITER_ELINKNO_ADDR, BP_DMA_TCD6_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD6_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD6_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD6_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD6_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CITER_ELINKNO_ADDR, BP_DMA_TCD6_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd6_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd6_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd6_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_DLASTSGA register
 */
//@{
#define HW_DMA_TCD6_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x10d8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_DLASTSGA           (*(__IO hw_dma_tcd6_dlastsga_t *) HW_DMA_TCD6_DLASTSGA_ADDR)
#define HW_DMA_TCD6_DLASTSGA_RD()      (HW_DMA_TCD6_DLASTSGA.U)
#define HW_DMA_TCD6_DLASTSGA_WR(v)     (HW_DMA_TCD6_DLASTSGA.U = (v))
#define HW_DMA_TCD6_DLASTSGA_SET(v)    (HW_DMA_TCD6_DLASTSGA_WR(HW_DMA_TCD6_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD6_DLASTSGA_CLR(v)    (HW_DMA_TCD6_DLASTSGA_WR(HW_DMA_TCD6_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD6_DLASTSGA_TOG(v)    (HW_DMA_TCD6_DLASTSGA_WR(HW_DMA_TCD6_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD6_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD6_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD6_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD6_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD6_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD6_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD6_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD6_DLASTSGA_DLASTSGA()   (HW_DMA_TCD6_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD6_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD6_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD6_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD6_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD6_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD6_DLASTSGA_WR((HW_DMA_TCD6_DLASTSGA_RD() & ~BM_DMA_TCD6_DLASTSGA_DLASTSGA) | BF_DMA_TCD6_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd6_csr
{
    uint16_t U;
    struct _hw_dma_tcd6_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd6_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_CSR register
 */
//@{
#define HW_DMA_TCD6_CSR_ADDR      (REGS_DMA_BASE + 0x10dcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_CSR           (*(__IO hw_dma_tcd6_csr_t *) HW_DMA_TCD6_CSR_ADDR)
#define HW_DMA_TCD6_CSR_RD()      (HW_DMA_TCD6_CSR.U)
#define HW_DMA_TCD6_CSR_WR(v)     (HW_DMA_TCD6_CSR.U = (v))
#define HW_DMA_TCD6_CSR_SET(v)    (HW_DMA_TCD6_CSR_WR(HW_DMA_TCD6_CSR_RD() |  (v)))
#define HW_DMA_TCD6_CSR_CLR(v)    (HW_DMA_TCD6_CSR_WR(HW_DMA_TCD6_CSR_RD() & ~(v)))
#define HW_DMA_TCD6_CSR_TOG(v)    (HW_DMA_TCD6_CSR_WR(HW_DMA_TCD6_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_CSR bitfields
 */

/*! @name Register DMA_TCD6_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD6_CSR_START      (0U)      //!< Bit position for DMA_TCD6_CSR_START.
#define BM_DMA_TCD6_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD6_CSR_START.
#define BS_DMA_TCD6_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD6_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_START field.
#define BR_DMA_TCD6_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_START.
#define BF_DMA_TCD6_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_START), uint16_t) & BM_DMA_TCD6_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD6_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD6_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD6_CSR_INTMAJOR.
#define BM_DMA_TCD6_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD6_CSR_INTMAJOR.
#define BS_DMA_TCD6_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD6_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_INTMAJOR field.
#define BR_DMA_TCD6_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_INTMAJOR.
#define BF_DMA_TCD6_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD6_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD6_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD6_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD6_CSR_INTHALF.
#define BM_DMA_TCD6_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD6_CSR_INTHALF.
#define BS_DMA_TCD6_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD6_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_INTHALF field.
#define BR_DMA_TCD6_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_INTHALF.
#define BF_DMA_TCD6_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_INTHALF), uint16_t) & BM_DMA_TCD6_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD6_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD6_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD6_CSR_DREQ.
#define BM_DMA_TCD6_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD6_CSR_DREQ.
#define BS_DMA_TCD6_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD6_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_DREQ field.
#define BR_DMA_TCD6_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_DREQ.
#define BF_DMA_TCD6_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_DREQ), uint16_t) & BM_DMA_TCD6_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD6_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD6_CSR_ESG      (4U)      //!< Bit position for DMA_TCD6_CSR_ESG.
#define BM_DMA_TCD6_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD6_CSR_ESG.
#define BS_DMA_TCD6_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD6_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_ESG field.
#define BR_DMA_TCD6_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_ESG.
#define BF_DMA_TCD6_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_ESG), uint16_t) & BM_DMA_TCD6_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD6_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD6_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD6_CSR_MAJORELINK.
#define BM_DMA_TCD6_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD6_CSR_MAJORELINK.
#define BS_DMA_TCD6_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD6_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_MAJORELINK field.
#define BR_DMA_TCD6_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_MAJORELINK.
#define BF_DMA_TCD6_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD6_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD6_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD6_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD6_CSR_ACTIVE.
#define BM_DMA_TCD6_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD6_CSR_ACTIVE.
#define BS_DMA_TCD6_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD6_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_ACTIVE field.
#define BR_DMA_TCD6_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_ACTIVE.
#define BF_DMA_TCD6_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_ACTIVE), uint16_t) & BM_DMA_TCD6_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD6_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD6_CSR_DONE      (7U)      //!< Bit position for DMA_TCD6_CSR_DONE.
#define BM_DMA_TCD6_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD6_CSR_DONE.
#define BS_DMA_TCD6_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD6_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_DONE field.
#define BR_DMA_TCD6_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_DONE.
#define BF_DMA_TCD6_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_DONE), uint16_t) & BM_DMA_TCD6_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD6_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_CSR_ADDR, BP_DMA_TCD6_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD6_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD6_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD6_CSR_MAJORLINKCH.
#define BM_DMA_TCD6_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD6_CSR_MAJORLINKCH.
#define BS_DMA_TCD6_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD6_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_MAJORLINKCH field.
#define BR_DMA_TCD6_CSR_MAJORLINKCH()   (HW_DMA_TCD6_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_MAJORLINKCH.
#define BF_DMA_TCD6_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD6_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD6_CSR_MAJORLINKCH(v)   (HW_DMA_TCD6_CSR_WR((HW_DMA_TCD6_CSR_RD() & ~BM_DMA_TCD6_CSR_MAJORLINKCH) | BF_DMA_TCD6_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD6_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD6_CSR_BWC      (14U)      //!< Bit position for DMA_TCD6_CSR_BWC.
#define BM_DMA_TCD6_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD6_CSR_BWC.
#define BS_DMA_TCD6_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD6_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_CSR_BWC field.
#define BR_DMA_TCD6_CSR_BWC()   (HW_DMA_TCD6_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD6_CSR_BWC.
#define BF_DMA_TCD6_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_CSR_BWC), uint16_t) & BM_DMA_TCD6_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD6_CSR_BWC(v)   (HW_DMA_TCD6_CSR_WR((HW_DMA_TCD6_CSR_RD() & ~BM_DMA_TCD6_CSR_BWC) | BF_DMA_TCD6_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd6_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd6_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd6_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD6_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x10deU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_BITER_ELINKYES           (*(__IO hw_dma_tcd6_biter_elinkyes_t *) HW_DMA_TCD6_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD6_BITER_ELINKYES_RD()      (HW_DMA_TCD6_BITER_ELINKYES.U)
#define HW_DMA_TCD6_BITER_ELINKYES_WR(v)     (HW_DMA_TCD6_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD6_BITER_ELINKYES_SET(v)    (HW_DMA_TCD6_BITER_ELINKYES_WR(HW_DMA_TCD6_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD6_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD6_BITER_ELINKYES_WR(HW_DMA_TCD6_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD6_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD6_BITER_ELINKYES_WR(HW_DMA_TCD6_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD6_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD6_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD6_BITER_ELINKYES_BITER.
#define BM_DMA_TCD6_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD6_BITER_ELINKYES_BITER.
#define BS_DMA_TCD6_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD6_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD6_BITER_ELINKYES_BITER()   (HW_DMA_TCD6_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD6_BITER_ELINKYES_BITER.
#define BF_DMA_TCD6_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD6_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD6_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD6_BITER_ELINKYES_WR((HW_DMA_TCD6_BITER_ELINKYES_RD() & ~BM_DMA_TCD6_BITER_ELINKYES_BITER) | BF_DMA_TCD6_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD6_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD6_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD6_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD6_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD6_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD6_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD6_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD6_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD6_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD6_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD6_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD6_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD6_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD6_BITER_ELINKYES_WR((HW_DMA_TCD6_BITER_ELINKYES_RD() & ~BM_DMA_TCD6_BITER_ELINKYES_LINKCH) | BF_DMA_TCD6_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD6_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD6_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD6_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD6_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD6_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD6_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD6_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD6_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD6_BITER_ELINKYES_ADDR, BP_DMA_TCD6_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD6_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD6_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD6_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD6_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_BITER_ELINKYES_ADDR, BP_DMA_TCD6_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD6_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD6_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd6_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd6_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd6_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD6_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD6_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x10deU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD6_BITER_ELINKNO           (*(__IO hw_dma_tcd6_biter_elinkno_t *) HW_DMA_TCD6_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD6_BITER_ELINKNO_RD()      (HW_DMA_TCD6_BITER_ELINKNO.U)
#define HW_DMA_TCD6_BITER_ELINKNO_WR(v)     (HW_DMA_TCD6_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD6_BITER_ELINKNO_SET(v)    (HW_DMA_TCD6_BITER_ELINKNO_WR(HW_DMA_TCD6_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD6_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD6_BITER_ELINKNO_WR(HW_DMA_TCD6_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD6_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD6_BITER_ELINKNO_WR(HW_DMA_TCD6_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD6_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD6_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD6_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD6_BITER_ELINKNO_BITER.
#define BM_DMA_TCD6_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD6_BITER_ELINKNO_BITER.
#define BS_DMA_TCD6_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD6_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD6_BITER_ELINKNO_BITER()   (HW_DMA_TCD6_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD6_BITER_ELINKNO_BITER.
#define BF_DMA_TCD6_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD6_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD6_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD6_BITER_ELINKNO_WR((HW_DMA_TCD6_BITER_ELINKNO_RD() & ~BM_DMA_TCD6_BITER_ELINKNO_BITER) | BF_DMA_TCD6_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD6_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD6_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD6_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD6_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD6_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD6_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD6_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD6_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD6_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD6_BITER_ELINKNO_ADDR, BP_DMA_TCD6_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD6_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD6_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD6_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD6_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD6_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD6_BITER_ELINKNO_ADDR, BP_DMA_TCD6_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd7_saddr
{
    uint32_t U;
    struct _hw_dma_tcd7_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd7_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_SADDR register
 */
//@{
#define HW_DMA_TCD7_SADDR_ADDR      (REGS_DMA_BASE + 0x10e0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_SADDR           (*(__IO hw_dma_tcd7_saddr_t *) HW_DMA_TCD7_SADDR_ADDR)
#define HW_DMA_TCD7_SADDR_RD()      (HW_DMA_TCD7_SADDR.U)
#define HW_DMA_TCD7_SADDR_WR(v)     (HW_DMA_TCD7_SADDR.U = (v))
#define HW_DMA_TCD7_SADDR_SET(v)    (HW_DMA_TCD7_SADDR_WR(HW_DMA_TCD7_SADDR_RD() |  (v)))
#define HW_DMA_TCD7_SADDR_CLR(v)    (HW_DMA_TCD7_SADDR_WR(HW_DMA_TCD7_SADDR_RD() & ~(v)))
#define HW_DMA_TCD7_SADDR_TOG(v)    (HW_DMA_TCD7_SADDR_WR(HW_DMA_TCD7_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_SADDR bitfields
 */

/*! @name Register DMA_TCD7_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD7_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD7_SADDR_SADDR.
#define BM_DMA_TCD7_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD7_SADDR_SADDR.
#define BS_DMA_TCD7_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD7_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_SADDR_SADDR field.
#define BR_DMA_TCD7_SADDR_SADDR()   (HW_DMA_TCD7_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD7_SADDR_SADDR.
#define BF_DMA_TCD7_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_SADDR_SADDR), uint32_t) & BM_DMA_TCD7_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD7_SADDR_SADDR(v)   (HW_DMA_TCD7_SADDR_WR((HW_DMA_TCD7_SADDR_RD() & ~BM_DMA_TCD7_SADDR_SADDR) | BF_DMA_TCD7_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd7_soff
{
    uint16_t U;
    struct _hw_dma_tcd7_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd7_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_SOFF register
 */
//@{
#define HW_DMA_TCD7_SOFF_ADDR      (REGS_DMA_BASE + 0x10e4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_SOFF           (*(__IO hw_dma_tcd7_soff_t *) HW_DMA_TCD7_SOFF_ADDR)
#define HW_DMA_TCD7_SOFF_RD()      (HW_DMA_TCD7_SOFF.U)
#define HW_DMA_TCD7_SOFF_WR(v)     (HW_DMA_TCD7_SOFF.U = (v))
#define HW_DMA_TCD7_SOFF_SET(v)    (HW_DMA_TCD7_SOFF_WR(HW_DMA_TCD7_SOFF_RD() |  (v)))
#define HW_DMA_TCD7_SOFF_CLR(v)    (HW_DMA_TCD7_SOFF_WR(HW_DMA_TCD7_SOFF_RD() & ~(v)))
#define HW_DMA_TCD7_SOFF_TOG(v)    (HW_DMA_TCD7_SOFF_WR(HW_DMA_TCD7_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_SOFF bitfields
 */

/*! @name Register DMA_TCD7_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD7_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD7_SOFF_SOFF.
#define BM_DMA_TCD7_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD7_SOFF_SOFF.
#define BS_DMA_TCD7_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD7_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_SOFF_SOFF field.
#define BR_DMA_TCD7_SOFF_SOFF()   (HW_DMA_TCD7_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD7_SOFF_SOFF.
#define BF_DMA_TCD7_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_SOFF_SOFF), uint16_t) & BM_DMA_TCD7_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD7_SOFF_SOFF(v)   (HW_DMA_TCD7_SOFF_WR((HW_DMA_TCD7_SOFF_RD() & ~BM_DMA_TCD7_SOFF_SOFF) | BF_DMA_TCD7_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd7_attr
{
    uint16_t U;
    struct _hw_dma_tcd7_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd7_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_ATTR register
 */
//@{
#define HW_DMA_TCD7_ATTR_ADDR      (REGS_DMA_BASE + 0x10e6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_ATTR           (*(__IO hw_dma_tcd7_attr_t *) HW_DMA_TCD7_ATTR_ADDR)
#define HW_DMA_TCD7_ATTR_RD()      (HW_DMA_TCD7_ATTR.U)
#define HW_DMA_TCD7_ATTR_WR(v)     (HW_DMA_TCD7_ATTR.U = (v))
#define HW_DMA_TCD7_ATTR_SET(v)    (HW_DMA_TCD7_ATTR_WR(HW_DMA_TCD7_ATTR_RD() |  (v)))
#define HW_DMA_TCD7_ATTR_CLR(v)    (HW_DMA_TCD7_ATTR_WR(HW_DMA_TCD7_ATTR_RD() & ~(v)))
#define HW_DMA_TCD7_ATTR_TOG(v)    (HW_DMA_TCD7_ATTR_WR(HW_DMA_TCD7_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_ATTR bitfields
 */

/*! @name Register DMA_TCD7_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD7_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD7_ATTR_DSIZE.
#define BM_DMA_TCD7_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD7_ATTR_DSIZE.
#define BS_DMA_TCD7_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD7_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_ATTR_DSIZE field.
#define BR_DMA_TCD7_ATTR_DSIZE()   (HW_DMA_TCD7_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD7_ATTR_DSIZE.
#define BF_DMA_TCD7_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_ATTR_DSIZE), uint16_t) & BM_DMA_TCD7_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD7_ATTR_DSIZE(v)   (HW_DMA_TCD7_ATTR_WR((HW_DMA_TCD7_ATTR_RD() & ~BM_DMA_TCD7_ATTR_DSIZE) | BF_DMA_TCD7_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD7_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD7_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD7_ATTR_DMOD.
#define BM_DMA_TCD7_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD7_ATTR_DMOD.
#define BS_DMA_TCD7_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD7_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_ATTR_DMOD field.
#define BR_DMA_TCD7_ATTR_DMOD()   (HW_DMA_TCD7_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD7_ATTR_DMOD.
#define BF_DMA_TCD7_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_ATTR_DMOD), uint16_t) & BM_DMA_TCD7_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD7_ATTR_DMOD(v)   (HW_DMA_TCD7_ATTR_WR((HW_DMA_TCD7_ATTR_RD() & ~BM_DMA_TCD7_ATTR_DMOD) | BF_DMA_TCD7_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD7_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD7_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD7_ATTR_SSIZE.
#define BM_DMA_TCD7_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD7_ATTR_SSIZE.
#define BS_DMA_TCD7_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD7_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_ATTR_SSIZE field.
#define BR_DMA_TCD7_ATTR_SSIZE()   (HW_DMA_TCD7_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD7_ATTR_SSIZE.
#define BF_DMA_TCD7_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_ATTR_SSIZE), uint16_t) & BM_DMA_TCD7_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD7_ATTR_SSIZE(v)   (HW_DMA_TCD7_ATTR_WR((HW_DMA_TCD7_ATTR_RD() & ~BM_DMA_TCD7_ATTR_SSIZE) | BF_DMA_TCD7_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD7_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD7_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD7_ATTR_SMOD.
#define BM_DMA_TCD7_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD7_ATTR_SMOD.
#define BS_DMA_TCD7_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD7_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_ATTR_SMOD field.
#define BR_DMA_TCD7_ATTR_SMOD()   (HW_DMA_TCD7_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD7_ATTR_SMOD.
#define BF_DMA_TCD7_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_ATTR_SMOD), uint16_t) & BM_DMA_TCD7_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD7_ATTR_SMOD(v)   (HW_DMA_TCD7_ATTR_WR((HW_DMA_TCD7_ATTR_RD() & ~BM_DMA_TCD7_ATTR_SMOD) | BF_DMA_TCD7_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd7_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd7_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd7_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD7_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x10e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_NBYTES_MLNO           (*(__IO hw_dma_tcd7_nbytes_mlno_t *) HW_DMA_TCD7_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD7_NBYTES_MLNO_RD()      (HW_DMA_TCD7_NBYTES_MLNO.U)
#define HW_DMA_TCD7_NBYTES_MLNO_WR(v)     (HW_DMA_TCD7_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD7_NBYTES_MLNO_SET(v)    (HW_DMA_TCD7_NBYTES_MLNO_WR(HW_DMA_TCD7_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD7_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD7_NBYTES_MLNO_WR(HW_DMA_TCD7_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD7_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD7_NBYTES_MLNO_WR(HW_DMA_TCD7_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD7_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD7_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD7_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD7_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD7_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD7_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD7_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD7_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD7_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD7_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD7_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD7_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD7_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD7_NBYTES_MLNO_WR((HW_DMA_TCD7_NBYTES_MLNO_RD() & ~BM_DMA_TCD7_NBYTES_MLNO_NBYTES) | BF_DMA_TCD7_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd7_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd7_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd7_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD7_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x10e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd7_nbytes_mloffno_t *) HW_DMA_TCD7_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD7_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD7_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD7_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD7_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD7_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD7_NBYTES_MLOFFNO_WR(HW_DMA_TCD7_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD7_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD7_NBYTES_MLOFFNO_WR(HW_DMA_TCD7_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD7_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD7_NBYTES_MLOFFNO_WR(HW_DMA_TCD7_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD7_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD7_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD7_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD7_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD7_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD7_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD7_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD7_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD7_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD7_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD7_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD7_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD7_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD7_NBYTES_MLOFFNO_WR((HW_DMA_TCD7_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD7_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD7_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD7_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD7_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD7_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD7_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD7_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD7_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD7_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD7_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD7_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD7_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD7_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD7_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD7_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD7_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD7_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD7_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD7_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD7_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD7_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD7_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD7_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD7_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD7_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD7_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD7_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD7_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD7_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD7_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD7_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD7_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD7_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd7_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd7_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd7_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD7_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x10e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd7_nbytes_mloffyes_t *) HW_DMA_TCD7_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD7_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD7_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD7_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD7_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD7_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD7_NBYTES_MLOFFYES_WR(HW_DMA_TCD7_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD7_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD7_NBYTES_MLOFFYES_WR(HW_DMA_TCD7_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD7_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD7_NBYTES_MLOFFYES_WR(HW_DMA_TCD7_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD7_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD7_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD7_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD7_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD7_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD7_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD7_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD7_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD7_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD7_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD7_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD7_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD7_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD7_NBYTES_MLOFFYES_WR((HW_DMA_TCD7_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD7_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD7_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD7_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD7_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD7_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD7_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD7_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD7_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD7_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD7_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD7_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD7_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD7_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD7_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD7_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD7_NBYTES_MLOFFYES_WR((HW_DMA_TCD7_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD7_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD7_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD7_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD7_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD7_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD7_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD7_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD7_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD7_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD7_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD7_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD7_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD7_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD7_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD7_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD7_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD7_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD7_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD7_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD7_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD7_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD7_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD7_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD7_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD7_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD7_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD7_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD7_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD7_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD7_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD7_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD7_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD7_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd7_slast
{
    uint32_t U;
    struct _hw_dma_tcd7_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd7_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_SLAST register
 */
//@{
#define HW_DMA_TCD7_SLAST_ADDR      (REGS_DMA_BASE + 0x10ecU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_SLAST           (*(__IO hw_dma_tcd7_slast_t *) HW_DMA_TCD7_SLAST_ADDR)
#define HW_DMA_TCD7_SLAST_RD()      (HW_DMA_TCD7_SLAST.U)
#define HW_DMA_TCD7_SLAST_WR(v)     (HW_DMA_TCD7_SLAST.U = (v))
#define HW_DMA_TCD7_SLAST_SET(v)    (HW_DMA_TCD7_SLAST_WR(HW_DMA_TCD7_SLAST_RD() |  (v)))
#define HW_DMA_TCD7_SLAST_CLR(v)    (HW_DMA_TCD7_SLAST_WR(HW_DMA_TCD7_SLAST_RD() & ~(v)))
#define HW_DMA_TCD7_SLAST_TOG(v)    (HW_DMA_TCD7_SLAST_WR(HW_DMA_TCD7_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_SLAST bitfields
 */

/*! @name Register DMA_TCD7_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD7_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD7_SLAST_SLAST.
#define BM_DMA_TCD7_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD7_SLAST_SLAST.
#define BS_DMA_TCD7_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD7_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_SLAST_SLAST field.
#define BR_DMA_TCD7_SLAST_SLAST()   (HW_DMA_TCD7_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD7_SLAST_SLAST.
#define BF_DMA_TCD7_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_SLAST_SLAST), uint32_t) & BM_DMA_TCD7_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD7_SLAST_SLAST(v)   (HW_DMA_TCD7_SLAST_WR((HW_DMA_TCD7_SLAST_RD() & ~BM_DMA_TCD7_SLAST_SLAST) | BF_DMA_TCD7_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd7_daddr
{
    uint32_t U;
    struct _hw_dma_tcd7_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd7_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_DADDR register
 */
//@{
#define HW_DMA_TCD7_DADDR_ADDR      (REGS_DMA_BASE + 0x10f0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_DADDR           (*(__IO hw_dma_tcd7_daddr_t *) HW_DMA_TCD7_DADDR_ADDR)
#define HW_DMA_TCD7_DADDR_RD()      (HW_DMA_TCD7_DADDR.U)
#define HW_DMA_TCD7_DADDR_WR(v)     (HW_DMA_TCD7_DADDR.U = (v))
#define HW_DMA_TCD7_DADDR_SET(v)    (HW_DMA_TCD7_DADDR_WR(HW_DMA_TCD7_DADDR_RD() |  (v)))
#define HW_DMA_TCD7_DADDR_CLR(v)    (HW_DMA_TCD7_DADDR_WR(HW_DMA_TCD7_DADDR_RD() & ~(v)))
#define HW_DMA_TCD7_DADDR_TOG(v)    (HW_DMA_TCD7_DADDR_WR(HW_DMA_TCD7_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_DADDR bitfields
 */

/*! @name Register DMA_TCD7_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD7_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD7_DADDR_DADDR.
#define BM_DMA_TCD7_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD7_DADDR_DADDR.
#define BS_DMA_TCD7_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD7_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_DADDR_DADDR field.
#define BR_DMA_TCD7_DADDR_DADDR()   (HW_DMA_TCD7_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD7_DADDR_DADDR.
#define BF_DMA_TCD7_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_DADDR_DADDR), uint32_t) & BM_DMA_TCD7_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD7_DADDR_DADDR(v)   (HW_DMA_TCD7_DADDR_WR((HW_DMA_TCD7_DADDR_RD() & ~BM_DMA_TCD7_DADDR_DADDR) | BF_DMA_TCD7_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd7_doff
{
    uint16_t U;
    struct _hw_dma_tcd7_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd7_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_DOFF register
 */
//@{
#define HW_DMA_TCD7_DOFF_ADDR      (REGS_DMA_BASE + 0x10f4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_DOFF           (*(__IO hw_dma_tcd7_doff_t *) HW_DMA_TCD7_DOFF_ADDR)
#define HW_DMA_TCD7_DOFF_RD()      (HW_DMA_TCD7_DOFF.U)
#define HW_DMA_TCD7_DOFF_WR(v)     (HW_DMA_TCD7_DOFF.U = (v))
#define HW_DMA_TCD7_DOFF_SET(v)    (HW_DMA_TCD7_DOFF_WR(HW_DMA_TCD7_DOFF_RD() |  (v)))
#define HW_DMA_TCD7_DOFF_CLR(v)    (HW_DMA_TCD7_DOFF_WR(HW_DMA_TCD7_DOFF_RD() & ~(v)))
#define HW_DMA_TCD7_DOFF_TOG(v)    (HW_DMA_TCD7_DOFF_WR(HW_DMA_TCD7_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_DOFF bitfields
 */

/*! @name Register DMA_TCD7_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD7_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD7_DOFF_DOFF.
#define BM_DMA_TCD7_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD7_DOFF_DOFF.
#define BS_DMA_TCD7_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD7_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_DOFF_DOFF field.
#define BR_DMA_TCD7_DOFF_DOFF()   (HW_DMA_TCD7_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD7_DOFF_DOFF.
#define BF_DMA_TCD7_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_DOFF_DOFF), uint16_t) & BM_DMA_TCD7_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD7_DOFF_DOFF(v)   (HW_DMA_TCD7_DOFF_WR((HW_DMA_TCD7_DOFF_RD() & ~BM_DMA_TCD7_DOFF_DOFF) | BF_DMA_TCD7_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd7_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd7_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd7_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD7_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x10f6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_CITER_ELINKYES           (*(__IO hw_dma_tcd7_citer_elinkyes_t *) HW_DMA_TCD7_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD7_CITER_ELINKYES_RD()      (HW_DMA_TCD7_CITER_ELINKYES.U)
#define HW_DMA_TCD7_CITER_ELINKYES_WR(v)     (HW_DMA_TCD7_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD7_CITER_ELINKYES_SET(v)    (HW_DMA_TCD7_CITER_ELINKYES_WR(HW_DMA_TCD7_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD7_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD7_CITER_ELINKYES_WR(HW_DMA_TCD7_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD7_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD7_CITER_ELINKYES_WR(HW_DMA_TCD7_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD7_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD7_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD7_CITER_ELINKYES_CITER.
#define BM_DMA_TCD7_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD7_CITER_ELINKYES_CITER.
#define BS_DMA_TCD7_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD7_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD7_CITER_ELINKYES_CITER()   (HW_DMA_TCD7_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD7_CITER_ELINKYES_CITER.
#define BF_DMA_TCD7_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD7_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD7_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD7_CITER_ELINKYES_WR((HW_DMA_TCD7_CITER_ELINKYES_RD() & ~BM_DMA_TCD7_CITER_ELINKYES_CITER) | BF_DMA_TCD7_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD7_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD7_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD7_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD7_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD7_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD7_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD7_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD7_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD7_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD7_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD7_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD7_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD7_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD7_CITER_ELINKYES_WR((HW_DMA_TCD7_CITER_ELINKYES_RD() & ~BM_DMA_TCD7_CITER_ELINKYES_LINKCH) | BF_DMA_TCD7_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD7_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD7_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD7_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD7_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD7_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD7_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD7_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD7_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD7_CITER_ELINKYES_ADDR, BP_DMA_TCD7_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD7_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD7_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD7_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD7_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CITER_ELINKYES_ADDR, BP_DMA_TCD7_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd7_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd7_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd7_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD7_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x10f6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_CITER_ELINKNO           (*(__IO hw_dma_tcd7_citer_elinkno_t *) HW_DMA_TCD7_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD7_CITER_ELINKNO_RD()      (HW_DMA_TCD7_CITER_ELINKNO.U)
#define HW_DMA_TCD7_CITER_ELINKNO_WR(v)     (HW_DMA_TCD7_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD7_CITER_ELINKNO_SET(v)    (HW_DMA_TCD7_CITER_ELINKNO_WR(HW_DMA_TCD7_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD7_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD7_CITER_ELINKNO_WR(HW_DMA_TCD7_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD7_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD7_CITER_ELINKNO_WR(HW_DMA_TCD7_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD7_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD7_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD7_CITER_ELINKNO_CITER.
#define BM_DMA_TCD7_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD7_CITER_ELINKNO_CITER.
#define BS_DMA_TCD7_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD7_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD7_CITER_ELINKNO_CITER()   (HW_DMA_TCD7_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD7_CITER_ELINKNO_CITER.
#define BF_DMA_TCD7_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD7_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD7_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD7_CITER_ELINKNO_WR((HW_DMA_TCD7_CITER_ELINKNO_RD() & ~BM_DMA_TCD7_CITER_ELINKNO_CITER) | BF_DMA_TCD7_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD7_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD7_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD7_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD7_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD7_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD7_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD7_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD7_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD7_CITER_ELINKNO_ADDR, BP_DMA_TCD7_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD7_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD7_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD7_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD7_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CITER_ELINKNO_ADDR, BP_DMA_TCD7_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd7_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd7_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd7_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_DLASTSGA register
 */
//@{
#define HW_DMA_TCD7_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x10f8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_DLASTSGA           (*(__IO hw_dma_tcd7_dlastsga_t *) HW_DMA_TCD7_DLASTSGA_ADDR)
#define HW_DMA_TCD7_DLASTSGA_RD()      (HW_DMA_TCD7_DLASTSGA.U)
#define HW_DMA_TCD7_DLASTSGA_WR(v)     (HW_DMA_TCD7_DLASTSGA.U = (v))
#define HW_DMA_TCD7_DLASTSGA_SET(v)    (HW_DMA_TCD7_DLASTSGA_WR(HW_DMA_TCD7_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD7_DLASTSGA_CLR(v)    (HW_DMA_TCD7_DLASTSGA_WR(HW_DMA_TCD7_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD7_DLASTSGA_TOG(v)    (HW_DMA_TCD7_DLASTSGA_WR(HW_DMA_TCD7_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD7_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD7_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD7_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD7_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD7_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD7_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD7_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD7_DLASTSGA_DLASTSGA()   (HW_DMA_TCD7_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD7_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD7_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD7_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD7_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD7_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD7_DLASTSGA_WR((HW_DMA_TCD7_DLASTSGA_RD() & ~BM_DMA_TCD7_DLASTSGA_DLASTSGA) | BF_DMA_TCD7_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd7_csr
{
    uint16_t U;
    struct _hw_dma_tcd7_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd7_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_CSR register
 */
//@{
#define HW_DMA_TCD7_CSR_ADDR      (REGS_DMA_BASE + 0x10fcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_CSR           (*(__IO hw_dma_tcd7_csr_t *) HW_DMA_TCD7_CSR_ADDR)
#define HW_DMA_TCD7_CSR_RD()      (HW_DMA_TCD7_CSR.U)
#define HW_DMA_TCD7_CSR_WR(v)     (HW_DMA_TCD7_CSR.U = (v))
#define HW_DMA_TCD7_CSR_SET(v)    (HW_DMA_TCD7_CSR_WR(HW_DMA_TCD7_CSR_RD() |  (v)))
#define HW_DMA_TCD7_CSR_CLR(v)    (HW_DMA_TCD7_CSR_WR(HW_DMA_TCD7_CSR_RD() & ~(v)))
#define HW_DMA_TCD7_CSR_TOG(v)    (HW_DMA_TCD7_CSR_WR(HW_DMA_TCD7_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_CSR bitfields
 */

/*! @name Register DMA_TCD7_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD7_CSR_START      (0U)      //!< Bit position for DMA_TCD7_CSR_START.
#define BM_DMA_TCD7_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD7_CSR_START.
#define BS_DMA_TCD7_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD7_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_START field.
#define BR_DMA_TCD7_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_START.
#define BF_DMA_TCD7_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_START), uint16_t) & BM_DMA_TCD7_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD7_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD7_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD7_CSR_INTMAJOR.
#define BM_DMA_TCD7_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD7_CSR_INTMAJOR.
#define BS_DMA_TCD7_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD7_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_INTMAJOR field.
#define BR_DMA_TCD7_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_INTMAJOR.
#define BF_DMA_TCD7_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD7_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD7_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD7_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD7_CSR_INTHALF.
#define BM_DMA_TCD7_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD7_CSR_INTHALF.
#define BS_DMA_TCD7_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD7_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_INTHALF field.
#define BR_DMA_TCD7_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_INTHALF.
#define BF_DMA_TCD7_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_INTHALF), uint16_t) & BM_DMA_TCD7_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD7_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD7_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD7_CSR_DREQ.
#define BM_DMA_TCD7_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD7_CSR_DREQ.
#define BS_DMA_TCD7_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD7_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_DREQ field.
#define BR_DMA_TCD7_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_DREQ.
#define BF_DMA_TCD7_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_DREQ), uint16_t) & BM_DMA_TCD7_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD7_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD7_CSR_ESG      (4U)      //!< Bit position for DMA_TCD7_CSR_ESG.
#define BM_DMA_TCD7_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD7_CSR_ESG.
#define BS_DMA_TCD7_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD7_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_ESG field.
#define BR_DMA_TCD7_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_ESG.
#define BF_DMA_TCD7_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_ESG), uint16_t) & BM_DMA_TCD7_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD7_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD7_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD7_CSR_MAJORELINK.
#define BM_DMA_TCD7_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD7_CSR_MAJORELINK.
#define BS_DMA_TCD7_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD7_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_MAJORELINK field.
#define BR_DMA_TCD7_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_MAJORELINK.
#define BF_DMA_TCD7_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD7_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD7_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD7_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD7_CSR_ACTIVE.
#define BM_DMA_TCD7_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD7_CSR_ACTIVE.
#define BS_DMA_TCD7_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD7_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_ACTIVE field.
#define BR_DMA_TCD7_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_ACTIVE.
#define BF_DMA_TCD7_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_ACTIVE), uint16_t) & BM_DMA_TCD7_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD7_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD7_CSR_DONE      (7U)      //!< Bit position for DMA_TCD7_CSR_DONE.
#define BM_DMA_TCD7_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD7_CSR_DONE.
#define BS_DMA_TCD7_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD7_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_DONE field.
#define BR_DMA_TCD7_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_DONE.
#define BF_DMA_TCD7_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_DONE), uint16_t) & BM_DMA_TCD7_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD7_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_CSR_ADDR, BP_DMA_TCD7_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD7_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD7_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD7_CSR_MAJORLINKCH.
#define BM_DMA_TCD7_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD7_CSR_MAJORLINKCH.
#define BS_DMA_TCD7_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD7_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_MAJORLINKCH field.
#define BR_DMA_TCD7_CSR_MAJORLINKCH()   (HW_DMA_TCD7_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_MAJORLINKCH.
#define BF_DMA_TCD7_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD7_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD7_CSR_MAJORLINKCH(v)   (HW_DMA_TCD7_CSR_WR((HW_DMA_TCD7_CSR_RD() & ~BM_DMA_TCD7_CSR_MAJORLINKCH) | BF_DMA_TCD7_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD7_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD7_CSR_BWC      (14U)      //!< Bit position for DMA_TCD7_CSR_BWC.
#define BM_DMA_TCD7_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD7_CSR_BWC.
#define BS_DMA_TCD7_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD7_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_CSR_BWC field.
#define BR_DMA_TCD7_CSR_BWC()   (HW_DMA_TCD7_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD7_CSR_BWC.
#define BF_DMA_TCD7_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_CSR_BWC), uint16_t) & BM_DMA_TCD7_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD7_CSR_BWC(v)   (HW_DMA_TCD7_CSR_WR((HW_DMA_TCD7_CSR_RD() & ~BM_DMA_TCD7_CSR_BWC) | BF_DMA_TCD7_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd7_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd7_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd7_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD7_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x10feU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_BITER_ELINKYES           (*(__IO hw_dma_tcd7_biter_elinkyes_t *) HW_DMA_TCD7_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD7_BITER_ELINKYES_RD()      (HW_DMA_TCD7_BITER_ELINKYES.U)
#define HW_DMA_TCD7_BITER_ELINKYES_WR(v)     (HW_DMA_TCD7_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD7_BITER_ELINKYES_SET(v)    (HW_DMA_TCD7_BITER_ELINKYES_WR(HW_DMA_TCD7_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD7_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD7_BITER_ELINKYES_WR(HW_DMA_TCD7_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD7_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD7_BITER_ELINKYES_WR(HW_DMA_TCD7_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD7_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD7_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD7_BITER_ELINKYES_BITER.
#define BM_DMA_TCD7_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD7_BITER_ELINKYES_BITER.
#define BS_DMA_TCD7_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD7_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD7_BITER_ELINKYES_BITER()   (HW_DMA_TCD7_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD7_BITER_ELINKYES_BITER.
#define BF_DMA_TCD7_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD7_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD7_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD7_BITER_ELINKYES_WR((HW_DMA_TCD7_BITER_ELINKYES_RD() & ~BM_DMA_TCD7_BITER_ELINKYES_BITER) | BF_DMA_TCD7_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD7_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD7_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD7_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD7_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD7_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD7_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD7_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD7_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD7_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD7_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD7_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD7_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD7_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD7_BITER_ELINKYES_WR((HW_DMA_TCD7_BITER_ELINKYES_RD() & ~BM_DMA_TCD7_BITER_ELINKYES_LINKCH) | BF_DMA_TCD7_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD7_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD7_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD7_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD7_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD7_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD7_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD7_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD7_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD7_BITER_ELINKYES_ADDR, BP_DMA_TCD7_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD7_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD7_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD7_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD7_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_BITER_ELINKYES_ADDR, BP_DMA_TCD7_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD7_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD7_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd7_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd7_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd7_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD7_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD7_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x10feU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD7_BITER_ELINKNO           (*(__IO hw_dma_tcd7_biter_elinkno_t *) HW_DMA_TCD7_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD7_BITER_ELINKNO_RD()      (HW_DMA_TCD7_BITER_ELINKNO.U)
#define HW_DMA_TCD7_BITER_ELINKNO_WR(v)     (HW_DMA_TCD7_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD7_BITER_ELINKNO_SET(v)    (HW_DMA_TCD7_BITER_ELINKNO_WR(HW_DMA_TCD7_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD7_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD7_BITER_ELINKNO_WR(HW_DMA_TCD7_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD7_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD7_BITER_ELINKNO_WR(HW_DMA_TCD7_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD7_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD7_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD7_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD7_BITER_ELINKNO_BITER.
#define BM_DMA_TCD7_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD7_BITER_ELINKNO_BITER.
#define BS_DMA_TCD7_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD7_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD7_BITER_ELINKNO_BITER()   (HW_DMA_TCD7_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD7_BITER_ELINKNO_BITER.
#define BF_DMA_TCD7_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD7_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD7_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD7_BITER_ELINKNO_WR((HW_DMA_TCD7_BITER_ELINKNO_RD() & ~BM_DMA_TCD7_BITER_ELINKNO_BITER) | BF_DMA_TCD7_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD7_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD7_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD7_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD7_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD7_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD7_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD7_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD7_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD7_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD7_BITER_ELINKNO_ADDR, BP_DMA_TCD7_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD7_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD7_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD7_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD7_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD7_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD7_BITER_ELINKNO_ADDR, BP_DMA_TCD7_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd8_saddr
{
    uint32_t U;
    struct _hw_dma_tcd8_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd8_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_SADDR register
 */
//@{
#define HW_DMA_TCD8_SADDR_ADDR      (REGS_DMA_BASE + 0x1100U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_SADDR           (*(__IO hw_dma_tcd8_saddr_t *) HW_DMA_TCD8_SADDR_ADDR)
#define HW_DMA_TCD8_SADDR_RD()      (HW_DMA_TCD8_SADDR.U)
#define HW_DMA_TCD8_SADDR_WR(v)     (HW_DMA_TCD8_SADDR.U = (v))
#define HW_DMA_TCD8_SADDR_SET(v)    (HW_DMA_TCD8_SADDR_WR(HW_DMA_TCD8_SADDR_RD() |  (v)))
#define HW_DMA_TCD8_SADDR_CLR(v)    (HW_DMA_TCD8_SADDR_WR(HW_DMA_TCD8_SADDR_RD() & ~(v)))
#define HW_DMA_TCD8_SADDR_TOG(v)    (HW_DMA_TCD8_SADDR_WR(HW_DMA_TCD8_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_SADDR bitfields
 */

/*! @name Register DMA_TCD8_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD8_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD8_SADDR_SADDR.
#define BM_DMA_TCD8_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD8_SADDR_SADDR.
#define BS_DMA_TCD8_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD8_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_SADDR_SADDR field.
#define BR_DMA_TCD8_SADDR_SADDR()   (HW_DMA_TCD8_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD8_SADDR_SADDR.
#define BF_DMA_TCD8_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_SADDR_SADDR), uint32_t) & BM_DMA_TCD8_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD8_SADDR_SADDR(v)   (HW_DMA_TCD8_SADDR_WR((HW_DMA_TCD8_SADDR_RD() & ~BM_DMA_TCD8_SADDR_SADDR) | BF_DMA_TCD8_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd8_soff
{
    uint16_t U;
    struct _hw_dma_tcd8_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd8_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_SOFF register
 */
//@{
#define HW_DMA_TCD8_SOFF_ADDR      (REGS_DMA_BASE + 0x1104U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_SOFF           (*(__IO hw_dma_tcd8_soff_t *) HW_DMA_TCD8_SOFF_ADDR)
#define HW_DMA_TCD8_SOFF_RD()      (HW_DMA_TCD8_SOFF.U)
#define HW_DMA_TCD8_SOFF_WR(v)     (HW_DMA_TCD8_SOFF.U = (v))
#define HW_DMA_TCD8_SOFF_SET(v)    (HW_DMA_TCD8_SOFF_WR(HW_DMA_TCD8_SOFF_RD() |  (v)))
#define HW_DMA_TCD8_SOFF_CLR(v)    (HW_DMA_TCD8_SOFF_WR(HW_DMA_TCD8_SOFF_RD() & ~(v)))
#define HW_DMA_TCD8_SOFF_TOG(v)    (HW_DMA_TCD8_SOFF_WR(HW_DMA_TCD8_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_SOFF bitfields
 */

/*! @name Register DMA_TCD8_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD8_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD8_SOFF_SOFF.
#define BM_DMA_TCD8_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD8_SOFF_SOFF.
#define BS_DMA_TCD8_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD8_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_SOFF_SOFF field.
#define BR_DMA_TCD8_SOFF_SOFF()   (HW_DMA_TCD8_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD8_SOFF_SOFF.
#define BF_DMA_TCD8_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_SOFF_SOFF), uint16_t) & BM_DMA_TCD8_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD8_SOFF_SOFF(v)   (HW_DMA_TCD8_SOFF_WR((HW_DMA_TCD8_SOFF_RD() & ~BM_DMA_TCD8_SOFF_SOFF) | BF_DMA_TCD8_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd8_attr
{
    uint16_t U;
    struct _hw_dma_tcd8_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd8_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_ATTR register
 */
//@{
#define HW_DMA_TCD8_ATTR_ADDR      (REGS_DMA_BASE + 0x1106U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_ATTR           (*(__IO hw_dma_tcd8_attr_t *) HW_DMA_TCD8_ATTR_ADDR)
#define HW_DMA_TCD8_ATTR_RD()      (HW_DMA_TCD8_ATTR.U)
#define HW_DMA_TCD8_ATTR_WR(v)     (HW_DMA_TCD8_ATTR.U = (v))
#define HW_DMA_TCD8_ATTR_SET(v)    (HW_DMA_TCD8_ATTR_WR(HW_DMA_TCD8_ATTR_RD() |  (v)))
#define HW_DMA_TCD8_ATTR_CLR(v)    (HW_DMA_TCD8_ATTR_WR(HW_DMA_TCD8_ATTR_RD() & ~(v)))
#define HW_DMA_TCD8_ATTR_TOG(v)    (HW_DMA_TCD8_ATTR_WR(HW_DMA_TCD8_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_ATTR bitfields
 */

/*! @name Register DMA_TCD8_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD8_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD8_ATTR_DSIZE.
#define BM_DMA_TCD8_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD8_ATTR_DSIZE.
#define BS_DMA_TCD8_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD8_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_ATTR_DSIZE field.
#define BR_DMA_TCD8_ATTR_DSIZE()   (HW_DMA_TCD8_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD8_ATTR_DSIZE.
#define BF_DMA_TCD8_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_ATTR_DSIZE), uint16_t) & BM_DMA_TCD8_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD8_ATTR_DSIZE(v)   (HW_DMA_TCD8_ATTR_WR((HW_DMA_TCD8_ATTR_RD() & ~BM_DMA_TCD8_ATTR_DSIZE) | BF_DMA_TCD8_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD8_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD8_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD8_ATTR_DMOD.
#define BM_DMA_TCD8_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD8_ATTR_DMOD.
#define BS_DMA_TCD8_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD8_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_ATTR_DMOD field.
#define BR_DMA_TCD8_ATTR_DMOD()   (HW_DMA_TCD8_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD8_ATTR_DMOD.
#define BF_DMA_TCD8_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_ATTR_DMOD), uint16_t) & BM_DMA_TCD8_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD8_ATTR_DMOD(v)   (HW_DMA_TCD8_ATTR_WR((HW_DMA_TCD8_ATTR_RD() & ~BM_DMA_TCD8_ATTR_DMOD) | BF_DMA_TCD8_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD8_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD8_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD8_ATTR_SSIZE.
#define BM_DMA_TCD8_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD8_ATTR_SSIZE.
#define BS_DMA_TCD8_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD8_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_ATTR_SSIZE field.
#define BR_DMA_TCD8_ATTR_SSIZE()   (HW_DMA_TCD8_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD8_ATTR_SSIZE.
#define BF_DMA_TCD8_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_ATTR_SSIZE), uint16_t) & BM_DMA_TCD8_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD8_ATTR_SSIZE(v)   (HW_DMA_TCD8_ATTR_WR((HW_DMA_TCD8_ATTR_RD() & ~BM_DMA_TCD8_ATTR_SSIZE) | BF_DMA_TCD8_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD8_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD8_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD8_ATTR_SMOD.
#define BM_DMA_TCD8_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD8_ATTR_SMOD.
#define BS_DMA_TCD8_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD8_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_ATTR_SMOD field.
#define BR_DMA_TCD8_ATTR_SMOD()   (HW_DMA_TCD8_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD8_ATTR_SMOD.
#define BF_DMA_TCD8_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_ATTR_SMOD), uint16_t) & BM_DMA_TCD8_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD8_ATTR_SMOD(v)   (HW_DMA_TCD8_ATTR_WR((HW_DMA_TCD8_ATTR_RD() & ~BM_DMA_TCD8_ATTR_SMOD) | BF_DMA_TCD8_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd8_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd8_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd8_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD8_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1108U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_NBYTES_MLNO           (*(__IO hw_dma_tcd8_nbytes_mlno_t *) HW_DMA_TCD8_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD8_NBYTES_MLNO_RD()      (HW_DMA_TCD8_NBYTES_MLNO.U)
#define HW_DMA_TCD8_NBYTES_MLNO_WR(v)     (HW_DMA_TCD8_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD8_NBYTES_MLNO_SET(v)    (HW_DMA_TCD8_NBYTES_MLNO_WR(HW_DMA_TCD8_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD8_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD8_NBYTES_MLNO_WR(HW_DMA_TCD8_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD8_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD8_NBYTES_MLNO_WR(HW_DMA_TCD8_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD8_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD8_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD8_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD8_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD8_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD8_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD8_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD8_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD8_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD8_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD8_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD8_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD8_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD8_NBYTES_MLNO_WR((HW_DMA_TCD8_NBYTES_MLNO_RD() & ~BM_DMA_TCD8_NBYTES_MLNO_NBYTES) | BF_DMA_TCD8_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd8_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd8_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd8_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD8_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1108U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd8_nbytes_mloffno_t *) HW_DMA_TCD8_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD8_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD8_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD8_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD8_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD8_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD8_NBYTES_MLOFFNO_WR(HW_DMA_TCD8_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD8_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD8_NBYTES_MLOFFNO_WR(HW_DMA_TCD8_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD8_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD8_NBYTES_MLOFFNO_WR(HW_DMA_TCD8_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD8_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD8_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD8_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD8_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD8_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD8_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD8_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD8_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD8_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD8_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD8_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD8_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD8_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD8_NBYTES_MLOFFNO_WR((HW_DMA_TCD8_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD8_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD8_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD8_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD8_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD8_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD8_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD8_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD8_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD8_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD8_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD8_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD8_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD8_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD8_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD8_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD8_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD8_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD8_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD8_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD8_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD8_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD8_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD8_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD8_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD8_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD8_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD8_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD8_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD8_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD8_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD8_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD8_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD8_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd8_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd8_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd8_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD8_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1108U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd8_nbytes_mloffyes_t *) HW_DMA_TCD8_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD8_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD8_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD8_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD8_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD8_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD8_NBYTES_MLOFFYES_WR(HW_DMA_TCD8_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD8_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD8_NBYTES_MLOFFYES_WR(HW_DMA_TCD8_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD8_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD8_NBYTES_MLOFFYES_WR(HW_DMA_TCD8_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD8_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD8_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD8_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD8_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD8_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD8_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD8_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD8_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD8_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD8_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD8_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD8_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD8_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD8_NBYTES_MLOFFYES_WR((HW_DMA_TCD8_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD8_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD8_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD8_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD8_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD8_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD8_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD8_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD8_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD8_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD8_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD8_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD8_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD8_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD8_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD8_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD8_NBYTES_MLOFFYES_WR((HW_DMA_TCD8_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD8_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD8_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD8_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD8_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD8_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD8_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD8_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD8_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD8_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD8_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD8_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD8_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD8_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD8_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD8_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD8_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD8_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD8_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD8_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD8_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD8_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD8_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD8_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD8_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD8_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD8_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD8_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD8_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD8_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD8_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD8_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD8_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD8_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd8_slast
{
    uint32_t U;
    struct _hw_dma_tcd8_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd8_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_SLAST register
 */
//@{
#define HW_DMA_TCD8_SLAST_ADDR      (REGS_DMA_BASE + 0x110cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_SLAST           (*(__IO hw_dma_tcd8_slast_t *) HW_DMA_TCD8_SLAST_ADDR)
#define HW_DMA_TCD8_SLAST_RD()      (HW_DMA_TCD8_SLAST.U)
#define HW_DMA_TCD8_SLAST_WR(v)     (HW_DMA_TCD8_SLAST.U = (v))
#define HW_DMA_TCD8_SLAST_SET(v)    (HW_DMA_TCD8_SLAST_WR(HW_DMA_TCD8_SLAST_RD() |  (v)))
#define HW_DMA_TCD8_SLAST_CLR(v)    (HW_DMA_TCD8_SLAST_WR(HW_DMA_TCD8_SLAST_RD() & ~(v)))
#define HW_DMA_TCD8_SLAST_TOG(v)    (HW_DMA_TCD8_SLAST_WR(HW_DMA_TCD8_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_SLAST bitfields
 */

/*! @name Register DMA_TCD8_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD8_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD8_SLAST_SLAST.
#define BM_DMA_TCD8_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD8_SLAST_SLAST.
#define BS_DMA_TCD8_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD8_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_SLAST_SLAST field.
#define BR_DMA_TCD8_SLAST_SLAST()   (HW_DMA_TCD8_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD8_SLAST_SLAST.
#define BF_DMA_TCD8_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_SLAST_SLAST), uint32_t) & BM_DMA_TCD8_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD8_SLAST_SLAST(v)   (HW_DMA_TCD8_SLAST_WR((HW_DMA_TCD8_SLAST_RD() & ~BM_DMA_TCD8_SLAST_SLAST) | BF_DMA_TCD8_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd8_daddr
{
    uint32_t U;
    struct _hw_dma_tcd8_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd8_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_DADDR register
 */
//@{
#define HW_DMA_TCD8_DADDR_ADDR      (REGS_DMA_BASE + 0x1110U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_DADDR           (*(__IO hw_dma_tcd8_daddr_t *) HW_DMA_TCD8_DADDR_ADDR)
#define HW_DMA_TCD8_DADDR_RD()      (HW_DMA_TCD8_DADDR.U)
#define HW_DMA_TCD8_DADDR_WR(v)     (HW_DMA_TCD8_DADDR.U = (v))
#define HW_DMA_TCD8_DADDR_SET(v)    (HW_DMA_TCD8_DADDR_WR(HW_DMA_TCD8_DADDR_RD() |  (v)))
#define HW_DMA_TCD8_DADDR_CLR(v)    (HW_DMA_TCD8_DADDR_WR(HW_DMA_TCD8_DADDR_RD() & ~(v)))
#define HW_DMA_TCD8_DADDR_TOG(v)    (HW_DMA_TCD8_DADDR_WR(HW_DMA_TCD8_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_DADDR bitfields
 */

/*! @name Register DMA_TCD8_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD8_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD8_DADDR_DADDR.
#define BM_DMA_TCD8_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD8_DADDR_DADDR.
#define BS_DMA_TCD8_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD8_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_DADDR_DADDR field.
#define BR_DMA_TCD8_DADDR_DADDR()   (HW_DMA_TCD8_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD8_DADDR_DADDR.
#define BF_DMA_TCD8_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_DADDR_DADDR), uint32_t) & BM_DMA_TCD8_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD8_DADDR_DADDR(v)   (HW_DMA_TCD8_DADDR_WR((HW_DMA_TCD8_DADDR_RD() & ~BM_DMA_TCD8_DADDR_DADDR) | BF_DMA_TCD8_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd8_doff
{
    uint16_t U;
    struct _hw_dma_tcd8_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd8_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_DOFF register
 */
//@{
#define HW_DMA_TCD8_DOFF_ADDR      (REGS_DMA_BASE + 0x1114U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_DOFF           (*(__IO hw_dma_tcd8_doff_t *) HW_DMA_TCD8_DOFF_ADDR)
#define HW_DMA_TCD8_DOFF_RD()      (HW_DMA_TCD8_DOFF.U)
#define HW_DMA_TCD8_DOFF_WR(v)     (HW_DMA_TCD8_DOFF.U = (v))
#define HW_DMA_TCD8_DOFF_SET(v)    (HW_DMA_TCD8_DOFF_WR(HW_DMA_TCD8_DOFF_RD() |  (v)))
#define HW_DMA_TCD8_DOFF_CLR(v)    (HW_DMA_TCD8_DOFF_WR(HW_DMA_TCD8_DOFF_RD() & ~(v)))
#define HW_DMA_TCD8_DOFF_TOG(v)    (HW_DMA_TCD8_DOFF_WR(HW_DMA_TCD8_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_DOFF bitfields
 */

/*! @name Register DMA_TCD8_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD8_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD8_DOFF_DOFF.
#define BM_DMA_TCD8_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD8_DOFF_DOFF.
#define BS_DMA_TCD8_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD8_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_DOFF_DOFF field.
#define BR_DMA_TCD8_DOFF_DOFF()   (HW_DMA_TCD8_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD8_DOFF_DOFF.
#define BF_DMA_TCD8_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_DOFF_DOFF), uint16_t) & BM_DMA_TCD8_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD8_DOFF_DOFF(v)   (HW_DMA_TCD8_DOFF_WR((HW_DMA_TCD8_DOFF_RD() & ~BM_DMA_TCD8_DOFF_DOFF) | BF_DMA_TCD8_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd8_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd8_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd8_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD8_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1116U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_CITER_ELINKYES           (*(__IO hw_dma_tcd8_citer_elinkyes_t *) HW_DMA_TCD8_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD8_CITER_ELINKYES_RD()      (HW_DMA_TCD8_CITER_ELINKYES.U)
#define HW_DMA_TCD8_CITER_ELINKYES_WR(v)     (HW_DMA_TCD8_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD8_CITER_ELINKYES_SET(v)    (HW_DMA_TCD8_CITER_ELINKYES_WR(HW_DMA_TCD8_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD8_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD8_CITER_ELINKYES_WR(HW_DMA_TCD8_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD8_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD8_CITER_ELINKYES_WR(HW_DMA_TCD8_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD8_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD8_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD8_CITER_ELINKYES_CITER.
#define BM_DMA_TCD8_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD8_CITER_ELINKYES_CITER.
#define BS_DMA_TCD8_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD8_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD8_CITER_ELINKYES_CITER()   (HW_DMA_TCD8_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD8_CITER_ELINKYES_CITER.
#define BF_DMA_TCD8_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD8_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD8_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD8_CITER_ELINKYES_WR((HW_DMA_TCD8_CITER_ELINKYES_RD() & ~BM_DMA_TCD8_CITER_ELINKYES_CITER) | BF_DMA_TCD8_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD8_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD8_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD8_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD8_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD8_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD8_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD8_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD8_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD8_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD8_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD8_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD8_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD8_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD8_CITER_ELINKYES_WR((HW_DMA_TCD8_CITER_ELINKYES_RD() & ~BM_DMA_TCD8_CITER_ELINKYES_LINKCH) | BF_DMA_TCD8_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD8_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD8_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD8_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD8_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD8_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD8_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD8_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD8_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD8_CITER_ELINKYES_ADDR, BP_DMA_TCD8_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD8_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD8_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD8_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD8_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CITER_ELINKYES_ADDR, BP_DMA_TCD8_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd8_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd8_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd8_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD8_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1116U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_CITER_ELINKNO           (*(__IO hw_dma_tcd8_citer_elinkno_t *) HW_DMA_TCD8_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD8_CITER_ELINKNO_RD()      (HW_DMA_TCD8_CITER_ELINKNO.U)
#define HW_DMA_TCD8_CITER_ELINKNO_WR(v)     (HW_DMA_TCD8_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD8_CITER_ELINKNO_SET(v)    (HW_DMA_TCD8_CITER_ELINKNO_WR(HW_DMA_TCD8_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD8_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD8_CITER_ELINKNO_WR(HW_DMA_TCD8_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD8_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD8_CITER_ELINKNO_WR(HW_DMA_TCD8_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD8_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD8_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD8_CITER_ELINKNO_CITER.
#define BM_DMA_TCD8_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD8_CITER_ELINKNO_CITER.
#define BS_DMA_TCD8_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD8_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD8_CITER_ELINKNO_CITER()   (HW_DMA_TCD8_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD8_CITER_ELINKNO_CITER.
#define BF_DMA_TCD8_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD8_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD8_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD8_CITER_ELINKNO_WR((HW_DMA_TCD8_CITER_ELINKNO_RD() & ~BM_DMA_TCD8_CITER_ELINKNO_CITER) | BF_DMA_TCD8_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD8_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD8_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD8_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD8_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD8_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD8_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD8_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD8_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD8_CITER_ELINKNO_ADDR, BP_DMA_TCD8_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD8_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD8_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD8_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD8_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CITER_ELINKNO_ADDR, BP_DMA_TCD8_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd8_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd8_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd8_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_DLASTSGA register
 */
//@{
#define HW_DMA_TCD8_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1118U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_DLASTSGA           (*(__IO hw_dma_tcd8_dlastsga_t *) HW_DMA_TCD8_DLASTSGA_ADDR)
#define HW_DMA_TCD8_DLASTSGA_RD()      (HW_DMA_TCD8_DLASTSGA.U)
#define HW_DMA_TCD8_DLASTSGA_WR(v)     (HW_DMA_TCD8_DLASTSGA.U = (v))
#define HW_DMA_TCD8_DLASTSGA_SET(v)    (HW_DMA_TCD8_DLASTSGA_WR(HW_DMA_TCD8_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD8_DLASTSGA_CLR(v)    (HW_DMA_TCD8_DLASTSGA_WR(HW_DMA_TCD8_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD8_DLASTSGA_TOG(v)    (HW_DMA_TCD8_DLASTSGA_WR(HW_DMA_TCD8_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD8_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD8_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD8_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD8_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD8_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD8_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD8_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD8_DLASTSGA_DLASTSGA()   (HW_DMA_TCD8_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD8_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD8_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD8_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD8_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD8_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD8_DLASTSGA_WR((HW_DMA_TCD8_DLASTSGA_RD() & ~BM_DMA_TCD8_DLASTSGA_DLASTSGA) | BF_DMA_TCD8_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd8_csr
{
    uint16_t U;
    struct _hw_dma_tcd8_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd8_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_CSR register
 */
//@{
#define HW_DMA_TCD8_CSR_ADDR      (REGS_DMA_BASE + 0x111cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_CSR           (*(__IO hw_dma_tcd8_csr_t *) HW_DMA_TCD8_CSR_ADDR)
#define HW_DMA_TCD8_CSR_RD()      (HW_DMA_TCD8_CSR.U)
#define HW_DMA_TCD8_CSR_WR(v)     (HW_DMA_TCD8_CSR.U = (v))
#define HW_DMA_TCD8_CSR_SET(v)    (HW_DMA_TCD8_CSR_WR(HW_DMA_TCD8_CSR_RD() |  (v)))
#define HW_DMA_TCD8_CSR_CLR(v)    (HW_DMA_TCD8_CSR_WR(HW_DMA_TCD8_CSR_RD() & ~(v)))
#define HW_DMA_TCD8_CSR_TOG(v)    (HW_DMA_TCD8_CSR_WR(HW_DMA_TCD8_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_CSR bitfields
 */

/*! @name Register DMA_TCD8_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD8_CSR_START      (0U)      //!< Bit position for DMA_TCD8_CSR_START.
#define BM_DMA_TCD8_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD8_CSR_START.
#define BS_DMA_TCD8_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD8_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_START field.
#define BR_DMA_TCD8_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_START.
#define BF_DMA_TCD8_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_START), uint16_t) & BM_DMA_TCD8_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD8_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD8_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD8_CSR_INTMAJOR.
#define BM_DMA_TCD8_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD8_CSR_INTMAJOR.
#define BS_DMA_TCD8_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD8_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_INTMAJOR field.
#define BR_DMA_TCD8_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_INTMAJOR.
#define BF_DMA_TCD8_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD8_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD8_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD8_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD8_CSR_INTHALF.
#define BM_DMA_TCD8_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD8_CSR_INTHALF.
#define BS_DMA_TCD8_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD8_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_INTHALF field.
#define BR_DMA_TCD8_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_INTHALF.
#define BF_DMA_TCD8_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_INTHALF), uint16_t) & BM_DMA_TCD8_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD8_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD8_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD8_CSR_DREQ.
#define BM_DMA_TCD8_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD8_CSR_DREQ.
#define BS_DMA_TCD8_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD8_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_DREQ field.
#define BR_DMA_TCD8_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_DREQ.
#define BF_DMA_TCD8_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_DREQ), uint16_t) & BM_DMA_TCD8_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD8_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD8_CSR_ESG      (4U)      //!< Bit position for DMA_TCD8_CSR_ESG.
#define BM_DMA_TCD8_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD8_CSR_ESG.
#define BS_DMA_TCD8_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD8_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_ESG field.
#define BR_DMA_TCD8_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_ESG.
#define BF_DMA_TCD8_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_ESG), uint16_t) & BM_DMA_TCD8_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD8_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD8_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD8_CSR_MAJORELINK.
#define BM_DMA_TCD8_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD8_CSR_MAJORELINK.
#define BS_DMA_TCD8_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD8_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_MAJORELINK field.
#define BR_DMA_TCD8_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_MAJORELINK.
#define BF_DMA_TCD8_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD8_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD8_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD8_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD8_CSR_ACTIVE.
#define BM_DMA_TCD8_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD8_CSR_ACTIVE.
#define BS_DMA_TCD8_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD8_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_ACTIVE field.
#define BR_DMA_TCD8_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_ACTIVE.
#define BF_DMA_TCD8_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_ACTIVE), uint16_t) & BM_DMA_TCD8_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD8_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD8_CSR_DONE      (7U)      //!< Bit position for DMA_TCD8_CSR_DONE.
#define BM_DMA_TCD8_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD8_CSR_DONE.
#define BS_DMA_TCD8_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD8_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_DONE field.
#define BR_DMA_TCD8_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_DONE.
#define BF_DMA_TCD8_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_DONE), uint16_t) & BM_DMA_TCD8_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD8_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_CSR_ADDR, BP_DMA_TCD8_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD8_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD8_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD8_CSR_MAJORLINKCH.
#define BM_DMA_TCD8_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD8_CSR_MAJORLINKCH.
#define BS_DMA_TCD8_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD8_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_MAJORLINKCH field.
#define BR_DMA_TCD8_CSR_MAJORLINKCH()   (HW_DMA_TCD8_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_MAJORLINKCH.
#define BF_DMA_TCD8_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD8_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD8_CSR_MAJORLINKCH(v)   (HW_DMA_TCD8_CSR_WR((HW_DMA_TCD8_CSR_RD() & ~BM_DMA_TCD8_CSR_MAJORLINKCH) | BF_DMA_TCD8_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD8_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD8_CSR_BWC      (14U)      //!< Bit position for DMA_TCD8_CSR_BWC.
#define BM_DMA_TCD8_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD8_CSR_BWC.
#define BS_DMA_TCD8_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD8_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_CSR_BWC field.
#define BR_DMA_TCD8_CSR_BWC()   (HW_DMA_TCD8_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD8_CSR_BWC.
#define BF_DMA_TCD8_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_CSR_BWC), uint16_t) & BM_DMA_TCD8_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD8_CSR_BWC(v)   (HW_DMA_TCD8_CSR_WR((HW_DMA_TCD8_CSR_RD() & ~BM_DMA_TCD8_CSR_BWC) | BF_DMA_TCD8_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd8_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd8_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd8_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD8_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x111eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_BITER_ELINKYES           (*(__IO hw_dma_tcd8_biter_elinkyes_t *) HW_DMA_TCD8_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD8_BITER_ELINKYES_RD()      (HW_DMA_TCD8_BITER_ELINKYES.U)
#define HW_DMA_TCD8_BITER_ELINKYES_WR(v)     (HW_DMA_TCD8_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD8_BITER_ELINKYES_SET(v)    (HW_DMA_TCD8_BITER_ELINKYES_WR(HW_DMA_TCD8_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD8_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD8_BITER_ELINKYES_WR(HW_DMA_TCD8_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD8_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD8_BITER_ELINKYES_WR(HW_DMA_TCD8_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD8_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD8_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD8_BITER_ELINKYES_BITER.
#define BM_DMA_TCD8_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD8_BITER_ELINKYES_BITER.
#define BS_DMA_TCD8_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD8_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD8_BITER_ELINKYES_BITER()   (HW_DMA_TCD8_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD8_BITER_ELINKYES_BITER.
#define BF_DMA_TCD8_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD8_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD8_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD8_BITER_ELINKYES_WR((HW_DMA_TCD8_BITER_ELINKYES_RD() & ~BM_DMA_TCD8_BITER_ELINKYES_BITER) | BF_DMA_TCD8_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD8_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD8_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD8_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD8_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD8_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD8_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD8_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD8_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD8_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD8_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD8_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD8_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD8_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD8_BITER_ELINKYES_WR((HW_DMA_TCD8_BITER_ELINKYES_RD() & ~BM_DMA_TCD8_BITER_ELINKYES_LINKCH) | BF_DMA_TCD8_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD8_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD8_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD8_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD8_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD8_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD8_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD8_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD8_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD8_BITER_ELINKYES_ADDR, BP_DMA_TCD8_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD8_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD8_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD8_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD8_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_BITER_ELINKYES_ADDR, BP_DMA_TCD8_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD8_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD8_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd8_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd8_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd8_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD8_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD8_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x111eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD8_BITER_ELINKNO           (*(__IO hw_dma_tcd8_biter_elinkno_t *) HW_DMA_TCD8_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD8_BITER_ELINKNO_RD()      (HW_DMA_TCD8_BITER_ELINKNO.U)
#define HW_DMA_TCD8_BITER_ELINKNO_WR(v)     (HW_DMA_TCD8_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD8_BITER_ELINKNO_SET(v)    (HW_DMA_TCD8_BITER_ELINKNO_WR(HW_DMA_TCD8_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD8_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD8_BITER_ELINKNO_WR(HW_DMA_TCD8_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD8_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD8_BITER_ELINKNO_WR(HW_DMA_TCD8_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD8_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD8_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD8_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD8_BITER_ELINKNO_BITER.
#define BM_DMA_TCD8_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD8_BITER_ELINKNO_BITER.
#define BS_DMA_TCD8_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD8_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD8_BITER_ELINKNO_BITER()   (HW_DMA_TCD8_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD8_BITER_ELINKNO_BITER.
#define BF_DMA_TCD8_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD8_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD8_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD8_BITER_ELINKNO_WR((HW_DMA_TCD8_BITER_ELINKNO_RD() & ~BM_DMA_TCD8_BITER_ELINKNO_BITER) | BF_DMA_TCD8_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD8_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD8_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD8_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD8_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD8_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD8_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD8_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD8_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD8_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD8_BITER_ELINKNO_ADDR, BP_DMA_TCD8_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD8_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD8_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD8_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD8_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD8_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD8_BITER_ELINKNO_ADDR, BP_DMA_TCD8_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd9_saddr
{
    uint32_t U;
    struct _hw_dma_tcd9_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd9_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_SADDR register
 */
//@{
#define HW_DMA_TCD9_SADDR_ADDR      (REGS_DMA_BASE + 0x1120U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_SADDR           (*(__IO hw_dma_tcd9_saddr_t *) HW_DMA_TCD9_SADDR_ADDR)
#define HW_DMA_TCD9_SADDR_RD()      (HW_DMA_TCD9_SADDR.U)
#define HW_DMA_TCD9_SADDR_WR(v)     (HW_DMA_TCD9_SADDR.U = (v))
#define HW_DMA_TCD9_SADDR_SET(v)    (HW_DMA_TCD9_SADDR_WR(HW_DMA_TCD9_SADDR_RD() |  (v)))
#define HW_DMA_TCD9_SADDR_CLR(v)    (HW_DMA_TCD9_SADDR_WR(HW_DMA_TCD9_SADDR_RD() & ~(v)))
#define HW_DMA_TCD9_SADDR_TOG(v)    (HW_DMA_TCD9_SADDR_WR(HW_DMA_TCD9_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_SADDR bitfields
 */

/*! @name Register DMA_TCD9_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD9_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD9_SADDR_SADDR.
#define BM_DMA_TCD9_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD9_SADDR_SADDR.
#define BS_DMA_TCD9_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD9_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_SADDR_SADDR field.
#define BR_DMA_TCD9_SADDR_SADDR()   (HW_DMA_TCD9_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD9_SADDR_SADDR.
#define BF_DMA_TCD9_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_SADDR_SADDR), uint32_t) & BM_DMA_TCD9_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD9_SADDR_SADDR(v)   (HW_DMA_TCD9_SADDR_WR((HW_DMA_TCD9_SADDR_RD() & ~BM_DMA_TCD9_SADDR_SADDR) | BF_DMA_TCD9_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd9_soff
{
    uint16_t U;
    struct _hw_dma_tcd9_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd9_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_SOFF register
 */
//@{
#define HW_DMA_TCD9_SOFF_ADDR      (REGS_DMA_BASE + 0x1124U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_SOFF           (*(__IO hw_dma_tcd9_soff_t *) HW_DMA_TCD9_SOFF_ADDR)
#define HW_DMA_TCD9_SOFF_RD()      (HW_DMA_TCD9_SOFF.U)
#define HW_DMA_TCD9_SOFF_WR(v)     (HW_DMA_TCD9_SOFF.U = (v))
#define HW_DMA_TCD9_SOFF_SET(v)    (HW_DMA_TCD9_SOFF_WR(HW_DMA_TCD9_SOFF_RD() |  (v)))
#define HW_DMA_TCD9_SOFF_CLR(v)    (HW_DMA_TCD9_SOFF_WR(HW_DMA_TCD9_SOFF_RD() & ~(v)))
#define HW_DMA_TCD9_SOFF_TOG(v)    (HW_DMA_TCD9_SOFF_WR(HW_DMA_TCD9_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_SOFF bitfields
 */

/*! @name Register DMA_TCD9_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD9_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD9_SOFF_SOFF.
#define BM_DMA_TCD9_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD9_SOFF_SOFF.
#define BS_DMA_TCD9_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD9_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_SOFF_SOFF field.
#define BR_DMA_TCD9_SOFF_SOFF()   (HW_DMA_TCD9_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD9_SOFF_SOFF.
#define BF_DMA_TCD9_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_SOFF_SOFF), uint16_t) & BM_DMA_TCD9_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD9_SOFF_SOFF(v)   (HW_DMA_TCD9_SOFF_WR((HW_DMA_TCD9_SOFF_RD() & ~BM_DMA_TCD9_SOFF_SOFF) | BF_DMA_TCD9_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd9_attr
{
    uint16_t U;
    struct _hw_dma_tcd9_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd9_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_ATTR register
 */
//@{
#define HW_DMA_TCD9_ATTR_ADDR      (REGS_DMA_BASE + 0x1126U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_ATTR           (*(__IO hw_dma_tcd9_attr_t *) HW_DMA_TCD9_ATTR_ADDR)
#define HW_DMA_TCD9_ATTR_RD()      (HW_DMA_TCD9_ATTR.U)
#define HW_DMA_TCD9_ATTR_WR(v)     (HW_DMA_TCD9_ATTR.U = (v))
#define HW_DMA_TCD9_ATTR_SET(v)    (HW_DMA_TCD9_ATTR_WR(HW_DMA_TCD9_ATTR_RD() |  (v)))
#define HW_DMA_TCD9_ATTR_CLR(v)    (HW_DMA_TCD9_ATTR_WR(HW_DMA_TCD9_ATTR_RD() & ~(v)))
#define HW_DMA_TCD9_ATTR_TOG(v)    (HW_DMA_TCD9_ATTR_WR(HW_DMA_TCD9_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_ATTR bitfields
 */

/*! @name Register DMA_TCD9_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD9_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD9_ATTR_DSIZE.
#define BM_DMA_TCD9_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD9_ATTR_DSIZE.
#define BS_DMA_TCD9_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD9_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_ATTR_DSIZE field.
#define BR_DMA_TCD9_ATTR_DSIZE()   (HW_DMA_TCD9_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD9_ATTR_DSIZE.
#define BF_DMA_TCD9_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_ATTR_DSIZE), uint16_t) & BM_DMA_TCD9_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD9_ATTR_DSIZE(v)   (HW_DMA_TCD9_ATTR_WR((HW_DMA_TCD9_ATTR_RD() & ~BM_DMA_TCD9_ATTR_DSIZE) | BF_DMA_TCD9_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD9_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD9_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD9_ATTR_DMOD.
#define BM_DMA_TCD9_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD9_ATTR_DMOD.
#define BS_DMA_TCD9_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD9_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_ATTR_DMOD field.
#define BR_DMA_TCD9_ATTR_DMOD()   (HW_DMA_TCD9_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD9_ATTR_DMOD.
#define BF_DMA_TCD9_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_ATTR_DMOD), uint16_t) & BM_DMA_TCD9_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD9_ATTR_DMOD(v)   (HW_DMA_TCD9_ATTR_WR((HW_DMA_TCD9_ATTR_RD() & ~BM_DMA_TCD9_ATTR_DMOD) | BF_DMA_TCD9_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD9_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD9_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD9_ATTR_SSIZE.
#define BM_DMA_TCD9_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD9_ATTR_SSIZE.
#define BS_DMA_TCD9_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD9_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_ATTR_SSIZE field.
#define BR_DMA_TCD9_ATTR_SSIZE()   (HW_DMA_TCD9_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD9_ATTR_SSIZE.
#define BF_DMA_TCD9_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_ATTR_SSIZE), uint16_t) & BM_DMA_TCD9_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD9_ATTR_SSIZE(v)   (HW_DMA_TCD9_ATTR_WR((HW_DMA_TCD9_ATTR_RD() & ~BM_DMA_TCD9_ATTR_SSIZE) | BF_DMA_TCD9_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD9_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD9_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD9_ATTR_SMOD.
#define BM_DMA_TCD9_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD9_ATTR_SMOD.
#define BS_DMA_TCD9_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD9_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_ATTR_SMOD field.
#define BR_DMA_TCD9_ATTR_SMOD()   (HW_DMA_TCD9_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD9_ATTR_SMOD.
#define BF_DMA_TCD9_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_ATTR_SMOD), uint16_t) & BM_DMA_TCD9_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD9_ATTR_SMOD(v)   (HW_DMA_TCD9_ATTR_WR((HW_DMA_TCD9_ATTR_RD() & ~BM_DMA_TCD9_ATTR_SMOD) | BF_DMA_TCD9_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd9_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd9_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd9_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD9_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1128U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_NBYTES_MLNO           (*(__IO hw_dma_tcd9_nbytes_mlno_t *) HW_DMA_TCD9_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD9_NBYTES_MLNO_RD()      (HW_DMA_TCD9_NBYTES_MLNO.U)
#define HW_DMA_TCD9_NBYTES_MLNO_WR(v)     (HW_DMA_TCD9_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD9_NBYTES_MLNO_SET(v)    (HW_DMA_TCD9_NBYTES_MLNO_WR(HW_DMA_TCD9_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD9_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD9_NBYTES_MLNO_WR(HW_DMA_TCD9_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD9_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD9_NBYTES_MLNO_WR(HW_DMA_TCD9_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD9_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD9_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD9_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD9_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD9_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD9_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD9_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD9_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD9_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD9_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD9_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD9_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD9_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD9_NBYTES_MLNO_WR((HW_DMA_TCD9_NBYTES_MLNO_RD() & ~BM_DMA_TCD9_NBYTES_MLNO_NBYTES) | BF_DMA_TCD9_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd9_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd9_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd9_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD9_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1128U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd9_nbytes_mloffno_t *) HW_DMA_TCD9_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD9_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD9_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD9_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD9_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD9_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD9_NBYTES_MLOFFNO_WR(HW_DMA_TCD9_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD9_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD9_NBYTES_MLOFFNO_WR(HW_DMA_TCD9_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD9_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD9_NBYTES_MLOFFNO_WR(HW_DMA_TCD9_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD9_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD9_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD9_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD9_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD9_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD9_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD9_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD9_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD9_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD9_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD9_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD9_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD9_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD9_NBYTES_MLOFFNO_WR((HW_DMA_TCD9_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD9_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD9_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD9_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD9_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD9_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD9_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD9_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD9_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD9_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD9_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD9_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD9_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD9_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD9_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD9_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD9_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD9_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD9_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD9_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD9_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD9_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD9_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD9_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD9_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD9_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD9_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD9_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD9_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD9_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD9_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD9_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD9_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD9_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd9_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd9_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd9_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD9_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1128U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd9_nbytes_mloffyes_t *) HW_DMA_TCD9_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD9_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD9_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD9_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD9_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD9_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD9_NBYTES_MLOFFYES_WR(HW_DMA_TCD9_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD9_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD9_NBYTES_MLOFFYES_WR(HW_DMA_TCD9_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD9_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD9_NBYTES_MLOFFYES_WR(HW_DMA_TCD9_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD9_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD9_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD9_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD9_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD9_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD9_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD9_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD9_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD9_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD9_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD9_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD9_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD9_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD9_NBYTES_MLOFFYES_WR((HW_DMA_TCD9_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD9_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD9_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD9_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD9_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD9_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD9_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD9_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD9_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD9_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD9_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD9_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD9_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD9_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD9_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD9_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD9_NBYTES_MLOFFYES_WR((HW_DMA_TCD9_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD9_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD9_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD9_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD9_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD9_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD9_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD9_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD9_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD9_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD9_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD9_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD9_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD9_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD9_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD9_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD9_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD9_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD9_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD9_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD9_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD9_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD9_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD9_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD9_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD9_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD9_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD9_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD9_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD9_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD9_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD9_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD9_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD9_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd9_slast
{
    uint32_t U;
    struct _hw_dma_tcd9_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd9_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_SLAST register
 */
//@{
#define HW_DMA_TCD9_SLAST_ADDR      (REGS_DMA_BASE + 0x112cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_SLAST           (*(__IO hw_dma_tcd9_slast_t *) HW_DMA_TCD9_SLAST_ADDR)
#define HW_DMA_TCD9_SLAST_RD()      (HW_DMA_TCD9_SLAST.U)
#define HW_DMA_TCD9_SLAST_WR(v)     (HW_DMA_TCD9_SLAST.U = (v))
#define HW_DMA_TCD9_SLAST_SET(v)    (HW_DMA_TCD9_SLAST_WR(HW_DMA_TCD9_SLAST_RD() |  (v)))
#define HW_DMA_TCD9_SLAST_CLR(v)    (HW_DMA_TCD9_SLAST_WR(HW_DMA_TCD9_SLAST_RD() & ~(v)))
#define HW_DMA_TCD9_SLAST_TOG(v)    (HW_DMA_TCD9_SLAST_WR(HW_DMA_TCD9_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_SLAST bitfields
 */

/*! @name Register DMA_TCD9_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD9_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD9_SLAST_SLAST.
#define BM_DMA_TCD9_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD9_SLAST_SLAST.
#define BS_DMA_TCD9_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD9_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_SLAST_SLAST field.
#define BR_DMA_TCD9_SLAST_SLAST()   (HW_DMA_TCD9_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD9_SLAST_SLAST.
#define BF_DMA_TCD9_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_SLAST_SLAST), uint32_t) & BM_DMA_TCD9_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD9_SLAST_SLAST(v)   (HW_DMA_TCD9_SLAST_WR((HW_DMA_TCD9_SLAST_RD() & ~BM_DMA_TCD9_SLAST_SLAST) | BF_DMA_TCD9_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd9_daddr
{
    uint32_t U;
    struct _hw_dma_tcd9_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd9_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_DADDR register
 */
//@{
#define HW_DMA_TCD9_DADDR_ADDR      (REGS_DMA_BASE + 0x1130U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_DADDR           (*(__IO hw_dma_tcd9_daddr_t *) HW_DMA_TCD9_DADDR_ADDR)
#define HW_DMA_TCD9_DADDR_RD()      (HW_DMA_TCD9_DADDR.U)
#define HW_DMA_TCD9_DADDR_WR(v)     (HW_DMA_TCD9_DADDR.U = (v))
#define HW_DMA_TCD9_DADDR_SET(v)    (HW_DMA_TCD9_DADDR_WR(HW_DMA_TCD9_DADDR_RD() |  (v)))
#define HW_DMA_TCD9_DADDR_CLR(v)    (HW_DMA_TCD9_DADDR_WR(HW_DMA_TCD9_DADDR_RD() & ~(v)))
#define HW_DMA_TCD9_DADDR_TOG(v)    (HW_DMA_TCD9_DADDR_WR(HW_DMA_TCD9_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_DADDR bitfields
 */

/*! @name Register DMA_TCD9_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD9_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD9_DADDR_DADDR.
#define BM_DMA_TCD9_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD9_DADDR_DADDR.
#define BS_DMA_TCD9_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD9_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_DADDR_DADDR field.
#define BR_DMA_TCD9_DADDR_DADDR()   (HW_DMA_TCD9_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD9_DADDR_DADDR.
#define BF_DMA_TCD9_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_DADDR_DADDR), uint32_t) & BM_DMA_TCD9_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD9_DADDR_DADDR(v)   (HW_DMA_TCD9_DADDR_WR((HW_DMA_TCD9_DADDR_RD() & ~BM_DMA_TCD9_DADDR_DADDR) | BF_DMA_TCD9_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd9_doff
{
    uint16_t U;
    struct _hw_dma_tcd9_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd9_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_DOFF register
 */
//@{
#define HW_DMA_TCD9_DOFF_ADDR      (REGS_DMA_BASE + 0x1134U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_DOFF           (*(__IO hw_dma_tcd9_doff_t *) HW_DMA_TCD9_DOFF_ADDR)
#define HW_DMA_TCD9_DOFF_RD()      (HW_DMA_TCD9_DOFF.U)
#define HW_DMA_TCD9_DOFF_WR(v)     (HW_DMA_TCD9_DOFF.U = (v))
#define HW_DMA_TCD9_DOFF_SET(v)    (HW_DMA_TCD9_DOFF_WR(HW_DMA_TCD9_DOFF_RD() |  (v)))
#define HW_DMA_TCD9_DOFF_CLR(v)    (HW_DMA_TCD9_DOFF_WR(HW_DMA_TCD9_DOFF_RD() & ~(v)))
#define HW_DMA_TCD9_DOFF_TOG(v)    (HW_DMA_TCD9_DOFF_WR(HW_DMA_TCD9_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_DOFF bitfields
 */

/*! @name Register DMA_TCD9_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD9_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD9_DOFF_DOFF.
#define BM_DMA_TCD9_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD9_DOFF_DOFF.
#define BS_DMA_TCD9_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD9_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_DOFF_DOFF field.
#define BR_DMA_TCD9_DOFF_DOFF()   (HW_DMA_TCD9_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD9_DOFF_DOFF.
#define BF_DMA_TCD9_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_DOFF_DOFF), uint16_t) & BM_DMA_TCD9_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD9_DOFF_DOFF(v)   (HW_DMA_TCD9_DOFF_WR((HW_DMA_TCD9_DOFF_RD() & ~BM_DMA_TCD9_DOFF_DOFF) | BF_DMA_TCD9_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd9_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd9_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd9_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD9_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1136U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_CITER_ELINKYES           (*(__IO hw_dma_tcd9_citer_elinkyes_t *) HW_DMA_TCD9_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD9_CITER_ELINKYES_RD()      (HW_DMA_TCD9_CITER_ELINKYES.U)
#define HW_DMA_TCD9_CITER_ELINKYES_WR(v)     (HW_DMA_TCD9_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD9_CITER_ELINKYES_SET(v)    (HW_DMA_TCD9_CITER_ELINKYES_WR(HW_DMA_TCD9_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD9_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD9_CITER_ELINKYES_WR(HW_DMA_TCD9_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD9_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD9_CITER_ELINKYES_WR(HW_DMA_TCD9_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD9_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD9_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD9_CITER_ELINKYES_CITER.
#define BM_DMA_TCD9_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD9_CITER_ELINKYES_CITER.
#define BS_DMA_TCD9_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD9_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD9_CITER_ELINKYES_CITER()   (HW_DMA_TCD9_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD9_CITER_ELINKYES_CITER.
#define BF_DMA_TCD9_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD9_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD9_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD9_CITER_ELINKYES_WR((HW_DMA_TCD9_CITER_ELINKYES_RD() & ~BM_DMA_TCD9_CITER_ELINKYES_CITER) | BF_DMA_TCD9_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD9_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD9_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD9_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD9_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD9_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD9_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD9_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD9_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD9_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD9_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD9_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD9_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD9_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD9_CITER_ELINKYES_WR((HW_DMA_TCD9_CITER_ELINKYES_RD() & ~BM_DMA_TCD9_CITER_ELINKYES_LINKCH) | BF_DMA_TCD9_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD9_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD9_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD9_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD9_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD9_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD9_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD9_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD9_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD9_CITER_ELINKYES_ADDR, BP_DMA_TCD9_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD9_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD9_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD9_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD9_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CITER_ELINKYES_ADDR, BP_DMA_TCD9_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd9_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd9_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd9_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD9_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1136U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_CITER_ELINKNO           (*(__IO hw_dma_tcd9_citer_elinkno_t *) HW_DMA_TCD9_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD9_CITER_ELINKNO_RD()      (HW_DMA_TCD9_CITER_ELINKNO.U)
#define HW_DMA_TCD9_CITER_ELINKNO_WR(v)     (HW_DMA_TCD9_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD9_CITER_ELINKNO_SET(v)    (HW_DMA_TCD9_CITER_ELINKNO_WR(HW_DMA_TCD9_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD9_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD9_CITER_ELINKNO_WR(HW_DMA_TCD9_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD9_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD9_CITER_ELINKNO_WR(HW_DMA_TCD9_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD9_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD9_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD9_CITER_ELINKNO_CITER.
#define BM_DMA_TCD9_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD9_CITER_ELINKNO_CITER.
#define BS_DMA_TCD9_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD9_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD9_CITER_ELINKNO_CITER()   (HW_DMA_TCD9_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD9_CITER_ELINKNO_CITER.
#define BF_DMA_TCD9_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD9_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD9_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD9_CITER_ELINKNO_WR((HW_DMA_TCD9_CITER_ELINKNO_RD() & ~BM_DMA_TCD9_CITER_ELINKNO_CITER) | BF_DMA_TCD9_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD9_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD9_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD9_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD9_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD9_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD9_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD9_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD9_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD9_CITER_ELINKNO_ADDR, BP_DMA_TCD9_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD9_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD9_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD9_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD9_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CITER_ELINKNO_ADDR, BP_DMA_TCD9_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd9_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd9_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd9_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_DLASTSGA register
 */
//@{
#define HW_DMA_TCD9_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1138U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_DLASTSGA           (*(__IO hw_dma_tcd9_dlastsga_t *) HW_DMA_TCD9_DLASTSGA_ADDR)
#define HW_DMA_TCD9_DLASTSGA_RD()      (HW_DMA_TCD9_DLASTSGA.U)
#define HW_DMA_TCD9_DLASTSGA_WR(v)     (HW_DMA_TCD9_DLASTSGA.U = (v))
#define HW_DMA_TCD9_DLASTSGA_SET(v)    (HW_DMA_TCD9_DLASTSGA_WR(HW_DMA_TCD9_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD9_DLASTSGA_CLR(v)    (HW_DMA_TCD9_DLASTSGA_WR(HW_DMA_TCD9_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD9_DLASTSGA_TOG(v)    (HW_DMA_TCD9_DLASTSGA_WR(HW_DMA_TCD9_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD9_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD9_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD9_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD9_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD9_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD9_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD9_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD9_DLASTSGA_DLASTSGA()   (HW_DMA_TCD9_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD9_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD9_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD9_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD9_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD9_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD9_DLASTSGA_WR((HW_DMA_TCD9_DLASTSGA_RD() & ~BM_DMA_TCD9_DLASTSGA_DLASTSGA) | BF_DMA_TCD9_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd9_csr
{
    uint16_t U;
    struct _hw_dma_tcd9_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd9_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_CSR register
 */
//@{
#define HW_DMA_TCD9_CSR_ADDR      (REGS_DMA_BASE + 0x113cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_CSR           (*(__IO hw_dma_tcd9_csr_t *) HW_DMA_TCD9_CSR_ADDR)
#define HW_DMA_TCD9_CSR_RD()      (HW_DMA_TCD9_CSR.U)
#define HW_DMA_TCD9_CSR_WR(v)     (HW_DMA_TCD9_CSR.U = (v))
#define HW_DMA_TCD9_CSR_SET(v)    (HW_DMA_TCD9_CSR_WR(HW_DMA_TCD9_CSR_RD() |  (v)))
#define HW_DMA_TCD9_CSR_CLR(v)    (HW_DMA_TCD9_CSR_WR(HW_DMA_TCD9_CSR_RD() & ~(v)))
#define HW_DMA_TCD9_CSR_TOG(v)    (HW_DMA_TCD9_CSR_WR(HW_DMA_TCD9_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_CSR bitfields
 */

/*! @name Register DMA_TCD9_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD9_CSR_START      (0U)      //!< Bit position for DMA_TCD9_CSR_START.
#define BM_DMA_TCD9_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD9_CSR_START.
#define BS_DMA_TCD9_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD9_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_START field.
#define BR_DMA_TCD9_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_START.
#define BF_DMA_TCD9_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_START), uint16_t) & BM_DMA_TCD9_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD9_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD9_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD9_CSR_INTMAJOR.
#define BM_DMA_TCD9_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD9_CSR_INTMAJOR.
#define BS_DMA_TCD9_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD9_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_INTMAJOR field.
#define BR_DMA_TCD9_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_INTMAJOR.
#define BF_DMA_TCD9_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD9_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD9_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD9_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD9_CSR_INTHALF.
#define BM_DMA_TCD9_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD9_CSR_INTHALF.
#define BS_DMA_TCD9_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD9_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_INTHALF field.
#define BR_DMA_TCD9_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_INTHALF.
#define BF_DMA_TCD9_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_INTHALF), uint16_t) & BM_DMA_TCD9_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD9_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD9_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD9_CSR_DREQ.
#define BM_DMA_TCD9_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD9_CSR_DREQ.
#define BS_DMA_TCD9_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD9_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_DREQ field.
#define BR_DMA_TCD9_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_DREQ.
#define BF_DMA_TCD9_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_DREQ), uint16_t) & BM_DMA_TCD9_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD9_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD9_CSR_ESG      (4U)      //!< Bit position for DMA_TCD9_CSR_ESG.
#define BM_DMA_TCD9_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD9_CSR_ESG.
#define BS_DMA_TCD9_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD9_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_ESG field.
#define BR_DMA_TCD9_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_ESG.
#define BF_DMA_TCD9_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_ESG), uint16_t) & BM_DMA_TCD9_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD9_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD9_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD9_CSR_MAJORELINK.
#define BM_DMA_TCD9_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD9_CSR_MAJORELINK.
#define BS_DMA_TCD9_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD9_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_MAJORELINK field.
#define BR_DMA_TCD9_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_MAJORELINK.
#define BF_DMA_TCD9_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD9_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD9_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD9_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD9_CSR_ACTIVE.
#define BM_DMA_TCD9_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD9_CSR_ACTIVE.
#define BS_DMA_TCD9_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD9_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_ACTIVE field.
#define BR_DMA_TCD9_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_ACTIVE.
#define BF_DMA_TCD9_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_ACTIVE), uint16_t) & BM_DMA_TCD9_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD9_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD9_CSR_DONE      (7U)      //!< Bit position for DMA_TCD9_CSR_DONE.
#define BM_DMA_TCD9_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD9_CSR_DONE.
#define BS_DMA_TCD9_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD9_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_DONE field.
#define BR_DMA_TCD9_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_DONE.
#define BF_DMA_TCD9_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_DONE), uint16_t) & BM_DMA_TCD9_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD9_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_CSR_ADDR, BP_DMA_TCD9_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD9_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD9_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD9_CSR_MAJORLINKCH.
#define BM_DMA_TCD9_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD9_CSR_MAJORLINKCH.
#define BS_DMA_TCD9_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD9_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_MAJORLINKCH field.
#define BR_DMA_TCD9_CSR_MAJORLINKCH()   (HW_DMA_TCD9_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_MAJORLINKCH.
#define BF_DMA_TCD9_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD9_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD9_CSR_MAJORLINKCH(v)   (HW_DMA_TCD9_CSR_WR((HW_DMA_TCD9_CSR_RD() & ~BM_DMA_TCD9_CSR_MAJORLINKCH) | BF_DMA_TCD9_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD9_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD9_CSR_BWC      (14U)      //!< Bit position for DMA_TCD9_CSR_BWC.
#define BM_DMA_TCD9_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD9_CSR_BWC.
#define BS_DMA_TCD9_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD9_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_CSR_BWC field.
#define BR_DMA_TCD9_CSR_BWC()   (HW_DMA_TCD9_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD9_CSR_BWC.
#define BF_DMA_TCD9_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_CSR_BWC), uint16_t) & BM_DMA_TCD9_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD9_CSR_BWC(v)   (HW_DMA_TCD9_CSR_WR((HW_DMA_TCD9_CSR_RD() & ~BM_DMA_TCD9_CSR_BWC) | BF_DMA_TCD9_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd9_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd9_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd9_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD9_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x113eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_BITER_ELINKYES           (*(__IO hw_dma_tcd9_biter_elinkyes_t *) HW_DMA_TCD9_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD9_BITER_ELINKYES_RD()      (HW_DMA_TCD9_BITER_ELINKYES.U)
#define HW_DMA_TCD9_BITER_ELINKYES_WR(v)     (HW_DMA_TCD9_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD9_BITER_ELINKYES_SET(v)    (HW_DMA_TCD9_BITER_ELINKYES_WR(HW_DMA_TCD9_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD9_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD9_BITER_ELINKYES_WR(HW_DMA_TCD9_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD9_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD9_BITER_ELINKYES_WR(HW_DMA_TCD9_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD9_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD9_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD9_BITER_ELINKYES_BITER.
#define BM_DMA_TCD9_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD9_BITER_ELINKYES_BITER.
#define BS_DMA_TCD9_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD9_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD9_BITER_ELINKYES_BITER()   (HW_DMA_TCD9_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD9_BITER_ELINKYES_BITER.
#define BF_DMA_TCD9_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD9_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD9_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD9_BITER_ELINKYES_WR((HW_DMA_TCD9_BITER_ELINKYES_RD() & ~BM_DMA_TCD9_BITER_ELINKYES_BITER) | BF_DMA_TCD9_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD9_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD9_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD9_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD9_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD9_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD9_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD9_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD9_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD9_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD9_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD9_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD9_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD9_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD9_BITER_ELINKYES_WR((HW_DMA_TCD9_BITER_ELINKYES_RD() & ~BM_DMA_TCD9_BITER_ELINKYES_LINKCH) | BF_DMA_TCD9_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD9_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD9_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD9_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD9_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD9_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD9_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD9_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD9_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD9_BITER_ELINKYES_ADDR, BP_DMA_TCD9_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD9_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD9_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD9_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD9_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_BITER_ELINKYES_ADDR, BP_DMA_TCD9_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD9_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD9_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd9_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd9_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd9_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD9_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD9_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x113eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD9_BITER_ELINKNO           (*(__IO hw_dma_tcd9_biter_elinkno_t *) HW_DMA_TCD9_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD9_BITER_ELINKNO_RD()      (HW_DMA_TCD9_BITER_ELINKNO.U)
#define HW_DMA_TCD9_BITER_ELINKNO_WR(v)     (HW_DMA_TCD9_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD9_BITER_ELINKNO_SET(v)    (HW_DMA_TCD9_BITER_ELINKNO_WR(HW_DMA_TCD9_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD9_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD9_BITER_ELINKNO_WR(HW_DMA_TCD9_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD9_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD9_BITER_ELINKNO_WR(HW_DMA_TCD9_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD9_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD9_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD9_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD9_BITER_ELINKNO_BITER.
#define BM_DMA_TCD9_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD9_BITER_ELINKNO_BITER.
#define BS_DMA_TCD9_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD9_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD9_BITER_ELINKNO_BITER()   (HW_DMA_TCD9_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD9_BITER_ELINKNO_BITER.
#define BF_DMA_TCD9_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD9_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD9_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD9_BITER_ELINKNO_WR((HW_DMA_TCD9_BITER_ELINKNO_RD() & ~BM_DMA_TCD9_BITER_ELINKNO_BITER) | BF_DMA_TCD9_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD9_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD9_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD9_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD9_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD9_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD9_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD9_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD9_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD9_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD9_BITER_ELINKNO_ADDR, BP_DMA_TCD9_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD9_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD9_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD9_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD9_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD9_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD9_BITER_ELINKNO_ADDR, BP_DMA_TCD9_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd10_saddr
{
    uint32_t U;
    struct _hw_dma_tcd10_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd10_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_SADDR register
 */
//@{
#define HW_DMA_TCD10_SADDR_ADDR      (REGS_DMA_BASE + 0x1140U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_SADDR           (*(__IO hw_dma_tcd10_saddr_t *) HW_DMA_TCD10_SADDR_ADDR)
#define HW_DMA_TCD10_SADDR_RD()      (HW_DMA_TCD10_SADDR.U)
#define HW_DMA_TCD10_SADDR_WR(v)     (HW_DMA_TCD10_SADDR.U = (v))
#define HW_DMA_TCD10_SADDR_SET(v)    (HW_DMA_TCD10_SADDR_WR(HW_DMA_TCD10_SADDR_RD() |  (v)))
#define HW_DMA_TCD10_SADDR_CLR(v)    (HW_DMA_TCD10_SADDR_WR(HW_DMA_TCD10_SADDR_RD() & ~(v)))
#define HW_DMA_TCD10_SADDR_TOG(v)    (HW_DMA_TCD10_SADDR_WR(HW_DMA_TCD10_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_SADDR bitfields
 */

/*! @name Register DMA_TCD10_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD10_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD10_SADDR_SADDR.
#define BM_DMA_TCD10_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD10_SADDR_SADDR.
#define BS_DMA_TCD10_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD10_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_SADDR_SADDR field.
#define BR_DMA_TCD10_SADDR_SADDR()   (HW_DMA_TCD10_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD10_SADDR_SADDR.
#define BF_DMA_TCD10_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_SADDR_SADDR), uint32_t) & BM_DMA_TCD10_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD10_SADDR_SADDR(v)   (HW_DMA_TCD10_SADDR_WR((HW_DMA_TCD10_SADDR_RD() & ~BM_DMA_TCD10_SADDR_SADDR) | BF_DMA_TCD10_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd10_soff
{
    uint16_t U;
    struct _hw_dma_tcd10_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd10_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_SOFF register
 */
//@{
#define HW_DMA_TCD10_SOFF_ADDR      (REGS_DMA_BASE + 0x1144U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_SOFF           (*(__IO hw_dma_tcd10_soff_t *) HW_DMA_TCD10_SOFF_ADDR)
#define HW_DMA_TCD10_SOFF_RD()      (HW_DMA_TCD10_SOFF.U)
#define HW_DMA_TCD10_SOFF_WR(v)     (HW_DMA_TCD10_SOFF.U = (v))
#define HW_DMA_TCD10_SOFF_SET(v)    (HW_DMA_TCD10_SOFF_WR(HW_DMA_TCD10_SOFF_RD() |  (v)))
#define HW_DMA_TCD10_SOFF_CLR(v)    (HW_DMA_TCD10_SOFF_WR(HW_DMA_TCD10_SOFF_RD() & ~(v)))
#define HW_DMA_TCD10_SOFF_TOG(v)    (HW_DMA_TCD10_SOFF_WR(HW_DMA_TCD10_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_SOFF bitfields
 */

/*! @name Register DMA_TCD10_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD10_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD10_SOFF_SOFF.
#define BM_DMA_TCD10_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD10_SOFF_SOFF.
#define BS_DMA_TCD10_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD10_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_SOFF_SOFF field.
#define BR_DMA_TCD10_SOFF_SOFF()   (HW_DMA_TCD10_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD10_SOFF_SOFF.
#define BF_DMA_TCD10_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_SOFF_SOFF), uint16_t) & BM_DMA_TCD10_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD10_SOFF_SOFF(v)   (HW_DMA_TCD10_SOFF_WR((HW_DMA_TCD10_SOFF_RD() & ~BM_DMA_TCD10_SOFF_SOFF) | BF_DMA_TCD10_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd10_attr
{
    uint16_t U;
    struct _hw_dma_tcd10_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd10_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_ATTR register
 */
//@{
#define HW_DMA_TCD10_ATTR_ADDR      (REGS_DMA_BASE + 0x1146U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_ATTR           (*(__IO hw_dma_tcd10_attr_t *) HW_DMA_TCD10_ATTR_ADDR)
#define HW_DMA_TCD10_ATTR_RD()      (HW_DMA_TCD10_ATTR.U)
#define HW_DMA_TCD10_ATTR_WR(v)     (HW_DMA_TCD10_ATTR.U = (v))
#define HW_DMA_TCD10_ATTR_SET(v)    (HW_DMA_TCD10_ATTR_WR(HW_DMA_TCD10_ATTR_RD() |  (v)))
#define HW_DMA_TCD10_ATTR_CLR(v)    (HW_DMA_TCD10_ATTR_WR(HW_DMA_TCD10_ATTR_RD() & ~(v)))
#define HW_DMA_TCD10_ATTR_TOG(v)    (HW_DMA_TCD10_ATTR_WR(HW_DMA_TCD10_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_ATTR bitfields
 */

/*! @name Register DMA_TCD10_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD10_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD10_ATTR_DSIZE.
#define BM_DMA_TCD10_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD10_ATTR_DSIZE.
#define BS_DMA_TCD10_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD10_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_ATTR_DSIZE field.
#define BR_DMA_TCD10_ATTR_DSIZE()   (HW_DMA_TCD10_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD10_ATTR_DSIZE.
#define BF_DMA_TCD10_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_ATTR_DSIZE), uint16_t) & BM_DMA_TCD10_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD10_ATTR_DSIZE(v)   (HW_DMA_TCD10_ATTR_WR((HW_DMA_TCD10_ATTR_RD() & ~BM_DMA_TCD10_ATTR_DSIZE) | BF_DMA_TCD10_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD10_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD10_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD10_ATTR_DMOD.
#define BM_DMA_TCD10_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD10_ATTR_DMOD.
#define BS_DMA_TCD10_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD10_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_ATTR_DMOD field.
#define BR_DMA_TCD10_ATTR_DMOD()   (HW_DMA_TCD10_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD10_ATTR_DMOD.
#define BF_DMA_TCD10_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_ATTR_DMOD), uint16_t) & BM_DMA_TCD10_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD10_ATTR_DMOD(v)   (HW_DMA_TCD10_ATTR_WR((HW_DMA_TCD10_ATTR_RD() & ~BM_DMA_TCD10_ATTR_DMOD) | BF_DMA_TCD10_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD10_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD10_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD10_ATTR_SSIZE.
#define BM_DMA_TCD10_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD10_ATTR_SSIZE.
#define BS_DMA_TCD10_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD10_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_ATTR_SSIZE field.
#define BR_DMA_TCD10_ATTR_SSIZE()   (HW_DMA_TCD10_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD10_ATTR_SSIZE.
#define BF_DMA_TCD10_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_ATTR_SSIZE), uint16_t) & BM_DMA_TCD10_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD10_ATTR_SSIZE(v)   (HW_DMA_TCD10_ATTR_WR((HW_DMA_TCD10_ATTR_RD() & ~BM_DMA_TCD10_ATTR_SSIZE) | BF_DMA_TCD10_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD10_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD10_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD10_ATTR_SMOD.
#define BM_DMA_TCD10_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD10_ATTR_SMOD.
#define BS_DMA_TCD10_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD10_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_ATTR_SMOD field.
#define BR_DMA_TCD10_ATTR_SMOD()   (HW_DMA_TCD10_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD10_ATTR_SMOD.
#define BF_DMA_TCD10_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_ATTR_SMOD), uint16_t) & BM_DMA_TCD10_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD10_ATTR_SMOD(v)   (HW_DMA_TCD10_ATTR_WR((HW_DMA_TCD10_ATTR_RD() & ~BM_DMA_TCD10_ATTR_SMOD) | BF_DMA_TCD10_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd10_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd10_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd10_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD10_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1148U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_NBYTES_MLNO           (*(__IO hw_dma_tcd10_nbytes_mlno_t *) HW_DMA_TCD10_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD10_NBYTES_MLNO_RD()      (HW_DMA_TCD10_NBYTES_MLNO.U)
#define HW_DMA_TCD10_NBYTES_MLNO_WR(v)     (HW_DMA_TCD10_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD10_NBYTES_MLNO_SET(v)    (HW_DMA_TCD10_NBYTES_MLNO_WR(HW_DMA_TCD10_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD10_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD10_NBYTES_MLNO_WR(HW_DMA_TCD10_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD10_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD10_NBYTES_MLNO_WR(HW_DMA_TCD10_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD10_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD10_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD10_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD10_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD10_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD10_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD10_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD10_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD10_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD10_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD10_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD10_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD10_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD10_NBYTES_MLNO_WR((HW_DMA_TCD10_NBYTES_MLNO_RD() & ~BM_DMA_TCD10_NBYTES_MLNO_NBYTES) | BF_DMA_TCD10_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd10_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd10_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd10_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD10_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1148U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd10_nbytes_mloffno_t *) HW_DMA_TCD10_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD10_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD10_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD10_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD10_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD10_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD10_NBYTES_MLOFFNO_WR(HW_DMA_TCD10_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD10_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD10_NBYTES_MLOFFNO_WR(HW_DMA_TCD10_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD10_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD10_NBYTES_MLOFFNO_WR(HW_DMA_TCD10_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD10_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD10_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD10_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD10_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD10_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD10_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD10_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD10_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD10_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD10_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD10_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD10_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD10_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD10_NBYTES_MLOFFNO_WR((HW_DMA_TCD10_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD10_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD10_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD10_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD10_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD10_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD10_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD10_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD10_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD10_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD10_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD10_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD10_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD10_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD10_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD10_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD10_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD10_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD10_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD10_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD10_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD10_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD10_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD10_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD10_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD10_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD10_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD10_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD10_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD10_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD10_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD10_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD10_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD10_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd10_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd10_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd10_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD10_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1148U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd10_nbytes_mloffyes_t *) HW_DMA_TCD10_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD10_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD10_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD10_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD10_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD10_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD10_NBYTES_MLOFFYES_WR(HW_DMA_TCD10_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD10_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD10_NBYTES_MLOFFYES_WR(HW_DMA_TCD10_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD10_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD10_NBYTES_MLOFFYES_WR(HW_DMA_TCD10_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD10_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD10_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD10_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD10_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD10_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD10_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD10_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD10_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD10_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD10_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD10_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD10_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD10_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD10_NBYTES_MLOFFYES_WR((HW_DMA_TCD10_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD10_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD10_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD10_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD10_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD10_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD10_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD10_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD10_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD10_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD10_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD10_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD10_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD10_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD10_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD10_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD10_NBYTES_MLOFFYES_WR((HW_DMA_TCD10_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD10_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD10_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD10_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD10_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD10_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD10_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD10_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD10_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD10_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD10_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD10_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD10_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD10_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD10_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD10_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD10_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD10_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD10_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD10_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD10_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD10_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD10_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD10_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD10_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD10_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD10_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD10_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD10_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD10_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD10_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD10_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD10_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD10_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd10_slast
{
    uint32_t U;
    struct _hw_dma_tcd10_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd10_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_SLAST register
 */
//@{
#define HW_DMA_TCD10_SLAST_ADDR      (REGS_DMA_BASE + 0x114cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_SLAST           (*(__IO hw_dma_tcd10_slast_t *) HW_DMA_TCD10_SLAST_ADDR)
#define HW_DMA_TCD10_SLAST_RD()      (HW_DMA_TCD10_SLAST.U)
#define HW_DMA_TCD10_SLAST_WR(v)     (HW_DMA_TCD10_SLAST.U = (v))
#define HW_DMA_TCD10_SLAST_SET(v)    (HW_DMA_TCD10_SLAST_WR(HW_DMA_TCD10_SLAST_RD() |  (v)))
#define HW_DMA_TCD10_SLAST_CLR(v)    (HW_DMA_TCD10_SLAST_WR(HW_DMA_TCD10_SLAST_RD() & ~(v)))
#define HW_DMA_TCD10_SLAST_TOG(v)    (HW_DMA_TCD10_SLAST_WR(HW_DMA_TCD10_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_SLAST bitfields
 */

/*! @name Register DMA_TCD10_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD10_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD10_SLAST_SLAST.
#define BM_DMA_TCD10_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD10_SLAST_SLAST.
#define BS_DMA_TCD10_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD10_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_SLAST_SLAST field.
#define BR_DMA_TCD10_SLAST_SLAST()   (HW_DMA_TCD10_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD10_SLAST_SLAST.
#define BF_DMA_TCD10_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_SLAST_SLAST), uint32_t) & BM_DMA_TCD10_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD10_SLAST_SLAST(v)   (HW_DMA_TCD10_SLAST_WR((HW_DMA_TCD10_SLAST_RD() & ~BM_DMA_TCD10_SLAST_SLAST) | BF_DMA_TCD10_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd10_daddr
{
    uint32_t U;
    struct _hw_dma_tcd10_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd10_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_DADDR register
 */
//@{
#define HW_DMA_TCD10_DADDR_ADDR      (REGS_DMA_BASE + 0x1150U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_DADDR           (*(__IO hw_dma_tcd10_daddr_t *) HW_DMA_TCD10_DADDR_ADDR)
#define HW_DMA_TCD10_DADDR_RD()      (HW_DMA_TCD10_DADDR.U)
#define HW_DMA_TCD10_DADDR_WR(v)     (HW_DMA_TCD10_DADDR.U = (v))
#define HW_DMA_TCD10_DADDR_SET(v)    (HW_DMA_TCD10_DADDR_WR(HW_DMA_TCD10_DADDR_RD() |  (v)))
#define HW_DMA_TCD10_DADDR_CLR(v)    (HW_DMA_TCD10_DADDR_WR(HW_DMA_TCD10_DADDR_RD() & ~(v)))
#define HW_DMA_TCD10_DADDR_TOG(v)    (HW_DMA_TCD10_DADDR_WR(HW_DMA_TCD10_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_DADDR bitfields
 */

/*! @name Register DMA_TCD10_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD10_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD10_DADDR_DADDR.
#define BM_DMA_TCD10_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD10_DADDR_DADDR.
#define BS_DMA_TCD10_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD10_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_DADDR_DADDR field.
#define BR_DMA_TCD10_DADDR_DADDR()   (HW_DMA_TCD10_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD10_DADDR_DADDR.
#define BF_DMA_TCD10_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_DADDR_DADDR), uint32_t) & BM_DMA_TCD10_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD10_DADDR_DADDR(v)   (HW_DMA_TCD10_DADDR_WR((HW_DMA_TCD10_DADDR_RD() & ~BM_DMA_TCD10_DADDR_DADDR) | BF_DMA_TCD10_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd10_doff
{
    uint16_t U;
    struct _hw_dma_tcd10_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd10_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_DOFF register
 */
//@{
#define HW_DMA_TCD10_DOFF_ADDR      (REGS_DMA_BASE + 0x1154U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_DOFF           (*(__IO hw_dma_tcd10_doff_t *) HW_DMA_TCD10_DOFF_ADDR)
#define HW_DMA_TCD10_DOFF_RD()      (HW_DMA_TCD10_DOFF.U)
#define HW_DMA_TCD10_DOFF_WR(v)     (HW_DMA_TCD10_DOFF.U = (v))
#define HW_DMA_TCD10_DOFF_SET(v)    (HW_DMA_TCD10_DOFF_WR(HW_DMA_TCD10_DOFF_RD() |  (v)))
#define HW_DMA_TCD10_DOFF_CLR(v)    (HW_DMA_TCD10_DOFF_WR(HW_DMA_TCD10_DOFF_RD() & ~(v)))
#define HW_DMA_TCD10_DOFF_TOG(v)    (HW_DMA_TCD10_DOFF_WR(HW_DMA_TCD10_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_DOFF bitfields
 */

/*! @name Register DMA_TCD10_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD10_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD10_DOFF_DOFF.
#define BM_DMA_TCD10_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD10_DOFF_DOFF.
#define BS_DMA_TCD10_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD10_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_DOFF_DOFF field.
#define BR_DMA_TCD10_DOFF_DOFF()   (HW_DMA_TCD10_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD10_DOFF_DOFF.
#define BF_DMA_TCD10_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_DOFF_DOFF), uint16_t) & BM_DMA_TCD10_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD10_DOFF_DOFF(v)   (HW_DMA_TCD10_DOFF_WR((HW_DMA_TCD10_DOFF_RD() & ~BM_DMA_TCD10_DOFF_DOFF) | BF_DMA_TCD10_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd10_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd10_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd10_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD10_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1156U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_CITER_ELINKYES           (*(__IO hw_dma_tcd10_citer_elinkyes_t *) HW_DMA_TCD10_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD10_CITER_ELINKYES_RD()      (HW_DMA_TCD10_CITER_ELINKYES.U)
#define HW_DMA_TCD10_CITER_ELINKYES_WR(v)     (HW_DMA_TCD10_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD10_CITER_ELINKYES_SET(v)    (HW_DMA_TCD10_CITER_ELINKYES_WR(HW_DMA_TCD10_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD10_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD10_CITER_ELINKYES_WR(HW_DMA_TCD10_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD10_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD10_CITER_ELINKYES_WR(HW_DMA_TCD10_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD10_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD10_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD10_CITER_ELINKYES_CITER.
#define BM_DMA_TCD10_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD10_CITER_ELINKYES_CITER.
#define BS_DMA_TCD10_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD10_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD10_CITER_ELINKYES_CITER()   (HW_DMA_TCD10_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD10_CITER_ELINKYES_CITER.
#define BF_DMA_TCD10_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD10_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD10_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD10_CITER_ELINKYES_WR((HW_DMA_TCD10_CITER_ELINKYES_RD() & ~BM_DMA_TCD10_CITER_ELINKYES_CITER) | BF_DMA_TCD10_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD10_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD10_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD10_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD10_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD10_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD10_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD10_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD10_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD10_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD10_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD10_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD10_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD10_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD10_CITER_ELINKYES_WR((HW_DMA_TCD10_CITER_ELINKYES_RD() & ~BM_DMA_TCD10_CITER_ELINKYES_LINKCH) | BF_DMA_TCD10_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD10_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD10_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD10_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD10_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD10_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD10_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD10_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD10_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD10_CITER_ELINKYES_ADDR, BP_DMA_TCD10_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD10_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD10_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD10_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD10_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CITER_ELINKYES_ADDR, BP_DMA_TCD10_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd10_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd10_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd10_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD10_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1156U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_CITER_ELINKNO           (*(__IO hw_dma_tcd10_citer_elinkno_t *) HW_DMA_TCD10_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD10_CITER_ELINKNO_RD()      (HW_DMA_TCD10_CITER_ELINKNO.U)
#define HW_DMA_TCD10_CITER_ELINKNO_WR(v)     (HW_DMA_TCD10_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD10_CITER_ELINKNO_SET(v)    (HW_DMA_TCD10_CITER_ELINKNO_WR(HW_DMA_TCD10_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD10_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD10_CITER_ELINKNO_WR(HW_DMA_TCD10_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD10_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD10_CITER_ELINKNO_WR(HW_DMA_TCD10_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD10_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD10_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD10_CITER_ELINKNO_CITER.
#define BM_DMA_TCD10_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD10_CITER_ELINKNO_CITER.
#define BS_DMA_TCD10_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD10_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD10_CITER_ELINKNO_CITER()   (HW_DMA_TCD10_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD10_CITER_ELINKNO_CITER.
#define BF_DMA_TCD10_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD10_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD10_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD10_CITER_ELINKNO_WR((HW_DMA_TCD10_CITER_ELINKNO_RD() & ~BM_DMA_TCD10_CITER_ELINKNO_CITER) | BF_DMA_TCD10_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD10_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD10_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD10_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD10_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD10_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD10_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD10_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD10_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD10_CITER_ELINKNO_ADDR, BP_DMA_TCD10_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD10_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD10_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD10_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD10_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CITER_ELINKNO_ADDR, BP_DMA_TCD10_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd10_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd10_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd10_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_DLASTSGA register
 */
//@{
#define HW_DMA_TCD10_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1158U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_DLASTSGA           (*(__IO hw_dma_tcd10_dlastsga_t *) HW_DMA_TCD10_DLASTSGA_ADDR)
#define HW_DMA_TCD10_DLASTSGA_RD()      (HW_DMA_TCD10_DLASTSGA.U)
#define HW_DMA_TCD10_DLASTSGA_WR(v)     (HW_DMA_TCD10_DLASTSGA.U = (v))
#define HW_DMA_TCD10_DLASTSGA_SET(v)    (HW_DMA_TCD10_DLASTSGA_WR(HW_DMA_TCD10_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD10_DLASTSGA_CLR(v)    (HW_DMA_TCD10_DLASTSGA_WR(HW_DMA_TCD10_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD10_DLASTSGA_TOG(v)    (HW_DMA_TCD10_DLASTSGA_WR(HW_DMA_TCD10_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD10_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD10_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD10_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD10_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD10_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD10_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD10_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD10_DLASTSGA_DLASTSGA()   (HW_DMA_TCD10_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD10_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD10_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD10_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD10_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD10_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD10_DLASTSGA_WR((HW_DMA_TCD10_DLASTSGA_RD() & ~BM_DMA_TCD10_DLASTSGA_DLASTSGA) | BF_DMA_TCD10_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd10_csr
{
    uint16_t U;
    struct _hw_dma_tcd10_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd10_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_CSR register
 */
//@{
#define HW_DMA_TCD10_CSR_ADDR      (REGS_DMA_BASE + 0x115cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_CSR           (*(__IO hw_dma_tcd10_csr_t *) HW_DMA_TCD10_CSR_ADDR)
#define HW_DMA_TCD10_CSR_RD()      (HW_DMA_TCD10_CSR.U)
#define HW_DMA_TCD10_CSR_WR(v)     (HW_DMA_TCD10_CSR.U = (v))
#define HW_DMA_TCD10_CSR_SET(v)    (HW_DMA_TCD10_CSR_WR(HW_DMA_TCD10_CSR_RD() |  (v)))
#define HW_DMA_TCD10_CSR_CLR(v)    (HW_DMA_TCD10_CSR_WR(HW_DMA_TCD10_CSR_RD() & ~(v)))
#define HW_DMA_TCD10_CSR_TOG(v)    (HW_DMA_TCD10_CSR_WR(HW_DMA_TCD10_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_CSR bitfields
 */

/*! @name Register DMA_TCD10_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD10_CSR_START      (0U)      //!< Bit position for DMA_TCD10_CSR_START.
#define BM_DMA_TCD10_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD10_CSR_START.
#define BS_DMA_TCD10_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD10_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_START field.
#define BR_DMA_TCD10_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_START.
#define BF_DMA_TCD10_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_START), uint16_t) & BM_DMA_TCD10_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD10_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD10_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD10_CSR_INTMAJOR.
#define BM_DMA_TCD10_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD10_CSR_INTMAJOR.
#define BS_DMA_TCD10_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD10_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_INTMAJOR field.
#define BR_DMA_TCD10_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_INTMAJOR.
#define BF_DMA_TCD10_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD10_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD10_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD10_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD10_CSR_INTHALF.
#define BM_DMA_TCD10_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD10_CSR_INTHALF.
#define BS_DMA_TCD10_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD10_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_INTHALF field.
#define BR_DMA_TCD10_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_INTHALF.
#define BF_DMA_TCD10_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_INTHALF), uint16_t) & BM_DMA_TCD10_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD10_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD10_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD10_CSR_DREQ.
#define BM_DMA_TCD10_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD10_CSR_DREQ.
#define BS_DMA_TCD10_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD10_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_DREQ field.
#define BR_DMA_TCD10_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_DREQ.
#define BF_DMA_TCD10_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_DREQ), uint16_t) & BM_DMA_TCD10_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD10_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD10_CSR_ESG      (4U)      //!< Bit position for DMA_TCD10_CSR_ESG.
#define BM_DMA_TCD10_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD10_CSR_ESG.
#define BS_DMA_TCD10_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD10_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_ESG field.
#define BR_DMA_TCD10_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_ESG.
#define BF_DMA_TCD10_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_ESG), uint16_t) & BM_DMA_TCD10_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD10_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD10_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD10_CSR_MAJORELINK.
#define BM_DMA_TCD10_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD10_CSR_MAJORELINK.
#define BS_DMA_TCD10_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD10_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_MAJORELINK field.
#define BR_DMA_TCD10_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_MAJORELINK.
#define BF_DMA_TCD10_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD10_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD10_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD10_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD10_CSR_ACTIVE.
#define BM_DMA_TCD10_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD10_CSR_ACTIVE.
#define BS_DMA_TCD10_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD10_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_ACTIVE field.
#define BR_DMA_TCD10_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_ACTIVE.
#define BF_DMA_TCD10_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_ACTIVE), uint16_t) & BM_DMA_TCD10_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD10_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD10_CSR_DONE      (7U)      //!< Bit position for DMA_TCD10_CSR_DONE.
#define BM_DMA_TCD10_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD10_CSR_DONE.
#define BS_DMA_TCD10_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD10_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_DONE field.
#define BR_DMA_TCD10_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_DONE.
#define BF_DMA_TCD10_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_DONE), uint16_t) & BM_DMA_TCD10_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD10_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_CSR_ADDR, BP_DMA_TCD10_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD10_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD10_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD10_CSR_MAJORLINKCH.
#define BM_DMA_TCD10_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD10_CSR_MAJORLINKCH.
#define BS_DMA_TCD10_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD10_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_MAJORLINKCH field.
#define BR_DMA_TCD10_CSR_MAJORLINKCH()   (HW_DMA_TCD10_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_MAJORLINKCH.
#define BF_DMA_TCD10_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD10_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD10_CSR_MAJORLINKCH(v)   (HW_DMA_TCD10_CSR_WR((HW_DMA_TCD10_CSR_RD() & ~BM_DMA_TCD10_CSR_MAJORLINKCH) | BF_DMA_TCD10_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD10_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD10_CSR_BWC      (14U)      //!< Bit position for DMA_TCD10_CSR_BWC.
#define BM_DMA_TCD10_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD10_CSR_BWC.
#define BS_DMA_TCD10_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD10_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_CSR_BWC field.
#define BR_DMA_TCD10_CSR_BWC()   (HW_DMA_TCD10_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD10_CSR_BWC.
#define BF_DMA_TCD10_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_CSR_BWC), uint16_t) & BM_DMA_TCD10_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD10_CSR_BWC(v)   (HW_DMA_TCD10_CSR_WR((HW_DMA_TCD10_CSR_RD() & ~BM_DMA_TCD10_CSR_BWC) | BF_DMA_TCD10_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd10_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd10_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd10_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD10_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x115eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_BITER_ELINKYES           (*(__IO hw_dma_tcd10_biter_elinkyes_t *) HW_DMA_TCD10_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD10_BITER_ELINKYES_RD()      (HW_DMA_TCD10_BITER_ELINKYES.U)
#define HW_DMA_TCD10_BITER_ELINKYES_WR(v)     (HW_DMA_TCD10_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD10_BITER_ELINKYES_SET(v)    (HW_DMA_TCD10_BITER_ELINKYES_WR(HW_DMA_TCD10_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD10_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD10_BITER_ELINKYES_WR(HW_DMA_TCD10_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD10_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD10_BITER_ELINKYES_WR(HW_DMA_TCD10_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD10_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD10_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD10_BITER_ELINKYES_BITER.
#define BM_DMA_TCD10_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD10_BITER_ELINKYES_BITER.
#define BS_DMA_TCD10_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD10_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD10_BITER_ELINKYES_BITER()   (HW_DMA_TCD10_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD10_BITER_ELINKYES_BITER.
#define BF_DMA_TCD10_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD10_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD10_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD10_BITER_ELINKYES_WR((HW_DMA_TCD10_BITER_ELINKYES_RD() & ~BM_DMA_TCD10_BITER_ELINKYES_BITER) | BF_DMA_TCD10_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD10_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD10_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD10_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD10_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD10_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD10_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD10_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD10_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD10_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD10_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD10_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD10_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD10_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD10_BITER_ELINKYES_WR((HW_DMA_TCD10_BITER_ELINKYES_RD() & ~BM_DMA_TCD10_BITER_ELINKYES_LINKCH) | BF_DMA_TCD10_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD10_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD10_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD10_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD10_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD10_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD10_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD10_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD10_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD10_BITER_ELINKYES_ADDR, BP_DMA_TCD10_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD10_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD10_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD10_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD10_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_BITER_ELINKYES_ADDR, BP_DMA_TCD10_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD10_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD10_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd10_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd10_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd10_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD10_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD10_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x115eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD10_BITER_ELINKNO           (*(__IO hw_dma_tcd10_biter_elinkno_t *) HW_DMA_TCD10_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD10_BITER_ELINKNO_RD()      (HW_DMA_TCD10_BITER_ELINKNO.U)
#define HW_DMA_TCD10_BITER_ELINKNO_WR(v)     (HW_DMA_TCD10_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD10_BITER_ELINKNO_SET(v)    (HW_DMA_TCD10_BITER_ELINKNO_WR(HW_DMA_TCD10_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD10_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD10_BITER_ELINKNO_WR(HW_DMA_TCD10_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD10_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD10_BITER_ELINKNO_WR(HW_DMA_TCD10_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD10_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD10_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD10_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD10_BITER_ELINKNO_BITER.
#define BM_DMA_TCD10_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD10_BITER_ELINKNO_BITER.
#define BS_DMA_TCD10_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD10_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD10_BITER_ELINKNO_BITER()   (HW_DMA_TCD10_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD10_BITER_ELINKNO_BITER.
#define BF_DMA_TCD10_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD10_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD10_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD10_BITER_ELINKNO_WR((HW_DMA_TCD10_BITER_ELINKNO_RD() & ~BM_DMA_TCD10_BITER_ELINKNO_BITER) | BF_DMA_TCD10_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD10_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD10_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD10_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD10_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD10_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD10_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD10_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD10_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD10_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD10_BITER_ELINKNO_ADDR, BP_DMA_TCD10_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD10_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD10_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD10_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD10_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD10_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD10_BITER_ELINKNO_ADDR, BP_DMA_TCD10_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd11_saddr
{
    uint32_t U;
    struct _hw_dma_tcd11_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd11_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_SADDR register
 */
//@{
#define HW_DMA_TCD11_SADDR_ADDR      (REGS_DMA_BASE + 0x1160U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_SADDR           (*(__IO hw_dma_tcd11_saddr_t *) HW_DMA_TCD11_SADDR_ADDR)
#define HW_DMA_TCD11_SADDR_RD()      (HW_DMA_TCD11_SADDR.U)
#define HW_DMA_TCD11_SADDR_WR(v)     (HW_DMA_TCD11_SADDR.U = (v))
#define HW_DMA_TCD11_SADDR_SET(v)    (HW_DMA_TCD11_SADDR_WR(HW_DMA_TCD11_SADDR_RD() |  (v)))
#define HW_DMA_TCD11_SADDR_CLR(v)    (HW_DMA_TCD11_SADDR_WR(HW_DMA_TCD11_SADDR_RD() & ~(v)))
#define HW_DMA_TCD11_SADDR_TOG(v)    (HW_DMA_TCD11_SADDR_WR(HW_DMA_TCD11_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_SADDR bitfields
 */

/*! @name Register DMA_TCD11_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD11_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD11_SADDR_SADDR.
#define BM_DMA_TCD11_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD11_SADDR_SADDR.
#define BS_DMA_TCD11_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD11_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_SADDR_SADDR field.
#define BR_DMA_TCD11_SADDR_SADDR()   (HW_DMA_TCD11_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD11_SADDR_SADDR.
#define BF_DMA_TCD11_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_SADDR_SADDR), uint32_t) & BM_DMA_TCD11_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD11_SADDR_SADDR(v)   (HW_DMA_TCD11_SADDR_WR((HW_DMA_TCD11_SADDR_RD() & ~BM_DMA_TCD11_SADDR_SADDR) | BF_DMA_TCD11_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd11_soff
{
    uint16_t U;
    struct _hw_dma_tcd11_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd11_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_SOFF register
 */
//@{
#define HW_DMA_TCD11_SOFF_ADDR      (REGS_DMA_BASE + 0x1164U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_SOFF           (*(__IO hw_dma_tcd11_soff_t *) HW_DMA_TCD11_SOFF_ADDR)
#define HW_DMA_TCD11_SOFF_RD()      (HW_DMA_TCD11_SOFF.U)
#define HW_DMA_TCD11_SOFF_WR(v)     (HW_DMA_TCD11_SOFF.U = (v))
#define HW_DMA_TCD11_SOFF_SET(v)    (HW_DMA_TCD11_SOFF_WR(HW_DMA_TCD11_SOFF_RD() |  (v)))
#define HW_DMA_TCD11_SOFF_CLR(v)    (HW_DMA_TCD11_SOFF_WR(HW_DMA_TCD11_SOFF_RD() & ~(v)))
#define HW_DMA_TCD11_SOFF_TOG(v)    (HW_DMA_TCD11_SOFF_WR(HW_DMA_TCD11_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_SOFF bitfields
 */

/*! @name Register DMA_TCD11_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD11_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD11_SOFF_SOFF.
#define BM_DMA_TCD11_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD11_SOFF_SOFF.
#define BS_DMA_TCD11_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD11_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_SOFF_SOFF field.
#define BR_DMA_TCD11_SOFF_SOFF()   (HW_DMA_TCD11_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD11_SOFF_SOFF.
#define BF_DMA_TCD11_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_SOFF_SOFF), uint16_t) & BM_DMA_TCD11_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD11_SOFF_SOFF(v)   (HW_DMA_TCD11_SOFF_WR((HW_DMA_TCD11_SOFF_RD() & ~BM_DMA_TCD11_SOFF_SOFF) | BF_DMA_TCD11_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd11_attr
{
    uint16_t U;
    struct _hw_dma_tcd11_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd11_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_ATTR register
 */
//@{
#define HW_DMA_TCD11_ATTR_ADDR      (REGS_DMA_BASE + 0x1166U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_ATTR           (*(__IO hw_dma_tcd11_attr_t *) HW_DMA_TCD11_ATTR_ADDR)
#define HW_DMA_TCD11_ATTR_RD()      (HW_DMA_TCD11_ATTR.U)
#define HW_DMA_TCD11_ATTR_WR(v)     (HW_DMA_TCD11_ATTR.U = (v))
#define HW_DMA_TCD11_ATTR_SET(v)    (HW_DMA_TCD11_ATTR_WR(HW_DMA_TCD11_ATTR_RD() |  (v)))
#define HW_DMA_TCD11_ATTR_CLR(v)    (HW_DMA_TCD11_ATTR_WR(HW_DMA_TCD11_ATTR_RD() & ~(v)))
#define HW_DMA_TCD11_ATTR_TOG(v)    (HW_DMA_TCD11_ATTR_WR(HW_DMA_TCD11_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_ATTR bitfields
 */

/*! @name Register DMA_TCD11_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD11_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD11_ATTR_DSIZE.
#define BM_DMA_TCD11_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD11_ATTR_DSIZE.
#define BS_DMA_TCD11_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD11_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_ATTR_DSIZE field.
#define BR_DMA_TCD11_ATTR_DSIZE()   (HW_DMA_TCD11_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD11_ATTR_DSIZE.
#define BF_DMA_TCD11_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_ATTR_DSIZE), uint16_t) & BM_DMA_TCD11_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD11_ATTR_DSIZE(v)   (HW_DMA_TCD11_ATTR_WR((HW_DMA_TCD11_ATTR_RD() & ~BM_DMA_TCD11_ATTR_DSIZE) | BF_DMA_TCD11_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD11_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD11_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD11_ATTR_DMOD.
#define BM_DMA_TCD11_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD11_ATTR_DMOD.
#define BS_DMA_TCD11_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD11_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_ATTR_DMOD field.
#define BR_DMA_TCD11_ATTR_DMOD()   (HW_DMA_TCD11_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD11_ATTR_DMOD.
#define BF_DMA_TCD11_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_ATTR_DMOD), uint16_t) & BM_DMA_TCD11_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD11_ATTR_DMOD(v)   (HW_DMA_TCD11_ATTR_WR((HW_DMA_TCD11_ATTR_RD() & ~BM_DMA_TCD11_ATTR_DMOD) | BF_DMA_TCD11_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD11_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD11_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD11_ATTR_SSIZE.
#define BM_DMA_TCD11_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD11_ATTR_SSIZE.
#define BS_DMA_TCD11_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD11_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_ATTR_SSIZE field.
#define BR_DMA_TCD11_ATTR_SSIZE()   (HW_DMA_TCD11_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD11_ATTR_SSIZE.
#define BF_DMA_TCD11_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_ATTR_SSIZE), uint16_t) & BM_DMA_TCD11_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD11_ATTR_SSIZE(v)   (HW_DMA_TCD11_ATTR_WR((HW_DMA_TCD11_ATTR_RD() & ~BM_DMA_TCD11_ATTR_SSIZE) | BF_DMA_TCD11_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD11_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD11_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD11_ATTR_SMOD.
#define BM_DMA_TCD11_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD11_ATTR_SMOD.
#define BS_DMA_TCD11_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD11_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_ATTR_SMOD field.
#define BR_DMA_TCD11_ATTR_SMOD()   (HW_DMA_TCD11_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD11_ATTR_SMOD.
#define BF_DMA_TCD11_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_ATTR_SMOD), uint16_t) & BM_DMA_TCD11_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD11_ATTR_SMOD(v)   (HW_DMA_TCD11_ATTR_WR((HW_DMA_TCD11_ATTR_RD() & ~BM_DMA_TCD11_ATTR_SMOD) | BF_DMA_TCD11_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd11_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd11_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd11_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD11_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1168U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_NBYTES_MLNO           (*(__IO hw_dma_tcd11_nbytes_mlno_t *) HW_DMA_TCD11_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD11_NBYTES_MLNO_RD()      (HW_DMA_TCD11_NBYTES_MLNO.U)
#define HW_DMA_TCD11_NBYTES_MLNO_WR(v)     (HW_DMA_TCD11_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD11_NBYTES_MLNO_SET(v)    (HW_DMA_TCD11_NBYTES_MLNO_WR(HW_DMA_TCD11_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD11_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD11_NBYTES_MLNO_WR(HW_DMA_TCD11_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD11_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD11_NBYTES_MLNO_WR(HW_DMA_TCD11_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD11_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD11_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD11_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD11_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD11_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD11_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD11_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD11_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD11_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD11_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD11_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD11_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD11_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD11_NBYTES_MLNO_WR((HW_DMA_TCD11_NBYTES_MLNO_RD() & ~BM_DMA_TCD11_NBYTES_MLNO_NBYTES) | BF_DMA_TCD11_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd11_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd11_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd11_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD11_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1168U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd11_nbytes_mloffno_t *) HW_DMA_TCD11_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD11_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD11_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD11_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD11_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD11_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD11_NBYTES_MLOFFNO_WR(HW_DMA_TCD11_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD11_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD11_NBYTES_MLOFFNO_WR(HW_DMA_TCD11_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD11_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD11_NBYTES_MLOFFNO_WR(HW_DMA_TCD11_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD11_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD11_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD11_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD11_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD11_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD11_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD11_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD11_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD11_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD11_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD11_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD11_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD11_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD11_NBYTES_MLOFFNO_WR((HW_DMA_TCD11_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD11_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD11_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD11_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD11_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD11_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD11_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD11_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD11_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD11_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD11_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD11_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD11_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD11_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD11_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD11_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD11_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD11_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD11_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD11_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD11_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD11_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD11_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD11_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD11_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD11_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD11_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD11_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD11_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD11_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD11_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD11_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD11_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD11_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd11_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd11_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd11_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD11_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1168U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd11_nbytes_mloffyes_t *) HW_DMA_TCD11_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD11_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD11_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD11_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD11_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD11_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD11_NBYTES_MLOFFYES_WR(HW_DMA_TCD11_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD11_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD11_NBYTES_MLOFFYES_WR(HW_DMA_TCD11_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD11_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD11_NBYTES_MLOFFYES_WR(HW_DMA_TCD11_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD11_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD11_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD11_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD11_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD11_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD11_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD11_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD11_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD11_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD11_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD11_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD11_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD11_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD11_NBYTES_MLOFFYES_WR((HW_DMA_TCD11_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD11_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD11_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD11_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD11_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD11_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD11_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD11_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD11_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD11_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD11_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD11_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD11_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD11_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD11_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD11_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD11_NBYTES_MLOFFYES_WR((HW_DMA_TCD11_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD11_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD11_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD11_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD11_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD11_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD11_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD11_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD11_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD11_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD11_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD11_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD11_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD11_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD11_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD11_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD11_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD11_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD11_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD11_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD11_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD11_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD11_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD11_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD11_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD11_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD11_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD11_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD11_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD11_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD11_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD11_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD11_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD11_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd11_slast
{
    uint32_t U;
    struct _hw_dma_tcd11_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd11_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_SLAST register
 */
//@{
#define HW_DMA_TCD11_SLAST_ADDR      (REGS_DMA_BASE + 0x116cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_SLAST           (*(__IO hw_dma_tcd11_slast_t *) HW_DMA_TCD11_SLAST_ADDR)
#define HW_DMA_TCD11_SLAST_RD()      (HW_DMA_TCD11_SLAST.U)
#define HW_DMA_TCD11_SLAST_WR(v)     (HW_DMA_TCD11_SLAST.U = (v))
#define HW_DMA_TCD11_SLAST_SET(v)    (HW_DMA_TCD11_SLAST_WR(HW_DMA_TCD11_SLAST_RD() |  (v)))
#define HW_DMA_TCD11_SLAST_CLR(v)    (HW_DMA_TCD11_SLAST_WR(HW_DMA_TCD11_SLAST_RD() & ~(v)))
#define HW_DMA_TCD11_SLAST_TOG(v)    (HW_DMA_TCD11_SLAST_WR(HW_DMA_TCD11_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_SLAST bitfields
 */

/*! @name Register DMA_TCD11_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD11_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD11_SLAST_SLAST.
#define BM_DMA_TCD11_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD11_SLAST_SLAST.
#define BS_DMA_TCD11_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD11_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_SLAST_SLAST field.
#define BR_DMA_TCD11_SLAST_SLAST()   (HW_DMA_TCD11_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD11_SLAST_SLAST.
#define BF_DMA_TCD11_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_SLAST_SLAST), uint32_t) & BM_DMA_TCD11_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD11_SLAST_SLAST(v)   (HW_DMA_TCD11_SLAST_WR((HW_DMA_TCD11_SLAST_RD() & ~BM_DMA_TCD11_SLAST_SLAST) | BF_DMA_TCD11_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd11_daddr
{
    uint32_t U;
    struct _hw_dma_tcd11_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd11_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_DADDR register
 */
//@{
#define HW_DMA_TCD11_DADDR_ADDR      (REGS_DMA_BASE + 0x1170U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_DADDR           (*(__IO hw_dma_tcd11_daddr_t *) HW_DMA_TCD11_DADDR_ADDR)
#define HW_DMA_TCD11_DADDR_RD()      (HW_DMA_TCD11_DADDR.U)
#define HW_DMA_TCD11_DADDR_WR(v)     (HW_DMA_TCD11_DADDR.U = (v))
#define HW_DMA_TCD11_DADDR_SET(v)    (HW_DMA_TCD11_DADDR_WR(HW_DMA_TCD11_DADDR_RD() |  (v)))
#define HW_DMA_TCD11_DADDR_CLR(v)    (HW_DMA_TCD11_DADDR_WR(HW_DMA_TCD11_DADDR_RD() & ~(v)))
#define HW_DMA_TCD11_DADDR_TOG(v)    (HW_DMA_TCD11_DADDR_WR(HW_DMA_TCD11_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_DADDR bitfields
 */

/*! @name Register DMA_TCD11_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD11_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD11_DADDR_DADDR.
#define BM_DMA_TCD11_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD11_DADDR_DADDR.
#define BS_DMA_TCD11_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD11_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_DADDR_DADDR field.
#define BR_DMA_TCD11_DADDR_DADDR()   (HW_DMA_TCD11_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD11_DADDR_DADDR.
#define BF_DMA_TCD11_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_DADDR_DADDR), uint32_t) & BM_DMA_TCD11_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD11_DADDR_DADDR(v)   (HW_DMA_TCD11_DADDR_WR((HW_DMA_TCD11_DADDR_RD() & ~BM_DMA_TCD11_DADDR_DADDR) | BF_DMA_TCD11_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd11_doff
{
    uint16_t U;
    struct _hw_dma_tcd11_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd11_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_DOFF register
 */
//@{
#define HW_DMA_TCD11_DOFF_ADDR      (REGS_DMA_BASE + 0x1174U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_DOFF           (*(__IO hw_dma_tcd11_doff_t *) HW_DMA_TCD11_DOFF_ADDR)
#define HW_DMA_TCD11_DOFF_RD()      (HW_DMA_TCD11_DOFF.U)
#define HW_DMA_TCD11_DOFF_WR(v)     (HW_DMA_TCD11_DOFF.U = (v))
#define HW_DMA_TCD11_DOFF_SET(v)    (HW_DMA_TCD11_DOFF_WR(HW_DMA_TCD11_DOFF_RD() |  (v)))
#define HW_DMA_TCD11_DOFF_CLR(v)    (HW_DMA_TCD11_DOFF_WR(HW_DMA_TCD11_DOFF_RD() & ~(v)))
#define HW_DMA_TCD11_DOFF_TOG(v)    (HW_DMA_TCD11_DOFF_WR(HW_DMA_TCD11_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_DOFF bitfields
 */

/*! @name Register DMA_TCD11_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD11_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD11_DOFF_DOFF.
#define BM_DMA_TCD11_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD11_DOFF_DOFF.
#define BS_DMA_TCD11_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD11_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_DOFF_DOFF field.
#define BR_DMA_TCD11_DOFF_DOFF()   (HW_DMA_TCD11_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD11_DOFF_DOFF.
#define BF_DMA_TCD11_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_DOFF_DOFF), uint16_t) & BM_DMA_TCD11_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD11_DOFF_DOFF(v)   (HW_DMA_TCD11_DOFF_WR((HW_DMA_TCD11_DOFF_RD() & ~BM_DMA_TCD11_DOFF_DOFF) | BF_DMA_TCD11_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd11_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd11_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd11_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD11_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1176U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_CITER_ELINKYES           (*(__IO hw_dma_tcd11_citer_elinkyes_t *) HW_DMA_TCD11_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD11_CITER_ELINKYES_RD()      (HW_DMA_TCD11_CITER_ELINKYES.U)
#define HW_DMA_TCD11_CITER_ELINKYES_WR(v)     (HW_DMA_TCD11_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD11_CITER_ELINKYES_SET(v)    (HW_DMA_TCD11_CITER_ELINKYES_WR(HW_DMA_TCD11_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD11_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD11_CITER_ELINKYES_WR(HW_DMA_TCD11_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD11_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD11_CITER_ELINKYES_WR(HW_DMA_TCD11_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD11_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD11_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD11_CITER_ELINKYES_CITER.
#define BM_DMA_TCD11_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD11_CITER_ELINKYES_CITER.
#define BS_DMA_TCD11_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD11_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD11_CITER_ELINKYES_CITER()   (HW_DMA_TCD11_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD11_CITER_ELINKYES_CITER.
#define BF_DMA_TCD11_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD11_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD11_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD11_CITER_ELINKYES_WR((HW_DMA_TCD11_CITER_ELINKYES_RD() & ~BM_DMA_TCD11_CITER_ELINKYES_CITER) | BF_DMA_TCD11_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD11_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD11_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD11_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD11_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD11_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD11_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD11_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD11_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD11_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD11_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD11_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD11_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD11_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD11_CITER_ELINKYES_WR((HW_DMA_TCD11_CITER_ELINKYES_RD() & ~BM_DMA_TCD11_CITER_ELINKYES_LINKCH) | BF_DMA_TCD11_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD11_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD11_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD11_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD11_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD11_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD11_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD11_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD11_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD11_CITER_ELINKYES_ADDR, BP_DMA_TCD11_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD11_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD11_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD11_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD11_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CITER_ELINKYES_ADDR, BP_DMA_TCD11_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd11_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd11_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd11_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD11_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1176U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_CITER_ELINKNO           (*(__IO hw_dma_tcd11_citer_elinkno_t *) HW_DMA_TCD11_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD11_CITER_ELINKNO_RD()      (HW_DMA_TCD11_CITER_ELINKNO.U)
#define HW_DMA_TCD11_CITER_ELINKNO_WR(v)     (HW_DMA_TCD11_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD11_CITER_ELINKNO_SET(v)    (HW_DMA_TCD11_CITER_ELINKNO_WR(HW_DMA_TCD11_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD11_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD11_CITER_ELINKNO_WR(HW_DMA_TCD11_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD11_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD11_CITER_ELINKNO_WR(HW_DMA_TCD11_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD11_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD11_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD11_CITER_ELINKNO_CITER.
#define BM_DMA_TCD11_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD11_CITER_ELINKNO_CITER.
#define BS_DMA_TCD11_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD11_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD11_CITER_ELINKNO_CITER()   (HW_DMA_TCD11_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD11_CITER_ELINKNO_CITER.
#define BF_DMA_TCD11_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD11_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD11_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD11_CITER_ELINKNO_WR((HW_DMA_TCD11_CITER_ELINKNO_RD() & ~BM_DMA_TCD11_CITER_ELINKNO_CITER) | BF_DMA_TCD11_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD11_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD11_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD11_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD11_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD11_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD11_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD11_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD11_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD11_CITER_ELINKNO_ADDR, BP_DMA_TCD11_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD11_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD11_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD11_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD11_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CITER_ELINKNO_ADDR, BP_DMA_TCD11_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd11_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd11_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd11_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_DLASTSGA register
 */
//@{
#define HW_DMA_TCD11_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1178U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_DLASTSGA           (*(__IO hw_dma_tcd11_dlastsga_t *) HW_DMA_TCD11_DLASTSGA_ADDR)
#define HW_DMA_TCD11_DLASTSGA_RD()      (HW_DMA_TCD11_DLASTSGA.U)
#define HW_DMA_TCD11_DLASTSGA_WR(v)     (HW_DMA_TCD11_DLASTSGA.U = (v))
#define HW_DMA_TCD11_DLASTSGA_SET(v)    (HW_DMA_TCD11_DLASTSGA_WR(HW_DMA_TCD11_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD11_DLASTSGA_CLR(v)    (HW_DMA_TCD11_DLASTSGA_WR(HW_DMA_TCD11_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD11_DLASTSGA_TOG(v)    (HW_DMA_TCD11_DLASTSGA_WR(HW_DMA_TCD11_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD11_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD11_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD11_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD11_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD11_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD11_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD11_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD11_DLASTSGA_DLASTSGA()   (HW_DMA_TCD11_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD11_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD11_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD11_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD11_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD11_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD11_DLASTSGA_WR((HW_DMA_TCD11_DLASTSGA_RD() & ~BM_DMA_TCD11_DLASTSGA_DLASTSGA) | BF_DMA_TCD11_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd11_csr
{
    uint16_t U;
    struct _hw_dma_tcd11_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd11_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_CSR register
 */
//@{
#define HW_DMA_TCD11_CSR_ADDR      (REGS_DMA_BASE + 0x117cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_CSR           (*(__IO hw_dma_tcd11_csr_t *) HW_DMA_TCD11_CSR_ADDR)
#define HW_DMA_TCD11_CSR_RD()      (HW_DMA_TCD11_CSR.U)
#define HW_DMA_TCD11_CSR_WR(v)     (HW_DMA_TCD11_CSR.U = (v))
#define HW_DMA_TCD11_CSR_SET(v)    (HW_DMA_TCD11_CSR_WR(HW_DMA_TCD11_CSR_RD() |  (v)))
#define HW_DMA_TCD11_CSR_CLR(v)    (HW_DMA_TCD11_CSR_WR(HW_DMA_TCD11_CSR_RD() & ~(v)))
#define HW_DMA_TCD11_CSR_TOG(v)    (HW_DMA_TCD11_CSR_WR(HW_DMA_TCD11_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_CSR bitfields
 */

/*! @name Register DMA_TCD11_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD11_CSR_START      (0U)      //!< Bit position for DMA_TCD11_CSR_START.
#define BM_DMA_TCD11_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD11_CSR_START.
#define BS_DMA_TCD11_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD11_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_START field.
#define BR_DMA_TCD11_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_START.
#define BF_DMA_TCD11_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_START), uint16_t) & BM_DMA_TCD11_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD11_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD11_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD11_CSR_INTMAJOR.
#define BM_DMA_TCD11_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD11_CSR_INTMAJOR.
#define BS_DMA_TCD11_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD11_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_INTMAJOR field.
#define BR_DMA_TCD11_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_INTMAJOR.
#define BF_DMA_TCD11_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD11_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD11_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD11_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD11_CSR_INTHALF.
#define BM_DMA_TCD11_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD11_CSR_INTHALF.
#define BS_DMA_TCD11_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD11_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_INTHALF field.
#define BR_DMA_TCD11_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_INTHALF.
#define BF_DMA_TCD11_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_INTHALF), uint16_t) & BM_DMA_TCD11_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD11_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD11_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD11_CSR_DREQ.
#define BM_DMA_TCD11_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD11_CSR_DREQ.
#define BS_DMA_TCD11_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD11_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_DREQ field.
#define BR_DMA_TCD11_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_DREQ.
#define BF_DMA_TCD11_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_DREQ), uint16_t) & BM_DMA_TCD11_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD11_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD11_CSR_ESG      (4U)      //!< Bit position for DMA_TCD11_CSR_ESG.
#define BM_DMA_TCD11_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD11_CSR_ESG.
#define BS_DMA_TCD11_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD11_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_ESG field.
#define BR_DMA_TCD11_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_ESG.
#define BF_DMA_TCD11_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_ESG), uint16_t) & BM_DMA_TCD11_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD11_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD11_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD11_CSR_MAJORELINK.
#define BM_DMA_TCD11_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD11_CSR_MAJORELINK.
#define BS_DMA_TCD11_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD11_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_MAJORELINK field.
#define BR_DMA_TCD11_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_MAJORELINK.
#define BF_DMA_TCD11_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD11_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD11_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD11_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD11_CSR_ACTIVE.
#define BM_DMA_TCD11_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD11_CSR_ACTIVE.
#define BS_DMA_TCD11_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD11_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_ACTIVE field.
#define BR_DMA_TCD11_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_ACTIVE.
#define BF_DMA_TCD11_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_ACTIVE), uint16_t) & BM_DMA_TCD11_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD11_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD11_CSR_DONE      (7U)      //!< Bit position for DMA_TCD11_CSR_DONE.
#define BM_DMA_TCD11_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD11_CSR_DONE.
#define BS_DMA_TCD11_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD11_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_DONE field.
#define BR_DMA_TCD11_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_DONE.
#define BF_DMA_TCD11_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_DONE), uint16_t) & BM_DMA_TCD11_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD11_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_CSR_ADDR, BP_DMA_TCD11_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD11_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD11_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD11_CSR_MAJORLINKCH.
#define BM_DMA_TCD11_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD11_CSR_MAJORLINKCH.
#define BS_DMA_TCD11_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD11_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_MAJORLINKCH field.
#define BR_DMA_TCD11_CSR_MAJORLINKCH()   (HW_DMA_TCD11_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_MAJORLINKCH.
#define BF_DMA_TCD11_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD11_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD11_CSR_MAJORLINKCH(v)   (HW_DMA_TCD11_CSR_WR((HW_DMA_TCD11_CSR_RD() & ~BM_DMA_TCD11_CSR_MAJORLINKCH) | BF_DMA_TCD11_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD11_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD11_CSR_BWC      (14U)      //!< Bit position for DMA_TCD11_CSR_BWC.
#define BM_DMA_TCD11_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD11_CSR_BWC.
#define BS_DMA_TCD11_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD11_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_CSR_BWC field.
#define BR_DMA_TCD11_CSR_BWC()   (HW_DMA_TCD11_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD11_CSR_BWC.
#define BF_DMA_TCD11_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_CSR_BWC), uint16_t) & BM_DMA_TCD11_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD11_CSR_BWC(v)   (HW_DMA_TCD11_CSR_WR((HW_DMA_TCD11_CSR_RD() & ~BM_DMA_TCD11_CSR_BWC) | BF_DMA_TCD11_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd11_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd11_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd11_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD11_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x117eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_BITER_ELINKYES           (*(__IO hw_dma_tcd11_biter_elinkyes_t *) HW_DMA_TCD11_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD11_BITER_ELINKYES_RD()      (HW_DMA_TCD11_BITER_ELINKYES.U)
#define HW_DMA_TCD11_BITER_ELINKYES_WR(v)     (HW_DMA_TCD11_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD11_BITER_ELINKYES_SET(v)    (HW_DMA_TCD11_BITER_ELINKYES_WR(HW_DMA_TCD11_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD11_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD11_BITER_ELINKYES_WR(HW_DMA_TCD11_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD11_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD11_BITER_ELINKYES_WR(HW_DMA_TCD11_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD11_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD11_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD11_BITER_ELINKYES_BITER.
#define BM_DMA_TCD11_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD11_BITER_ELINKYES_BITER.
#define BS_DMA_TCD11_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD11_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD11_BITER_ELINKYES_BITER()   (HW_DMA_TCD11_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD11_BITER_ELINKYES_BITER.
#define BF_DMA_TCD11_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD11_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD11_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD11_BITER_ELINKYES_WR((HW_DMA_TCD11_BITER_ELINKYES_RD() & ~BM_DMA_TCD11_BITER_ELINKYES_BITER) | BF_DMA_TCD11_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD11_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD11_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD11_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD11_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD11_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD11_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD11_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD11_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD11_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD11_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD11_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD11_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD11_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD11_BITER_ELINKYES_WR((HW_DMA_TCD11_BITER_ELINKYES_RD() & ~BM_DMA_TCD11_BITER_ELINKYES_LINKCH) | BF_DMA_TCD11_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD11_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD11_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD11_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD11_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD11_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD11_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD11_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD11_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD11_BITER_ELINKYES_ADDR, BP_DMA_TCD11_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD11_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD11_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD11_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD11_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_BITER_ELINKYES_ADDR, BP_DMA_TCD11_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD11_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD11_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd11_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd11_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd11_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD11_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD11_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x117eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD11_BITER_ELINKNO           (*(__IO hw_dma_tcd11_biter_elinkno_t *) HW_DMA_TCD11_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD11_BITER_ELINKNO_RD()      (HW_DMA_TCD11_BITER_ELINKNO.U)
#define HW_DMA_TCD11_BITER_ELINKNO_WR(v)     (HW_DMA_TCD11_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD11_BITER_ELINKNO_SET(v)    (HW_DMA_TCD11_BITER_ELINKNO_WR(HW_DMA_TCD11_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD11_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD11_BITER_ELINKNO_WR(HW_DMA_TCD11_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD11_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD11_BITER_ELINKNO_WR(HW_DMA_TCD11_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD11_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD11_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD11_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD11_BITER_ELINKNO_BITER.
#define BM_DMA_TCD11_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD11_BITER_ELINKNO_BITER.
#define BS_DMA_TCD11_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD11_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD11_BITER_ELINKNO_BITER()   (HW_DMA_TCD11_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD11_BITER_ELINKNO_BITER.
#define BF_DMA_TCD11_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD11_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD11_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD11_BITER_ELINKNO_WR((HW_DMA_TCD11_BITER_ELINKNO_RD() & ~BM_DMA_TCD11_BITER_ELINKNO_BITER) | BF_DMA_TCD11_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD11_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD11_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD11_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD11_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD11_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD11_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD11_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD11_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD11_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD11_BITER_ELINKNO_ADDR, BP_DMA_TCD11_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD11_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD11_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD11_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD11_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD11_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD11_BITER_ELINKNO_ADDR, BP_DMA_TCD11_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd12_saddr
{
    uint32_t U;
    struct _hw_dma_tcd12_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd12_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_SADDR register
 */
//@{
#define HW_DMA_TCD12_SADDR_ADDR      (REGS_DMA_BASE + 0x1180U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_SADDR           (*(__IO hw_dma_tcd12_saddr_t *) HW_DMA_TCD12_SADDR_ADDR)
#define HW_DMA_TCD12_SADDR_RD()      (HW_DMA_TCD12_SADDR.U)
#define HW_DMA_TCD12_SADDR_WR(v)     (HW_DMA_TCD12_SADDR.U = (v))
#define HW_DMA_TCD12_SADDR_SET(v)    (HW_DMA_TCD12_SADDR_WR(HW_DMA_TCD12_SADDR_RD() |  (v)))
#define HW_DMA_TCD12_SADDR_CLR(v)    (HW_DMA_TCD12_SADDR_WR(HW_DMA_TCD12_SADDR_RD() & ~(v)))
#define HW_DMA_TCD12_SADDR_TOG(v)    (HW_DMA_TCD12_SADDR_WR(HW_DMA_TCD12_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_SADDR bitfields
 */

/*! @name Register DMA_TCD12_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD12_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD12_SADDR_SADDR.
#define BM_DMA_TCD12_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD12_SADDR_SADDR.
#define BS_DMA_TCD12_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD12_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_SADDR_SADDR field.
#define BR_DMA_TCD12_SADDR_SADDR()   (HW_DMA_TCD12_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD12_SADDR_SADDR.
#define BF_DMA_TCD12_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_SADDR_SADDR), uint32_t) & BM_DMA_TCD12_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD12_SADDR_SADDR(v)   (HW_DMA_TCD12_SADDR_WR((HW_DMA_TCD12_SADDR_RD() & ~BM_DMA_TCD12_SADDR_SADDR) | BF_DMA_TCD12_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd12_soff
{
    uint16_t U;
    struct _hw_dma_tcd12_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd12_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_SOFF register
 */
//@{
#define HW_DMA_TCD12_SOFF_ADDR      (REGS_DMA_BASE + 0x1184U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_SOFF           (*(__IO hw_dma_tcd12_soff_t *) HW_DMA_TCD12_SOFF_ADDR)
#define HW_DMA_TCD12_SOFF_RD()      (HW_DMA_TCD12_SOFF.U)
#define HW_DMA_TCD12_SOFF_WR(v)     (HW_DMA_TCD12_SOFF.U = (v))
#define HW_DMA_TCD12_SOFF_SET(v)    (HW_DMA_TCD12_SOFF_WR(HW_DMA_TCD12_SOFF_RD() |  (v)))
#define HW_DMA_TCD12_SOFF_CLR(v)    (HW_DMA_TCD12_SOFF_WR(HW_DMA_TCD12_SOFF_RD() & ~(v)))
#define HW_DMA_TCD12_SOFF_TOG(v)    (HW_DMA_TCD12_SOFF_WR(HW_DMA_TCD12_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_SOFF bitfields
 */

/*! @name Register DMA_TCD12_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD12_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD12_SOFF_SOFF.
#define BM_DMA_TCD12_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD12_SOFF_SOFF.
#define BS_DMA_TCD12_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD12_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_SOFF_SOFF field.
#define BR_DMA_TCD12_SOFF_SOFF()   (HW_DMA_TCD12_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD12_SOFF_SOFF.
#define BF_DMA_TCD12_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_SOFF_SOFF), uint16_t) & BM_DMA_TCD12_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD12_SOFF_SOFF(v)   (HW_DMA_TCD12_SOFF_WR((HW_DMA_TCD12_SOFF_RD() & ~BM_DMA_TCD12_SOFF_SOFF) | BF_DMA_TCD12_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd12_attr
{
    uint16_t U;
    struct _hw_dma_tcd12_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd12_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_ATTR register
 */
//@{
#define HW_DMA_TCD12_ATTR_ADDR      (REGS_DMA_BASE + 0x1186U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_ATTR           (*(__IO hw_dma_tcd12_attr_t *) HW_DMA_TCD12_ATTR_ADDR)
#define HW_DMA_TCD12_ATTR_RD()      (HW_DMA_TCD12_ATTR.U)
#define HW_DMA_TCD12_ATTR_WR(v)     (HW_DMA_TCD12_ATTR.U = (v))
#define HW_DMA_TCD12_ATTR_SET(v)    (HW_DMA_TCD12_ATTR_WR(HW_DMA_TCD12_ATTR_RD() |  (v)))
#define HW_DMA_TCD12_ATTR_CLR(v)    (HW_DMA_TCD12_ATTR_WR(HW_DMA_TCD12_ATTR_RD() & ~(v)))
#define HW_DMA_TCD12_ATTR_TOG(v)    (HW_DMA_TCD12_ATTR_WR(HW_DMA_TCD12_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_ATTR bitfields
 */

/*! @name Register DMA_TCD12_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD12_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD12_ATTR_DSIZE.
#define BM_DMA_TCD12_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD12_ATTR_DSIZE.
#define BS_DMA_TCD12_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD12_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_ATTR_DSIZE field.
#define BR_DMA_TCD12_ATTR_DSIZE()   (HW_DMA_TCD12_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD12_ATTR_DSIZE.
#define BF_DMA_TCD12_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_ATTR_DSIZE), uint16_t) & BM_DMA_TCD12_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD12_ATTR_DSIZE(v)   (HW_DMA_TCD12_ATTR_WR((HW_DMA_TCD12_ATTR_RD() & ~BM_DMA_TCD12_ATTR_DSIZE) | BF_DMA_TCD12_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD12_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD12_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD12_ATTR_DMOD.
#define BM_DMA_TCD12_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD12_ATTR_DMOD.
#define BS_DMA_TCD12_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD12_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_ATTR_DMOD field.
#define BR_DMA_TCD12_ATTR_DMOD()   (HW_DMA_TCD12_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD12_ATTR_DMOD.
#define BF_DMA_TCD12_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_ATTR_DMOD), uint16_t) & BM_DMA_TCD12_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD12_ATTR_DMOD(v)   (HW_DMA_TCD12_ATTR_WR((HW_DMA_TCD12_ATTR_RD() & ~BM_DMA_TCD12_ATTR_DMOD) | BF_DMA_TCD12_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD12_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD12_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD12_ATTR_SSIZE.
#define BM_DMA_TCD12_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD12_ATTR_SSIZE.
#define BS_DMA_TCD12_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD12_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_ATTR_SSIZE field.
#define BR_DMA_TCD12_ATTR_SSIZE()   (HW_DMA_TCD12_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD12_ATTR_SSIZE.
#define BF_DMA_TCD12_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_ATTR_SSIZE), uint16_t) & BM_DMA_TCD12_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD12_ATTR_SSIZE(v)   (HW_DMA_TCD12_ATTR_WR((HW_DMA_TCD12_ATTR_RD() & ~BM_DMA_TCD12_ATTR_SSIZE) | BF_DMA_TCD12_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD12_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD12_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD12_ATTR_SMOD.
#define BM_DMA_TCD12_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD12_ATTR_SMOD.
#define BS_DMA_TCD12_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD12_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_ATTR_SMOD field.
#define BR_DMA_TCD12_ATTR_SMOD()   (HW_DMA_TCD12_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD12_ATTR_SMOD.
#define BF_DMA_TCD12_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_ATTR_SMOD), uint16_t) & BM_DMA_TCD12_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD12_ATTR_SMOD(v)   (HW_DMA_TCD12_ATTR_WR((HW_DMA_TCD12_ATTR_RD() & ~BM_DMA_TCD12_ATTR_SMOD) | BF_DMA_TCD12_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd12_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd12_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd12_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD12_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1188U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_NBYTES_MLNO           (*(__IO hw_dma_tcd12_nbytes_mlno_t *) HW_DMA_TCD12_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD12_NBYTES_MLNO_RD()      (HW_DMA_TCD12_NBYTES_MLNO.U)
#define HW_DMA_TCD12_NBYTES_MLNO_WR(v)     (HW_DMA_TCD12_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD12_NBYTES_MLNO_SET(v)    (HW_DMA_TCD12_NBYTES_MLNO_WR(HW_DMA_TCD12_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD12_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD12_NBYTES_MLNO_WR(HW_DMA_TCD12_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD12_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD12_NBYTES_MLNO_WR(HW_DMA_TCD12_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD12_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD12_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD12_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD12_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD12_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD12_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD12_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD12_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD12_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD12_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD12_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD12_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD12_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD12_NBYTES_MLNO_WR((HW_DMA_TCD12_NBYTES_MLNO_RD() & ~BM_DMA_TCD12_NBYTES_MLNO_NBYTES) | BF_DMA_TCD12_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd12_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd12_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd12_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD12_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1188U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd12_nbytes_mloffno_t *) HW_DMA_TCD12_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD12_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD12_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD12_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD12_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD12_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD12_NBYTES_MLOFFNO_WR(HW_DMA_TCD12_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD12_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD12_NBYTES_MLOFFNO_WR(HW_DMA_TCD12_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD12_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD12_NBYTES_MLOFFNO_WR(HW_DMA_TCD12_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD12_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD12_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD12_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD12_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD12_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD12_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD12_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD12_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD12_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD12_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD12_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD12_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD12_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD12_NBYTES_MLOFFNO_WR((HW_DMA_TCD12_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD12_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD12_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD12_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD12_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD12_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD12_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD12_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD12_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD12_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD12_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD12_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD12_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD12_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD12_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD12_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD12_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD12_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD12_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD12_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD12_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD12_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD12_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD12_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD12_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD12_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD12_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD12_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD12_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD12_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD12_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD12_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD12_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD12_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd12_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd12_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd12_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD12_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1188U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd12_nbytes_mloffyes_t *) HW_DMA_TCD12_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD12_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD12_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD12_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD12_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD12_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD12_NBYTES_MLOFFYES_WR(HW_DMA_TCD12_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD12_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD12_NBYTES_MLOFFYES_WR(HW_DMA_TCD12_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD12_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD12_NBYTES_MLOFFYES_WR(HW_DMA_TCD12_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD12_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD12_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD12_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD12_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD12_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD12_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD12_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD12_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD12_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD12_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD12_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD12_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD12_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD12_NBYTES_MLOFFYES_WR((HW_DMA_TCD12_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD12_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD12_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD12_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD12_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD12_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD12_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD12_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD12_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD12_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD12_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD12_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD12_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD12_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD12_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD12_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD12_NBYTES_MLOFFYES_WR((HW_DMA_TCD12_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD12_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD12_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD12_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD12_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD12_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD12_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD12_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD12_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD12_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD12_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD12_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD12_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD12_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD12_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD12_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD12_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD12_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD12_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD12_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD12_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD12_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD12_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD12_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD12_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD12_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD12_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD12_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD12_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD12_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD12_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD12_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD12_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD12_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd12_slast
{
    uint32_t U;
    struct _hw_dma_tcd12_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd12_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_SLAST register
 */
//@{
#define HW_DMA_TCD12_SLAST_ADDR      (REGS_DMA_BASE + 0x118cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_SLAST           (*(__IO hw_dma_tcd12_slast_t *) HW_DMA_TCD12_SLAST_ADDR)
#define HW_DMA_TCD12_SLAST_RD()      (HW_DMA_TCD12_SLAST.U)
#define HW_DMA_TCD12_SLAST_WR(v)     (HW_DMA_TCD12_SLAST.U = (v))
#define HW_DMA_TCD12_SLAST_SET(v)    (HW_DMA_TCD12_SLAST_WR(HW_DMA_TCD12_SLAST_RD() |  (v)))
#define HW_DMA_TCD12_SLAST_CLR(v)    (HW_DMA_TCD12_SLAST_WR(HW_DMA_TCD12_SLAST_RD() & ~(v)))
#define HW_DMA_TCD12_SLAST_TOG(v)    (HW_DMA_TCD12_SLAST_WR(HW_DMA_TCD12_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_SLAST bitfields
 */

/*! @name Register DMA_TCD12_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD12_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD12_SLAST_SLAST.
#define BM_DMA_TCD12_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD12_SLAST_SLAST.
#define BS_DMA_TCD12_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD12_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_SLAST_SLAST field.
#define BR_DMA_TCD12_SLAST_SLAST()   (HW_DMA_TCD12_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD12_SLAST_SLAST.
#define BF_DMA_TCD12_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_SLAST_SLAST), uint32_t) & BM_DMA_TCD12_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD12_SLAST_SLAST(v)   (HW_DMA_TCD12_SLAST_WR((HW_DMA_TCD12_SLAST_RD() & ~BM_DMA_TCD12_SLAST_SLAST) | BF_DMA_TCD12_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd12_daddr
{
    uint32_t U;
    struct _hw_dma_tcd12_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd12_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_DADDR register
 */
//@{
#define HW_DMA_TCD12_DADDR_ADDR      (REGS_DMA_BASE + 0x1190U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_DADDR           (*(__IO hw_dma_tcd12_daddr_t *) HW_DMA_TCD12_DADDR_ADDR)
#define HW_DMA_TCD12_DADDR_RD()      (HW_DMA_TCD12_DADDR.U)
#define HW_DMA_TCD12_DADDR_WR(v)     (HW_DMA_TCD12_DADDR.U = (v))
#define HW_DMA_TCD12_DADDR_SET(v)    (HW_DMA_TCD12_DADDR_WR(HW_DMA_TCD12_DADDR_RD() |  (v)))
#define HW_DMA_TCD12_DADDR_CLR(v)    (HW_DMA_TCD12_DADDR_WR(HW_DMA_TCD12_DADDR_RD() & ~(v)))
#define HW_DMA_TCD12_DADDR_TOG(v)    (HW_DMA_TCD12_DADDR_WR(HW_DMA_TCD12_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_DADDR bitfields
 */

/*! @name Register DMA_TCD12_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD12_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD12_DADDR_DADDR.
#define BM_DMA_TCD12_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD12_DADDR_DADDR.
#define BS_DMA_TCD12_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD12_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_DADDR_DADDR field.
#define BR_DMA_TCD12_DADDR_DADDR()   (HW_DMA_TCD12_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD12_DADDR_DADDR.
#define BF_DMA_TCD12_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_DADDR_DADDR), uint32_t) & BM_DMA_TCD12_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD12_DADDR_DADDR(v)   (HW_DMA_TCD12_DADDR_WR((HW_DMA_TCD12_DADDR_RD() & ~BM_DMA_TCD12_DADDR_DADDR) | BF_DMA_TCD12_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd12_doff
{
    uint16_t U;
    struct _hw_dma_tcd12_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd12_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_DOFF register
 */
//@{
#define HW_DMA_TCD12_DOFF_ADDR      (REGS_DMA_BASE + 0x1194U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_DOFF           (*(__IO hw_dma_tcd12_doff_t *) HW_DMA_TCD12_DOFF_ADDR)
#define HW_DMA_TCD12_DOFF_RD()      (HW_DMA_TCD12_DOFF.U)
#define HW_DMA_TCD12_DOFF_WR(v)     (HW_DMA_TCD12_DOFF.U = (v))
#define HW_DMA_TCD12_DOFF_SET(v)    (HW_DMA_TCD12_DOFF_WR(HW_DMA_TCD12_DOFF_RD() |  (v)))
#define HW_DMA_TCD12_DOFF_CLR(v)    (HW_DMA_TCD12_DOFF_WR(HW_DMA_TCD12_DOFF_RD() & ~(v)))
#define HW_DMA_TCD12_DOFF_TOG(v)    (HW_DMA_TCD12_DOFF_WR(HW_DMA_TCD12_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_DOFF bitfields
 */

/*! @name Register DMA_TCD12_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD12_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD12_DOFF_DOFF.
#define BM_DMA_TCD12_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD12_DOFF_DOFF.
#define BS_DMA_TCD12_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD12_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_DOFF_DOFF field.
#define BR_DMA_TCD12_DOFF_DOFF()   (HW_DMA_TCD12_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD12_DOFF_DOFF.
#define BF_DMA_TCD12_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_DOFF_DOFF), uint16_t) & BM_DMA_TCD12_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD12_DOFF_DOFF(v)   (HW_DMA_TCD12_DOFF_WR((HW_DMA_TCD12_DOFF_RD() & ~BM_DMA_TCD12_DOFF_DOFF) | BF_DMA_TCD12_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd12_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd12_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd12_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD12_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1196U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_CITER_ELINKYES           (*(__IO hw_dma_tcd12_citer_elinkyes_t *) HW_DMA_TCD12_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD12_CITER_ELINKYES_RD()      (HW_DMA_TCD12_CITER_ELINKYES.U)
#define HW_DMA_TCD12_CITER_ELINKYES_WR(v)     (HW_DMA_TCD12_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD12_CITER_ELINKYES_SET(v)    (HW_DMA_TCD12_CITER_ELINKYES_WR(HW_DMA_TCD12_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD12_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD12_CITER_ELINKYES_WR(HW_DMA_TCD12_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD12_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD12_CITER_ELINKYES_WR(HW_DMA_TCD12_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD12_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD12_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD12_CITER_ELINKYES_CITER.
#define BM_DMA_TCD12_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD12_CITER_ELINKYES_CITER.
#define BS_DMA_TCD12_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD12_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD12_CITER_ELINKYES_CITER()   (HW_DMA_TCD12_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD12_CITER_ELINKYES_CITER.
#define BF_DMA_TCD12_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD12_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD12_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD12_CITER_ELINKYES_WR((HW_DMA_TCD12_CITER_ELINKYES_RD() & ~BM_DMA_TCD12_CITER_ELINKYES_CITER) | BF_DMA_TCD12_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD12_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD12_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD12_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD12_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD12_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD12_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD12_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD12_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD12_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD12_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD12_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD12_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD12_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD12_CITER_ELINKYES_WR((HW_DMA_TCD12_CITER_ELINKYES_RD() & ~BM_DMA_TCD12_CITER_ELINKYES_LINKCH) | BF_DMA_TCD12_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD12_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD12_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD12_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD12_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD12_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD12_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD12_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD12_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD12_CITER_ELINKYES_ADDR, BP_DMA_TCD12_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD12_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD12_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD12_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD12_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CITER_ELINKYES_ADDR, BP_DMA_TCD12_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd12_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd12_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd12_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD12_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1196U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_CITER_ELINKNO           (*(__IO hw_dma_tcd12_citer_elinkno_t *) HW_DMA_TCD12_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD12_CITER_ELINKNO_RD()      (HW_DMA_TCD12_CITER_ELINKNO.U)
#define HW_DMA_TCD12_CITER_ELINKNO_WR(v)     (HW_DMA_TCD12_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD12_CITER_ELINKNO_SET(v)    (HW_DMA_TCD12_CITER_ELINKNO_WR(HW_DMA_TCD12_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD12_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD12_CITER_ELINKNO_WR(HW_DMA_TCD12_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD12_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD12_CITER_ELINKNO_WR(HW_DMA_TCD12_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD12_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD12_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD12_CITER_ELINKNO_CITER.
#define BM_DMA_TCD12_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD12_CITER_ELINKNO_CITER.
#define BS_DMA_TCD12_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD12_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD12_CITER_ELINKNO_CITER()   (HW_DMA_TCD12_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD12_CITER_ELINKNO_CITER.
#define BF_DMA_TCD12_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD12_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD12_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD12_CITER_ELINKNO_WR((HW_DMA_TCD12_CITER_ELINKNO_RD() & ~BM_DMA_TCD12_CITER_ELINKNO_CITER) | BF_DMA_TCD12_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD12_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD12_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD12_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD12_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD12_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD12_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD12_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD12_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD12_CITER_ELINKNO_ADDR, BP_DMA_TCD12_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD12_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD12_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD12_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD12_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CITER_ELINKNO_ADDR, BP_DMA_TCD12_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd12_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd12_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd12_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_DLASTSGA register
 */
//@{
#define HW_DMA_TCD12_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1198U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_DLASTSGA           (*(__IO hw_dma_tcd12_dlastsga_t *) HW_DMA_TCD12_DLASTSGA_ADDR)
#define HW_DMA_TCD12_DLASTSGA_RD()      (HW_DMA_TCD12_DLASTSGA.U)
#define HW_DMA_TCD12_DLASTSGA_WR(v)     (HW_DMA_TCD12_DLASTSGA.U = (v))
#define HW_DMA_TCD12_DLASTSGA_SET(v)    (HW_DMA_TCD12_DLASTSGA_WR(HW_DMA_TCD12_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD12_DLASTSGA_CLR(v)    (HW_DMA_TCD12_DLASTSGA_WR(HW_DMA_TCD12_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD12_DLASTSGA_TOG(v)    (HW_DMA_TCD12_DLASTSGA_WR(HW_DMA_TCD12_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD12_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD12_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD12_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD12_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD12_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD12_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD12_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD12_DLASTSGA_DLASTSGA()   (HW_DMA_TCD12_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD12_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD12_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD12_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD12_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD12_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD12_DLASTSGA_WR((HW_DMA_TCD12_DLASTSGA_RD() & ~BM_DMA_TCD12_DLASTSGA_DLASTSGA) | BF_DMA_TCD12_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd12_csr
{
    uint16_t U;
    struct _hw_dma_tcd12_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd12_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_CSR register
 */
//@{
#define HW_DMA_TCD12_CSR_ADDR      (REGS_DMA_BASE + 0x119cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_CSR           (*(__IO hw_dma_tcd12_csr_t *) HW_DMA_TCD12_CSR_ADDR)
#define HW_DMA_TCD12_CSR_RD()      (HW_DMA_TCD12_CSR.U)
#define HW_DMA_TCD12_CSR_WR(v)     (HW_DMA_TCD12_CSR.U = (v))
#define HW_DMA_TCD12_CSR_SET(v)    (HW_DMA_TCD12_CSR_WR(HW_DMA_TCD12_CSR_RD() |  (v)))
#define HW_DMA_TCD12_CSR_CLR(v)    (HW_DMA_TCD12_CSR_WR(HW_DMA_TCD12_CSR_RD() & ~(v)))
#define HW_DMA_TCD12_CSR_TOG(v)    (HW_DMA_TCD12_CSR_WR(HW_DMA_TCD12_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_CSR bitfields
 */

/*! @name Register DMA_TCD12_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD12_CSR_START      (0U)      //!< Bit position for DMA_TCD12_CSR_START.
#define BM_DMA_TCD12_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD12_CSR_START.
#define BS_DMA_TCD12_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD12_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_START field.
#define BR_DMA_TCD12_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_START.
#define BF_DMA_TCD12_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_START), uint16_t) & BM_DMA_TCD12_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD12_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD12_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD12_CSR_INTMAJOR.
#define BM_DMA_TCD12_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD12_CSR_INTMAJOR.
#define BS_DMA_TCD12_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD12_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_INTMAJOR field.
#define BR_DMA_TCD12_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_INTMAJOR.
#define BF_DMA_TCD12_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD12_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD12_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD12_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD12_CSR_INTHALF.
#define BM_DMA_TCD12_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD12_CSR_INTHALF.
#define BS_DMA_TCD12_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD12_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_INTHALF field.
#define BR_DMA_TCD12_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_INTHALF.
#define BF_DMA_TCD12_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_INTHALF), uint16_t) & BM_DMA_TCD12_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD12_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD12_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD12_CSR_DREQ.
#define BM_DMA_TCD12_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD12_CSR_DREQ.
#define BS_DMA_TCD12_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD12_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_DREQ field.
#define BR_DMA_TCD12_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_DREQ.
#define BF_DMA_TCD12_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_DREQ), uint16_t) & BM_DMA_TCD12_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD12_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD12_CSR_ESG      (4U)      //!< Bit position for DMA_TCD12_CSR_ESG.
#define BM_DMA_TCD12_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD12_CSR_ESG.
#define BS_DMA_TCD12_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD12_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_ESG field.
#define BR_DMA_TCD12_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_ESG.
#define BF_DMA_TCD12_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_ESG), uint16_t) & BM_DMA_TCD12_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD12_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD12_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD12_CSR_MAJORELINK.
#define BM_DMA_TCD12_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD12_CSR_MAJORELINK.
#define BS_DMA_TCD12_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD12_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_MAJORELINK field.
#define BR_DMA_TCD12_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_MAJORELINK.
#define BF_DMA_TCD12_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD12_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD12_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD12_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD12_CSR_ACTIVE.
#define BM_DMA_TCD12_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD12_CSR_ACTIVE.
#define BS_DMA_TCD12_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD12_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_ACTIVE field.
#define BR_DMA_TCD12_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_ACTIVE.
#define BF_DMA_TCD12_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_ACTIVE), uint16_t) & BM_DMA_TCD12_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD12_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD12_CSR_DONE      (7U)      //!< Bit position for DMA_TCD12_CSR_DONE.
#define BM_DMA_TCD12_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD12_CSR_DONE.
#define BS_DMA_TCD12_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD12_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_DONE field.
#define BR_DMA_TCD12_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_DONE.
#define BF_DMA_TCD12_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_DONE), uint16_t) & BM_DMA_TCD12_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD12_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_CSR_ADDR, BP_DMA_TCD12_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD12_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD12_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD12_CSR_MAJORLINKCH.
#define BM_DMA_TCD12_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD12_CSR_MAJORLINKCH.
#define BS_DMA_TCD12_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD12_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_MAJORLINKCH field.
#define BR_DMA_TCD12_CSR_MAJORLINKCH()   (HW_DMA_TCD12_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_MAJORLINKCH.
#define BF_DMA_TCD12_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD12_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD12_CSR_MAJORLINKCH(v)   (HW_DMA_TCD12_CSR_WR((HW_DMA_TCD12_CSR_RD() & ~BM_DMA_TCD12_CSR_MAJORLINKCH) | BF_DMA_TCD12_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD12_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD12_CSR_BWC      (14U)      //!< Bit position for DMA_TCD12_CSR_BWC.
#define BM_DMA_TCD12_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD12_CSR_BWC.
#define BS_DMA_TCD12_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD12_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_CSR_BWC field.
#define BR_DMA_TCD12_CSR_BWC()   (HW_DMA_TCD12_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD12_CSR_BWC.
#define BF_DMA_TCD12_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_CSR_BWC), uint16_t) & BM_DMA_TCD12_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD12_CSR_BWC(v)   (HW_DMA_TCD12_CSR_WR((HW_DMA_TCD12_CSR_RD() & ~BM_DMA_TCD12_CSR_BWC) | BF_DMA_TCD12_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd12_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd12_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd12_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD12_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x119eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_BITER_ELINKYES           (*(__IO hw_dma_tcd12_biter_elinkyes_t *) HW_DMA_TCD12_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD12_BITER_ELINKYES_RD()      (HW_DMA_TCD12_BITER_ELINKYES.U)
#define HW_DMA_TCD12_BITER_ELINKYES_WR(v)     (HW_DMA_TCD12_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD12_BITER_ELINKYES_SET(v)    (HW_DMA_TCD12_BITER_ELINKYES_WR(HW_DMA_TCD12_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD12_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD12_BITER_ELINKYES_WR(HW_DMA_TCD12_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD12_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD12_BITER_ELINKYES_WR(HW_DMA_TCD12_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD12_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD12_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD12_BITER_ELINKYES_BITER.
#define BM_DMA_TCD12_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD12_BITER_ELINKYES_BITER.
#define BS_DMA_TCD12_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD12_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD12_BITER_ELINKYES_BITER()   (HW_DMA_TCD12_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD12_BITER_ELINKYES_BITER.
#define BF_DMA_TCD12_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD12_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD12_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD12_BITER_ELINKYES_WR((HW_DMA_TCD12_BITER_ELINKYES_RD() & ~BM_DMA_TCD12_BITER_ELINKYES_BITER) | BF_DMA_TCD12_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD12_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD12_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD12_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD12_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD12_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD12_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD12_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD12_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD12_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD12_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD12_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD12_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD12_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD12_BITER_ELINKYES_WR((HW_DMA_TCD12_BITER_ELINKYES_RD() & ~BM_DMA_TCD12_BITER_ELINKYES_LINKCH) | BF_DMA_TCD12_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD12_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD12_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD12_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD12_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD12_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD12_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD12_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD12_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD12_BITER_ELINKYES_ADDR, BP_DMA_TCD12_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD12_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD12_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD12_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD12_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_BITER_ELINKYES_ADDR, BP_DMA_TCD12_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD12_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD12_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd12_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd12_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd12_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD12_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD12_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x119eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD12_BITER_ELINKNO           (*(__IO hw_dma_tcd12_biter_elinkno_t *) HW_DMA_TCD12_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD12_BITER_ELINKNO_RD()      (HW_DMA_TCD12_BITER_ELINKNO.U)
#define HW_DMA_TCD12_BITER_ELINKNO_WR(v)     (HW_DMA_TCD12_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD12_BITER_ELINKNO_SET(v)    (HW_DMA_TCD12_BITER_ELINKNO_WR(HW_DMA_TCD12_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD12_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD12_BITER_ELINKNO_WR(HW_DMA_TCD12_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD12_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD12_BITER_ELINKNO_WR(HW_DMA_TCD12_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD12_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD12_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD12_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD12_BITER_ELINKNO_BITER.
#define BM_DMA_TCD12_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD12_BITER_ELINKNO_BITER.
#define BS_DMA_TCD12_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD12_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD12_BITER_ELINKNO_BITER()   (HW_DMA_TCD12_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD12_BITER_ELINKNO_BITER.
#define BF_DMA_TCD12_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD12_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD12_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD12_BITER_ELINKNO_WR((HW_DMA_TCD12_BITER_ELINKNO_RD() & ~BM_DMA_TCD12_BITER_ELINKNO_BITER) | BF_DMA_TCD12_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD12_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD12_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD12_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD12_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD12_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD12_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD12_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD12_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD12_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD12_BITER_ELINKNO_ADDR, BP_DMA_TCD12_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD12_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD12_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD12_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD12_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD12_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD12_BITER_ELINKNO_ADDR, BP_DMA_TCD12_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd13_saddr
{
    uint32_t U;
    struct _hw_dma_tcd13_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd13_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_SADDR register
 */
//@{
#define HW_DMA_TCD13_SADDR_ADDR      (REGS_DMA_BASE + 0x11a0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_SADDR           (*(__IO hw_dma_tcd13_saddr_t *) HW_DMA_TCD13_SADDR_ADDR)
#define HW_DMA_TCD13_SADDR_RD()      (HW_DMA_TCD13_SADDR.U)
#define HW_DMA_TCD13_SADDR_WR(v)     (HW_DMA_TCD13_SADDR.U = (v))
#define HW_DMA_TCD13_SADDR_SET(v)    (HW_DMA_TCD13_SADDR_WR(HW_DMA_TCD13_SADDR_RD() |  (v)))
#define HW_DMA_TCD13_SADDR_CLR(v)    (HW_DMA_TCD13_SADDR_WR(HW_DMA_TCD13_SADDR_RD() & ~(v)))
#define HW_DMA_TCD13_SADDR_TOG(v)    (HW_DMA_TCD13_SADDR_WR(HW_DMA_TCD13_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_SADDR bitfields
 */

/*! @name Register DMA_TCD13_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD13_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD13_SADDR_SADDR.
#define BM_DMA_TCD13_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD13_SADDR_SADDR.
#define BS_DMA_TCD13_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD13_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_SADDR_SADDR field.
#define BR_DMA_TCD13_SADDR_SADDR()   (HW_DMA_TCD13_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD13_SADDR_SADDR.
#define BF_DMA_TCD13_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_SADDR_SADDR), uint32_t) & BM_DMA_TCD13_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD13_SADDR_SADDR(v)   (HW_DMA_TCD13_SADDR_WR((HW_DMA_TCD13_SADDR_RD() & ~BM_DMA_TCD13_SADDR_SADDR) | BF_DMA_TCD13_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd13_soff
{
    uint16_t U;
    struct _hw_dma_tcd13_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd13_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_SOFF register
 */
//@{
#define HW_DMA_TCD13_SOFF_ADDR      (REGS_DMA_BASE + 0x11a4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_SOFF           (*(__IO hw_dma_tcd13_soff_t *) HW_DMA_TCD13_SOFF_ADDR)
#define HW_DMA_TCD13_SOFF_RD()      (HW_DMA_TCD13_SOFF.U)
#define HW_DMA_TCD13_SOFF_WR(v)     (HW_DMA_TCD13_SOFF.U = (v))
#define HW_DMA_TCD13_SOFF_SET(v)    (HW_DMA_TCD13_SOFF_WR(HW_DMA_TCD13_SOFF_RD() |  (v)))
#define HW_DMA_TCD13_SOFF_CLR(v)    (HW_DMA_TCD13_SOFF_WR(HW_DMA_TCD13_SOFF_RD() & ~(v)))
#define HW_DMA_TCD13_SOFF_TOG(v)    (HW_DMA_TCD13_SOFF_WR(HW_DMA_TCD13_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_SOFF bitfields
 */

/*! @name Register DMA_TCD13_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD13_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD13_SOFF_SOFF.
#define BM_DMA_TCD13_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD13_SOFF_SOFF.
#define BS_DMA_TCD13_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD13_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_SOFF_SOFF field.
#define BR_DMA_TCD13_SOFF_SOFF()   (HW_DMA_TCD13_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD13_SOFF_SOFF.
#define BF_DMA_TCD13_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_SOFF_SOFF), uint16_t) & BM_DMA_TCD13_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD13_SOFF_SOFF(v)   (HW_DMA_TCD13_SOFF_WR((HW_DMA_TCD13_SOFF_RD() & ~BM_DMA_TCD13_SOFF_SOFF) | BF_DMA_TCD13_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd13_attr
{
    uint16_t U;
    struct _hw_dma_tcd13_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd13_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_ATTR register
 */
//@{
#define HW_DMA_TCD13_ATTR_ADDR      (REGS_DMA_BASE + 0x11a6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_ATTR           (*(__IO hw_dma_tcd13_attr_t *) HW_DMA_TCD13_ATTR_ADDR)
#define HW_DMA_TCD13_ATTR_RD()      (HW_DMA_TCD13_ATTR.U)
#define HW_DMA_TCD13_ATTR_WR(v)     (HW_DMA_TCD13_ATTR.U = (v))
#define HW_DMA_TCD13_ATTR_SET(v)    (HW_DMA_TCD13_ATTR_WR(HW_DMA_TCD13_ATTR_RD() |  (v)))
#define HW_DMA_TCD13_ATTR_CLR(v)    (HW_DMA_TCD13_ATTR_WR(HW_DMA_TCD13_ATTR_RD() & ~(v)))
#define HW_DMA_TCD13_ATTR_TOG(v)    (HW_DMA_TCD13_ATTR_WR(HW_DMA_TCD13_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_ATTR bitfields
 */

/*! @name Register DMA_TCD13_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD13_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD13_ATTR_DSIZE.
#define BM_DMA_TCD13_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD13_ATTR_DSIZE.
#define BS_DMA_TCD13_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD13_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_ATTR_DSIZE field.
#define BR_DMA_TCD13_ATTR_DSIZE()   (HW_DMA_TCD13_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD13_ATTR_DSIZE.
#define BF_DMA_TCD13_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_ATTR_DSIZE), uint16_t) & BM_DMA_TCD13_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD13_ATTR_DSIZE(v)   (HW_DMA_TCD13_ATTR_WR((HW_DMA_TCD13_ATTR_RD() & ~BM_DMA_TCD13_ATTR_DSIZE) | BF_DMA_TCD13_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD13_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD13_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD13_ATTR_DMOD.
#define BM_DMA_TCD13_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD13_ATTR_DMOD.
#define BS_DMA_TCD13_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD13_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_ATTR_DMOD field.
#define BR_DMA_TCD13_ATTR_DMOD()   (HW_DMA_TCD13_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD13_ATTR_DMOD.
#define BF_DMA_TCD13_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_ATTR_DMOD), uint16_t) & BM_DMA_TCD13_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD13_ATTR_DMOD(v)   (HW_DMA_TCD13_ATTR_WR((HW_DMA_TCD13_ATTR_RD() & ~BM_DMA_TCD13_ATTR_DMOD) | BF_DMA_TCD13_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD13_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD13_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD13_ATTR_SSIZE.
#define BM_DMA_TCD13_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD13_ATTR_SSIZE.
#define BS_DMA_TCD13_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD13_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_ATTR_SSIZE field.
#define BR_DMA_TCD13_ATTR_SSIZE()   (HW_DMA_TCD13_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD13_ATTR_SSIZE.
#define BF_DMA_TCD13_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_ATTR_SSIZE), uint16_t) & BM_DMA_TCD13_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD13_ATTR_SSIZE(v)   (HW_DMA_TCD13_ATTR_WR((HW_DMA_TCD13_ATTR_RD() & ~BM_DMA_TCD13_ATTR_SSIZE) | BF_DMA_TCD13_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD13_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD13_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD13_ATTR_SMOD.
#define BM_DMA_TCD13_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD13_ATTR_SMOD.
#define BS_DMA_TCD13_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD13_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_ATTR_SMOD field.
#define BR_DMA_TCD13_ATTR_SMOD()   (HW_DMA_TCD13_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD13_ATTR_SMOD.
#define BF_DMA_TCD13_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_ATTR_SMOD), uint16_t) & BM_DMA_TCD13_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD13_ATTR_SMOD(v)   (HW_DMA_TCD13_ATTR_WR((HW_DMA_TCD13_ATTR_RD() & ~BM_DMA_TCD13_ATTR_SMOD) | BF_DMA_TCD13_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd13_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd13_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd13_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD13_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x11a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_NBYTES_MLNO           (*(__IO hw_dma_tcd13_nbytes_mlno_t *) HW_DMA_TCD13_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD13_NBYTES_MLNO_RD()      (HW_DMA_TCD13_NBYTES_MLNO.U)
#define HW_DMA_TCD13_NBYTES_MLNO_WR(v)     (HW_DMA_TCD13_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD13_NBYTES_MLNO_SET(v)    (HW_DMA_TCD13_NBYTES_MLNO_WR(HW_DMA_TCD13_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD13_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD13_NBYTES_MLNO_WR(HW_DMA_TCD13_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD13_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD13_NBYTES_MLNO_WR(HW_DMA_TCD13_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD13_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD13_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD13_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD13_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD13_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD13_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD13_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD13_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD13_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD13_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD13_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD13_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD13_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD13_NBYTES_MLNO_WR((HW_DMA_TCD13_NBYTES_MLNO_RD() & ~BM_DMA_TCD13_NBYTES_MLNO_NBYTES) | BF_DMA_TCD13_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd13_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd13_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd13_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD13_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x11a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd13_nbytes_mloffno_t *) HW_DMA_TCD13_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD13_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD13_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD13_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD13_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD13_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD13_NBYTES_MLOFFNO_WR(HW_DMA_TCD13_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD13_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD13_NBYTES_MLOFFNO_WR(HW_DMA_TCD13_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD13_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD13_NBYTES_MLOFFNO_WR(HW_DMA_TCD13_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD13_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD13_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD13_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD13_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD13_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD13_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD13_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD13_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD13_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD13_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD13_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD13_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD13_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD13_NBYTES_MLOFFNO_WR((HW_DMA_TCD13_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD13_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD13_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD13_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD13_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD13_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD13_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD13_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD13_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD13_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD13_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD13_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD13_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD13_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD13_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD13_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD13_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD13_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD13_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD13_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD13_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD13_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD13_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD13_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD13_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD13_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD13_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD13_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD13_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD13_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD13_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD13_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD13_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD13_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd13_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd13_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd13_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD13_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x11a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd13_nbytes_mloffyes_t *) HW_DMA_TCD13_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD13_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD13_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD13_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD13_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD13_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD13_NBYTES_MLOFFYES_WR(HW_DMA_TCD13_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD13_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD13_NBYTES_MLOFFYES_WR(HW_DMA_TCD13_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD13_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD13_NBYTES_MLOFFYES_WR(HW_DMA_TCD13_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD13_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD13_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD13_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD13_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD13_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD13_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD13_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD13_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD13_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD13_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD13_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD13_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD13_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD13_NBYTES_MLOFFYES_WR((HW_DMA_TCD13_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD13_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD13_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD13_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD13_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD13_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD13_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD13_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD13_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD13_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD13_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD13_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD13_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD13_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD13_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD13_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD13_NBYTES_MLOFFYES_WR((HW_DMA_TCD13_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD13_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD13_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD13_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD13_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD13_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD13_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD13_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD13_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD13_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD13_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD13_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD13_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD13_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD13_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD13_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD13_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD13_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD13_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD13_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD13_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD13_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD13_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD13_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD13_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD13_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD13_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD13_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD13_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD13_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD13_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD13_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD13_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD13_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd13_slast
{
    uint32_t U;
    struct _hw_dma_tcd13_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd13_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_SLAST register
 */
//@{
#define HW_DMA_TCD13_SLAST_ADDR      (REGS_DMA_BASE + 0x11acU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_SLAST           (*(__IO hw_dma_tcd13_slast_t *) HW_DMA_TCD13_SLAST_ADDR)
#define HW_DMA_TCD13_SLAST_RD()      (HW_DMA_TCD13_SLAST.U)
#define HW_DMA_TCD13_SLAST_WR(v)     (HW_DMA_TCD13_SLAST.U = (v))
#define HW_DMA_TCD13_SLAST_SET(v)    (HW_DMA_TCD13_SLAST_WR(HW_DMA_TCD13_SLAST_RD() |  (v)))
#define HW_DMA_TCD13_SLAST_CLR(v)    (HW_DMA_TCD13_SLAST_WR(HW_DMA_TCD13_SLAST_RD() & ~(v)))
#define HW_DMA_TCD13_SLAST_TOG(v)    (HW_DMA_TCD13_SLAST_WR(HW_DMA_TCD13_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_SLAST bitfields
 */

/*! @name Register DMA_TCD13_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD13_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD13_SLAST_SLAST.
#define BM_DMA_TCD13_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD13_SLAST_SLAST.
#define BS_DMA_TCD13_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD13_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_SLAST_SLAST field.
#define BR_DMA_TCD13_SLAST_SLAST()   (HW_DMA_TCD13_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD13_SLAST_SLAST.
#define BF_DMA_TCD13_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_SLAST_SLAST), uint32_t) & BM_DMA_TCD13_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD13_SLAST_SLAST(v)   (HW_DMA_TCD13_SLAST_WR((HW_DMA_TCD13_SLAST_RD() & ~BM_DMA_TCD13_SLAST_SLAST) | BF_DMA_TCD13_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd13_daddr
{
    uint32_t U;
    struct _hw_dma_tcd13_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd13_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_DADDR register
 */
//@{
#define HW_DMA_TCD13_DADDR_ADDR      (REGS_DMA_BASE + 0x11b0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_DADDR           (*(__IO hw_dma_tcd13_daddr_t *) HW_DMA_TCD13_DADDR_ADDR)
#define HW_DMA_TCD13_DADDR_RD()      (HW_DMA_TCD13_DADDR.U)
#define HW_DMA_TCD13_DADDR_WR(v)     (HW_DMA_TCD13_DADDR.U = (v))
#define HW_DMA_TCD13_DADDR_SET(v)    (HW_DMA_TCD13_DADDR_WR(HW_DMA_TCD13_DADDR_RD() |  (v)))
#define HW_DMA_TCD13_DADDR_CLR(v)    (HW_DMA_TCD13_DADDR_WR(HW_DMA_TCD13_DADDR_RD() & ~(v)))
#define HW_DMA_TCD13_DADDR_TOG(v)    (HW_DMA_TCD13_DADDR_WR(HW_DMA_TCD13_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_DADDR bitfields
 */

/*! @name Register DMA_TCD13_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD13_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD13_DADDR_DADDR.
#define BM_DMA_TCD13_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD13_DADDR_DADDR.
#define BS_DMA_TCD13_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD13_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_DADDR_DADDR field.
#define BR_DMA_TCD13_DADDR_DADDR()   (HW_DMA_TCD13_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD13_DADDR_DADDR.
#define BF_DMA_TCD13_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_DADDR_DADDR), uint32_t) & BM_DMA_TCD13_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD13_DADDR_DADDR(v)   (HW_DMA_TCD13_DADDR_WR((HW_DMA_TCD13_DADDR_RD() & ~BM_DMA_TCD13_DADDR_DADDR) | BF_DMA_TCD13_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd13_doff
{
    uint16_t U;
    struct _hw_dma_tcd13_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd13_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_DOFF register
 */
//@{
#define HW_DMA_TCD13_DOFF_ADDR      (REGS_DMA_BASE + 0x11b4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_DOFF           (*(__IO hw_dma_tcd13_doff_t *) HW_DMA_TCD13_DOFF_ADDR)
#define HW_DMA_TCD13_DOFF_RD()      (HW_DMA_TCD13_DOFF.U)
#define HW_DMA_TCD13_DOFF_WR(v)     (HW_DMA_TCD13_DOFF.U = (v))
#define HW_DMA_TCD13_DOFF_SET(v)    (HW_DMA_TCD13_DOFF_WR(HW_DMA_TCD13_DOFF_RD() |  (v)))
#define HW_DMA_TCD13_DOFF_CLR(v)    (HW_DMA_TCD13_DOFF_WR(HW_DMA_TCD13_DOFF_RD() & ~(v)))
#define HW_DMA_TCD13_DOFF_TOG(v)    (HW_DMA_TCD13_DOFF_WR(HW_DMA_TCD13_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_DOFF bitfields
 */

/*! @name Register DMA_TCD13_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD13_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD13_DOFF_DOFF.
#define BM_DMA_TCD13_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD13_DOFF_DOFF.
#define BS_DMA_TCD13_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD13_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_DOFF_DOFF field.
#define BR_DMA_TCD13_DOFF_DOFF()   (HW_DMA_TCD13_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD13_DOFF_DOFF.
#define BF_DMA_TCD13_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_DOFF_DOFF), uint16_t) & BM_DMA_TCD13_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD13_DOFF_DOFF(v)   (HW_DMA_TCD13_DOFF_WR((HW_DMA_TCD13_DOFF_RD() & ~BM_DMA_TCD13_DOFF_DOFF) | BF_DMA_TCD13_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd13_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd13_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd13_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD13_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x11b6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_CITER_ELINKYES           (*(__IO hw_dma_tcd13_citer_elinkyes_t *) HW_DMA_TCD13_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD13_CITER_ELINKYES_RD()      (HW_DMA_TCD13_CITER_ELINKYES.U)
#define HW_DMA_TCD13_CITER_ELINKYES_WR(v)     (HW_DMA_TCD13_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD13_CITER_ELINKYES_SET(v)    (HW_DMA_TCD13_CITER_ELINKYES_WR(HW_DMA_TCD13_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD13_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD13_CITER_ELINKYES_WR(HW_DMA_TCD13_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD13_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD13_CITER_ELINKYES_WR(HW_DMA_TCD13_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD13_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD13_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD13_CITER_ELINKYES_CITER.
#define BM_DMA_TCD13_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD13_CITER_ELINKYES_CITER.
#define BS_DMA_TCD13_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD13_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD13_CITER_ELINKYES_CITER()   (HW_DMA_TCD13_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD13_CITER_ELINKYES_CITER.
#define BF_DMA_TCD13_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD13_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD13_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD13_CITER_ELINKYES_WR((HW_DMA_TCD13_CITER_ELINKYES_RD() & ~BM_DMA_TCD13_CITER_ELINKYES_CITER) | BF_DMA_TCD13_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD13_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD13_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD13_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD13_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD13_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD13_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD13_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD13_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD13_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD13_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD13_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD13_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD13_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD13_CITER_ELINKYES_WR((HW_DMA_TCD13_CITER_ELINKYES_RD() & ~BM_DMA_TCD13_CITER_ELINKYES_LINKCH) | BF_DMA_TCD13_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD13_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD13_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD13_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD13_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD13_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD13_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD13_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD13_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD13_CITER_ELINKYES_ADDR, BP_DMA_TCD13_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD13_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD13_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD13_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD13_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CITER_ELINKYES_ADDR, BP_DMA_TCD13_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd13_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd13_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd13_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD13_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x11b6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_CITER_ELINKNO           (*(__IO hw_dma_tcd13_citer_elinkno_t *) HW_DMA_TCD13_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD13_CITER_ELINKNO_RD()      (HW_DMA_TCD13_CITER_ELINKNO.U)
#define HW_DMA_TCD13_CITER_ELINKNO_WR(v)     (HW_DMA_TCD13_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD13_CITER_ELINKNO_SET(v)    (HW_DMA_TCD13_CITER_ELINKNO_WR(HW_DMA_TCD13_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD13_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD13_CITER_ELINKNO_WR(HW_DMA_TCD13_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD13_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD13_CITER_ELINKNO_WR(HW_DMA_TCD13_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD13_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD13_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD13_CITER_ELINKNO_CITER.
#define BM_DMA_TCD13_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD13_CITER_ELINKNO_CITER.
#define BS_DMA_TCD13_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD13_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD13_CITER_ELINKNO_CITER()   (HW_DMA_TCD13_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD13_CITER_ELINKNO_CITER.
#define BF_DMA_TCD13_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD13_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD13_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD13_CITER_ELINKNO_WR((HW_DMA_TCD13_CITER_ELINKNO_RD() & ~BM_DMA_TCD13_CITER_ELINKNO_CITER) | BF_DMA_TCD13_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD13_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD13_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD13_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD13_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD13_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD13_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD13_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD13_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD13_CITER_ELINKNO_ADDR, BP_DMA_TCD13_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD13_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD13_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD13_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD13_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CITER_ELINKNO_ADDR, BP_DMA_TCD13_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd13_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd13_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd13_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_DLASTSGA register
 */
//@{
#define HW_DMA_TCD13_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x11b8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_DLASTSGA           (*(__IO hw_dma_tcd13_dlastsga_t *) HW_DMA_TCD13_DLASTSGA_ADDR)
#define HW_DMA_TCD13_DLASTSGA_RD()      (HW_DMA_TCD13_DLASTSGA.U)
#define HW_DMA_TCD13_DLASTSGA_WR(v)     (HW_DMA_TCD13_DLASTSGA.U = (v))
#define HW_DMA_TCD13_DLASTSGA_SET(v)    (HW_DMA_TCD13_DLASTSGA_WR(HW_DMA_TCD13_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD13_DLASTSGA_CLR(v)    (HW_DMA_TCD13_DLASTSGA_WR(HW_DMA_TCD13_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD13_DLASTSGA_TOG(v)    (HW_DMA_TCD13_DLASTSGA_WR(HW_DMA_TCD13_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD13_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD13_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD13_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD13_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD13_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD13_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD13_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD13_DLASTSGA_DLASTSGA()   (HW_DMA_TCD13_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD13_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD13_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD13_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD13_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD13_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD13_DLASTSGA_WR((HW_DMA_TCD13_DLASTSGA_RD() & ~BM_DMA_TCD13_DLASTSGA_DLASTSGA) | BF_DMA_TCD13_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd13_csr
{
    uint16_t U;
    struct _hw_dma_tcd13_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd13_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_CSR register
 */
//@{
#define HW_DMA_TCD13_CSR_ADDR      (REGS_DMA_BASE + 0x11bcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_CSR           (*(__IO hw_dma_tcd13_csr_t *) HW_DMA_TCD13_CSR_ADDR)
#define HW_DMA_TCD13_CSR_RD()      (HW_DMA_TCD13_CSR.U)
#define HW_DMA_TCD13_CSR_WR(v)     (HW_DMA_TCD13_CSR.U = (v))
#define HW_DMA_TCD13_CSR_SET(v)    (HW_DMA_TCD13_CSR_WR(HW_DMA_TCD13_CSR_RD() |  (v)))
#define HW_DMA_TCD13_CSR_CLR(v)    (HW_DMA_TCD13_CSR_WR(HW_DMA_TCD13_CSR_RD() & ~(v)))
#define HW_DMA_TCD13_CSR_TOG(v)    (HW_DMA_TCD13_CSR_WR(HW_DMA_TCD13_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_CSR bitfields
 */

/*! @name Register DMA_TCD13_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD13_CSR_START      (0U)      //!< Bit position for DMA_TCD13_CSR_START.
#define BM_DMA_TCD13_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD13_CSR_START.
#define BS_DMA_TCD13_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD13_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_START field.
#define BR_DMA_TCD13_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_START.
#define BF_DMA_TCD13_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_START), uint16_t) & BM_DMA_TCD13_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD13_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD13_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD13_CSR_INTMAJOR.
#define BM_DMA_TCD13_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD13_CSR_INTMAJOR.
#define BS_DMA_TCD13_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD13_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_INTMAJOR field.
#define BR_DMA_TCD13_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_INTMAJOR.
#define BF_DMA_TCD13_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD13_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD13_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD13_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD13_CSR_INTHALF.
#define BM_DMA_TCD13_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD13_CSR_INTHALF.
#define BS_DMA_TCD13_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD13_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_INTHALF field.
#define BR_DMA_TCD13_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_INTHALF.
#define BF_DMA_TCD13_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_INTHALF), uint16_t) & BM_DMA_TCD13_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD13_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD13_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD13_CSR_DREQ.
#define BM_DMA_TCD13_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD13_CSR_DREQ.
#define BS_DMA_TCD13_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD13_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_DREQ field.
#define BR_DMA_TCD13_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_DREQ.
#define BF_DMA_TCD13_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_DREQ), uint16_t) & BM_DMA_TCD13_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD13_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD13_CSR_ESG      (4U)      //!< Bit position for DMA_TCD13_CSR_ESG.
#define BM_DMA_TCD13_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD13_CSR_ESG.
#define BS_DMA_TCD13_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD13_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_ESG field.
#define BR_DMA_TCD13_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_ESG.
#define BF_DMA_TCD13_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_ESG), uint16_t) & BM_DMA_TCD13_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD13_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD13_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD13_CSR_MAJORELINK.
#define BM_DMA_TCD13_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD13_CSR_MAJORELINK.
#define BS_DMA_TCD13_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD13_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_MAJORELINK field.
#define BR_DMA_TCD13_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_MAJORELINK.
#define BF_DMA_TCD13_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD13_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD13_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD13_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD13_CSR_ACTIVE.
#define BM_DMA_TCD13_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD13_CSR_ACTIVE.
#define BS_DMA_TCD13_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD13_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_ACTIVE field.
#define BR_DMA_TCD13_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_ACTIVE.
#define BF_DMA_TCD13_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_ACTIVE), uint16_t) & BM_DMA_TCD13_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD13_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD13_CSR_DONE      (7U)      //!< Bit position for DMA_TCD13_CSR_DONE.
#define BM_DMA_TCD13_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD13_CSR_DONE.
#define BS_DMA_TCD13_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD13_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_DONE field.
#define BR_DMA_TCD13_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_DONE.
#define BF_DMA_TCD13_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_DONE), uint16_t) & BM_DMA_TCD13_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD13_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_CSR_ADDR, BP_DMA_TCD13_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD13_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD13_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD13_CSR_MAJORLINKCH.
#define BM_DMA_TCD13_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD13_CSR_MAJORLINKCH.
#define BS_DMA_TCD13_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD13_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_MAJORLINKCH field.
#define BR_DMA_TCD13_CSR_MAJORLINKCH()   (HW_DMA_TCD13_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_MAJORLINKCH.
#define BF_DMA_TCD13_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD13_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD13_CSR_MAJORLINKCH(v)   (HW_DMA_TCD13_CSR_WR((HW_DMA_TCD13_CSR_RD() & ~BM_DMA_TCD13_CSR_MAJORLINKCH) | BF_DMA_TCD13_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD13_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD13_CSR_BWC      (14U)      //!< Bit position for DMA_TCD13_CSR_BWC.
#define BM_DMA_TCD13_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD13_CSR_BWC.
#define BS_DMA_TCD13_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD13_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_CSR_BWC field.
#define BR_DMA_TCD13_CSR_BWC()   (HW_DMA_TCD13_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD13_CSR_BWC.
#define BF_DMA_TCD13_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_CSR_BWC), uint16_t) & BM_DMA_TCD13_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD13_CSR_BWC(v)   (HW_DMA_TCD13_CSR_WR((HW_DMA_TCD13_CSR_RD() & ~BM_DMA_TCD13_CSR_BWC) | BF_DMA_TCD13_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd13_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd13_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd13_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD13_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x11beU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_BITER_ELINKYES           (*(__IO hw_dma_tcd13_biter_elinkyes_t *) HW_DMA_TCD13_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD13_BITER_ELINKYES_RD()      (HW_DMA_TCD13_BITER_ELINKYES.U)
#define HW_DMA_TCD13_BITER_ELINKYES_WR(v)     (HW_DMA_TCD13_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD13_BITER_ELINKYES_SET(v)    (HW_DMA_TCD13_BITER_ELINKYES_WR(HW_DMA_TCD13_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD13_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD13_BITER_ELINKYES_WR(HW_DMA_TCD13_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD13_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD13_BITER_ELINKYES_WR(HW_DMA_TCD13_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD13_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD13_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD13_BITER_ELINKYES_BITER.
#define BM_DMA_TCD13_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD13_BITER_ELINKYES_BITER.
#define BS_DMA_TCD13_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD13_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD13_BITER_ELINKYES_BITER()   (HW_DMA_TCD13_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD13_BITER_ELINKYES_BITER.
#define BF_DMA_TCD13_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD13_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD13_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD13_BITER_ELINKYES_WR((HW_DMA_TCD13_BITER_ELINKYES_RD() & ~BM_DMA_TCD13_BITER_ELINKYES_BITER) | BF_DMA_TCD13_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD13_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD13_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD13_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD13_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD13_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD13_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD13_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD13_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD13_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD13_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD13_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD13_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD13_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD13_BITER_ELINKYES_WR((HW_DMA_TCD13_BITER_ELINKYES_RD() & ~BM_DMA_TCD13_BITER_ELINKYES_LINKCH) | BF_DMA_TCD13_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD13_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD13_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD13_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD13_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD13_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD13_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD13_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD13_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD13_BITER_ELINKYES_ADDR, BP_DMA_TCD13_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD13_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD13_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD13_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD13_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_BITER_ELINKYES_ADDR, BP_DMA_TCD13_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD13_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD13_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd13_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd13_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd13_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD13_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD13_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x11beU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD13_BITER_ELINKNO           (*(__IO hw_dma_tcd13_biter_elinkno_t *) HW_DMA_TCD13_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD13_BITER_ELINKNO_RD()      (HW_DMA_TCD13_BITER_ELINKNO.U)
#define HW_DMA_TCD13_BITER_ELINKNO_WR(v)     (HW_DMA_TCD13_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD13_BITER_ELINKNO_SET(v)    (HW_DMA_TCD13_BITER_ELINKNO_WR(HW_DMA_TCD13_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD13_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD13_BITER_ELINKNO_WR(HW_DMA_TCD13_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD13_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD13_BITER_ELINKNO_WR(HW_DMA_TCD13_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD13_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD13_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD13_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD13_BITER_ELINKNO_BITER.
#define BM_DMA_TCD13_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD13_BITER_ELINKNO_BITER.
#define BS_DMA_TCD13_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD13_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD13_BITER_ELINKNO_BITER()   (HW_DMA_TCD13_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD13_BITER_ELINKNO_BITER.
#define BF_DMA_TCD13_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD13_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD13_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD13_BITER_ELINKNO_WR((HW_DMA_TCD13_BITER_ELINKNO_RD() & ~BM_DMA_TCD13_BITER_ELINKNO_BITER) | BF_DMA_TCD13_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD13_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD13_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD13_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD13_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD13_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD13_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD13_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD13_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD13_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD13_BITER_ELINKNO_ADDR, BP_DMA_TCD13_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD13_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD13_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD13_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD13_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD13_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD13_BITER_ELINKNO_ADDR, BP_DMA_TCD13_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd14_saddr
{
    uint32_t U;
    struct _hw_dma_tcd14_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd14_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_SADDR register
 */
//@{
#define HW_DMA_TCD14_SADDR_ADDR      (REGS_DMA_BASE + 0x11c0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_SADDR           (*(__IO hw_dma_tcd14_saddr_t *) HW_DMA_TCD14_SADDR_ADDR)
#define HW_DMA_TCD14_SADDR_RD()      (HW_DMA_TCD14_SADDR.U)
#define HW_DMA_TCD14_SADDR_WR(v)     (HW_DMA_TCD14_SADDR.U = (v))
#define HW_DMA_TCD14_SADDR_SET(v)    (HW_DMA_TCD14_SADDR_WR(HW_DMA_TCD14_SADDR_RD() |  (v)))
#define HW_DMA_TCD14_SADDR_CLR(v)    (HW_DMA_TCD14_SADDR_WR(HW_DMA_TCD14_SADDR_RD() & ~(v)))
#define HW_DMA_TCD14_SADDR_TOG(v)    (HW_DMA_TCD14_SADDR_WR(HW_DMA_TCD14_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_SADDR bitfields
 */

/*! @name Register DMA_TCD14_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD14_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD14_SADDR_SADDR.
#define BM_DMA_TCD14_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD14_SADDR_SADDR.
#define BS_DMA_TCD14_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD14_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_SADDR_SADDR field.
#define BR_DMA_TCD14_SADDR_SADDR()   (HW_DMA_TCD14_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD14_SADDR_SADDR.
#define BF_DMA_TCD14_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_SADDR_SADDR), uint32_t) & BM_DMA_TCD14_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD14_SADDR_SADDR(v)   (HW_DMA_TCD14_SADDR_WR((HW_DMA_TCD14_SADDR_RD() & ~BM_DMA_TCD14_SADDR_SADDR) | BF_DMA_TCD14_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd14_soff
{
    uint16_t U;
    struct _hw_dma_tcd14_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd14_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_SOFF register
 */
//@{
#define HW_DMA_TCD14_SOFF_ADDR      (REGS_DMA_BASE + 0x11c4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_SOFF           (*(__IO hw_dma_tcd14_soff_t *) HW_DMA_TCD14_SOFF_ADDR)
#define HW_DMA_TCD14_SOFF_RD()      (HW_DMA_TCD14_SOFF.U)
#define HW_DMA_TCD14_SOFF_WR(v)     (HW_DMA_TCD14_SOFF.U = (v))
#define HW_DMA_TCD14_SOFF_SET(v)    (HW_DMA_TCD14_SOFF_WR(HW_DMA_TCD14_SOFF_RD() |  (v)))
#define HW_DMA_TCD14_SOFF_CLR(v)    (HW_DMA_TCD14_SOFF_WR(HW_DMA_TCD14_SOFF_RD() & ~(v)))
#define HW_DMA_TCD14_SOFF_TOG(v)    (HW_DMA_TCD14_SOFF_WR(HW_DMA_TCD14_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_SOFF bitfields
 */

/*! @name Register DMA_TCD14_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD14_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD14_SOFF_SOFF.
#define BM_DMA_TCD14_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD14_SOFF_SOFF.
#define BS_DMA_TCD14_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD14_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_SOFF_SOFF field.
#define BR_DMA_TCD14_SOFF_SOFF()   (HW_DMA_TCD14_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD14_SOFF_SOFF.
#define BF_DMA_TCD14_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_SOFF_SOFF), uint16_t) & BM_DMA_TCD14_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD14_SOFF_SOFF(v)   (HW_DMA_TCD14_SOFF_WR((HW_DMA_TCD14_SOFF_RD() & ~BM_DMA_TCD14_SOFF_SOFF) | BF_DMA_TCD14_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd14_attr
{
    uint16_t U;
    struct _hw_dma_tcd14_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd14_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_ATTR register
 */
//@{
#define HW_DMA_TCD14_ATTR_ADDR      (REGS_DMA_BASE + 0x11c6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_ATTR           (*(__IO hw_dma_tcd14_attr_t *) HW_DMA_TCD14_ATTR_ADDR)
#define HW_DMA_TCD14_ATTR_RD()      (HW_DMA_TCD14_ATTR.U)
#define HW_DMA_TCD14_ATTR_WR(v)     (HW_DMA_TCD14_ATTR.U = (v))
#define HW_DMA_TCD14_ATTR_SET(v)    (HW_DMA_TCD14_ATTR_WR(HW_DMA_TCD14_ATTR_RD() |  (v)))
#define HW_DMA_TCD14_ATTR_CLR(v)    (HW_DMA_TCD14_ATTR_WR(HW_DMA_TCD14_ATTR_RD() & ~(v)))
#define HW_DMA_TCD14_ATTR_TOG(v)    (HW_DMA_TCD14_ATTR_WR(HW_DMA_TCD14_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_ATTR bitfields
 */

/*! @name Register DMA_TCD14_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD14_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD14_ATTR_DSIZE.
#define BM_DMA_TCD14_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD14_ATTR_DSIZE.
#define BS_DMA_TCD14_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD14_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_ATTR_DSIZE field.
#define BR_DMA_TCD14_ATTR_DSIZE()   (HW_DMA_TCD14_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD14_ATTR_DSIZE.
#define BF_DMA_TCD14_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_ATTR_DSIZE), uint16_t) & BM_DMA_TCD14_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD14_ATTR_DSIZE(v)   (HW_DMA_TCD14_ATTR_WR((HW_DMA_TCD14_ATTR_RD() & ~BM_DMA_TCD14_ATTR_DSIZE) | BF_DMA_TCD14_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD14_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD14_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD14_ATTR_DMOD.
#define BM_DMA_TCD14_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD14_ATTR_DMOD.
#define BS_DMA_TCD14_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD14_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_ATTR_DMOD field.
#define BR_DMA_TCD14_ATTR_DMOD()   (HW_DMA_TCD14_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD14_ATTR_DMOD.
#define BF_DMA_TCD14_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_ATTR_DMOD), uint16_t) & BM_DMA_TCD14_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD14_ATTR_DMOD(v)   (HW_DMA_TCD14_ATTR_WR((HW_DMA_TCD14_ATTR_RD() & ~BM_DMA_TCD14_ATTR_DMOD) | BF_DMA_TCD14_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD14_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD14_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD14_ATTR_SSIZE.
#define BM_DMA_TCD14_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD14_ATTR_SSIZE.
#define BS_DMA_TCD14_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD14_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_ATTR_SSIZE field.
#define BR_DMA_TCD14_ATTR_SSIZE()   (HW_DMA_TCD14_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD14_ATTR_SSIZE.
#define BF_DMA_TCD14_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_ATTR_SSIZE), uint16_t) & BM_DMA_TCD14_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD14_ATTR_SSIZE(v)   (HW_DMA_TCD14_ATTR_WR((HW_DMA_TCD14_ATTR_RD() & ~BM_DMA_TCD14_ATTR_SSIZE) | BF_DMA_TCD14_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD14_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD14_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD14_ATTR_SMOD.
#define BM_DMA_TCD14_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD14_ATTR_SMOD.
#define BS_DMA_TCD14_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD14_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_ATTR_SMOD field.
#define BR_DMA_TCD14_ATTR_SMOD()   (HW_DMA_TCD14_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD14_ATTR_SMOD.
#define BF_DMA_TCD14_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_ATTR_SMOD), uint16_t) & BM_DMA_TCD14_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD14_ATTR_SMOD(v)   (HW_DMA_TCD14_ATTR_WR((HW_DMA_TCD14_ATTR_RD() & ~BM_DMA_TCD14_ATTR_SMOD) | BF_DMA_TCD14_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd14_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd14_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd14_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD14_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x11c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_NBYTES_MLNO           (*(__IO hw_dma_tcd14_nbytes_mlno_t *) HW_DMA_TCD14_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD14_NBYTES_MLNO_RD()      (HW_DMA_TCD14_NBYTES_MLNO.U)
#define HW_DMA_TCD14_NBYTES_MLNO_WR(v)     (HW_DMA_TCD14_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD14_NBYTES_MLNO_SET(v)    (HW_DMA_TCD14_NBYTES_MLNO_WR(HW_DMA_TCD14_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD14_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD14_NBYTES_MLNO_WR(HW_DMA_TCD14_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD14_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD14_NBYTES_MLNO_WR(HW_DMA_TCD14_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD14_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD14_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD14_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD14_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD14_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD14_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD14_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD14_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD14_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD14_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD14_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD14_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD14_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD14_NBYTES_MLNO_WR((HW_DMA_TCD14_NBYTES_MLNO_RD() & ~BM_DMA_TCD14_NBYTES_MLNO_NBYTES) | BF_DMA_TCD14_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd14_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd14_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd14_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD14_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x11c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd14_nbytes_mloffno_t *) HW_DMA_TCD14_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD14_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD14_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD14_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD14_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD14_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD14_NBYTES_MLOFFNO_WR(HW_DMA_TCD14_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD14_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD14_NBYTES_MLOFFNO_WR(HW_DMA_TCD14_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD14_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD14_NBYTES_MLOFFNO_WR(HW_DMA_TCD14_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD14_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD14_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD14_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD14_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD14_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD14_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD14_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD14_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD14_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD14_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD14_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD14_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD14_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD14_NBYTES_MLOFFNO_WR((HW_DMA_TCD14_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD14_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD14_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD14_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD14_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD14_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD14_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD14_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD14_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD14_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD14_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD14_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD14_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD14_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD14_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD14_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD14_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD14_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD14_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD14_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD14_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD14_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD14_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD14_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD14_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD14_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD14_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD14_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD14_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD14_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD14_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD14_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD14_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD14_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd14_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd14_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd14_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD14_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x11c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd14_nbytes_mloffyes_t *) HW_DMA_TCD14_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD14_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD14_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD14_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD14_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD14_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD14_NBYTES_MLOFFYES_WR(HW_DMA_TCD14_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD14_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD14_NBYTES_MLOFFYES_WR(HW_DMA_TCD14_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD14_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD14_NBYTES_MLOFFYES_WR(HW_DMA_TCD14_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD14_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD14_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD14_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD14_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD14_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD14_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD14_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD14_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD14_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD14_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD14_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD14_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD14_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD14_NBYTES_MLOFFYES_WR((HW_DMA_TCD14_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD14_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD14_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD14_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD14_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD14_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD14_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD14_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD14_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD14_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD14_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD14_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD14_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD14_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD14_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD14_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD14_NBYTES_MLOFFYES_WR((HW_DMA_TCD14_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD14_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD14_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD14_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD14_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD14_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD14_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD14_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD14_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD14_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD14_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD14_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD14_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD14_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD14_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD14_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD14_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD14_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD14_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD14_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD14_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD14_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD14_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD14_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD14_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD14_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD14_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD14_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD14_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD14_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD14_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD14_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD14_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD14_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd14_slast
{
    uint32_t U;
    struct _hw_dma_tcd14_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd14_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_SLAST register
 */
//@{
#define HW_DMA_TCD14_SLAST_ADDR      (REGS_DMA_BASE + 0x11ccU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_SLAST           (*(__IO hw_dma_tcd14_slast_t *) HW_DMA_TCD14_SLAST_ADDR)
#define HW_DMA_TCD14_SLAST_RD()      (HW_DMA_TCD14_SLAST.U)
#define HW_DMA_TCD14_SLAST_WR(v)     (HW_DMA_TCD14_SLAST.U = (v))
#define HW_DMA_TCD14_SLAST_SET(v)    (HW_DMA_TCD14_SLAST_WR(HW_DMA_TCD14_SLAST_RD() |  (v)))
#define HW_DMA_TCD14_SLAST_CLR(v)    (HW_DMA_TCD14_SLAST_WR(HW_DMA_TCD14_SLAST_RD() & ~(v)))
#define HW_DMA_TCD14_SLAST_TOG(v)    (HW_DMA_TCD14_SLAST_WR(HW_DMA_TCD14_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_SLAST bitfields
 */

/*! @name Register DMA_TCD14_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD14_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD14_SLAST_SLAST.
#define BM_DMA_TCD14_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD14_SLAST_SLAST.
#define BS_DMA_TCD14_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD14_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_SLAST_SLAST field.
#define BR_DMA_TCD14_SLAST_SLAST()   (HW_DMA_TCD14_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD14_SLAST_SLAST.
#define BF_DMA_TCD14_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_SLAST_SLAST), uint32_t) & BM_DMA_TCD14_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD14_SLAST_SLAST(v)   (HW_DMA_TCD14_SLAST_WR((HW_DMA_TCD14_SLAST_RD() & ~BM_DMA_TCD14_SLAST_SLAST) | BF_DMA_TCD14_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd14_daddr
{
    uint32_t U;
    struct _hw_dma_tcd14_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd14_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_DADDR register
 */
//@{
#define HW_DMA_TCD14_DADDR_ADDR      (REGS_DMA_BASE + 0x11d0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_DADDR           (*(__IO hw_dma_tcd14_daddr_t *) HW_DMA_TCD14_DADDR_ADDR)
#define HW_DMA_TCD14_DADDR_RD()      (HW_DMA_TCD14_DADDR.U)
#define HW_DMA_TCD14_DADDR_WR(v)     (HW_DMA_TCD14_DADDR.U = (v))
#define HW_DMA_TCD14_DADDR_SET(v)    (HW_DMA_TCD14_DADDR_WR(HW_DMA_TCD14_DADDR_RD() |  (v)))
#define HW_DMA_TCD14_DADDR_CLR(v)    (HW_DMA_TCD14_DADDR_WR(HW_DMA_TCD14_DADDR_RD() & ~(v)))
#define HW_DMA_TCD14_DADDR_TOG(v)    (HW_DMA_TCD14_DADDR_WR(HW_DMA_TCD14_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_DADDR bitfields
 */

/*! @name Register DMA_TCD14_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD14_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD14_DADDR_DADDR.
#define BM_DMA_TCD14_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD14_DADDR_DADDR.
#define BS_DMA_TCD14_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD14_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_DADDR_DADDR field.
#define BR_DMA_TCD14_DADDR_DADDR()   (HW_DMA_TCD14_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD14_DADDR_DADDR.
#define BF_DMA_TCD14_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_DADDR_DADDR), uint32_t) & BM_DMA_TCD14_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD14_DADDR_DADDR(v)   (HW_DMA_TCD14_DADDR_WR((HW_DMA_TCD14_DADDR_RD() & ~BM_DMA_TCD14_DADDR_DADDR) | BF_DMA_TCD14_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd14_doff
{
    uint16_t U;
    struct _hw_dma_tcd14_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd14_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_DOFF register
 */
//@{
#define HW_DMA_TCD14_DOFF_ADDR      (REGS_DMA_BASE + 0x11d4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_DOFF           (*(__IO hw_dma_tcd14_doff_t *) HW_DMA_TCD14_DOFF_ADDR)
#define HW_DMA_TCD14_DOFF_RD()      (HW_DMA_TCD14_DOFF.U)
#define HW_DMA_TCD14_DOFF_WR(v)     (HW_DMA_TCD14_DOFF.U = (v))
#define HW_DMA_TCD14_DOFF_SET(v)    (HW_DMA_TCD14_DOFF_WR(HW_DMA_TCD14_DOFF_RD() |  (v)))
#define HW_DMA_TCD14_DOFF_CLR(v)    (HW_DMA_TCD14_DOFF_WR(HW_DMA_TCD14_DOFF_RD() & ~(v)))
#define HW_DMA_TCD14_DOFF_TOG(v)    (HW_DMA_TCD14_DOFF_WR(HW_DMA_TCD14_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_DOFF bitfields
 */

/*! @name Register DMA_TCD14_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD14_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD14_DOFF_DOFF.
#define BM_DMA_TCD14_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD14_DOFF_DOFF.
#define BS_DMA_TCD14_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD14_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_DOFF_DOFF field.
#define BR_DMA_TCD14_DOFF_DOFF()   (HW_DMA_TCD14_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD14_DOFF_DOFF.
#define BF_DMA_TCD14_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_DOFF_DOFF), uint16_t) & BM_DMA_TCD14_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD14_DOFF_DOFF(v)   (HW_DMA_TCD14_DOFF_WR((HW_DMA_TCD14_DOFF_RD() & ~BM_DMA_TCD14_DOFF_DOFF) | BF_DMA_TCD14_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd14_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd14_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd14_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD14_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x11d6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_CITER_ELINKYES           (*(__IO hw_dma_tcd14_citer_elinkyes_t *) HW_DMA_TCD14_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD14_CITER_ELINKYES_RD()      (HW_DMA_TCD14_CITER_ELINKYES.U)
#define HW_DMA_TCD14_CITER_ELINKYES_WR(v)     (HW_DMA_TCD14_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD14_CITER_ELINKYES_SET(v)    (HW_DMA_TCD14_CITER_ELINKYES_WR(HW_DMA_TCD14_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD14_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD14_CITER_ELINKYES_WR(HW_DMA_TCD14_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD14_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD14_CITER_ELINKYES_WR(HW_DMA_TCD14_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD14_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD14_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD14_CITER_ELINKYES_CITER.
#define BM_DMA_TCD14_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD14_CITER_ELINKYES_CITER.
#define BS_DMA_TCD14_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD14_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD14_CITER_ELINKYES_CITER()   (HW_DMA_TCD14_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD14_CITER_ELINKYES_CITER.
#define BF_DMA_TCD14_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD14_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD14_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD14_CITER_ELINKYES_WR((HW_DMA_TCD14_CITER_ELINKYES_RD() & ~BM_DMA_TCD14_CITER_ELINKYES_CITER) | BF_DMA_TCD14_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD14_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD14_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD14_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD14_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD14_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD14_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD14_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD14_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD14_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD14_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD14_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD14_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD14_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD14_CITER_ELINKYES_WR((HW_DMA_TCD14_CITER_ELINKYES_RD() & ~BM_DMA_TCD14_CITER_ELINKYES_LINKCH) | BF_DMA_TCD14_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD14_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD14_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD14_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD14_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD14_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD14_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD14_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD14_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD14_CITER_ELINKYES_ADDR, BP_DMA_TCD14_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD14_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD14_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD14_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD14_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CITER_ELINKYES_ADDR, BP_DMA_TCD14_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd14_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd14_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd14_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD14_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x11d6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_CITER_ELINKNO           (*(__IO hw_dma_tcd14_citer_elinkno_t *) HW_DMA_TCD14_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD14_CITER_ELINKNO_RD()      (HW_DMA_TCD14_CITER_ELINKNO.U)
#define HW_DMA_TCD14_CITER_ELINKNO_WR(v)     (HW_DMA_TCD14_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD14_CITER_ELINKNO_SET(v)    (HW_DMA_TCD14_CITER_ELINKNO_WR(HW_DMA_TCD14_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD14_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD14_CITER_ELINKNO_WR(HW_DMA_TCD14_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD14_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD14_CITER_ELINKNO_WR(HW_DMA_TCD14_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD14_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD14_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD14_CITER_ELINKNO_CITER.
#define BM_DMA_TCD14_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD14_CITER_ELINKNO_CITER.
#define BS_DMA_TCD14_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD14_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD14_CITER_ELINKNO_CITER()   (HW_DMA_TCD14_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD14_CITER_ELINKNO_CITER.
#define BF_DMA_TCD14_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD14_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD14_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD14_CITER_ELINKNO_WR((HW_DMA_TCD14_CITER_ELINKNO_RD() & ~BM_DMA_TCD14_CITER_ELINKNO_CITER) | BF_DMA_TCD14_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD14_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD14_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD14_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD14_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD14_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD14_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD14_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD14_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD14_CITER_ELINKNO_ADDR, BP_DMA_TCD14_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD14_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD14_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD14_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD14_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CITER_ELINKNO_ADDR, BP_DMA_TCD14_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd14_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd14_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd14_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_DLASTSGA register
 */
//@{
#define HW_DMA_TCD14_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x11d8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_DLASTSGA           (*(__IO hw_dma_tcd14_dlastsga_t *) HW_DMA_TCD14_DLASTSGA_ADDR)
#define HW_DMA_TCD14_DLASTSGA_RD()      (HW_DMA_TCD14_DLASTSGA.U)
#define HW_DMA_TCD14_DLASTSGA_WR(v)     (HW_DMA_TCD14_DLASTSGA.U = (v))
#define HW_DMA_TCD14_DLASTSGA_SET(v)    (HW_DMA_TCD14_DLASTSGA_WR(HW_DMA_TCD14_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD14_DLASTSGA_CLR(v)    (HW_DMA_TCD14_DLASTSGA_WR(HW_DMA_TCD14_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD14_DLASTSGA_TOG(v)    (HW_DMA_TCD14_DLASTSGA_WR(HW_DMA_TCD14_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD14_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD14_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD14_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD14_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD14_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD14_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD14_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD14_DLASTSGA_DLASTSGA()   (HW_DMA_TCD14_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD14_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD14_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD14_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD14_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD14_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD14_DLASTSGA_WR((HW_DMA_TCD14_DLASTSGA_RD() & ~BM_DMA_TCD14_DLASTSGA_DLASTSGA) | BF_DMA_TCD14_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd14_csr
{
    uint16_t U;
    struct _hw_dma_tcd14_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd14_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_CSR register
 */
//@{
#define HW_DMA_TCD14_CSR_ADDR      (REGS_DMA_BASE + 0x11dcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_CSR           (*(__IO hw_dma_tcd14_csr_t *) HW_DMA_TCD14_CSR_ADDR)
#define HW_DMA_TCD14_CSR_RD()      (HW_DMA_TCD14_CSR.U)
#define HW_DMA_TCD14_CSR_WR(v)     (HW_DMA_TCD14_CSR.U = (v))
#define HW_DMA_TCD14_CSR_SET(v)    (HW_DMA_TCD14_CSR_WR(HW_DMA_TCD14_CSR_RD() |  (v)))
#define HW_DMA_TCD14_CSR_CLR(v)    (HW_DMA_TCD14_CSR_WR(HW_DMA_TCD14_CSR_RD() & ~(v)))
#define HW_DMA_TCD14_CSR_TOG(v)    (HW_DMA_TCD14_CSR_WR(HW_DMA_TCD14_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_CSR bitfields
 */

/*! @name Register DMA_TCD14_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD14_CSR_START      (0U)      //!< Bit position for DMA_TCD14_CSR_START.
#define BM_DMA_TCD14_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD14_CSR_START.
#define BS_DMA_TCD14_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD14_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_START field.
#define BR_DMA_TCD14_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_START.
#define BF_DMA_TCD14_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_START), uint16_t) & BM_DMA_TCD14_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD14_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD14_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD14_CSR_INTMAJOR.
#define BM_DMA_TCD14_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD14_CSR_INTMAJOR.
#define BS_DMA_TCD14_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD14_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_INTMAJOR field.
#define BR_DMA_TCD14_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_INTMAJOR.
#define BF_DMA_TCD14_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD14_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD14_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD14_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD14_CSR_INTHALF.
#define BM_DMA_TCD14_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD14_CSR_INTHALF.
#define BS_DMA_TCD14_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD14_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_INTHALF field.
#define BR_DMA_TCD14_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_INTHALF.
#define BF_DMA_TCD14_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_INTHALF), uint16_t) & BM_DMA_TCD14_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD14_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD14_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD14_CSR_DREQ.
#define BM_DMA_TCD14_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD14_CSR_DREQ.
#define BS_DMA_TCD14_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD14_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_DREQ field.
#define BR_DMA_TCD14_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_DREQ.
#define BF_DMA_TCD14_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_DREQ), uint16_t) & BM_DMA_TCD14_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD14_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD14_CSR_ESG      (4U)      //!< Bit position for DMA_TCD14_CSR_ESG.
#define BM_DMA_TCD14_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD14_CSR_ESG.
#define BS_DMA_TCD14_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD14_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_ESG field.
#define BR_DMA_TCD14_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_ESG.
#define BF_DMA_TCD14_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_ESG), uint16_t) & BM_DMA_TCD14_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD14_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD14_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD14_CSR_MAJORELINK.
#define BM_DMA_TCD14_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD14_CSR_MAJORELINK.
#define BS_DMA_TCD14_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD14_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_MAJORELINK field.
#define BR_DMA_TCD14_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_MAJORELINK.
#define BF_DMA_TCD14_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD14_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD14_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD14_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD14_CSR_ACTIVE.
#define BM_DMA_TCD14_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD14_CSR_ACTIVE.
#define BS_DMA_TCD14_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD14_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_ACTIVE field.
#define BR_DMA_TCD14_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_ACTIVE.
#define BF_DMA_TCD14_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_ACTIVE), uint16_t) & BM_DMA_TCD14_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD14_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD14_CSR_DONE      (7U)      //!< Bit position for DMA_TCD14_CSR_DONE.
#define BM_DMA_TCD14_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD14_CSR_DONE.
#define BS_DMA_TCD14_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD14_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_DONE field.
#define BR_DMA_TCD14_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_DONE.
#define BF_DMA_TCD14_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_DONE), uint16_t) & BM_DMA_TCD14_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD14_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_CSR_ADDR, BP_DMA_TCD14_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD14_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD14_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD14_CSR_MAJORLINKCH.
#define BM_DMA_TCD14_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD14_CSR_MAJORLINKCH.
#define BS_DMA_TCD14_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD14_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_MAJORLINKCH field.
#define BR_DMA_TCD14_CSR_MAJORLINKCH()   (HW_DMA_TCD14_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_MAJORLINKCH.
#define BF_DMA_TCD14_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD14_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD14_CSR_MAJORLINKCH(v)   (HW_DMA_TCD14_CSR_WR((HW_DMA_TCD14_CSR_RD() & ~BM_DMA_TCD14_CSR_MAJORLINKCH) | BF_DMA_TCD14_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD14_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD14_CSR_BWC      (14U)      //!< Bit position for DMA_TCD14_CSR_BWC.
#define BM_DMA_TCD14_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD14_CSR_BWC.
#define BS_DMA_TCD14_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD14_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_CSR_BWC field.
#define BR_DMA_TCD14_CSR_BWC()   (HW_DMA_TCD14_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD14_CSR_BWC.
#define BF_DMA_TCD14_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_CSR_BWC), uint16_t) & BM_DMA_TCD14_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD14_CSR_BWC(v)   (HW_DMA_TCD14_CSR_WR((HW_DMA_TCD14_CSR_RD() & ~BM_DMA_TCD14_CSR_BWC) | BF_DMA_TCD14_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd14_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd14_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd14_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD14_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x11deU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_BITER_ELINKYES           (*(__IO hw_dma_tcd14_biter_elinkyes_t *) HW_DMA_TCD14_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD14_BITER_ELINKYES_RD()      (HW_DMA_TCD14_BITER_ELINKYES.U)
#define HW_DMA_TCD14_BITER_ELINKYES_WR(v)     (HW_DMA_TCD14_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD14_BITER_ELINKYES_SET(v)    (HW_DMA_TCD14_BITER_ELINKYES_WR(HW_DMA_TCD14_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD14_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD14_BITER_ELINKYES_WR(HW_DMA_TCD14_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD14_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD14_BITER_ELINKYES_WR(HW_DMA_TCD14_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD14_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD14_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD14_BITER_ELINKYES_BITER.
#define BM_DMA_TCD14_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD14_BITER_ELINKYES_BITER.
#define BS_DMA_TCD14_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD14_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD14_BITER_ELINKYES_BITER()   (HW_DMA_TCD14_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD14_BITER_ELINKYES_BITER.
#define BF_DMA_TCD14_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD14_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD14_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD14_BITER_ELINKYES_WR((HW_DMA_TCD14_BITER_ELINKYES_RD() & ~BM_DMA_TCD14_BITER_ELINKYES_BITER) | BF_DMA_TCD14_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD14_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD14_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD14_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD14_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD14_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD14_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD14_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD14_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD14_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD14_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD14_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD14_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD14_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD14_BITER_ELINKYES_WR((HW_DMA_TCD14_BITER_ELINKYES_RD() & ~BM_DMA_TCD14_BITER_ELINKYES_LINKCH) | BF_DMA_TCD14_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD14_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD14_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD14_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD14_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD14_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD14_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD14_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD14_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD14_BITER_ELINKYES_ADDR, BP_DMA_TCD14_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD14_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD14_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD14_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD14_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_BITER_ELINKYES_ADDR, BP_DMA_TCD14_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD14_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD14_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd14_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd14_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd14_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD14_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD14_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x11deU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD14_BITER_ELINKNO           (*(__IO hw_dma_tcd14_biter_elinkno_t *) HW_DMA_TCD14_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD14_BITER_ELINKNO_RD()      (HW_DMA_TCD14_BITER_ELINKNO.U)
#define HW_DMA_TCD14_BITER_ELINKNO_WR(v)     (HW_DMA_TCD14_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD14_BITER_ELINKNO_SET(v)    (HW_DMA_TCD14_BITER_ELINKNO_WR(HW_DMA_TCD14_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD14_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD14_BITER_ELINKNO_WR(HW_DMA_TCD14_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD14_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD14_BITER_ELINKNO_WR(HW_DMA_TCD14_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD14_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD14_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD14_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD14_BITER_ELINKNO_BITER.
#define BM_DMA_TCD14_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD14_BITER_ELINKNO_BITER.
#define BS_DMA_TCD14_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD14_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD14_BITER_ELINKNO_BITER()   (HW_DMA_TCD14_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD14_BITER_ELINKNO_BITER.
#define BF_DMA_TCD14_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD14_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD14_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD14_BITER_ELINKNO_WR((HW_DMA_TCD14_BITER_ELINKNO_RD() & ~BM_DMA_TCD14_BITER_ELINKNO_BITER) | BF_DMA_TCD14_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD14_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD14_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD14_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD14_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD14_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD14_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD14_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD14_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD14_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD14_BITER_ELINKNO_ADDR, BP_DMA_TCD14_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD14_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD14_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD14_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD14_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD14_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD14_BITER_ELINKNO_ADDR, BP_DMA_TCD14_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd15_saddr
{
    uint32_t U;
    struct _hw_dma_tcd15_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd15_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_SADDR register
 */
//@{
#define HW_DMA_TCD15_SADDR_ADDR      (REGS_DMA_BASE + 0x11e0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_SADDR           (*(__IO hw_dma_tcd15_saddr_t *) HW_DMA_TCD15_SADDR_ADDR)
#define HW_DMA_TCD15_SADDR_RD()      (HW_DMA_TCD15_SADDR.U)
#define HW_DMA_TCD15_SADDR_WR(v)     (HW_DMA_TCD15_SADDR.U = (v))
#define HW_DMA_TCD15_SADDR_SET(v)    (HW_DMA_TCD15_SADDR_WR(HW_DMA_TCD15_SADDR_RD() |  (v)))
#define HW_DMA_TCD15_SADDR_CLR(v)    (HW_DMA_TCD15_SADDR_WR(HW_DMA_TCD15_SADDR_RD() & ~(v)))
#define HW_DMA_TCD15_SADDR_TOG(v)    (HW_DMA_TCD15_SADDR_WR(HW_DMA_TCD15_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_SADDR bitfields
 */

/*! @name Register DMA_TCD15_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD15_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD15_SADDR_SADDR.
#define BM_DMA_TCD15_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD15_SADDR_SADDR.
#define BS_DMA_TCD15_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD15_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_SADDR_SADDR field.
#define BR_DMA_TCD15_SADDR_SADDR()   (HW_DMA_TCD15_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD15_SADDR_SADDR.
#define BF_DMA_TCD15_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_SADDR_SADDR), uint32_t) & BM_DMA_TCD15_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD15_SADDR_SADDR(v)   (HW_DMA_TCD15_SADDR_WR((HW_DMA_TCD15_SADDR_RD() & ~BM_DMA_TCD15_SADDR_SADDR) | BF_DMA_TCD15_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd15_soff
{
    uint16_t U;
    struct _hw_dma_tcd15_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd15_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_SOFF register
 */
//@{
#define HW_DMA_TCD15_SOFF_ADDR      (REGS_DMA_BASE + 0x11e4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_SOFF           (*(__IO hw_dma_tcd15_soff_t *) HW_DMA_TCD15_SOFF_ADDR)
#define HW_DMA_TCD15_SOFF_RD()      (HW_DMA_TCD15_SOFF.U)
#define HW_DMA_TCD15_SOFF_WR(v)     (HW_DMA_TCD15_SOFF.U = (v))
#define HW_DMA_TCD15_SOFF_SET(v)    (HW_DMA_TCD15_SOFF_WR(HW_DMA_TCD15_SOFF_RD() |  (v)))
#define HW_DMA_TCD15_SOFF_CLR(v)    (HW_DMA_TCD15_SOFF_WR(HW_DMA_TCD15_SOFF_RD() & ~(v)))
#define HW_DMA_TCD15_SOFF_TOG(v)    (HW_DMA_TCD15_SOFF_WR(HW_DMA_TCD15_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_SOFF bitfields
 */

/*! @name Register DMA_TCD15_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD15_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD15_SOFF_SOFF.
#define BM_DMA_TCD15_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD15_SOFF_SOFF.
#define BS_DMA_TCD15_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD15_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_SOFF_SOFF field.
#define BR_DMA_TCD15_SOFF_SOFF()   (HW_DMA_TCD15_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD15_SOFF_SOFF.
#define BF_DMA_TCD15_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_SOFF_SOFF), uint16_t) & BM_DMA_TCD15_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD15_SOFF_SOFF(v)   (HW_DMA_TCD15_SOFF_WR((HW_DMA_TCD15_SOFF_RD() & ~BM_DMA_TCD15_SOFF_SOFF) | BF_DMA_TCD15_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd15_attr
{
    uint16_t U;
    struct _hw_dma_tcd15_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd15_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_ATTR register
 */
//@{
#define HW_DMA_TCD15_ATTR_ADDR      (REGS_DMA_BASE + 0x11e6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_ATTR           (*(__IO hw_dma_tcd15_attr_t *) HW_DMA_TCD15_ATTR_ADDR)
#define HW_DMA_TCD15_ATTR_RD()      (HW_DMA_TCD15_ATTR.U)
#define HW_DMA_TCD15_ATTR_WR(v)     (HW_DMA_TCD15_ATTR.U = (v))
#define HW_DMA_TCD15_ATTR_SET(v)    (HW_DMA_TCD15_ATTR_WR(HW_DMA_TCD15_ATTR_RD() |  (v)))
#define HW_DMA_TCD15_ATTR_CLR(v)    (HW_DMA_TCD15_ATTR_WR(HW_DMA_TCD15_ATTR_RD() & ~(v)))
#define HW_DMA_TCD15_ATTR_TOG(v)    (HW_DMA_TCD15_ATTR_WR(HW_DMA_TCD15_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_ATTR bitfields
 */

/*! @name Register DMA_TCD15_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD15_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD15_ATTR_DSIZE.
#define BM_DMA_TCD15_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD15_ATTR_DSIZE.
#define BS_DMA_TCD15_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD15_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_ATTR_DSIZE field.
#define BR_DMA_TCD15_ATTR_DSIZE()   (HW_DMA_TCD15_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD15_ATTR_DSIZE.
#define BF_DMA_TCD15_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_ATTR_DSIZE), uint16_t) & BM_DMA_TCD15_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD15_ATTR_DSIZE(v)   (HW_DMA_TCD15_ATTR_WR((HW_DMA_TCD15_ATTR_RD() & ~BM_DMA_TCD15_ATTR_DSIZE) | BF_DMA_TCD15_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD15_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD15_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD15_ATTR_DMOD.
#define BM_DMA_TCD15_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD15_ATTR_DMOD.
#define BS_DMA_TCD15_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD15_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_ATTR_DMOD field.
#define BR_DMA_TCD15_ATTR_DMOD()   (HW_DMA_TCD15_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD15_ATTR_DMOD.
#define BF_DMA_TCD15_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_ATTR_DMOD), uint16_t) & BM_DMA_TCD15_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD15_ATTR_DMOD(v)   (HW_DMA_TCD15_ATTR_WR((HW_DMA_TCD15_ATTR_RD() & ~BM_DMA_TCD15_ATTR_DMOD) | BF_DMA_TCD15_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD15_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD15_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD15_ATTR_SSIZE.
#define BM_DMA_TCD15_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD15_ATTR_SSIZE.
#define BS_DMA_TCD15_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD15_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_ATTR_SSIZE field.
#define BR_DMA_TCD15_ATTR_SSIZE()   (HW_DMA_TCD15_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD15_ATTR_SSIZE.
#define BF_DMA_TCD15_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_ATTR_SSIZE), uint16_t) & BM_DMA_TCD15_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD15_ATTR_SSIZE(v)   (HW_DMA_TCD15_ATTR_WR((HW_DMA_TCD15_ATTR_RD() & ~BM_DMA_TCD15_ATTR_SSIZE) | BF_DMA_TCD15_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD15_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD15_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD15_ATTR_SMOD.
#define BM_DMA_TCD15_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD15_ATTR_SMOD.
#define BS_DMA_TCD15_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD15_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_ATTR_SMOD field.
#define BR_DMA_TCD15_ATTR_SMOD()   (HW_DMA_TCD15_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD15_ATTR_SMOD.
#define BF_DMA_TCD15_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_ATTR_SMOD), uint16_t) & BM_DMA_TCD15_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD15_ATTR_SMOD(v)   (HW_DMA_TCD15_ATTR_WR((HW_DMA_TCD15_ATTR_RD() & ~BM_DMA_TCD15_ATTR_SMOD) | BF_DMA_TCD15_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd15_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd15_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd15_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD15_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x11e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_NBYTES_MLNO           (*(__IO hw_dma_tcd15_nbytes_mlno_t *) HW_DMA_TCD15_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD15_NBYTES_MLNO_RD()      (HW_DMA_TCD15_NBYTES_MLNO.U)
#define HW_DMA_TCD15_NBYTES_MLNO_WR(v)     (HW_DMA_TCD15_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD15_NBYTES_MLNO_SET(v)    (HW_DMA_TCD15_NBYTES_MLNO_WR(HW_DMA_TCD15_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD15_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD15_NBYTES_MLNO_WR(HW_DMA_TCD15_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD15_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD15_NBYTES_MLNO_WR(HW_DMA_TCD15_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD15_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD15_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD15_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD15_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD15_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD15_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD15_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD15_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD15_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD15_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD15_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD15_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD15_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD15_NBYTES_MLNO_WR((HW_DMA_TCD15_NBYTES_MLNO_RD() & ~BM_DMA_TCD15_NBYTES_MLNO_NBYTES) | BF_DMA_TCD15_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd15_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd15_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd15_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD15_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x11e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd15_nbytes_mloffno_t *) HW_DMA_TCD15_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD15_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD15_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD15_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD15_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD15_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD15_NBYTES_MLOFFNO_WR(HW_DMA_TCD15_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD15_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD15_NBYTES_MLOFFNO_WR(HW_DMA_TCD15_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD15_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD15_NBYTES_MLOFFNO_WR(HW_DMA_TCD15_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD15_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD15_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD15_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD15_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD15_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD15_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD15_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD15_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD15_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD15_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD15_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD15_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD15_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD15_NBYTES_MLOFFNO_WR((HW_DMA_TCD15_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD15_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD15_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD15_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD15_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD15_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD15_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD15_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD15_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD15_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD15_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD15_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD15_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD15_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD15_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD15_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD15_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD15_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD15_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD15_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD15_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD15_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD15_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD15_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD15_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD15_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD15_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD15_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD15_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD15_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD15_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD15_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD15_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD15_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd15_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd15_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd15_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD15_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x11e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd15_nbytes_mloffyes_t *) HW_DMA_TCD15_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD15_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD15_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD15_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD15_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD15_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD15_NBYTES_MLOFFYES_WR(HW_DMA_TCD15_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD15_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD15_NBYTES_MLOFFYES_WR(HW_DMA_TCD15_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD15_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD15_NBYTES_MLOFFYES_WR(HW_DMA_TCD15_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD15_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD15_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD15_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD15_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD15_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD15_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD15_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD15_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD15_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD15_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD15_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD15_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD15_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD15_NBYTES_MLOFFYES_WR((HW_DMA_TCD15_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD15_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD15_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD15_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD15_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD15_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD15_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD15_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD15_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD15_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD15_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD15_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD15_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD15_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD15_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD15_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD15_NBYTES_MLOFFYES_WR((HW_DMA_TCD15_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD15_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD15_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD15_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD15_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD15_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD15_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD15_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD15_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD15_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD15_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD15_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD15_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD15_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD15_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD15_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD15_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD15_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD15_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD15_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD15_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD15_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD15_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD15_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD15_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD15_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD15_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD15_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD15_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD15_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD15_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD15_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD15_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD15_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd15_slast
{
    uint32_t U;
    struct _hw_dma_tcd15_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd15_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_SLAST register
 */
//@{
#define HW_DMA_TCD15_SLAST_ADDR      (REGS_DMA_BASE + 0x11ecU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_SLAST           (*(__IO hw_dma_tcd15_slast_t *) HW_DMA_TCD15_SLAST_ADDR)
#define HW_DMA_TCD15_SLAST_RD()      (HW_DMA_TCD15_SLAST.U)
#define HW_DMA_TCD15_SLAST_WR(v)     (HW_DMA_TCD15_SLAST.U = (v))
#define HW_DMA_TCD15_SLAST_SET(v)    (HW_DMA_TCD15_SLAST_WR(HW_DMA_TCD15_SLAST_RD() |  (v)))
#define HW_DMA_TCD15_SLAST_CLR(v)    (HW_DMA_TCD15_SLAST_WR(HW_DMA_TCD15_SLAST_RD() & ~(v)))
#define HW_DMA_TCD15_SLAST_TOG(v)    (HW_DMA_TCD15_SLAST_WR(HW_DMA_TCD15_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_SLAST bitfields
 */

/*! @name Register DMA_TCD15_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD15_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD15_SLAST_SLAST.
#define BM_DMA_TCD15_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD15_SLAST_SLAST.
#define BS_DMA_TCD15_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD15_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_SLAST_SLAST field.
#define BR_DMA_TCD15_SLAST_SLAST()   (HW_DMA_TCD15_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD15_SLAST_SLAST.
#define BF_DMA_TCD15_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_SLAST_SLAST), uint32_t) & BM_DMA_TCD15_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD15_SLAST_SLAST(v)   (HW_DMA_TCD15_SLAST_WR((HW_DMA_TCD15_SLAST_RD() & ~BM_DMA_TCD15_SLAST_SLAST) | BF_DMA_TCD15_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd15_daddr
{
    uint32_t U;
    struct _hw_dma_tcd15_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd15_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_DADDR register
 */
//@{
#define HW_DMA_TCD15_DADDR_ADDR      (REGS_DMA_BASE + 0x11f0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_DADDR           (*(__IO hw_dma_tcd15_daddr_t *) HW_DMA_TCD15_DADDR_ADDR)
#define HW_DMA_TCD15_DADDR_RD()      (HW_DMA_TCD15_DADDR.U)
#define HW_DMA_TCD15_DADDR_WR(v)     (HW_DMA_TCD15_DADDR.U = (v))
#define HW_DMA_TCD15_DADDR_SET(v)    (HW_DMA_TCD15_DADDR_WR(HW_DMA_TCD15_DADDR_RD() |  (v)))
#define HW_DMA_TCD15_DADDR_CLR(v)    (HW_DMA_TCD15_DADDR_WR(HW_DMA_TCD15_DADDR_RD() & ~(v)))
#define HW_DMA_TCD15_DADDR_TOG(v)    (HW_DMA_TCD15_DADDR_WR(HW_DMA_TCD15_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_DADDR bitfields
 */

/*! @name Register DMA_TCD15_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD15_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD15_DADDR_DADDR.
#define BM_DMA_TCD15_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD15_DADDR_DADDR.
#define BS_DMA_TCD15_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD15_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_DADDR_DADDR field.
#define BR_DMA_TCD15_DADDR_DADDR()   (HW_DMA_TCD15_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD15_DADDR_DADDR.
#define BF_DMA_TCD15_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_DADDR_DADDR), uint32_t) & BM_DMA_TCD15_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD15_DADDR_DADDR(v)   (HW_DMA_TCD15_DADDR_WR((HW_DMA_TCD15_DADDR_RD() & ~BM_DMA_TCD15_DADDR_DADDR) | BF_DMA_TCD15_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd15_doff
{
    uint16_t U;
    struct _hw_dma_tcd15_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd15_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_DOFF register
 */
//@{
#define HW_DMA_TCD15_DOFF_ADDR      (REGS_DMA_BASE + 0x11f4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_DOFF           (*(__IO hw_dma_tcd15_doff_t *) HW_DMA_TCD15_DOFF_ADDR)
#define HW_DMA_TCD15_DOFF_RD()      (HW_DMA_TCD15_DOFF.U)
#define HW_DMA_TCD15_DOFF_WR(v)     (HW_DMA_TCD15_DOFF.U = (v))
#define HW_DMA_TCD15_DOFF_SET(v)    (HW_DMA_TCD15_DOFF_WR(HW_DMA_TCD15_DOFF_RD() |  (v)))
#define HW_DMA_TCD15_DOFF_CLR(v)    (HW_DMA_TCD15_DOFF_WR(HW_DMA_TCD15_DOFF_RD() & ~(v)))
#define HW_DMA_TCD15_DOFF_TOG(v)    (HW_DMA_TCD15_DOFF_WR(HW_DMA_TCD15_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_DOFF bitfields
 */

/*! @name Register DMA_TCD15_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD15_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD15_DOFF_DOFF.
#define BM_DMA_TCD15_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD15_DOFF_DOFF.
#define BS_DMA_TCD15_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD15_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_DOFF_DOFF field.
#define BR_DMA_TCD15_DOFF_DOFF()   (HW_DMA_TCD15_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD15_DOFF_DOFF.
#define BF_DMA_TCD15_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_DOFF_DOFF), uint16_t) & BM_DMA_TCD15_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD15_DOFF_DOFF(v)   (HW_DMA_TCD15_DOFF_WR((HW_DMA_TCD15_DOFF_RD() & ~BM_DMA_TCD15_DOFF_DOFF) | BF_DMA_TCD15_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd15_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd15_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd15_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD15_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x11f6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_CITER_ELINKYES           (*(__IO hw_dma_tcd15_citer_elinkyes_t *) HW_DMA_TCD15_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD15_CITER_ELINKYES_RD()      (HW_DMA_TCD15_CITER_ELINKYES.U)
#define HW_DMA_TCD15_CITER_ELINKYES_WR(v)     (HW_DMA_TCD15_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD15_CITER_ELINKYES_SET(v)    (HW_DMA_TCD15_CITER_ELINKYES_WR(HW_DMA_TCD15_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD15_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD15_CITER_ELINKYES_WR(HW_DMA_TCD15_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD15_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD15_CITER_ELINKYES_WR(HW_DMA_TCD15_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD15_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD15_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD15_CITER_ELINKYES_CITER.
#define BM_DMA_TCD15_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD15_CITER_ELINKYES_CITER.
#define BS_DMA_TCD15_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD15_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD15_CITER_ELINKYES_CITER()   (HW_DMA_TCD15_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD15_CITER_ELINKYES_CITER.
#define BF_DMA_TCD15_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD15_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD15_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD15_CITER_ELINKYES_WR((HW_DMA_TCD15_CITER_ELINKYES_RD() & ~BM_DMA_TCD15_CITER_ELINKYES_CITER) | BF_DMA_TCD15_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD15_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD15_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD15_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD15_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD15_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD15_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD15_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD15_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD15_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD15_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD15_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD15_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD15_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD15_CITER_ELINKYES_WR((HW_DMA_TCD15_CITER_ELINKYES_RD() & ~BM_DMA_TCD15_CITER_ELINKYES_LINKCH) | BF_DMA_TCD15_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD15_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD15_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD15_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD15_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD15_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD15_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD15_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD15_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD15_CITER_ELINKYES_ADDR, BP_DMA_TCD15_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD15_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD15_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD15_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD15_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CITER_ELINKYES_ADDR, BP_DMA_TCD15_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd15_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd15_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd15_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD15_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x11f6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_CITER_ELINKNO           (*(__IO hw_dma_tcd15_citer_elinkno_t *) HW_DMA_TCD15_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD15_CITER_ELINKNO_RD()      (HW_DMA_TCD15_CITER_ELINKNO.U)
#define HW_DMA_TCD15_CITER_ELINKNO_WR(v)     (HW_DMA_TCD15_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD15_CITER_ELINKNO_SET(v)    (HW_DMA_TCD15_CITER_ELINKNO_WR(HW_DMA_TCD15_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD15_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD15_CITER_ELINKNO_WR(HW_DMA_TCD15_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD15_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD15_CITER_ELINKNO_WR(HW_DMA_TCD15_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD15_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD15_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD15_CITER_ELINKNO_CITER.
#define BM_DMA_TCD15_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD15_CITER_ELINKNO_CITER.
#define BS_DMA_TCD15_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD15_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD15_CITER_ELINKNO_CITER()   (HW_DMA_TCD15_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD15_CITER_ELINKNO_CITER.
#define BF_DMA_TCD15_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD15_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD15_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD15_CITER_ELINKNO_WR((HW_DMA_TCD15_CITER_ELINKNO_RD() & ~BM_DMA_TCD15_CITER_ELINKNO_CITER) | BF_DMA_TCD15_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD15_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD15_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD15_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD15_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD15_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD15_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD15_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD15_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD15_CITER_ELINKNO_ADDR, BP_DMA_TCD15_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD15_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD15_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD15_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD15_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CITER_ELINKNO_ADDR, BP_DMA_TCD15_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd15_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd15_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd15_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_DLASTSGA register
 */
//@{
#define HW_DMA_TCD15_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x11f8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_DLASTSGA           (*(__IO hw_dma_tcd15_dlastsga_t *) HW_DMA_TCD15_DLASTSGA_ADDR)
#define HW_DMA_TCD15_DLASTSGA_RD()      (HW_DMA_TCD15_DLASTSGA.U)
#define HW_DMA_TCD15_DLASTSGA_WR(v)     (HW_DMA_TCD15_DLASTSGA.U = (v))
#define HW_DMA_TCD15_DLASTSGA_SET(v)    (HW_DMA_TCD15_DLASTSGA_WR(HW_DMA_TCD15_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD15_DLASTSGA_CLR(v)    (HW_DMA_TCD15_DLASTSGA_WR(HW_DMA_TCD15_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD15_DLASTSGA_TOG(v)    (HW_DMA_TCD15_DLASTSGA_WR(HW_DMA_TCD15_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD15_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD15_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD15_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD15_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD15_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD15_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD15_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD15_DLASTSGA_DLASTSGA()   (HW_DMA_TCD15_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD15_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD15_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD15_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD15_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD15_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD15_DLASTSGA_WR((HW_DMA_TCD15_DLASTSGA_RD() & ~BM_DMA_TCD15_DLASTSGA_DLASTSGA) | BF_DMA_TCD15_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd15_csr
{
    uint16_t U;
    struct _hw_dma_tcd15_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd15_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_CSR register
 */
//@{
#define HW_DMA_TCD15_CSR_ADDR      (REGS_DMA_BASE + 0x11fcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_CSR           (*(__IO hw_dma_tcd15_csr_t *) HW_DMA_TCD15_CSR_ADDR)
#define HW_DMA_TCD15_CSR_RD()      (HW_DMA_TCD15_CSR.U)
#define HW_DMA_TCD15_CSR_WR(v)     (HW_DMA_TCD15_CSR.U = (v))
#define HW_DMA_TCD15_CSR_SET(v)    (HW_DMA_TCD15_CSR_WR(HW_DMA_TCD15_CSR_RD() |  (v)))
#define HW_DMA_TCD15_CSR_CLR(v)    (HW_DMA_TCD15_CSR_WR(HW_DMA_TCD15_CSR_RD() & ~(v)))
#define HW_DMA_TCD15_CSR_TOG(v)    (HW_DMA_TCD15_CSR_WR(HW_DMA_TCD15_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_CSR bitfields
 */

/*! @name Register DMA_TCD15_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD15_CSR_START      (0U)      //!< Bit position for DMA_TCD15_CSR_START.
#define BM_DMA_TCD15_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD15_CSR_START.
#define BS_DMA_TCD15_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD15_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_START field.
#define BR_DMA_TCD15_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_START.
#define BF_DMA_TCD15_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_START), uint16_t) & BM_DMA_TCD15_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD15_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD15_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD15_CSR_INTMAJOR.
#define BM_DMA_TCD15_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD15_CSR_INTMAJOR.
#define BS_DMA_TCD15_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD15_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_INTMAJOR field.
#define BR_DMA_TCD15_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_INTMAJOR.
#define BF_DMA_TCD15_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD15_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD15_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD15_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD15_CSR_INTHALF.
#define BM_DMA_TCD15_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD15_CSR_INTHALF.
#define BS_DMA_TCD15_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD15_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_INTHALF field.
#define BR_DMA_TCD15_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_INTHALF.
#define BF_DMA_TCD15_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_INTHALF), uint16_t) & BM_DMA_TCD15_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD15_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD15_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD15_CSR_DREQ.
#define BM_DMA_TCD15_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD15_CSR_DREQ.
#define BS_DMA_TCD15_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD15_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_DREQ field.
#define BR_DMA_TCD15_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_DREQ.
#define BF_DMA_TCD15_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_DREQ), uint16_t) & BM_DMA_TCD15_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD15_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD15_CSR_ESG      (4U)      //!< Bit position for DMA_TCD15_CSR_ESG.
#define BM_DMA_TCD15_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD15_CSR_ESG.
#define BS_DMA_TCD15_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD15_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_ESG field.
#define BR_DMA_TCD15_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_ESG.
#define BF_DMA_TCD15_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_ESG), uint16_t) & BM_DMA_TCD15_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD15_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD15_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD15_CSR_MAJORELINK.
#define BM_DMA_TCD15_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD15_CSR_MAJORELINK.
#define BS_DMA_TCD15_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD15_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_MAJORELINK field.
#define BR_DMA_TCD15_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_MAJORELINK.
#define BF_DMA_TCD15_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD15_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD15_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD15_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD15_CSR_ACTIVE.
#define BM_DMA_TCD15_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD15_CSR_ACTIVE.
#define BS_DMA_TCD15_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD15_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_ACTIVE field.
#define BR_DMA_TCD15_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_ACTIVE.
#define BF_DMA_TCD15_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_ACTIVE), uint16_t) & BM_DMA_TCD15_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD15_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD15_CSR_DONE      (7U)      //!< Bit position for DMA_TCD15_CSR_DONE.
#define BM_DMA_TCD15_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD15_CSR_DONE.
#define BS_DMA_TCD15_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD15_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_DONE field.
#define BR_DMA_TCD15_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_DONE.
#define BF_DMA_TCD15_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_DONE), uint16_t) & BM_DMA_TCD15_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD15_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_CSR_ADDR, BP_DMA_TCD15_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD15_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD15_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD15_CSR_MAJORLINKCH.
#define BM_DMA_TCD15_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD15_CSR_MAJORLINKCH.
#define BS_DMA_TCD15_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD15_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_MAJORLINKCH field.
#define BR_DMA_TCD15_CSR_MAJORLINKCH()   (HW_DMA_TCD15_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_MAJORLINKCH.
#define BF_DMA_TCD15_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD15_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD15_CSR_MAJORLINKCH(v)   (HW_DMA_TCD15_CSR_WR((HW_DMA_TCD15_CSR_RD() & ~BM_DMA_TCD15_CSR_MAJORLINKCH) | BF_DMA_TCD15_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD15_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD15_CSR_BWC      (14U)      //!< Bit position for DMA_TCD15_CSR_BWC.
#define BM_DMA_TCD15_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD15_CSR_BWC.
#define BS_DMA_TCD15_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD15_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_CSR_BWC field.
#define BR_DMA_TCD15_CSR_BWC()   (HW_DMA_TCD15_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD15_CSR_BWC.
#define BF_DMA_TCD15_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_CSR_BWC), uint16_t) & BM_DMA_TCD15_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD15_CSR_BWC(v)   (HW_DMA_TCD15_CSR_WR((HW_DMA_TCD15_CSR_RD() & ~BM_DMA_TCD15_CSR_BWC) | BF_DMA_TCD15_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd15_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd15_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd15_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD15_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x11feU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_BITER_ELINKYES           (*(__IO hw_dma_tcd15_biter_elinkyes_t *) HW_DMA_TCD15_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD15_BITER_ELINKYES_RD()      (HW_DMA_TCD15_BITER_ELINKYES.U)
#define HW_DMA_TCD15_BITER_ELINKYES_WR(v)     (HW_DMA_TCD15_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD15_BITER_ELINKYES_SET(v)    (HW_DMA_TCD15_BITER_ELINKYES_WR(HW_DMA_TCD15_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD15_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD15_BITER_ELINKYES_WR(HW_DMA_TCD15_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD15_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD15_BITER_ELINKYES_WR(HW_DMA_TCD15_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD15_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD15_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD15_BITER_ELINKYES_BITER.
#define BM_DMA_TCD15_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD15_BITER_ELINKYES_BITER.
#define BS_DMA_TCD15_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD15_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD15_BITER_ELINKYES_BITER()   (HW_DMA_TCD15_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD15_BITER_ELINKYES_BITER.
#define BF_DMA_TCD15_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD15_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD15_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD15_BITER_ELINKYES_WR((HW_DMA_TCD15_BITER_ELINKYES_RD() & ~BM_DMA_TCD15_BITER_ELINKYES_BITER) | BF_DMA_TCD15_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD15_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD15_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD15_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD15_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD15_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD15_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD15_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD15_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD15_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD15_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD15_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD15_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD15_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD15_BITER_ELINKYES_WR((HW_DMA_TCD15_BITER_ELINKYES_RD() & ~BM_DMA_TCD15_BITER_ELINKYES_LINKCH) | BF_DMA_TCD15_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD15_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD15_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD15_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD15_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD15_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD15_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD15_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD15_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD15_BITER_ELINKYES_ADDR, BP_DMA_TCD15_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD15_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD15_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD15_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD15_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_BITER_ELINKYES_ADDR, BP_DMA_TCD15_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD15_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD15_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd15_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd15_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd15_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD15_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD15_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x11feU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD15_BITER_ELINKNO           (*(__IO hw_dma_tcd15_biter_elinkno_t *) HW_DMA_TCD15_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD15_BITER_ELINKNO_RD()      (HW_DMA_TCD15_BITER_ELINKNO.U)
#define HW_DMA_TCD15_BITER_ELINKNO_WR(v)     (HW_DMA_TCD15_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD15_BITER_ELINKNO_SET(v)    (HW_DMA_TCD15_BITER_ELINKNO_WR(HW_DMA_TCD15_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD15_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD15_BITER_ELINKNO_WR(HW_DMA_TCD15_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD15_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD15_BITER_ELINKNO_WR(HW_DMA_TCD15_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD15_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD15_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD15_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD15_BITER_ELINKNO_BITER.
#define BM_DMA_TCD15_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD15_BITER_ELINKNO_BITER.
#define BS_DMA_TCD15_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD15_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD15_BITER_ELINKNO_BITER()   (HW_DMA_TCD15_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD15_BITER_ELINKNO_BITER.
#define BF_DMA_TCD15_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD15_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD15_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD15_BITER_ELINKNO_WR((HW_DMA_TCD15_BITER_ELINKNO_RD() & ~BM_DMA_TCD15_BITER_ELINKNO_BITER) | BF_DMA_TCD15_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD15_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD15_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD15_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD15_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD15_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD15_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD15_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD15_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD15_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD15_BITER_ELINKNO_ADDR, BP_DMA_TCD15_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD15_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD15_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD15_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD15_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD15_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD15_BITER_ELINKNO_ADDR, BP_DMA_TCD15_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd16_saddr
{
    uint32_t U;
    struct _hw_dma_tcd16_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd16_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_SADDR register
 */
//@{
#define HW_DMA_TCD16_SADDR_ADDR      (REGS_DMA_BASE + 0x1200U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_SADDR           (*(__IO hw_dma_tcd16_saddr_t *) HW_DMA_TCD16_SADDR_ADDR)
#define HW_DMA_TCD16_SADDR_RD()      (HW_DMA_TCD16_SADDR.U)
#define HW_DMA_TCD16_SADDR_WR(v)     (HW_DMA_TCD16_SADDR.U = (v))
#define HW_DMA_TCD16_SADDR_SET(v)    (HW_DMA_TCD16_SADDR_WR(HW_DMA_TCD16_SADDR_RD() |  (v)))
#define HW_DMA_TCD16_SADDR_CLR(v)    (HW_DMA_TCD16_SADDR_WR(HW_DMA_TCD16_SADDR_RD() & ~(v)))
#define HW_DMA_TCD16_SADDR_TOG(v)    (HW_DMA_TCD16_SADDR_WR(HW_DMA_TCD16_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_SADDR bitfields
 */

/*! @name Register DMA_TCD16_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD16_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD16_SADDR_SADDR.
#define BM_DMA_TCD16_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD16_SADDR_SADDR.
#define BS_DMA_TCD16_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD16_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_SADDR_SADDR field.
#define BR_DMA_TCD16_SADDR_SADDR()   (HW_DMA_TCD16_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD16_SADDR_SADDR.
#define BF_DMA_TCD16_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_SADDR_SADDR), uint32_t) & BM_DMA_TCD16_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD16_SADDR_SADDR(v)   (HW_DMA_TCD16_SADDR_WR((HW_DMA_TCD16_SADDR_RD() & ~BM_DMA_TCD16_SADDR_SADDR) | BF_DMA_TCD16_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd16_soff
{
    uint16_t U;
    struct _hw_dma_tcd16_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd16_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_SOFF register
 */
//@{
#define HW_DMA_TCD16_SOFF_ADDR      (REGS_DMA_BASE + 0x1204U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_SOFF           (*(__IO hw_dma_tcd16_soff_t *) HW_DMA_TCD16_SOFF_ADDR)
#define HW_DMA_TCD16_SOFF_RD()      (HW_DMA_TCD16_SOFF.U)
#define HW_DMA_TCD16_SOFF_WR(v)     (HW_DMA_TCD16_SOFF.U = (v))
#define HW_DMA_TCD16_SOFF_SET(v)    (HW_DMA_TCD16_SOFF_WR(HW_DMA_TCD16_SOFF_RD() |  (v)))
#define HW_DMA_TCD16_SOFF_CLR(v)    (HW_DMA_TCD16_SOFF_WR(HW_DMA_TCD16_SOFF_RD() & ~(v)))
#define HW_DMA_TCD16_SOFF_TOG(v)    (HW_DMA_TCD16_SOFF_WR(HW_DMA_TCD16_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_SOFF bitfields
 */

/*! @name Register DMA_TCD16_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD16_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD16_SOFF_SOFF.
#define BM_DMA_TCD16_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD16_SOFF_SOFF.
#define BS_DMA_TCD16_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD16_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_SOFF_SOFF field.
#define BR_DMA_TCD16_SOFF_SOFF()   (HW_DMA_TCD16_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD16_SOFF_SOFF.
#define BF_DMA_TCD16_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_SOFF_SOFF), uint16_t) & BM_DMA_TCD16_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD16_SOFF_SOFF(v)   (HW_DMA_TCD16_SOFF_WR((HW_DMA_TCD16_SOFF_RD() & ~BM_DMA_TCD16_SOFF_SOFF) | BF_DMA_TCD16_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd16_attr
{
    uint16_t U;
    struct _hw_dma_tcd16_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd16_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_ATTR register
 */
//@{
#define HW_DMA_TCD16_ATTR_ADDR      (REGS_DMA_BASE + 0x1206U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_ATTR           (*(__IO hw_dma_tcd16_attr_t *) HW_DMA_TCD16_ATTR_ADDR)
#define HW_DMA_TCD16_ATTR_RD()      (HW_DMA_TCD16_ATTR.U)
#define HW_DMA_TCD16_ATTR_WR(v)     (HW_DMA_TCD16_ATTR.U = (v))
#define HW_DMA_TCD16_ATTR_SET(v)    (HW_DMA_TCD16_ATTR_WR(HW_DMA_TCD16_ATTR_RD() |  (v)))
#define HW_DMA_TCD16_ATTR_CLR(v)    (HW_DMA_TCD16_ATTR_WR(HW_DMA_TCD16_ATTR_RD() & ~(v)))
#define HW_DMA_TCD16_ATTR_TOG(v)    (HW_DMA_TCD16_ATTR_WR(HW_DMA_TCD16_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_ATTR bitfields
 */

/*! @name Register DMA_TCD16_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD16_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD16_ATTR_DSIZE.
#define BM_DMA_TCD16_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD16_ATTR_DSIZE.
#define BS_DMA_TCD16_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD16_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_ATTR_DSIZE field.
#define BR_DMA_TCD16_ATTR_DSIZE()   (HW_DMA_TCD16_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD16_ATTR_DSIZE.
#define BF_DMA_TCD16_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_ATTR_DSIZE), uint16_t) & BM_DMA_TCD16_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD16_ATTR_DSIZE(v)   (HW_DMA_TCD16_ATTR_WR((HW_DMA_TCD16_ATTR_RD() & ~BM_DMA_TCD16_ATTR_DSIZE) | BF_DMA_TCD16_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD16_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD16_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD16_ATTR_DMOD.
#define BM_DMA_TCD16_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD16_ATTR_DMOD.
#define BS_DMA_TCD16_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD16_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_ATTR_DMOD field.
#define BR_DMA_TCD16_ATTR_DMOD()   (HW_DMA_TCD16_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD16_ATTR_DMOD.
#define BF_DMA_TCD16_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_ATTR_DMOD), uint16_t) & BM_DMA_TCD16_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD16_ATTR_DMOD(v)   (HW_DMA_TCD16_ATTR_WR((HW_DMA_TCD16_ATTR_RD() & ~BM_DMA_TCD16_ATTR_DMOD) | BF_DMA_TCD16_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD16_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD16_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD16_ATTR_SSIZE.
#define BM_DMA_TCD16_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD16_ATTR_SSIZE.
#define BS_DMA_TCD16_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD16_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_ATTR_SSIZE field.
#define BR_DMA_TCD16_ATTR_SSIZE()   (HW_DMA_TCD16_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD16_ATTR_SSIZE.
#define BF_DMA_TCD16_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_ATTR_SSIZE), uint16_t) & BM_DMA_TCD16_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD16_ATTR_SSIZE(v)   (HW_DMA_TCD16_ATTR_WR((HW_DMA_TCD16_ATTR_RD() & ~BM_DMA_TCD16_ATTR_SSIZE) | BF_DMA_TCD16_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD16_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD16_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD16_ATTR_SMOD.
#define BM_DMA_TCD16_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD16_ATTR_SMOD.
#define BS_DMA_TCD16_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD16_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_ATTR_SMOD field.
#define BR_DMA_TCD16_ATTR_SMOD()   (HW_DMA_TCD16_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD16_ATTR_SMOD.
#define BF_DMA_TCD16_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_ATTR_SMOD), uint16_t) & BM_DMA_TCD16_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD16_ATTR_SMOD(v)   (HW_DMA_TCD16_ATTR_WR((HW_DMA_TCD16_ATTR_RD() & ~BM_DMA_TCD16_ATTR_SMOD) | BF_DMA_TCD16_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd16_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd16_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd16_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD16_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1208U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_NBYTES_MLNO           (*(__IO hw_dma_tcd16_nbytes_mlno_t *) HW_DMA_TCD16_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD16_NBYTES_MLNO_RD()      (HW_DMA_TCD16_NBYTES_MLNO.U)
#define HW_DMA_TCD16_NBYTES_MLNO_WR(v)     (HW_DMA_TCD16_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD16_NBYTES_MLNO_SET(v)    (HW_DMA_TCD16_NBYTES_MLNO_WR(HW_DMA_TCD16_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD16_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD16_NBYTES_MLNO_WR(HW_DMA_TCD16_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD16_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD16_NBYTES_MLNO_WR(HW_DMA_TCD16_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD16_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD16_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD16_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD16_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD16_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD16_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD16_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD16_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD16_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD16_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD16_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD16_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD16_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD16_NBYTES_MLNO_WR((HW_DMA_TCD16_NBYTES_MLNO_RD() & ~BM_DMA_TCD16_NBYTES_MLNO_NBYTES) | BF_DMA_TCD16_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd16_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd16_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd16_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD16_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1208U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd16_nbytes_mloffno_t *) HW_DMA_TCD16_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD16_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD16_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD16_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD16_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD16_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD16_NBYTES_MLOFFNO_WR(HW_DMA_TCD16_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD16_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD16_NBYTES_MLOFFNO_WR(HW_DMA_TCD16_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD16_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD16_NBYTES_MLOFFNO_WR(HW_DMA_TCD16_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD16_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD16_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD16_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD16_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD16_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD16_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD16_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD16_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD16_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD16_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD16_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD16_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD16_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD16_NBYTES_MLOFFNO_WR((HW_DMA_TCD16_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD16_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD16_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD16_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD16_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD16_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD16_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD16_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD16_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD16_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD16_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD16_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD16_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD16_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD16_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD16_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD16_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD16_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD16_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD16_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD16_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD16_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD16_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD16_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD16_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD16_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD16_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD16_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD16_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD16_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD16_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD16_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD16_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD16_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd16_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd16_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd16_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD16_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1208U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd16_nbytes_mloffyes_t *) HW_DMA_TCD16_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD16_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD16_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD16_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD16_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD16_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD16_NBYTES_MLOFFYES_WR(HW_DMA_TCD16_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD16_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD16_NBYTES_MLOFFYES_WR(HW_DMA_TCD16_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD16_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD16_NBYTES_MLOFFYES_WR(HW_DMA_TCD16_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD16_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD16_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD16_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD16_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD16_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD16_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD16_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD16_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD16_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD16_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD16_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD16_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD16_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD16_NBYTES_MLOFFYES_WR((HW_DMA_TCD16_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD16_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD16_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD16_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD16_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD16_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD16_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD16_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD16_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD16_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD16_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD16_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD16_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD16_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD16_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD16_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD16_NBYTES_MLOFFYES_WR((HW_DMA_TCD16_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD16_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD16_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD16_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD16_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD16_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD16_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD16_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD16_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD16_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD16_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD16_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD16_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD16_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD16_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD16_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD16_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD16_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD16_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD16_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD16_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD16_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD16_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD16_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD16_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD16_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD16_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD16_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD16_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD16_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD16_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD16_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD16_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD16_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd16_slast
{
    uint32_t U;
    struct _hw_dma_tcd16_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd16_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_SLAST register
 */
//@{
#define HW_DMA_TCD16_SLAST_ADDR      (REGS_DMA_BASE + 0x120cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_SLAST           (*(__IO hw_dma_tcd16_slast_t *) HW_DMA_TCD16_SLAST_ADDR)
#define HW_DMA_TCD16_SLAST_RD()      (HW_DMA_TCD16_SLAST.U)
#define HW_DMA_TCD16_SLAST_WR(v)     (HW_DMA_TCD16_SLAST.U = (v))
#define HW_DMA_TCD16_SLAST_SET(v)    (HW_DMA_TCD16_SLAST_WR(HW_DMA_TCD16_SLAST_RD() |  (v)))
#define HW_DMA_TCD16_SLAST_CLR(v)    (HW_DMA_TCD16_SLAST_WR(HW_DMA_TCD16_SLAST_RD() & ~(v)))
#define HW_DMA_TCD16_SLAST_TOG(v)    (HW_DMA_TCD16_SLAST_WR(HW_DMA_TCD16_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_SLAST bitfields
 */

/*! @name Register DMA_TCD16_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD16_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD16_SLAST_SLAST.
#define BM_DMA_TCD16_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD16_SLAST_SLAST.
#define BS_DMA_TCD16_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD16_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_SLAST_SLAST field.
#define BR_DMA_TCD16_SLAST_SLAST()   (HW_DMA_TCD16_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD16_SLAST_SLAST.
#define BF_DMA_TCD16_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_SLAST_SLAST), uint32_t) & BM_DMA_TCD16_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD16_SLAST_SLAST(v)   (HW_DMA_TCD16_SLAST_WR((HW_DMA_TCD16_SLAST_RD() & ~BM_DMA_TCD16_SLAST_SLAST) | BF_DMA_TCD16_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd16_daddr
{
    uint32_t U;
    struct _hw_dma_tcd16_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd16_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_DADDR register
 */
//@{
#define HW_DMA_TCD16_DADDR_ADDR      (REGS_DMA_BASE + 0x1210U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_DADDR           (*(__IO hw_dma_tcd16_daddr_t *) HW_DMA_TCD16_DADDR_ADDR)
#define HW_DMA_TCD16_DADDR_RD()      (HW_DMA_TCD16_DADDR.U)
#define HW_DMA_TCD16_DADDR_WR(v)     (HW_DMA_TCD16_DADDR.U = (v))
#define HW_DMA_TCD16_DADDR_SET(v)    (HW_DMA_TCD16_DADDR_WR(HW_DMA_TCD16_DADDR_RD() |  (v)))
#define HW_DMA_TCD16_DADDR_CLR(v)    (HW_DMA_TCD16_DADDR_WR(HW_DMA_TCD16_DADDR_RD() & ~(v)))
#define HW_DMA_TCD16_DADDR_TOG(v)    (HW_DMA_TCD16_DADDR_WR(HW_DMA_TCD16_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_DADDR bitfields
 */

/*! @name Register DMA_TCD16_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD16_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD16_DADDR_DADDR.
#define BM_DMA_TCD16_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD16_DADDR_DADDR.
#define BS_DMA_TCD16_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD16_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_DADDR_DADDR field.
#define BR_DMA_TCD16_DADDR_DADDR()   (HW_DMA_TCD16_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD16_DADDR_DADDR.
#define BF_DMA_TCD16_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_DADDR_DADDR), uint32_t) & BM_DMA_TCD16_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD16_DADDR_DADDR(v)   (HW_DMA_TCD16_DADDR_WR((HW_DMA_TCD16_DADDR_RD() & ~BM_DMA_TCD16_DADDR_DADDR) | BF_DMA_TCD16_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd16_doff
{
    uint16_t U;
    struct _hw_dma_tcd16_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd16_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_DOFF register
 */
//@{
#define HW_DMA_TCD16_DOFF_ADDR      (REGS_DMA_BASE + 0x1214U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_DOFF           (*(__IO hw_dma_tcd16_doff_t *) HW_DMA_TCD16_DOFF_ADDR)
#define HW_DMA_TCD16_DOFF_RD()      (HW_DMA_TCD16_DOFF.U)
#define HW_DMA_TCD16_DOFF_WR(v)     (HW_DMA_TCD16_DOFF.U = (v))
#define HW_DMA_TCD16_DOFF_SET(v)    (HW_DMA_TCD16_DOFF_WR(HW_DMA_TCD16_DOFF_RD() |  (v)))
#define HW_DMA_TCD16_DOFF_CLR(v)    (HW_DMA_TCD16_DOFF_WR(HW_DMA_TCD16_DOFF_RD() & ~(v)))
#define HW_DMA_TCD16_DOFF_TOG(v)    (HW_DMA_TCD16_DOFF_WR(HW_DMA_TCD16_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_DOFF bitfields
 */

/*! @name Register DMA_TCD16_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD16_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD16_DOFF_DOFF.
#define BM_DMA_TCD16_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD16_DOFF_DOFF.
#define BS_DMA_TCD16_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD16_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_DOFF_DOFF field.
#define BR_DMA_TCD16_DOFF_DOFF()   (HW_DMA_TCD16_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD16_DOFF_DOFF.
#define BF_DMA_TCD16_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_DOFF_DOFF), uint16_t) & BM_DMA_TCD16_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD16_DOFF_DOFF(v)   (HW_DMA_TCD16_DOFF_WR((HW_DMA_TCD16_DOFF_RD() & ~BM_DMA_TCD16_DOFF_DOFF) | BF_DMA_TCD16_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd16_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd16_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd16_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD16_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1216U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_CITER_ELINKYES           (*(__IO hw_dma_tcd16_citer_elinkyes_t *) HW_DMA_TCD16_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD16_CITER_ELINKYES_RD()      (HW_DMA_TCD16_CITER_ELINKYES.U)
#define HW_DMA_TCD16_CITER_ELINKYES_WR(v)     (HW_DMA_TCD16_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD16_CITER_ELINKYES_SET(v)    (HW_DMA_TCD16_CITER_ELINKYES_WR(HW_DMA_TCD16_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD16_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD16_CITER_ELINKYES_WR(HW_DMA_TCD16_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD16_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD16_CITER_ELINKYES_WR(HW_DMA_TCD16_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD16_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD16_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD16_CITER_ELINKYES_CITER.
#define BM_DMA_TCD16_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD16_CITER_ELINKYES_CITER.
#define BS_DMA_TCD16_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD16_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD16_CITER_ELINKYES_CITER()   (HW_DMA_TCD16_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD16_CITER_ELINKYES_CITER.
#define BF_DMA_TCD16_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD16_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD16_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD16_CITER_ELINKYES_WR((HW_DMA_TCD16_CITER_ELINKYES_RD() & ~BM_DMA_TCD16_CITER_ELINKYES_CITER) | BF_DMA_TCD16_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD16_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD16_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD16_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD16_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD16_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD16_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD16_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD16_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD16_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD16_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD16_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD16_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD16_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD16_CITER_ELINKYES_WR((HW_DMA_TCD16_CITER_ELINKYES_RD() & ~BM_DMA_TCD16_CITER_ELINKYES_LINKCH) | BF_DMA_TCD16_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD16_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD16_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD16_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD16_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD16_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD16_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD16_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD16_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD16_CITER_ELINKYES_ADDR, BP_DMA_TCD16_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD16_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD16_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD16_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD16_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CITER_ELINKYES_ADDR, BP_DMA_TCD16_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd16_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd16_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd16_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD16_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1216U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_CITER_ELINKNO           (*(__IO hw_dma_tcd16_citer_elinkno_t *) HW_DMA_TCD16_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD16_CITER_ELINKNO_RD()      (HW_DMA_TCD16_CITER_ELINKNO.U)
#define HW_DMA_TCD16_CITER_ELINKNO_WR(v)     (HW_DMA_TCD16_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD16_CITER_ELINKNO_SET(v)    (HW_DMA_TCD16_CITER_ELINKNO_WR(HW_DMA_TCD16_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD16_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD16_CITER_ELINKNO_WR(HW_DMA_TCD16_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD16_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD16_CITER_ELINKNO_WR(HW_DMA_TCD16_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD16_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD16_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD16_CITER_ELINKNO_CITER.
#define BM_DMA_TCD16_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD16_CITER_ELINKNO_CITER.
#define BS_DMA_TCD16_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD16_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD16_CITER_ELINKNO_CITER()   (HW_DMA_TCD16_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD16_CITER_ELINKNO_CITER.
#define BF_DMA_TCD16_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD16_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD16_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD16_CITER_ELINKNO_WR((HW_DMA_TCD16_CITER_ELINKNO_RD() & ~BM_DMA_TCD16_CITER_ELINKNO_CITER) | BF_DMA_TCD16_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD16_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD16_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD16_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD16_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD16_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD16_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD16_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD16_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD16_CITER_ELINKNO_ADDR, BP_DMA_TCD16_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD16_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD16_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD16_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD16_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CITER_ELINKNO_ADDR, BP_DMA_TCD16_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd16_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd16_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd16_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_DLASTSGA register
 */
//@{
#define HW_DMA_TCD16_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1218U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_DLASTSGA           (*(__IO hw_dma_tcd16_dlastsga_t *) HW_DMA_TCD16_DLASTSGA_ADDR)
#define HW_DMA_TCD16_DLASTSGA_RD()      (HW_DMA_TCD16_DLASTSGA.U)
#define HW_DMA_TCD16_DLASTSGA_WR(v)     (HW_DMA_TCD16_DLASTSGA.U = (v))
#define HW_DMA_TCD16_DLASTSGA_SET(v)    (HW_DMA_TCD16_DLASTSGA_WR(HW_DMA_TCD16_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD16_DLASTSGA_CLR(v)    (HW_DMA_TCD16_DLASTSGA_WR(HW_DMA_TCD16_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD16_DLASTSGA_TOG(v)    (HW_DMA_TCD16_DLASTSGA_WR(HW_DMA_TCD16_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD16_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD16_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD16_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD16_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD16_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD16_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD16_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD16_DLASTSGA_DLASTSGA()   (HW_DMA_TCD16_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD16_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD16_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD16_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD16_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD16_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD16_DLASTSGA_WR((HW_DMA_TCD16_DLASTSGA_RD() & ~BM_DMA_TCD16_DLASTSGA_DLASTSGA) | BF_DMA_TCD16_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd16_csr
{
    uint16_t U;
    struct _hw_dma_tcd16_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd16_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_CSR register
 */
//@{
#define HW_DMA_TCD16_CSR_ADDR      (REGS_DMA_BASE + 0x121cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_CSR           (*(__IO hw_dma_tcd16_csr_t *) HW_DMA_TCD16_CSR_ADDR)
#define HW_DMA_TCD16_CSR_RD()      (HW_DMA_TCD16_CSR.U)
#define HW_DMA_TCD16_CSR_WR(v)     (HW_DMA_TCD16_CSR.U = (v))
#define HW_DMA_TCD16_CSR_SET(v)    (HW_DMA_TCD16_CSR_WR(HW_DMA_TCD16_CSR_RD() |  (v)))
#define HW_DMA_TCD16_CSR_CLR(v)    (HW_DMA_TCD16_CSR_WR(HW_DMA_TCD16_CSR_RD() & ~(v)))
#define HW_DMA_TCD16_CSR_TOG(v)    (HW_DMA_TCD16_CSR_WR(HW_DMA_TCD16_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_CSR bitfields
 */

/*! @name Register DMA_TCD16_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD16_CSR_START      (0U)      //!< Bit position for DMA_TCD16_CSR_START.
#define BM_DMA_TCD16_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD16_CSR_START.
#define BS_DMA_TCD16_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD16_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_START field.
#define BR_DMA_TCD16_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_START.
#define BF_DMA_TCD16_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_START), uint16_t) & BM_DMA_TCD16_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD16_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD16_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD16_CSR_INTMAJOR.
#define BM_DMA_TCD16_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD16_CSR_INTMAJOR.
#define BS_DMA_TCD16_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD16_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_INTMAJOR field.
#define BR_DMA_TCD16_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_INTMAJOR.
#define BF_DMA_TCD16_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD16_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD16_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD16_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD16_CSR_INTHALF.
#define BM_DMA_TCD16_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD16_CSR_INTHALF.
#define BS_DMA_TCD16_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD16_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_INTHALF field.
#define BR_DMA_TCD16_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_INTHALF.
#define BF_DMA_TCD16_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_INTHALF), uint16_t) & BM_DMA_TCD16_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD16_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD16_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD16_CSR_DREQ.
#define BM_DMA_TCD16_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD16_CSR_DREQ.
#define BS_DMA_TCD16_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD16_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_DREQ field.
#define BR_DMA_TCD16_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_DREQ.
#define BF_DMA_TCD16_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_DREQ), uint16_t) & BM_DMA_TCD16_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD16_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD16_CSR_ESG      (4U)      //!< Bit position for DMA_TCD16_CSR_ESG.
#define BM_DMA_TCD16_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD16_CSR_ESG.
#define BS_DMA_TCD16_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD16_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_ESG field.
#define BR_DMA_TCD16_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_ESG.
#define BF_DMA_TCD16_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_ESG), uint16_t) & BM_DMA_TCD16_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD16_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD16_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD16_CSR_MAJORELINK.
#define BM_DMA_TCD16_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD16_CSR_MAJORELINK.
#define BS_DMA_TCD16_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD16_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_MAJORELINK field.
#define BR_DMA_TCD16_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_MAJORELINK.
#define BF_DMA_TCD16_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD16_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD16_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD16_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD16_CSR_ACTIVE.
#define BM_DMA_TCD16_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD16_CSR_ACTIVE.
#define BS_DMA_TCD16_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD16_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_ACTIVE field.
#define BR_DMA_TCD16_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_ACTIVE.
#define BF_DMA_TCD16_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_ACTIVE), uint16_t) & BM_DMA_TCD16_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD16_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD16_CSR_DONE      (7U)      //!< Bit position for DMA_TCD16_CSR_DONE.
#define BM_DMA_TCD16_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD16_CSR_DONE.
#define BS_DMA_TCD16_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD16_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_DONE field.
#define BR_DMA_TCD16_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_DONE.
#define BF_DMA_TCD16_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_DONE), uint16_t) & BM_DMA_TCD16_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD16_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_CSR_ADDR, BP_DMA_TCD16_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD16_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD16_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD16_CSR_MAJORLINKCH.
#define BM_DMA_TCD16_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD16_CSR_MAJORLINKCH.
#define BS_DMA_TCD16_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD16_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_MAJORLINKCH field.
#define BR_DMA_TCD16_CSR_MAJORLINKCH()   (HW_DMA_TCD16_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_MAJORLINKCH.
#define BF_DMA_TCD16_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD16_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD16_CSR_MAJORLINKCH(v)   (HW_DMA_TCD16_CSR_WR((HW_DMA_TCD16_CSR_RD() & ~BM_DMA_TCD16_CSR_MAJORLINKCH) | BF_DMA_TCD16_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD16_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD16_CSR_BWC      (14U)      //!< Bit position for DMA_TCD16_CSR_BWC.
#define BM_DMA_TCD16_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD16_CSR_BWC.
#define BS_DMA_TCD16_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD16_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_CSR_BWC field.
#define BR_DMA_TCD16_CSR_BWC()   (HW_DMA_TCD16_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD16_CSR_BWC.
#define BF_DMA_TCD16_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_CSR_BWC), uint16_t) & BM_DMA_TCD16_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD16_CSR_BWC(v)   (HW_DMA_TCD16_CSR_WR((HW_DMA_TCD16_CSR_RD() & ~BM_DMA_TCD16_CSR_BWC) | BF_DMA_TCD16_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd16_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd16_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd16_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD16_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x121eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_BITER_ELINKYES           (*(__IO hw_dma_tcd16_biter_elinkyes_t *) HW_DMA_TCD16_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD16_BITER_ELINKYES_RD()      (HW_DMA_TCD16_BITER_ELINKYES.U)
#define HW_DMA_TCD16_BITER_ELINKYES_WR(v)     (HW_DMA_TCD16_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD16_BITER_ELINKYES_SET(v)    (HW_DMA_TCD16_BITER_ELINKYES_WR(HW_DMA_TCD16_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD16_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD16_BITER_ELINKYES_WR(HW_DMA_TCD16_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD16_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD16_BITER_ELINKYES_WR(HW_DMA_TCD16_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD16_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD16_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD16_BITER_ELINKYES_BITER.
#define BM_DMA_TCD16_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD16_BITER_ELINKYES_BITER.
#define BS_DMA_TCD16_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD16_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD16_BITER_ELINKYES_BITER()   (HW_DMA_TCD16_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD16_BITER_ELINKYES_BITER.
#define BF_DMA_TCD16_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD16_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD16_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD16_BITER_ELINKYES_WR((HW_DMA_TCD16_BITER_ELINKYES_RD() & ~BM_DMA_TCD16_BITER_ELINKYES_BITER) | BF_DMA_TCD16_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD16_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD16_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD16_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD16_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD16_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD16_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD16_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD16_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD16_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD16_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD16_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD16_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD16_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD16_BITER_ELINKYES_WR((HW_DMA_TCD16_BITER_ELINKYES_RD() & ~BM_DMA_TCD16_BITER_ELINKYES_LINKCH) | BF_DMA_TCD16_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD16_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD16_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD16_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD16_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD16_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD16_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD16_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD16_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD16_BITER_ELINKYES_ADDR, BP_DMA_TCD16_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD16_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD16_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD16_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD16_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_BITER_ELINKYES_ADDR, BP_DMA_TCD16_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD16_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD16_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd16_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd16_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd16_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD16_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD16_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x121eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD16_BITER_ELINKNO           (*(__IO hw_dma_tcd16_biter_elinkno_t *) HW_DMA_TCD16_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD16_BITER_ELINKNO_RD()      (HW_DMA_TCD16_BITER_ELINKNO.U)
#define HW_DMA_TCD16_BITER_ELINKNO_WR(v)     (HW_DMA_TCD16_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD16_BITER_ELINKNO_SET(v)    (HW_DMA_TCD16_BITER_ELINKNO_WR(HW_DMA_TCD16_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD16_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD16_BITER_ELINKNO_WR(HW_DMA_TCD16_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD16_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD16_BITER_ELINKNO_WR(HW_DMA_TCD16_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD16_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD16_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD16_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD16_BITER_ELINKNO_BITER.
#define BM_DMA_TCD16_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD16_BITER_ELINKNO_BITER.
#define BS_DMA_TCD16_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD16_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD16_BITER_ELINKNO_BITER()   (HW_DMA_TCD16_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD16_BITER_ELINKNO_BITER.
#define BF_DMA_TCD16_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD16_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD16_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD16_BITER_ELINKNO_WR((HW_DMA_TCD16_BITER_ELINKNO_RD() & ~BM_DMA_TCD16_BITER_ELINKNO_BITER) | BF_DMA_TCD16_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD16_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD16_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD16_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD16_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD16_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD16_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD16_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD16_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD16_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD16_BITER_ELINKNO_ADDR, BP_DMA_TCD16_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD16_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD16_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD16_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD16_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD16_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD16_BITER_ELINKNO_ADDR, BP_DMA_TCD16_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd17_saddr
{
    uint32_t U;
    struct _hw_dma_tcd17_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd17_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_SADDR register
 */
//@{
#define HW_DMA_TCD17_SADDR_ADDR      (REGS_DMA_BASE + 0x1220U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_SADDR           (*(__IO hw_dma_tcd17_saddr_t *) HW_DMA_TCD17_SADDR_ADDR)
#define HW_DMA_TCD17_SADDR_RD()      (HW_DMA_TCD17_SADDR.U)
#define HW_DMA_TCD17_SADDR_WR(v)     (HW_DMA_TCD17_SADDR.U = (v))
#define HW_DMA_TCD17_SADDR_SET(v)    (HW_DMA_TCD17_SADDR_WR(HW_DMA_TCD17_SADDR_RD() |  (v)))
#define HW_DMA_TCD17_SADDR_CLR(v)    (HW_DMA_TCD17_SADDR_WR(HW_DMA_TCD17_SADDR_RD() & ~(v)))
#define HW_DMA_TCD17_SADDR_TOG(v)    (HW_DMA_TCD17_SADDR_WR(HW_DMA_TCD17_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_SADDR bitfields
 */

/*! @name Register DMA_TCD17_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD17_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD17_SADDR_SADDR.
#define BM_DMA_TCD17_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD17_SADDR_SADDR.
#define BS_DMA_TCD17_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD17_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_SADDR_SADDR field.
#define BR_DMA_TCD17_SADDR_SADDR()   (HW_DMA_TCD17_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD17_SADDR_SADDR.
#define BF_DMA_TCD17_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_SADDR_SADDR), uint32_t) & BM_DMA_TCD17_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD17_SADDR_SADDR(v)   (HW_DMA_TCD17_SADDR_WR((HW_DMA_TCD17_SADDR_RD() & ~BM_DMA_TCD17_SADDR_SADDR) | BF_DMA_TCD17_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd17_soff
{
    uint16_t U;
    struct _hw_dma_tcd17_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd17_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_SOFF register
 */
//@{
#define HW_DMA_TCD17_SOFF_ADDR      (REGS_DMA_BASE + 0x1224U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_SOFF           (*(__IO hw_dma_tcd17_soff_t *) HW_DMA_TCD17_SOFF_ADDR)
#define HW_DMA_TCD17_SOFF_RD()      (HW_DMA_TCD17_SOFF.U)
#define HW_DMA_TCD17_SOFF_WR(v)     (HW_DMA_TCD17_SOFF.U = (v))
#define HW_DMA_TCD17_SOFF_SET(v)    (HW_DMA_TCD17_SOFF_WR(HW_DMA_TCD17_SOFF_RD() |  (v)))
#define HW_DMA_TCD17_SOFF_CLR(v)    (HW_DMA_TCD17_SOFF_WR(HW_DMA_TCD17_SOFF_RD() & ~(v)))
#define HW_DMA_TCD17_SOFF_TOG(v)    (HW_DMA_TCD17_SOFF_WR(HW_DMA_TCD17_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_SOFF bitfields
 */

/*! @name Register DMA_TCD17_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD17_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD17_SOFF_SOFF.
#define BM_DMA_TCD17_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD17_SOFF_SOFF.
#define BS_DMA_TCD17_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD17_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_SOFF_SOFF field.
#define BR_DMA_TCD17_SOFF_SOFF()   (HW_DMA_TCD17_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD17_SOFF_SOFF.
#define BF_DMA_TCD17_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_SOFF_SOFF), uint16_t) & BM_DMA_TCD17_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD17_SOFF_SOFF(v)   (HW_DMA_TCD17_SOFF_WR((HW_DMA_TCD17_SOFF_RD() & ~BM_DMA_TCD17_SOFF_SOFF) | BF_DMA_TCD17_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd17_attr
{
    uint16_t U;
    struct _hw_dma_tcd17_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd17_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_ATTR register
 */
//@{
#define HW_DMA_TCD17_ATTR_ADDR      (REGS_DMA_BASE + 0x1226U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_ATTR           (*(__IO hw_dma_tcd17_attr_t *) HW_DMA_TCD17_ATTR_ADDR)
#define HW_DMA_TCD17_ATTR_RD()      (HW_DMA_TCD17_ATTR.U)
#define HW_DMA_TCD17_ATTR_WR(v)     (HW_DMA_TCD17_ATTR.U = (v))
#define HW_DMA_TCD17_ATTR_SET(v)    (HW_DMA_TCD17_ATTR_WR(HW_DMA_TCD17_ATTR_RD() |  (v)))
#define HW_DMA_TCD17_ATTR_CLR(v)    (HW_DMA_TCD17_ATTR_WR(HW_DMA_TCD17_ATTR_RD() & ~(v)))
#define HW_DMA_TCD17_ATTR_TOG(v)    (HW_DMA_TCD17_ATTR_WR(HW_DMA_TCD17_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_ATTR bitfields
 */

/*! @name Register DMA_TCD17_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD17_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD17_ATTR_DSIZE.
#define BM_DMA_TCD17_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD17_ATTR_DSIZE.
#define BS_DMA_TCD17_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD17_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_ATTR_DSIZE field.
#define BR_DMA_TCD17_ATTR_DSIZE()   (HW_DMA_TCD17_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD17_ATTR_DSIZE.
#define BF_DMA_TCD17_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_ATTR_DSIZE), uint16_t) & BM_DMA_TCD17_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD17_ATTR_DSIZE(v)   (HW_DMA_TCD17_ATTR_WR((HW_DMA_TCD17_ATTR_RD() & ~BM_DMA_TCD17_ATTR_DSIZE) | BF_DMA_TCD17_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD17_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD17_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD17_ATTR_DMOD.
#define BM_DMA_TCD17_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD17_ATTR_DMOD.
#define BS_DMA_TCD17_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD17_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_ATTR_DMOD field.
#define BR_DMA_TCD17_ATTR_DMOD()   (HW_DMA_TCD17_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD17_ATTR_DMOD.
#define BF_DMA_TCD17_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_ATTR_DMOD), uint16_t) & BM_DMA_TCD17_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD17_ATTR_DMOD(v)   (HW_DMA_TCD17_ATTR_WR((HW_DMA_TCD17_ATTR_RD() & ~BM_DMA_TCD17_ATTR_DMOD) | BF_DMA_TCD17_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD17_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD17_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD17_ATTR_SSIZE.
#define BM_DMA_TCD17_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD17_ATTR_SSIZE.
#define BS_DMA_TCD17_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD17_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_ATTR_SSIZE field.
#define BR_DMA_TCD17_ATTR_SSIZE()   (HW_DMA_TCD17_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD17_ATTR_SSIZE.
#define BF_DMA_TCD17_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_ATTR_SSIZE), uint16_t) & BM_DMA_TCD17_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD17_ATTR_SSIZE(v)   (HW_DMA_TCD17_ATTR_WR((HW_DMA_TCD17_ATTR_RD() & ~BM_DMA_TCD17_ATTR_SSIZE) | BF_DMA_TCD17_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD17_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD17_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD17_ATTR_SMOD.
#define BM_DMA_TCD17_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD17_ATTR_SMOD.
#define BS_DMA_TCD17_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD17_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_ATTR_SMOD field.
#define BR_DMA_TCD17_ATTR_SMOD()   (HW_DMA_TCD17_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD17_ATTR_SMOD.
#define BF_DMA_TCD17_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_ATTR_SMOD), uint16_t) & BM_DMA_TCD17_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD17_ATTR_SMOD(v)   (HW_DMA_TCD17_ATTR_WR((HW_DMA_TCD17_ATTR_RD() & ~BM_DMA_TCD17_ATTR_SMOD) | BF_DMA_TCD17_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd17_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd17_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd17_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD17_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1228U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_NBYTES_MLNO           (*(__IO hw_dma_tcd17_nbytes_mlno_t *) HW_DMA_TCD17_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD17_NBYTES_MLNO_RD()      (HW_DMA_TCD17_NBYTES_MLNO.U)
#define HW_DMA_TCD17_NBYTES_MLNO_WR(v)     (HW_DMA_TCD17_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD17_NBYTES_MLNO_SET(v)    (HW_DMA_TCD17_NBYTES_MLNO_WR(HW_DMA_TCD17_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD17_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD17_NBYTES_MLNO_WR(HW_DMA_TCD17_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD17_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD17_NBYTES_MLNO_WR(HW_DMA_TCD17_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD17_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD17_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD17_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD17_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD17_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD17_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD17_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD17_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD17_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD17_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD17_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD17_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD17_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD17_NBYTES_MLNO_WR((HW_DMA_TCD17_NBYTES_MLNO_RD() & ~BM_DMA_TCD17_NBYTES_MLNO_NBYTES) | BF_DMA_TCD17_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd17_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd17_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd17_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD17_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1228U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd17_nbytes_mloffno_t *) HW_DMA_TCD17_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD17_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD17_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD17_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD17_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD17_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD17_NBYTES_MLOFFNO_WR(HW_DMA_TCD17_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD17_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD17_NBYTES_MLOFFNO_WR(HW_DMA_TCD17_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD17_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD17_NBYTES_MLOFFNO_WR(HW_DMA_TCD17_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD17_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD17_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD17_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD17_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD17_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD17_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD17_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD17_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD17_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD17_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD17_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD17_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD17_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD17_NBYTES_MLOFFNO_WR((HW_DMA_TCD17_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD17_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD17_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD17_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD17_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD17_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD17_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD17_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD17_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD17_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD17_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD17_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD17_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD17_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD17_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD17_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD17_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD17_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD17_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD17_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD17_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD17_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD17_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD17_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD17_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD17_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD17_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD17_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD17_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD17_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD17_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD17_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD17_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD17_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd17_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd17_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd17_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD17_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1228U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd17_nbytes_mloffyes_t *) HW_DMA_TCD17_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD17_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD17_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD17_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD17_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD17_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD17_NBYTES_MLOFFYES_WR(HW_DMA_TCD17_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD17_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD17_NBYTES_MLOFFYES_WR(HW_DMA_TCD17_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD17_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD17_NBYTES_MLOFFYES_WR(HW_DMA_TCD17_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD17_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD17_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD17_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD17_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD17_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD17_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD17_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD17_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD17_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD17_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD17_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD17_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD17_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD17_NBYTES_MLOFFYES_WR((HW_DMA_TCD17_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD17_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD17_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD17_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD17_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD17_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD17_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD17_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD17_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD17_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD17_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD17_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD17_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD17_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD17_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD17_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD17_NBYTES_MLOFFYES_WR((HW_DMA_TCD17_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD17_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD17_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD17_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD17_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD17_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD17_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD17_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD17_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD17_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD17_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD17_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD17_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD17_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD17_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD17_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD17_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD17_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD17_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD17_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD17_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD17_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD17_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD17_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD17_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD17_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD17_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD17_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD17_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD17_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD17_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD17_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD17_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD17_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd17_slast
{
    uint32_t U;
    struct _hw_dma_tcd17_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd17_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_SLAST register
 */
//@{
#define HW_DMA_TCD17_SLAST_ADDR      (REGS_DMA_BASE + 0x122cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_SLAST           (*(__IO hw_dma_tcd17_slast_t *) HW_DMA_TCD17_SLAST_ADDR)
#define HW_DMA_TCD17_SLAST_RD()      (HW_DMA_TCD17_SLAST.U)
#define HW_DMA_TCD17_SLAST_WR(v)     (HW_DMA_TCD17_SLAST.U = (v))
#define HW_DMA_TCD17_SLAST_SET(v)    (HW_DMA_TCD17_SLAST_WR(HW_DMA_TCD17_SLAST_RD() |  (v)))
#define HW_DMA_TCD17_SLAST_CLR(v)    (HW_DMA_TCD17_SLAST_WR(HW_DMA_TCD17_SLAST_RD() & ~(v)))
#define HW_DMA_TCD17_SLAST_TOG(v)    (HW_DMA_TCD17_SLAST_WR(HW_DMA_TCD17_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_SLAST bitfields
 */

/*! @name Register DMA_TCD17_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD17_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD17_SLAST_SLAST.
#define BM_DMA_TCD17_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD17_SLAST_SLAST.
#define BS_DMA_TCD17_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD17_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_SLAST_SLAST field.
#define BR_DMA_TCD17_SLAST_SLAST()   (HW_DMA_TCD17_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD17_SLAST_SLAST.
#define BF_DMA_TCD17_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_SLAST_SLAST), uint32_t) & BM_DMA_TCD17_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD17_SLAST_SLAST(v)   (HW_DMA_TCD17_SLAST_WR((HW_DMA_TCD17_SLAST_RD() & ~BM_DMA_TCD17_SLAST_SLAST) | BF_DMA_TCD17_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd17_daddr
{
    uint32_t U;
    struct _hw_dma_tcd17_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd17_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_DADDR register
 */
//@{
#define HW_DMA_TCD17_DADDR_ADDR      (REGS_DMA_BASE + 0x1230U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_DADDR           (*(__IO hw_dma_tcd17_daddr_t *) HW_DMA_TCD17_DADDR_ADDR)
#define HW_DMA_TCD17_DADDR_RD()      (HW_DMA_TCD17_DADDR.U)
#define HW_DMA_TCD17_DADDR_WR(v)     (HW_DMA_TCD17_DADDR.U = (v))
#define HW_DMA_TCD17_DADDR_SET(v)    (HW_DMA_TCD17_DADDR_WR(HW_DMA_TCD17_DADDR_RD() |  (v)))
#define HW_DMA_TCD17_DADDR_CLR(v)    (HW_DMA_TCD17_DADDR_WR(HW_DMA_TCD17_DADDR_RD() & ~(v)))
#define HW_DMA_TCD17_DADDR_TOG(v)    (HW_DMA_TCD17_DADDR_WR(HW_DMA_TCD17_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_DADDR bitfields
 */

/*! @name Register DMA_TCD17_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD17_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD17_DADDR_DADDR.
#define BM_DMA_TCD17_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD17_DADDR_DADDR.
#define BS_DMA_TCD17_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD17_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_DADDR_DADDR field.
#define BR_DMA_TCD17_DADDR_DADDR()   (HW_DMA_TCD17_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD17_DADDR_DADDR.
#define BF_DMA_TCD17_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_DADDR_DADDR), uint32_t) & BM_DMA_TCD17_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD17_DADDR_DADDR(v)   (HW_DMA_TCD17_DADDR_WR((HW_DMA_TCD17_DADDR_RD() & ~BM_DMA_TCD17_DADDR_DADDR) | BF_DMA_TCD17_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd17_doff
{
    uint16_t U;
    struct _hw_dma_tcd17_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd17_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_DOFF register
 */
//@{
#define HW_DMA_TCD17_DOFF_ADDR      (REGS_DMA_BASE + 0x1234U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_DOFF           (*(__IO hw_dma_tcd17_doff_t *) HW_DMA_TCD17_DOFF_ADDR)
#define HW_DMA_TCD17_DOFF_RD()      (HW_DMA_TCD17_DOFF.U)
#define HW_DMA_TCD17_DOFF_WR(v)     (HW_DMA_TCD17_DOFF.U = (v))
#define HW_DMA_TCD17_DOFF_SET(v)    (HW_DMA_TCD17_DOFF_WR(HW_DMA_TCD17_DOFF_RD() |  (v)))
#define HW_DMA_TCD17_DOFF_CLR(v)    (HW_DMA_TCD17_DOFF_WR(HW_DMA_TCD17_DOFF_RD() & ~(v)))
#define HW_DMA_TCD17_DOFF_TOG(v)    (HW_DMA_TCD17_DOFF_WR(HW_DMA_TCD17_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_DOFF bitfields
 */

/*! @name Register DMA_TCD17_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD17_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD17_DOFF_DOFF.
#define BM_DMA_TCD17_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD17_DOFF_DOFF.
#define BS_DMA_TCD17_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD17_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_DOFF_DOFF field.
#define BR_DMA_TCD17_DOFF_DOFF()   (HW_DMA_TCD17_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD17_DOFF_DOFF.
#define BF_DMA_TCD17_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_DOFF_DOFF), uint16_t) & BM_DMA_TCD17_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD17_DOFF_DOFF(v)   (HW_DMA_TCD17_DOFF_WR((HW_DMA_TCD17_DOFF_RD() & ~BM_DMA_TCD17_DOFF_DOFF) | BF_DMA_TCD17_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd17_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd17_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd17_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD17_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1236U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_CITER_ELINKYES           (*(__IO hw_dma_tcd17_citer_elinkyes_t *) HW_DMA_TCD17_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD17_CITER_ELINKYES_RD()      (HW_DMA_TCD17_CITER_ELINKYES.U)
#define HW_DMA_TCD17_CITER_ELINKYES_WR(v)     (HW_DMA_TCD17_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD17_CITER_ELINKYES_SET(v)    (HW_DMA_TCD17_CITER_ELINKYES_WR(HW_DMA_TCD17_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD17_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD17_CITER_ELINKYES_WR(HW_DMA_TCD17_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD17_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD17_CITER_ELINKYES_WR(HW_DMA_TCD17_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD17_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD17_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD17_CITER_ELINKYES_CITER.
#define BM_DMA_TCD17_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD17_CITER_ELINKYES_CITER.
#define BS_DMA_TCD17_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD17_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD17_CITER_ELINKYES_CITER()   (HW_DMA_TCD17_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD17_CITER_ELINKYES_CITER.
#define BF_DMA_TCD17_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD17_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD17_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD17_CITER_ELINKYES_WR((HW_DMA_TCD17_CITER_ELINKYES_RD() & ~BM_DMA_TCD17_CITER_ELINKYES_CITER) | BF_DMA_TCD17_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD17_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD17_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD17_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD17_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD17_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD17_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD17_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD17_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD17_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD17_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD17_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD17_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD17_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD17_CITER_ELINKYES_WR((HW_DMA_TCD17_CITER_ELINKYES_RD() & ~BM_DMA_TCD17_CITER_ELINKYES_LINKCH) | BF_DMA_TCD17_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD17_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD17_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD17_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD17_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD17_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD17_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD17_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD17_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD17_CITER_ELINKYES_ADDR, BP_DMA_TCD17_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD17_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD17_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD17_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD17_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CITER_ELINKYES_ADDR, BP_DMA_TCD17_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd17_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd17_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd17_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD17_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1236U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_CITER_ELINKNO           (*(__IO hw_dma_tcd17_citer_elinkno_t *) HW_DMA_TCD17_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD17_CITER_ELINKNO_RD()      (HW_DMA_TCD17_CITER_ELINKNO.U)
#define HW_DMA_TCD17_CITER_ELINKNO_WR(v)     (HW_DMA_TCD17_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD17_CITER_ELINKNO_SET(v)    (HW_DMA_TCD17_CITER_ELINKNO_WR(HW_DMA_TCD17_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD17_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD17_CITER_ELINKNO_WR(HW_DMA_TCD17_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD17_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD17_CITER_ELINKNO_WR(HW_DMA_TCD17_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD17_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD17_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD17_CITER_ELINKNO_CITER.
#define BM_DMA_TCD17_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD17_CITER_ELINKNO_CITER.
#define BS_DMA_TCD17_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD17_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD17_CITER_ELINKNO_CITER()   (HW_DMA_TCD17_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD17_CITER_ELINKNO_CITER.
#define BF_DMA_TCD17_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD17_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD17_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD17_CITER_ELINKNO_WR((HW_DMA_TCD17_CITER_ELINKNO_RD() & ~BM_DMA_TCD17_CITER_ELINKNO_CITER) | BF_DMA_TCD17_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD17_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD17_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD17_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD17_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD17_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD17_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD17_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD17_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD17_CITER_ELINKNO_ADDR, BP_DMA_TCD17_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD17_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD17_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD17_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD17_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CITER_ELINKNO_ADDR, BP_DMA_TCD17_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd17_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd17_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd17_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_DLASTSGA register
 */
//@{
#define HW_DMA_TCD17_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1238U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_DLASTSGA           (*(__IO hw_dma_tcd17_dlastsga_t *) HW_DMA_TCD17_DLASTSGA_ADDR)
#define HW_DMA_TCD17_DLASTSGA_RD()      (HW_DMA_TCD17_DLASTSGA.U)
#define HW_DMA_TCD17_DLASTSGA_WR(v)     (HW_DMA_TCD17_DLASTSGA.U = (v))
#define HW_DMA_TCD17_DLASTSGA_SET(v)    (HW_DMA_TCD17_DLASTSGA_WR(HW_DMA_TCD17_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD17_DLASTSGA_CLR(v)    (HW_DMA_TCD17_DLASTSGA_WR(HW_DMA_TCD17_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD17_DLASTSGA_TOG(v)    (HW_DMA_TCD17_DLASTSGA_WR(HW_DMA_TCD17_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD17_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD17_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD17_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD17_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD17_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD17_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD17_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD17_DLASTSGA_DLASTSGA()   (HW_DMA_TCD17_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD17_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD17_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD17_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD17_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD17_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD17_DLASTSGA_WR((HW_DMA_TCD17_DLASTSGA_RD() & ~BM_DMA_TCD17_DLASTSGA_DLASTSGA) | BF_DMA_TCD17_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd17_csr
{
    uint16_t U;
    struct _hw_dma_tcd17_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd17_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_CSR register
 */
//@{
#define HW_DMA_TCD17_CSR_ADDR      (REGS_DMA_BASE + 0x123cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_CSR           (*(__IO hw_dma_tcd17_csr_t *) HW_DMA_TCD17_CSR_ADDR)
#define HW_DMA_TCD17_CSR_RD()      (HW_DMA_TCD17_CSR.U)
#define HW_DMA_TCD17_CSR_WR(v)     (HW_DMA_TCD17_CSR.U = (v))
#define HW_DMA_TCD17_CSR_SET(v)    (HW_DMA_TCD17_CSR_WR(HW_DMA_TCD17_CSR_RD() |  (v)))
#define HW_DMA_TCD17_CSR_CLR(v)    (HW_DMA_TCD17_CSR_WR(HW_DMA_TCD17_CSR_RD() & ~(v)))
#define HW_DMA_TCD17_CSR_TOG(v)    (HW_DMA_TCD17_CSR_WR(HW_DMA_TCD17_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_CSR bitfields
 */

/*! @name Register DMA_TCD17_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD17_CSR_START      (0U)      //!< Bit position for DMA_TCD17_CSR_START.
#define BM_DMA_TCD17_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD17_CSR_START.
#define BS_DMA_TCD17_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD17_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_START field.
#define BR_DMA_TCD17_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_START.
#define BF_DMA_TCD17_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_START), uint16_t) & BM_DMA_TCD17_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD17_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD17_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD17_CSR_INTMAJOR.
#define BM_DMA_TCD17_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD17_CSR_INTMAJOR.
#define BS_DMA_TCD17_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD17_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_INTMAJOR field.
#define BR_DMA_TCD17_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_INTMAJOR.
#define BF_DMA_TCD17_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD17_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD17_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD17_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD17_CSR_INTHALF.
#define BM_DMA_TCD17_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD17_CSR_INTHALF.
#define BS_DMA_TCD17_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD17_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_INTHALF field.
#define BR_DMA_TCD17_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_INTHALF.
#define BF_DMA_TCD17_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_INTHALF), uint16_t) & BM_DMA_TCD17_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD17_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD17_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD17_CSR_DREQ.
#define BM_DMA_TCD17_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD17_CSR_DREQ.
#define BS_DMA_TCD17_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD17_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_DREQ field.
#define BR_DMA_TCD17_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_DREQ.
#define BF_DMA_TCD17_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_DREQ), uint16_t) & BM_DMA_TCD17_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD17_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD17_CSR_ESG      (4U)      //!< Bit position for DMA_TCD17_CSR_ESG.
#define BM_DMA_TCD17_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD17_CSR_ESG.
#define BS_DMA_TCD17_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD17_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_ESG field.
#define BR_DMA_TCD17_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_ESG.
#define BF_DMA_TCD17_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_ESG), uint16_t) & BM_DMA_TCD17_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD17_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD17_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD17_CSR_MAJORELINK.
#define BM_DMA_TCD17_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD17_CSR_MAJORELINK.
#define BS_DMA_TCD17_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD17_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_MAJORELINK field.
#define BR_DMA_TCD17_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_MAJORELINK.
#define BF_DMA_TCD17_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD17_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD17_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD17_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD17_CSR_ACTIVE.
#define BM_DMA_TCD17_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD17_CSR_ACTIVE.
#define BS_DMA_TCD17_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD17_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_ACTIVE field.
#define BR_DMA_TCD17_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_ACTIVE.
#define BF_DMA_TCD17_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_ACTIVE), uint16_t) & BM_DMA_TCD17_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD17_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD17_CSR_DONE      (7U)      //!< Bit position for DMA_TCD17_CSR_DONE.
#define BM_DMA_TCD17_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD17_CSR_DONE.
#define BS_DMA_TCD17_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD17_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_DONE field.
#define BR_DMA_TCD17_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_DONE.
#define BF_DMA_TCD17_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_DONE), uint16_t) & BM_DMA_TCD17_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD17_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_CSR_ADDR, BP_DMA_TCD17_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD17_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD17_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD17_CSR_MAJORLINKCH.
#define BM_DMA_TCD17_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD17_CSR_MAJORLINKCH.
#define BS_DMA_TCD17_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD17_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_MAJORLINKCH field.
#define BR_DMA_TCD17_CSR_MAJORLINKCH()   (HW_DMA_TCD17_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_MAJORLINKCH.
#define BF_DMA_TCD17_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD17_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD17_CSR_MAJORLINKCH(v)   (HW_DMA_TCD17_CSR_WR((HW_DMA_TCD17_CSR_RD() & ~BM_DMA_TCD17_CSR_MAJORLINKCH) | BF_DMA_TCD17_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD17_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD17_CSR_BWC      (14U)      //!< Bit position for DMA_TCD17_CSR_BWC.
#define BM_DMA_TCD17_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD17_CSR_BWC.
#define BS_DMA_TCD17_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD17_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_CSR_BWC field.
#define BR_DMA_TCD17_CSR_BWC()   (HW_DMA_TCD17_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD17_CSR_BWC.
#define BF_DMA_TCD17_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_CSR_BWC), uint16_t) & BM_DMA_TCD17_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD17_CSR_BWC(v)   (HW_DMA_TCD17_CSR_WR((HW_DMA_TCD17_CSR_RD() & ~BM_DMA_TCD17_CSR_BWC) | BF_DMA_TCD17_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd17_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd17_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd17_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD17_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x123eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_BITER_ELINKYES           (*(__IO hw_dma_tcd17_biter_elinkyes_t *) HW_DMA_TCD17_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD17_BITER_ELINKYES_RD()      (HW_DMA_TCD17_BITER_ELINKYES.U)
#define HW_DMA_TCD17_BITER_ELINKYES_WR(v)     (HW_DMA_TCD17_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD17_BITER_ELINKYES_SET(v)    (HW_DMA_TCD17_BITER_ELINKYES_WR(HW_DMA_TCD17_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD17_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD17_BITER_ELINKYES_WR(HW_DMA_TCD17_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD17_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD17_BITER_ELINKYES_WR(HW_DMA_TCD17_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD17_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD17_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD17_BITER_ELINKYES_BITER.
#define BM_DMA_TCD17_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD17_BITER_ELINKYES_BITER.
#define BS_DMA_TCD17_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD17_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD17_BITER_ELINKYES_BITER()   (HW_DMA_TCD17_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD17_BITER_ELINKYES_BITER.
#define BF_DMA_TCD17_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD17_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD17_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD17_BITER_ELINKYES_WR((HW_DMA_TCD17_BITER_ELINKYES_RD() & ~BM_DMA_TCD17_BITER_ELINKYES_BITER) | BF_DMA_TCD17_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD17_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD17_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD17_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD17_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD17_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD17_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD17_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD17_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD17_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD17_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD17_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD17_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD17_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD17_BITER_ELINKYES_WR((HW_DMA_TCD17_BITER_ELINKYES_RD() & ~BM_DMA_TCD17_BITER_ELINKYES_LINKCH) | BF_DMA_TCD17_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD17_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD17_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD17_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD17_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD17_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD17_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD17_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD17_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD17_BITER_ELINKYES_ADDR, BP_DMA_TCD17_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD17_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD17_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD17_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD17_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_BITER_ELINKYES_ADDR, BP_DMA_TCD17_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD17_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD17_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd17_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd17_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd17_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD17_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD17_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x123eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD17_BITER_ELINKNO           (*(__IO hw_dma_tcd17_biter_elinkno_t *) HW_DMA_TCD17_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD17_BITER_ELINKNO_RD()      (HW_DMA_TCD17_BITER_ELINKNO.U)
#define HW_DMA_TCD17_BITER_ELINKNO_WR(v)     (HW_DMA_TCD17_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD17_BITER_ELINKNO_SET(v)    (HW_DMA_TCD17_BITER_ELINKNO_WR(HW_DMA_TCD17_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD17_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD17_BITER_ELINKNO_WR(HW_DMA_TCD17_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD17_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD17_BITER_ELINKNO_WR(HW_DMA_TCD17_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD17_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD17_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD17_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD17_BITER_ELINKNO_BITER.
#define BM_DMA_TCD17_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD17_BITER_ELINKNO_BITER.
#define BS_DMA_TCD17_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD17_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD17_BITER_ELINKNO_BITER()   (HW_DMA_TCD17_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD17_BITER_ELINKNO_BITER.
#define BF_DMA_TCD17_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD17_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD17_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD17_BITER_ELINKNO_WR((HW_DMA_TCD17_BITER_ELINKNO_RD() & ~BM_DMA_TCD17_BITER_ELINKNO_BITER) | BF_DMA_TCD17_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD17_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD17_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD17_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD17_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD17_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD17_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD17_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD17_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD17_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD17_BITER_ELINKNO_ADDR, BP_DMA_TCD17_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD17_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD17_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD17_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD17_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD17_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD17_BITER_ELINKNO_ADDR, BP_DMA_TCD17_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd18_saddr
{
    uint32_t U;
    struct _hw_dma_tcd18_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd18_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_SADDR register
 */
//@{
#define HW_DMA_TCD18_SADDR_ADDR      (REGS_DMA_BASE + 0x1240U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_SADDR           (*(__IO hw_dma_tcd18_saddr_t *) HW_DMA_TCD18_SADDR_ADDR)
#define HW_DMA_TCD18_SADDR_RD()      (HW_DMA_TCD18_SADDR.U)
#define HW_DMA_TCD18_SADDR_WR(v)     (HW_DMA_TCD18_SADDR.U = (v))
#define HW_DMA_TCD18_SADDR_SET(v)    (HW_DMA_TCD18_SADDR_WR(HW_DMA_TCD18_SADDR_RD() |  (v)))
#define HW_DMA_TCD18_SADDR_CLR(v)    (HW_DMA_TCD18_SADDR_WR(HW_DMA_TCD18_SADDR_RD() & ~(v)))
#define HW_DMA_TCD18_SADDR_TOG(v)    (HW_DMA_TCD18_SADDR_WR(HW_DMA_TCD18_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_SADDR bitfields
 */

/*! @name Register DMA_TCD18_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD18_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD18_SADDR_SADDR.
#define BM_DMA_TCD18_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD18_SADDR_SADDR.
#define BS_DMA_TCD18_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD18_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_SADDR_SADDR field.
#define BR_DMA_TCD18_SADDR_SADDR()   (HW_DMA_TCD18_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD18_SADDR_SADDR.
#define BF_DMA_TCD18_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_SADDR_SADDR), uint32_t) & BM_DMA_TCD18_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD18_SADDR_SADDR(v)   (HW_DMA_TCD18_SADDR_WR((HW_DMA_TCD18_SADDR_RD() & ~BM_DMA_TCD18_SADDR_SADDR) | BF_DMA_TCD18_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd18_soff
{
    uint16_t U;
    struct _hw_dma_tcd18_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd18_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_SOFF register
 */
//@{
#define HW_DMA_TCD18_SOFF_ADDR      (REGS_DMA_BASE + 0x1244U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_SOFF           (*(__IO hw_dma_tcd18_soff_t *) HW_DMA_TCD18_SOFF_ADDR)
#define HW_DMA_TCD18_SOFF_RD()      (HW_DMA_TCD18_SOFF.U)
#define HW_DMA_TCD18_SOFF_WR(v)     (HW_DMA_TCD18_SOFF.U = (v))
#define HW_DMA_TCD18_SOFF_SET(v)    (HW_DMA_TCD18_SOFF_WR(HW_DMA_TCD18_SOFF_RD() |  (v)))
#define HW_DMA_TCD18_SOFF_CLR(v)    (HW_DMA_TCD18_SOFF_WR(HW_DMA_TCD18_SOFF_RD() & ~(v)))
#define HW_DMA_TCD18_SOFF_TOG(v)    (HW_DMA_TCD18_SOFF_WR(HW_DMA_TCD18_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_SOFF bitfields
 */

/*! @name Register DMA_TCD18_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD18_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD18_SOFF_SOFF.
#define BM_DMA_TCD18_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD18_SOFF_SOFF.
#define BS_DMA_TCD18_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD18_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_SOFF_SOFF field.
#define BR_DMA_TCD18_SOFF_SOFF()   (HW_DMA_TCD18_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD18_SOFF_SOFF.
#define BF_DMA_TCD18_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_SOFF_SOFF), uint16_t) & BM_DMA_TCD18_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD18_SOFF_SOFF(v)   (HW_DMA_TCD18_SOFF_WR((HW_DMA_TCD18_SOFF_RD() & ~BM_DMA_TCD18_SOFF_SOFF) | BF_DMA_TCD18_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd18_attr
{
    uint16_t U;
    struct _hw_dma_tcd18_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd18_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_ATTR register
 */
//@{
#define HW_DMA_TCD18_ATTR_ADDR      (REGS_DMA_BASE + 0x1246U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_ATTR           (*(__IO hw_dma_tcd18_attr_t *) HW_DMA_TCD18_ATTR_ADDR)
#define HW_DMA_TCD18_ATTR_RD()      (HW_DMA_TCD18_ATTR.U)
#define HW_DMA_TCD18_ATTR_WR(v)     (HW_DMA_TCD18_ATTR.U = (v))
#define HW_DMA_TCD18_ATTR_SET(v)    (HW_DMA_TCD18_ATTR_WR(HW_DMA_TCD18_ATTR_RD() |  (v)))
#define HW_DMA_TCD18_ATTR_CLR(v)    (HW_DMA_TCD18_ATTR_WR(HW_DMA_TCD18_ATTR_RD() & ~(v)))
#define HW_DMA_TCD18_ATTR_TOG(v)    (HW_DMA_TCD18_ATTR_WR(HW_DMA_TCD18_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_ATTR bitfields
 */

/*! @name Register DMA_TCD18_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD18_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD18_ATTR_DSIZE.
#define BM_DMA_TCD18_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD18_ATTR_DSIZE.
#define BS_DMA_TCD18_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD18_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_ATTR_DSIZE field.
#define BR_DMA_TCD18_ATTR_DSIZE()   (HW_DMA_TCD18_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD18_ATTR_DSIZE.
#define BF_DMA_TCD18_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_ATTR_DSIZE), uint16_t) & BM_DMA_TCD18_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD18_ATTR_DSIZE(v)   (HW_DMA_TCD18_ATTR_WR((HW_DMA_TCD18_ATTR_RD() & ~BM_DMA_TCD18_ATTR_DSIZE) | BF_DMA_TCD18_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD18_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD18_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD18_ATTR_DMOD.
#define BM_DMA_TCD18_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD18_ATTR_DMOD.
#define BS_DMA_TCD18_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD18_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_ATTR_DMOD field.
#define BR_DMA_TCD18_ATTR_DMOD()   (HW_DMA_TCD18_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD18_ATTR_DMOD.
#define BF_DMA_TCD18_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_ATTR_DMOD), uint16_t) & BM_DMA_TCD18_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD18_ATTR_DMOD(v)   (HW_DMA_TCD18_ATTR_WR((HW_DMA_TCD18_ATTR_RD() & ~BM_DMA_TCD18_ATTR_DMOD) | BF_DMA_TCD18_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD18_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD18_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD18_ATTR_SSIZE.
#define BM_DMA_TCD18_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD18_ATTR_SSIZE.
#define BS_DMA_TCD18_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD18_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_ATTR_SSIZE field.
#define BR_DMA_TCD18_ATTR_SSIZE()   (HW_DMA_TCD18_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD18_ATTR_SSIZE.
#define BF_DMA_TCD18_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_ATTR_SSIZE), uint16_t) & BM_DMA_TCD18_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD18_ATTR_SSIZE(v)   (HW_DMA_TCD18_ATTR_WR((HW_DMA_TCD18_ATTR_RD() & ~BM_DMA_TCD18_ATTR_SSIZE) | BF_DMA_TCD18_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD18_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD18_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD18_ATTR_SMOD.
#define BM_DMA_TCD18_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD18_ATTR_SMOD.
#define BS_DMA_TCD18_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD18_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_ATTR_SMOD field.
#define BR_DMA_TCD18_ATTR_SMOD()   (HW_DMA_TCD18_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD18_ATTR_SMOD.
#define BF_DMA_TCD18_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_ATTR_SMOD), uint16_t) & BM_DMA_TCD18_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD18_ATTR_SMOD(v)   (HW_DMA_TCD18_ATTR_WR((HW_DMA_TCD18_ATTR_RD() & ~BM_DMA_TCD18_ATTR_SMOD) | BF_DMA_TCD18_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd18_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd18_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd18_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD18_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1248U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_NBYTES_MLNO           (*(__IO hw_dma_tcd18_nbytes_mlno_t *) HW_DMA_TCD18_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD18_NBYTES_MLNO_RD()      (HW_DMA_TCD18_NBYTES_MLNO.U)
#define HW_DMA_TCD18_NBYTES_MLNO_WR(v)     (HW_DMA_TCD18_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD18_NBYTES_MLNO_SET(v)    (HW_DMA_TCD18_NBYTES_MLNO_WR(HW_DMA_TCD18_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD18_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD18_NBYTES_MLNO_WR(HW_DMA_TCD18_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD18_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD18_NBYTES_MLNO_WR(HW_DMA_TCD18_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD18_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD18_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD18_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD18_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD18_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD18_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD18_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD18_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD18_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD18_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD18_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD18_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD18_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD18_NBYTES_MLNO_WR((HW_DMA_TCD18_NBYTES_MLNO_RD() & ~BM_DMA_TCD18_NBYTES_MLNO_NBYTES) | BF_DMA_TCD18_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd18_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd18_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd18_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD18_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1248U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd18_nbytes_mloffno_t *) HW_DMA_TCD18_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD18_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD18_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD18_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD18_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD18_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD18_NBYTES_MLOFFNO_WR(HW_DMA_TCD18_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD18_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD18_NBYTES_MLOFFNO_WR(HW_DMA_TCD18_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD18_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD18_NBYTES_MLOFFNO_WR(HW_DMA_TCD18_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD18_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD18_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD18_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD18_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD18_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD18_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD18_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD18_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD18_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD18_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD18_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD18_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD18_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD18_NBYTES_MLOFFNO_WR((HW_DMA_TCD18_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD18_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD18_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD18_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD18_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD18_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD18_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD18_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD18_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD18_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD18_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD18_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD18_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD18_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD18_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD18_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD18_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD18_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD18_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD18_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD18_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD18_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD18_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD18_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD18_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD18_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD18_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD18_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD18_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD18_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD18_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD18_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD18_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD18_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd18_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd18_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd18_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD18_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1248U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd18_nbytes_mloffyes_t *) HW_DMA_TCD18_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD18_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD18_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD18_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD18_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD18_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD18_NBYTES_MLOFFYES_WR(HW_DMA_TCD18_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD18_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD18_NBYTES_MLOFFYES_WR(HW_DMA_TCD18_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD18_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD18_NBYTES_MLOFFYES_WR(HW_DMA_TCD18_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD18_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD18_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD18_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD18_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD18_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD18_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD18_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD18_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD18_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD18_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD18_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD18_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD18_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD18_NBYTES_MLOFFYES_WR((HW_DMA_TCD18_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD18_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD18_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD18_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD18_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD18_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD18_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD18_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD18_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD18_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD18_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD18_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD18_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD18_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD18_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD18_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD18_NBYTES_MLOFFYES_WR((HW_DMA_TCD18_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD18_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD18_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD18_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD18_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD18_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD18_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD18_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD18_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD18_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD18_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD18_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD18_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD18_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD18_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD18_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD18_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD18_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD18_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD18_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD18_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD18_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD18_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD18_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD18_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD18_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD18_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD18_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD18_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD18_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD18_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD18_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD18_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD18_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd18_slast
{
    uint32_t U;
    struct _hw_dma_tcd18_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd18_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_SLAST register
 */
//@{
#define HW_DMA_TCD18_SLAST_ADDR      (REGS_DMA_BASE + 0x124cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_SLAST           (*(__IO hw_dma_tcd18_slast_t *) HW_DMA_TCD18_SLAST_ADDR)
#define HW_DMA_TCD18_SLAST_RD()      (HW_DMA_TCD18_SLAST.U)
#define HW_DMA_TCD18_SLAST_WR(v)     (HW_DMA_TCD18_SLAST.U = (v))
#define HW_DMA_TCD18_SLAST_SET(v)    (HW_DMA_TCD18_SLAST_WR(HW_DMA_TCD18_SLAST_RD() |  (v)))
#define HW_DMA_TCD18_SLAST_CLR(v)    (HW_DMA_TCD18_SLAST_WR(HW_DMA_TCD18_SLAST_RD() & ~(v)))
#define HW_DMA_TCD18_SLAST_TOG(v)    (HW_DMA_TCD18_SLAST_WR(HW_DMA_TCD18_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_SLAST bitfields
 */

/*! @name Register DMA_TCD18_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD18_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD18_SLAST_SLAST.
#define BM_DMA_TCD18_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD18_SLAST_SLAST.
#define BS_DMA_TCD18_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD18_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_SLAST_SLAST field.
#define BR_DMA_TCD18_SLAST_SLAST()   (HW_DMA_TCD18_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD18_SLAST_SLAST.
#define BF_DMA_TCD18_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_SLAST_SLAST), uint32_t) & BM_DMA_TCD18_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD18_SLAST_SLAST(v)   (HW_DMA_TCD18_SLAST_WR((HW_DMA_TCD18_SLAST_RD() & ~BM_DMA_TCD18_SLAST_SLAST) | BF_DMA_TCD18_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd18_daddr
{
    uint32_t U;
    struct _hw_dma_tcd18_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd18_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_DADDR register
 */
//@{
#define HW_DMA_TCD18_DADDR_ADDR      (REGS_DMA_BASE + 0x1250U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_DADDR           (*(__IO hw_dma_tcd18_daddr_t *) HW_DMA_TCD18_DADDR_ADDR)
#define HW_DMA_TCD18_DADDR_RD()      (HW_DMA_TCD18_DADDR.U)
#define HW_DMA_TCD18_DADDR_WR(v)     (HW_DMA_TCD18_DADDR.U = (v))
#define HW_DMA_TCD18_DADDR_SET(v)    (HW_DMA_TCD18_DADDR_WR(HW_DMA_TCD18_DADDR_RD() |  (v)))
#define HW_DMA_TCD18_DADDR_CLR(v)    (HW_DMA_TCD18_DADDR_WR(HW_DMA_TCD18_DADDR_RD() & ~(v)))
#define HW_DMA_TCD18_DADDR_TOG(v)    (HW_DMA_TCD18_DADDR_WR(HW_DMA_TCD18_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_DADDR bitfields
 */

/*! @name Register DMA_TCD18_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD18_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD18_DADDR_DADDR.
#define BM_DMA_TCD18_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD18_DADDR_DADDR.
#define BS_DMA_TCD18_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD18_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_DADDR_DADDR field.
#define BR_DMA_TCD18_DADDR_DADDR()   (HW_DMA_TCD18_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD18_DADDR_DADDR.
#define BF_DMA_TCD18_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_DADDR_DADDR), uint32_t) & BM_DMA_TCD18_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD18_DADDR_DADDR(v)   (HW_DMA_TCD18_DADDR_WR((HW_DMA_TCD18_DADDR_RD() & ~BM_DMA_TCD18_DADDR_DADDR) | BF_DMA_TCD18_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd18_doff
{
    uint16_t U;
    struct _hw_dma_tcd18_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd18_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_DOFF register
 */
//@{
#define HW_DMA_TCD18_DOFF_ADDR      (REGS_DMA_BASE + 0x1254U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_DOFF           (*(__IO hw_dma_tcd18_doff_t *) HW_DMA_TCD18_DOFF_ADDR)
#define HW_DMA_TCD18_DOFF_RD()      (HW_DMA_TCD18_DOFF.U)
#define HW_DMA_TCD18_DOFF_WR(v)     (HW_DMA_TCD18_DOFF.U = (v))
#define HW_DMA_TCD18_DOFF_SET(v)    (HW_DMA_TCD18_DOFF_WR(HW_DMA_TCD18_DOFF_RD() |  (v)))
#define HW_DMA_TCD18_DOFF_CLR(v)    (HW_DMA_TCD18_DOFF_WR(HW_DMA_TCD18_DOFF_RD() & ~(v)))
#define HW_DMA_TCD18_DOFF_TOG(v)    (HW_DMA_TCD18_DOFF_WR(HW_DMA_TCD18_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_DOFF bitfields
 */

/*! @name Register DMA_TCD18_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD18_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD18_DOFF_DOFF.
#define BM_DMA_TCD18_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD18_DOFF_DOFF.
#define BS_DMA_TCD18_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD18_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_DOFF_DOFF field.
#define BR_DMA_TCD18_DOFF_DOFF()   (HW_DMA_TCD18_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD18_DOFF_DOFF.
#define BF_DMA_TCD18_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_DOFF_DOFF), uint16_t) & BM_DMA_TCD18_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD18_DOFF_DOFF(v)   (HW_DMA_TCD18_DOFF_WR((HW_DMA_TCD18_DOFF_RD() & ~BM_DMA_TCD18_DOFF_DOFF) | BF_DMA_TCD18_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd18_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd18_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd18_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD18_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1256U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_CITER_ELINKYES           (*(__IO hw_dma_tcd18_citer_elinkyes_t *) HW_DMA_TCD18_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD18_CITER_ELINKYES_RD()      (HW_DMA_TCD18_CITER_ELINKYES.U)
#define HW_DMA_TCD18_CITER_ELINKYES_WR(v)     (HW_DMA_TCD18_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD18_CITER_ELINKYES_SET(v)    (HW_DMA_TCD18_CITER_ELINKYES_WR(HW_DMA_TCD18_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD18_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD18_CITER_ELINKYES_WR(HW_DMA_TCD18_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD18_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD18_CITER_ELINKYES_WR(HW_DMA_TCD18_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD18_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD18_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD18_CITER_ELINKYES_CITER.
#define BM_DMA_TCD18_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD18_CITER_ELINKYES_CITER.
#define BS_DMA_TCD18_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD18_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD18_CITER_ELINKYES_CITER()   (HW_DMA_TCD18_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD18_CITER_ELINKYES_CITER.
#define BF_DMA_TCD18_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD18_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD18_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD18_CITER_ELINKYES_WR((HW_DMA_TCD18_CITER_ELINKYES_RD() & ~BM_DMA_TCD18_CITER_ELINKYES_CITER) | BF_DMA_TCD18_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD18_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD18_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD18_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD18_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD18_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD18_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD18_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD18_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD18_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD18_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD18_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD18_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD18_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD18_CITER_ELINKYES_WR((HW_DMA_TCD18_CITER_ELINKYES_RD() & ~BM_DMA_TCD18_CITER_ELINKYES_LINKCH) | BF_DMA_TCD18_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD18_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD18_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD18_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD18_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD18_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD18_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD18_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD18_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD18_CITER_ELINKYES_ADDR, BP_DMA_TCD18_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD18_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD18_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD18_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD18_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CITER_ELINKYES_ADDR, BP_DMA_TCD18_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd18_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd18_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd18_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD18_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1256U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_CITER_ELINKNO           (*(__IO hw_dma_tcd18_citer_elinkno_t *) HW_DMA_TCD18_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD18_CITER_ELINKNO_RD()      (HW_DMA_TCD18_CITER_ELINKNO.U)
#define HW_DMA_TCD18_CITER_ELINKNO_WR(v)     (HW_DMA_TCD18_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD18_CITER_ELINKNO_SET(v)    (HW_DMA_TCD18_CITER_ELINKNO_WR(HW_DMA_TCD18_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD18_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD18_CITER_ELINKNO_WR(HW_DMA_TCD18_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD18_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD18_CITER_ELINKNO_WR(HW_DMA_TCD18_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD18_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD18_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD18_CITER_ELINKNO_CITER.
#define BM_DMA_TCD18_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD18_CITER_ELINKNO_CITER.
#define BS_DMA_TCD18_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD18_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD18_CITER_ELINKNO_CITER()   (HW_DMA_TCD18_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD18_CITER_ELINKNO_CITER.
#define BF_DMA_TCD18_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD18_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD18_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD18_CITER_ELINKNO_WR((HW_DMA_TCD18_CITER_ELINKNO_RD() & ~BM_DMA_TCD18_CITER_ELINKNO_CITER) | BF_DMA_TCD18_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD18_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD18_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD18_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD18_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD18_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD18_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD18_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD18_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD18_CITER_ELINKNO_ADDR, BP_DMA_TCD18_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD18_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD18_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD18_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD18_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CITER_ELINKNO_ADDR, BP_DMA_TCD18_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd18_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd18_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd18_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_DLASTSGA register
 */
//@{
#define HW_DMA_TCD18_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1258U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_DLASTSGA           (*(__IO hw_dma_tcd18_dlastsga_t *) HW_DMA_TCD18_DLASTSGA_ADDR)
#define HW_DMA_TCD18_DLASTSGA_RD()      (HW_DMA_TCD18_DLASTSGA.U)
#define HW_DMA_TCD18_DLASTSGA_WR(v)     (HW_DMA_TCD18_DLASTSGA.U = (v))
#define HW_DMA_TCD18_DLASTSGA_SET(v)    (HW_DMA_TCD18_DLASTSGA_WR(HW_DMA_TCD18_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD18_DLASTSGA_CLR(v)    (HW_DMA_TCD18_DLASTSGA_WR(HW_DMA_TCD18_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD18_DLASTSGA_TOG(v)    (HW_DMA_TCD18_DLASTSGA_WR(HW_DMA_TCD18_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD18_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD18_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD18_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD18_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD18_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD18_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD18_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD18_DLASTSGA_DLASTSGA()   (HW_DMA_TCD18_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD18_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD18_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD18_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD18_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD18_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD18_DLASTSGA_WR((HW_DMA_TCD18_DLASTSGA_RD() & ~BM_DMA_TCD18_DLASTSGA_DLASTSGA) | BF_DMA_TCD18_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd18_csr
{
    uint16_t U;
    struct _hw_dma_tcd18_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd18_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_CSR register
 */
//@{
#define HW_DMA_TCD18_CSR_ADDR      (REGS_DMA_BASE + 0x125cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_CSR           (*(__IO hw_dma_tcd18_csr_t *) HW_DMA_TCD18_CSR_ADDR)
#define HW_DMA_TCD18_CSR_RD()      (HW_DMA_TCD18_CSR.U)
#define HW_DMA_TCD18_CSR_WR(v)     (HW_DMA_TCD18_CSR.U = (v))
#define HW_DMA_TCD18_CSR_SET(v)    (HW_DMA_TCD18_CSR_WR(HW_DMA_TCD18_CSR_RD() |  (v)))
#define HW_DMA_TCD18_CSR_CLR(v)    (HW_DMA_TCD18_CSR_WR(HW_DMA_TCD18_CSR_RD() & ~(v)))
#define HW_DMA_TCD18_CSR_TOG(v)    (HW_DMA_TCD18_CSR_WR(HW_DMA_TCD18_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_CSR bitfields
 */

/*! @name Register DMA_TCD18_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD18_CSR_START      (0U)      //!< Bit position for DMA_TCD18_CSR_START.
#define BM_DMA_TCD18_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD18_CSR_START.
#define BS_DMA_TCD18_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD18_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_START field.
#define BR_DMA_TCD18_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_START.
#define BF_DMA_TCD18_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_START), uint16_t) & BM_DMA_TCD18_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD18_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD18_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD18_CSR_INTMAJOR.
#define BM_DMA_TCD18_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD18_CSR_INTMAJOR.
#define BS_DMA_TCD18_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD18_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_INTMAJOR field.
#define BR_DMA_TCD18_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_INTMAJOR.
#define BF_DMA_TCD18_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD18_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD18_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD18_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD18_CSR_INTHALF.
#define BM_DMA_TCD18_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD18_CSR_INTHALF.
#define BS_DMA_TCD18_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD18_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_INTHALF field.
#define BR_DMA_TCD18_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_INTHALF.
#define BF_DMA_TCD18_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_INTHALF), uint16_t) & BM_DMA_TCD18_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD18_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD18_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD18_CSR_DREQ.
#define BM_DMA_TCD18_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD18_CSR_DREQ.
#define BS_DMA_TCD18_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD18_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_DREQ field.
#define BR_DMA_TCD18_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_DREQ.
#define BF_DMA_TCD18_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_DREQ), uint16_t) & BM_DMA_TCD18_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD18_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD18_CSR_ESG      (4U)      //!< Bit position for DMA_TCD18_CSR_ESG.
#define BM_DMA_TCD18_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD18_CSR_ESG.
#define BS_DMA_TCD18_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD18_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_ESG field.
#define BR_DMA_TCD18_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_ESG.
#define BF_DMA_TCD18_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_ESG), uint16_t) & BM_DMA_TCD18_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD18_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD18_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD18_CSR_MAJORELINK.
#define BM_DMA_TCD18_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD18_CSR_MAJORELINK.
#define BS_DMA_TCD18_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD18_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_MAJORELINK field.
#define BR_DMA_TCD18_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_MAJORELINK.
#define BF_DMA_TCD18_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD18_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD18_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD18_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD18_CSR_ACTIVE.
#define BM_DMA_TCD18_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD18_CSR_ACTIVE.
#define BS_DMA_TCD18_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD18_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_ACTIVE field.
#define BR_DMA_TCD18_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_ACTIVE.
#define BF_DMA_TCD18_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_ACTIVE), uint16_t) & BM_DMA_TCD18_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD18_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD18_CSR_DONE      (7U)      //!< Bit position for DMA_TCD18_CSR_DONE.
#define BM_DMA_TCD18_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD18_CSR_DONE.
#define BS_DMA_TCD18_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD18_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_DONE field.
#define BR_DMA_TCD18_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_DONE.
#define BF_DMA_TCD18_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_DONE), uint16_t) & BM_DMA_TCD18_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD18_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_CSR_ADDR, BP_DMA_TCD18_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD18_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD18_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD18_CSR_MAJORLINKCH.
#define BM_DMA_TCD18_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD18_CSR_MAJORLINKCH.
#define BS_DMA_TCD18_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD18_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_MAJORLINKCH field.
#define BR_DMA_TCD18_CSR_MAJORLINKCH()   (HW_DMA_TCD18_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_MAJORLINKCH.
#define BF_DMA_TCD18_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD18_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD18_CSR_MAJORLINKCH(v)   (HW_DMA_TCD18_CSR_WR((HW_DMA_TCD18_CSR_RD() & ~BM_DMA_TCD18_CSR_MAJORLINKCH) | BF_DMA_TCD18_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD18_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD18_CSR_BWC      (14U)      //!< Bit position for DMA_TCD18_CSR_BWC.
#define BM_DMA_TCD18_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD18_CSR_BWC.
#define BS_DMA_TCD18_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD18_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_CSR_BWC field.
#define BR_DMA_TCD18_CSR_BWC()   (HW_DMA_TCD18_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD18_CSR_BWC.
#define BF_DMA_TCD18_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_CSR_BWC), uint16_t) & BM_DMA_TCD18_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD18_CSR_BWC(v)   (HW_DMA_TCD18_CSR_WR((HW_DMA_TCD18_CSR_RD() & ~BM_DMA_TCD18_CSR_BWC) | BF_DMA_TCD18_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd18_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd18_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd18_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD18_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x125eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_BITER_ELINKYES           (*(__IO hw_dma_tcd18_biter_elinkyes_t *) HW_DMA_TCD18_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD18_BITER_ELINKYES_RD()      (HW_DMA_TCD18_BITER_ELINKYES.U)
#define HW_DMA_TCD18_BITER_ELINKYES_WR(v)     (HW_DMA_TCD18_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD18_BITER_ELINKYES_SET(v)    (HW_DMA_TCD18_BITER_ELINKYES_WR(HW_DMA_TCD18_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD18_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD18_BITER_ELINKYES_WR(HW_DMA_TCD18_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD18_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD18_BITER_ELINKYES_WR(HW_DMA_TCD18_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD18_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD18_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD18_BITER_ELINKYES_BITER.
#define BM_DMA_TCD18_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD18_BITER_ELINKYES_BITER.
#define BS_DMA_TCD18_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD18_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD18_BITER_ELINKYES_BITER()   (HW_DMA_TCD18_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD18_BITER_ELINKYES_BITER.
#define BF_DMA_TCD18_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD18_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD18_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD18_BITER_ELINKYES_WR((HW_DMA_TCD18_BITER_ELINKYES_RD() & ~BM_DMA_TCD18_BITER_ELINKYES_BITER) | BF_DMA_TCD18_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD18_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD18_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD18_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD18_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD18_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD18_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD18_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD18_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD18_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD18_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD18_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD18_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD18_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD18_BITER_ELINKYES_WR((HW_DMA_TCD18_BITER_ELINKYES_RD() & ~BM_DMA_TCD18_BITER_ELINKYES_LINKCH) | BF_DMA_TCD18_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD18_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD18_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD18_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD18_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD18_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD18_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD18_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD18_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD18_BITER_ELINKYES_ADDR, BP_DMA_TCD18_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD18_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD18_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD18_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD18_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_BITER_ELINKYES_ADDR, BP_DMA_TCD18_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD18_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD18_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd18_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd18_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd18_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD18_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD18_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x125eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD18_BITER_ELINKNO           (*(__IO hw_dma_tcd18_biter_elinkno_t *) HW_DMA_TCD18_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD18_BITER_ELINKNO_RD()      (HW_DMA_TCD18_BITER_ELINKNO.U)
#define HW_DMA_TCD18_BITER_ELINKNO_WR(v)     (HW_DMA_TCD18_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD18_BITER_ELINKNO_SET(v)    (HW_DMA_TCD18_BITER_ELINKNO_WR(HW_DMA_TCD18_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD18_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD18_BITER_ELINKNO_WR(HW_DMA_TCD18_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD18_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD18_BITER_ELINKNO_WR(HW_DMA_TCD18_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD18_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD18_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD18_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD18_BITER_ELINKNO_BITER.
#define BM_DMA_TCD18_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD18_BITER_ELINKNO_BITER.
#define BS_DMA_TCD18_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD18_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD18_BITER_ELINKNO_BITER()   (HW_DMA_TCD18_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD18_BITER_ELINKNO_BITER.
#define BF_DMA_TCD18_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD18_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD18_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD18_BITER_ELINKNO_WR((HW_DMA_TCD18_BITER_ELINKNO_RD() & ~BM_DMA_TCD18_BITER_ELINKNO_BITER) | BF_DMA_TCD18_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD18_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD18_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD18_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD18_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD18_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD18_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD18_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD18_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD18_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD18_BITER_ELINKNO_ADDR, BP_DMA_TCD18_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD18_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD18_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD18_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD18_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD18_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD18_BITER_ELINKNO_ADDR, BP_DMA_TCD18_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd19_saddr
{
    uint32_t U;
    struct _hw_dma_tcd19_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd19_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_SADDR register
 */
//@{
#define HW_DMA_TCD19_SADDR_ADDR      (REGS_DMA_BASE + 0x1260U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_SADDR           (*(__IO hw_dma_tcd19_saddr_t *) HW_DMA_TCD19_SADDR_ADDR)
#define HW_DMA_TCD19_SADDR_RD()      (HW_DMA_TCD19_SADDR.U)
#define HW_DMA_TCD19_SADDR_WR(v)     (HW_DMA_TCD19_SADDR.U = (v))
#define HW_DMA_TCD19_SADDR_SET(v)    (HW_DMA_TCD19_SADDR_WR(HW_DMA_TCD19_SADDR_RD() |  (v)))
#define HW_DMA_TCD19_SADDR_CLR(v)    (HW_DMA_TCD19_SADDR_WR(HW_DMA_TCD19_SADDR_RD() & ~(v)))
#define HW_DMA_TCD19_SADDR_TOG(v)    (HW_DMA_TCD19_SADDR_WR(HW_DMA_TCD19_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_SADDR bitfields
 */

/*! @name Register DMA_TCD19_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD19_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD19_SADDR_SADDR.
#define BM_DMA_TCD19_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD19_SADDR_SADDR.
#define BS_DMA_TCD19_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD19_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_SADDR_SADDR field.
#define BR_DMA_TCD19_SADDR_SADDR()   (HW_DMA_TCD19_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD19_SADDR_SADDR.
#define BF_DMA_TCD19_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_SADDR_SADDR), uint32_t) & BM_DMA_TCD19_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD19_SADDR_SADDR(v)   (HW_DMA_TCD19_SADDR_WR((HW_DMA_TCD19_SADDR_RD() & ~BM_DMA_TCD19_SADDR_SADDR) | BF_DMA_TCD19_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd19_soff
{
    uint16_t U;
    struct _hw_dma_tcd19_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd19_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_SOFF register
 */
//@{
#define HW_DMA_TCD19_SOFF_ADDR      (REGS_DMA_BASE + 0x1264U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_SOFF           (*(__IO hw_dma_tcd19_soff_t *) HW_DMA_TCD19_SOFF_ADDR)
#define HW_DMA_TCD19_SOFF_RD()      (HW_DMA_TCD19_SOFF.U)
#define HW_DMA_TCD19_SOFF_WR(v)     (HW_DMA_TCD19_SOFF.U = (v))
#define HW_DMA_TCD19_SOFF_SET(v)    (HW_DMA_TCD19_SOFF_WR(HW_DMA_TCD19_SOFF_RD() |  (v)))
#define HW_DMA_TCD19_SOFF_CLR(v)    (HW_DMA_TCD19_SOFF_WR(HW_DMA_TCD19_SOFF_RD() & ~(v)))
#define HW_DMA_TCD19_SOFF_TOG(v)    (HW_DMA_TCD19_SOFF_WR(HW_DMA_TCD19_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_SOFF bitfields
 */

/*! @name Register DMA_TCD19_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD19_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD19_SOFF_SOFF.
#define BM_DMA_TCD19_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD19_SOFF_SOFF.
#define BS_DMA_TCD19_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD19_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_SOFF_SOFF field.
#define BR_DMA_TCD19_SOFF_SOFF()   (HW_DMA_TCD19_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD19_SOFF_SOFF.
#define BF_DMA_TCD19_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_SOFF_SOFF), uint16_t) & BM_DMA_TCD19_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD19_SOFF_SOFF(v)   (HW_DMA_TCD19_SOFF_WR((HW_DMA_TCD19_SOFF_RD() & ~BM_DMA_TCD19_SOFF_SOFF) | BF_DMA_TCD19_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd19_attr
{
    uint16_t U;
    struct _hw_dma_tcd19_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd19_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_ATTR register
 */
//@{
#define HW_DMA_TCD19_ATTR_ADDR      (REGS_DMA_BASE + 0x1266U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_ATTR           (*(__IO hw_dma_tcd19_attr_t *) HW_DMA_TCD19_ATTR_ADDR)
#define HW_DMA_TCD19_ATTR_RD()      (HW_DMA_TCD19_ATTR.U)
#define HW_DMA_TCD19_ATTR_WR(v)     (HW_DMA_TCD19_ATTR.U = (v))
#define HW_DMA_TCD19_ATTR_SET(v)    (HW_DMA_TCD19_ATTR_WR(HW_DMA_TCD19_ATTR_RD() |  (v)))
#define HW_DMA_TCD19_ATTR_CLR(v)    (HW_DMA_TCD19_ATTR_WR(HW_DMA_TCD19_ATTR_RD() & ~(v)))
#define HW_DMA_TCD19_ATTR_TOG(v)    (HW_DMA_TCD19_ATTR_WR(HW_DMA_TCD19_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_ATTR bitfields
 */

/*! @name Register DMA_TCD19_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD19_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD19_ATTR_DSIZE.
#define BM_DMA_TCD19_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD19_ATTR_DSIZE.
#define BS_DMA_TCD19_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD19_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_ATTR_DSIZE field.
#define BR_DMA_TCD19_ATTR_DSIZE()   (HW_DMA_TCD19_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD19_ATTR_DSIZE.
#define BF_DMA_TCD19_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_ATTR_DSIZE), uint16_t) & BM_DMA_TCD19_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD19_ATTR_DSIZE(v)   (HW_DMA_TCD19_ATTR_WR((HW_DMA_TCD19_ATTR_RD() & ~BM_DMA_TCD19_ATTR_DSIZE) | BF_DMA_TCD19_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD19_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD19_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD19_ATTR_DMOD.
#define BM_DMA_TCD19_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD19_ATTR_DMOD.
#define BS_DMA_TCD19_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD19_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_ATTR_DMOD field.
#define BR_DMA_TCD19_ATTR_DMOD()   (HW_DMA_TCD19_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD19_ATTR_DMOD.
#define BF_DMA_TCD19_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_ATTR_DMOD), uint16_t) & BM_DMA_TCD19_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD19_ATTR_DMOD(v)   (HW_DMA_TCD19_ATTR_WR((HW_DMA_TCD19_ATTR_RD() & ~BM_DMA_TCD19_ATTR_DMOD) | BF_DMA_TCD19_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD19_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD19_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD19_ATTR_SSIZE.
#define BM_DMA_TCD19_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD19_ATTR_SSIZE.
#define BS_DMA_TCD19_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD19_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_ATTR_SSIZE field.
#define BR_DMA_TCD19_ATTR_SSIZE()   (HW_DMA_TCD19_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD19_ATTR_SSIZE.
#define BF_DMA_TCD19_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_ATTR_SSIZE), uint16_t) & BM_DMA_TCD19_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD19_ATTR_SSIZE(v)   (HW_DMA_TCD19_ATTR_WR((HW_DMA_TCD19_ATTR_RD() & ~BM_DMA_TCD19_ATTR_SSIZE) | BF_DMA_TCD19_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD19_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD19_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD19_ATTR_SMOD.
#define BM_DMA_TCD19_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD19_ATTR_SMOD.
#define BS_DMA_TCD19_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD19_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_ATTR_SMOD field.
#define BR_DMA_TCD19_ATTR_SMOD()   (HW_DMA_TCD19_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD19_ATTR_SMOD.
#define BF_DMA_TCD19_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_ATTR_SMOD), uint16_t) & BM_DMA_TCD19_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD19_ATTR_SMOD(v)   (HW_DMA_TCD19_ATTR_WR((HW_DMA_TCD19_ATTR_RD() & ~BM_DMA_TCD19_ATTR_SMOD) | BF_DMA_TCD19_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd19_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd19_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd19_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD19_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1268U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_NBYTES_MLNO           (*(__IO hw_dma_tcd19_nbytes_mlno_t *) HW_DMA_TCD19_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD19_NBYTES_MLNO_RD()      (HW_DMA_TCD19_NBYTES_MLNO.U)
#define HW_DMA_TCD19_NBYTES_MLNO_WR(v)     (HW_DMA_TCD19_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD19_NBYTES_MLNO_SET(v)    (HW_DMA_TCD19_NBYTES_MLNO_WR(HW_DMA_TCD19_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD19_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD19_NBYTES_MLNO_WR(HW_DMA_TCD19_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD19_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD19_NBYTES_MLNO_WR(HW_DMA_TCD19_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD19_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD19_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD19_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD19_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD19_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD19_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD19_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD19_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD19_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD19_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD19_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD19_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD19_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD19_NBYTES_MLNO_WR((HW_DMA_TCD19_NBYTES_MLNO_RD() & ~BM_DMA_TCD19_NBYTES_MLNO_NBYTES) | BF_DMA_TCD19_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd19_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd19_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd19_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD19_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1268U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd19_nbytes_mloffno_t *) HW_DMA_TCD19_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD19_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD19_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD19_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD19_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD19_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD19_NBYTES_MLOFFNO_WR(HW_DMA_TCD19_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD19_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD19_NBYTES_MLOFFNO_WR(HW_DMA_TCD19_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD19_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD19_NBYTES_MLOFFNO_WR(HW_DMA_TCD19_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD19_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD19_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD19_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD19_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD19_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD19_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD19_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD19_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD19_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD19_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD19_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD19_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD19_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD19_NBYTES_MLOFFNO_WR((HW_DMA_TCD19_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD19_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD19_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD19_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD19_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD19_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD19_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD19_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD19_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD19_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD19_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD19_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD19_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD19_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD19_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD19_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD19_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD19_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD19_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD19_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD19_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD19_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD19_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD19_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD19_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD19_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD19_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD19_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD19_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD19_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD19_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD19_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD19_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD19_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd19_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd19_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd19_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD19_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1268U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd19_nbytes_mloffyes_t *) HW_DMA_TCD19_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD19_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD19_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD19_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD19_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD19_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD19_NBYTES_MLOFFYES_WR(HW_DMA_TCD19_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD19_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD19_NBYTES_MLOFFYES_WR(HW_DMA_TCD19_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD19_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD19_NBYTES_MLOFFYES_WR(HW_DMA_TCD19_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD19_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD19_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD19_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD19_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD19_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD19_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD19_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD19_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD19_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD19_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD19_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD19_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD19_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD19_NBYTES_MLOFFYES_WR((HW_DMA_TCD19_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD19_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD19_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD19_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD19_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD19_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD19_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD19_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD19_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD19_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD19_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD19_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD19_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD19_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD19_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD19_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD19_NBYTES_MLOFFYES_WR((HW_DMA_TCD19_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD19_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD19_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD19_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD19_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD19_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD19_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD19_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD19_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD19_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD19_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD19_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD19_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD19_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD19_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD19_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD19_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD19_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD19_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD19_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD19_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD19_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD19_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD19_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD19_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD19_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD19_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD19_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD19_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD19_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD19_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD19_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD19_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD19_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd19_slast
{
    uint32_t U;
    struct _hw_dma_tcd19_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd19_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_SLAST register
 */
//@{
#define HW_DMA_TCD19_SLAST_ADDR      (REGS_DMA_BASE + 0x126cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_SLAST           (*(__IO hw_dma_tcd19_slast_t *) HW_DMA_TCD19_SLAST_ADDR)
#define HW_DMA_TCD19_SLAST_RD()      (HW_DMA_TCD19_SLAST.U)
#define HW_DMA_TCD19_SLAST_WR(v)     (HW_DMA_TCD19_SLAST.U = (v))
#define HW_DMA_TCD19_SLAST_SET(v)    (HW_DMA_TCD19_SLAST_WR(HW_DMA_TCD19_SLAST_RD() |  (v)))
#define HW_DMA_TCD19_SLAST_CLR(v)    (HW_DMA_TCD19_SLAST_WR(HW_DMA_TCD19_SLAST_RD() & ~(v)))
#define HW_DMA_TCD19_SLAST_TOG(v)    (HW_DMA_TCD19_SLAST_WR(HW_DMA_TCD19_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_SLAST bitfields
 */

/*! @name Register DMA_TCD19_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD19_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD19_SLAST_SLAST.
#define BM_DMA_TCD19_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD19_SLAST_SLAST.
#define BS_DMA_TCD19_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD19_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_SLAST_SLAST field.
#define BR_DMA_TCD19_SLAST_SLAST()   (HW_DMA_TCD19_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD19_SLAST_SLAST.
#define BF_DMA_TCD19_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_SLAST_SLAST), uint32_t) & BM_DMA_TCD19_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD19_SLAST_SLAST(v)   (HW_DMA_TCD19_SLAST_WR((HW_DMA_TCD19_SLAST_RD() & ~BM_DMA_TCD19_SLAST_SLAST) | BF_DMA_TCD19_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd19_daddr
{
    uint32_t U;
    struct _hw_dma_tcd19_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd19_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_DADDR register
 */
//@{
#define HW_DMA_TCD19_DADDR_ADDR      (REGS_DMA_BASE + 0x1270U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_DADDR           (*(__IO hw_dma_tcd19_daddr_t *) HW_DMA_TCD19_DADDR_ADDR)
#define HW_DMA_TCD19_DADDR_RD()      (HW_DMA_TCD19_DADDR.U)
#define HW_DMA_TCD19_DADDR_WR(v)     (HW_DMA_TCD19_DADDR.U = (v))
#define HW_DMA_TCD19_DADDR_SET(v)    (HW_DMA_TCD19_DADDR_WR(HW_DMA_TCD19_DADDR_RD() |  (v)))
#define HW_DMA_TCD19_DADDR_CLR(v)    (HW_DMA_TCD19_DADDR_WR(HW_DMA_TCD19_DADDR_RD() & ~(v)))
#define HW_DMA_TCD19_DADDR_TOG(v)    (HW_DMA_TCD19_DADDR_WR(HW_DMA_TCD19_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_DADDR bitfields
 */

/*! @name Register DMA_TCD19_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD19_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD19_DADDR_DADDR.
#define BM_DMA_TCD19_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD19_DADDR_DADDR.
#define BS_DMA_TCD19_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD19_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_DADDR_DADDR field.
#define BR_DMA_TCD19_DADDR_DADDR()   (HW_DMA_TCD19_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD19_DADDR_DADDR.
#define BF_DMA_TCD19_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_DADDR_DADDR), uint32_t) & BM_DMA_TCD19_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD19_DADDR_DADDR(v)   (HW_DMA_TCD19_DADDR_WR((HW_DMA_TCD19_DADDR_RD() & ~BM_DMA_TCD19_DADDR_DADDR) | BF_DMA_TCD19_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd19_doff
{
    uint16_t U;
    struct _hw_dma_tcd19_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd19_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_DOFF register
 */
//@{
#define HW_DMA_TCD19_DOFF_ADDR      (REGS_DMA_BASE + 0x1274U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_DOFF           (*(__IO hw_dma_tcd19_doff_t *) HW_DMA_TCD19_DOFF_ADDR)
#define HW_DMA_TCD19_DOFF_RD()      (HW_DMA_TCD19_DOFF.U)
#define HW_DMA_TCD19_DOFF_WR(v)     (HW_DMA_TCD19_DOFF.U = (v))
#define HW_DMA_TCD19_DOFF_SET(v)    (HW_DMA_TCD19_DOFF_WR(HW_DMA_TCD19_DOFF_RD() |  (v)))
#define HW_DMA_TCD19_DOFF_CLR(v)    (HW_DMA_TCD19_DOFF_WR(HW_DMA_TCD19_DOFF_RD() & ~(v)))
#define HW_DMA_TCD19_DOFF_TOG(v)    (HW_DMA_TCD19_DOFF_WR(HW_DMA_TCD19_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_DOFF bitfields
 */

/*! @name Register DMA_TCD19_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD19_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD19_DOFF_DOFF.
#define BM_DMA_TCD19_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD19_DOFF_DOFF.
#define BS_DMA_TCD19_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD19_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_DOFF_DOFF field.
#define BR_DMA_TCD19_DOFF_DOFF()   (HW_DMA_TCD19_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD19_DOFF_DOFF.
#define BF_DMA_TCD19_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_DOFF_DOFF), uint16_t) & BM_DMA_TCD19_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD19_DOFF_DOFF(v)   (HW_DMA_TCD19_DOFF_WR((HW_DMA_TCD19_DOFF_RD() & ~BM_DMA_TCD19_DOFF_DOFF) | BF_DMA_TCD19_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd19_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd19_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd19_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD19_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1276U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_CITER_ELINKYES           (*(__IO hw_dma_tcd19_citer_elinkyes_t *) HW_DMA_TCD19_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD19_CITER_ELINKYES_RD()      (HW_DMA_TCD19_CITER_ELINKYES.U)
#define HW_DMA_TCD19_CITER_ELINKYES_WR(v)     (HW_DMA_TCD19_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD19_CITER_ELINKYES_SET(v)    (HW_DMA_TCD19_CITER_ELINKYES_WR(HW_DMA_TCD19_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD19_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD19_CITER_ELINKYES_WR(HW_DMA_TCD19_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD19_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD19_CITER_ELINKYES_WR(HW_DMA_TCD19_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD19_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD19_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD19_CITER_ELINKYES_CITER.
#define BM_DMA_TCD19_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD19_CITER_ELINKYES_CITER.
#define BS_DMA_TCD19_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD19_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD19_CITER_ELINKYES_CITER()   (HW_DMA_TCD19_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD19_CITER_ELINKYES_CITER.
#define BF_DMA_TCD19_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD19_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD19_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD19_CITER_ELINKYES_WR((HW_DMA_TCD19_CITER_ELINKYES_RD() & ~BM_DMA_TCD19_CITER_ELINKYES_CITER) | BF_DMA_TCD19_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD19_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD19_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD19_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD19_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD19_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD19_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD19_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD19_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD19_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD19_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD19_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD19_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD19_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD19_CITER_ELINKYES_WR((HW_DMA_TCD19_CITER_ELINKYES_RD() & ~BM_DMA_TCD19_CITER_ELINKYES_LINKCH) | BF_DMA_TCD19_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD19_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD19_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD19_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD19_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD19_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD19_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD19_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD19_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD19_CITER_ELINKYES_ADDR, BP_DMA_TCD19_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD19_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD19_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD19_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD19_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CITER_ELINKYES_ADDR, BP_DMA_TCD19_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd19_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd19_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd19_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD19_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1276U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_CITER_ELINKNO           (*(__IO hw_dma_tcd19_citer_elinkno_t *) HW_DMA_TCD19_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD19_CITER_ELINKNO_RD()      (HW_DMA_TCD19_CITER_ELINKNO.U)
#define HW_DMA_TCD19_CITER_ELINKNO_WR(v)     (HW_DMA_TCD19_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD19_CITER_ELINKNO_SET(v)    (HW_DMA_TCD19_CITER_ELINKNO_WR(HW_DMA_TCD19_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD19_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD19_CITER_ELINKNO_WR(HW_DMA_TCD19_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD19_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD19_CITER_ELINKNO_WR(HW_DMA_TCD19_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD19_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD19_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD19_CITER_ELINKNO_CITER.
#define BM_DMA_TCD19_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD19_CITER_ELINKNO_CITER.
#define BS_DMA_TCD19_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD19_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD19_CITER_ELINKNO_CITER()   (HW_DMA_TCD19_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD19_CITER_ELINKNO_CITER.
#define BF_DMA_TCD19_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD19_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD19_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD19_CITER_ELINKNO_WR((HW_DMA_TCD19_CITER_ELINKNO_RD() & ~BM_DMA_TCD19_CITER_ELINKNO_CITER) | BF_DMA_TCD19_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD19_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD19_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD19_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD19_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD19_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD19_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD19_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD19_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD19_CITER_ELINKNO_ADDR, BP_DMA_TCD19_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD19_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD19_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD19_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD19_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CITER_ELINKNO_ADDR, BP_DMA_TCD19_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd19_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd19_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd19_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_DLASTSGA register
 */
//@{
#define HW_DMA_TCD19_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1278U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_DLASTSGA           (*(__IO hw_dma_tcd19_dlastsga_t *) HW_DMA_TCD19_DLASTSGA_ADDR)
#define HW_DMA_TCD19_DLASTSGA_RD()      (HW_DMA_TCD19_DLASTSGA.U)
#define HW_DMA_TCD19_DLASTSGA_WR(v)     (HW_DMA_TCD19_DLASTSGA.U = (v))
#define HW_DMA_TCD19_DLASTSGA_SET(v)    (HW_DMA_TCD19_DLASTSGA_WR(HW_DMA_TCD19_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD19_DLASTSGA_CLR(v)    (HW_DMA_TCD19_DLASTSGA_WR(HW_DMA_TCD19_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD19_DLASTSGA_TOG(v)    (HW_DMA_TCD19_DLASTSGA_WR(HW_DMA_TCD19_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD19_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD19_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD19_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD19_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD19_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD19_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD19_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD19_DLASTSGA_DLASTSGA()   (HW_DMA_TCD19_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD19_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD19_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD19_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD19_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD19_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD19_DLASTSGA_WR((HW_DMA_TCD19_DLASTSGA_RD() & ~BM_DMA_TCD19_DLASTSGA_DLASTSGA) | BF_DMA_TCD19_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd19_csr
{
    uint16_t U;
    struct _hw_dma_tcd19_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd19_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_CSR register
 */
//@{
#define HW_DMA_TCD19_CSR_ADDR      (REGS_DMA_BASE + 0x127cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_CSR           (*(__IO hw_dma_tcd19_csr_t *) HW_DMA_TCD19_CSR_ADDR)
#define HW_DMA_TCD19_CSR_RD()      (HW_DMA_TCD19_CSR.U)
#define HW_DMA_TCD19_CSR_WR(v)     (HW_DMA_TCD19_CSR.U = (v))
#define HW_DMA_TCD19_CSR_SET(v)    (HW_DMA_TCD19_CSR_WR(HW_DMA_TCD19_CSR_RD() |  (v)))
#define HW_DMA_TCD19_CSR_CLR(v)    (HW_DMA_TCD19_CSR_WR(HW_DMA_TCD19_CSR_RD() & ~(v)))
#define HW_DMA_TCD19_CSR_TOG(v)    (HW_DMA_TCD19_CSR_WR(HW_DMA_TCD19_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_CSR bitfields
 */

/*! @name Register DMA_TCD19_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD19_CSR_START      (0U)      //!< Bit position for DMA_TCD19_CSR_START.
#define BM_DMA_TCD19_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD19_CSR_START.
#define BS_DMA_TCD19_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD19_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_START field.
#define BR_DMA_TCD19_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_START.
#define BF_DMA_TCD19_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_START), uint16_t) & BM_DMA_TCD19_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD19_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD19_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD19_CSR_INTMAJOR.
#define BM_DMA_TCD19_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD19_CSR_INTMAJOR.
#define BS_DMA_TCD19_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD19_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_INTMAJOR field.
#define BR_DMA_TCD19_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_INTMAJOR.
#define BF_DMA_TCD19_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD19_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD19_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD19_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD19_CSR_INTHALF.
#define BM_DMA_TCD19_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD19_CSR_INTHALF.
#define BS_DMA_TCD19_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD19_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_INTHALF field.
#define BR_DMA_TCD19_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_INTHALF.
#define BF_DMA_TCD19_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_INTHALF), uint16_t) & BM_DMA_TCD19_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD19_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD19_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD19_CSR_DREQ.
#define BM_DMA_TCD19_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD19_CSR_DREQ.
#define BS_DMA_TCD19_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD19_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_DREQ field.
#define BR_DMA_TCD19_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_DREQ.
#define BF_DMA_TCD19_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_DREQ), uint16_t) & BM_DMA_TCD19_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD19_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD19_CSR_ESG      (4U)      //!< Bit position for DMA_TCD19_CSR_ESG.
#define BM_DMA_TCD19_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD19_CSR_ESG.
#define BS_DMA_TCD19_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD19_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_ESG field.
#define BR_DMA_TCD19_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_ESG.
#define BF_DMA_TCD19_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_ESG), uint16_t) & BM_DMA_TCD19_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD19_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD19_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD19_CSR_MAJORELINK.
#define BM_DMA_TCD19_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD19_CSR_MAJORELINK.
#define BS_DMA_TCD19_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD19_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_MAJORELINK field.
#define BR_DMA_TCD19_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_MAJORELINK.
#define BF_DMA_TCD19_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD19_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD19_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD19_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD19_CSR_ACTIVE.
#define BM_DMA_TCD19_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD19_CSR_ACTIVE.
#define BS_DMA_TCD19_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD19_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_ACTIVE field.
#define BR_DMA_TCD19_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_ACTIVE.
#define BF_DMA_TCD19_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_ACTIVE), uint16_t) & BM_DMA_TCD19_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD19_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD19_CSR_DONE      (7U)      //!< Bit position for DMA_TCD19_CSR_DONE.
#define BM_DMA_TCD19_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD19_CSR_DONE.
#define BS_DMA_TCD19_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD19_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_DONE field.
#define BR_DMA_TCD19_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_DONE.
#define BF_DMA_TCD19_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_DONE), uint16_t) & BM_DMA_TCD19_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD19_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_CSR_ADDR, BP_DMA_TCD19_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD19_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD19_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD19_CSR_MAJORLINKCH.
#define BM_DMA_TCD19_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD19_CSR_MAJORLINKCH.
#define BS_DMA_TCD19_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD19_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_MAJORLINKCH field.
#define BR_DMA_TCD19_CSR_MAJORLINKCH()   (HW_DMA_TCD19_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_MAJORLINKCH.
#define BF_DMA_TCD19_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD19_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD19_CSR_MAJORLINKCH(v)   (HW_DMA_TCD19_CSR_WR((HW_DMA_TCD19_CSR_RD() & ~BM_DMA_TCD19_CSR_MAJORLINKCH) | BF_DMA_TCD19_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD19_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD19_CSR_BWC      (14U)      //!< Bit position for DMA_TCD19_CSR_BWC.
#define BM_DMA_TCD19_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD19_CSR_BWC.
#define BS_DMA_TCD19_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD19_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_CSR_BWC field.
#define BR_DMA_TCD19_CSR_BWC()   (HW_DMA_TCD19_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD19_CSR_BWC.
#define BF_DMA_TCD19_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_CSR_BWC), uint16_t) & BM_DMA_TCD19_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD19_CSR_BWC(v)   (HW_DMA_TCD19_CSR_WR((HW_DMA_TCD19_CSR_RD() & ~BM_DMA_TCD19_CSR_BWC) | BF_DMA_TCD19_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd19_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd19_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd19_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD19_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x127eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_BITER_ELINKYES           (*(__IO hw_dma_tcd19_biter_elinkyes_t *) HW_DMA_TCD19_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD19_BITER_ELINKYES_RD()      (HW_DMA_TCD19_BITER_ELINKYES.U)
#define HW_DMA_TCD19_BITER_ELINKYES_WR(v)     (HW_DMA_TCD19_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD19_BITER_ELINKYES_SET(v)    (HW_DMA_TCD19_BITER_ELINKYES_WR(HW_DMA_TCD19_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD19_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD19_BITER_ELINKYES_WR(HW_DMA_TCD19_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD19_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD19_BITER_ELINKYES_WR(HW_DMA_TCD19_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD19_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD19_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD19_BITER_ELINKYES_BITER.
#define BM_DMA_TCD19_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD19_BITER_ELINKYES_BITER.
#define BS_DMA_TCD19_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD19_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD19_BITER_ELINKYES_BITER()   (HW_DMA_TCD19_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD19_BITER_ELINKYES_BITER.
#define BF_DMA_TCD19_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD19_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD19_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD19_BITER_ELINKYES_WR((HW_DMA_TCD19_BITER_ELINKYES_RD() & ~BM_DMA_TCD19_BITER_ELINKYES_BITER) | BF_DMA_TCD19_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD19_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD19_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD19_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD19_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD19_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD19_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD19_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD19_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD19_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD19_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD19_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD19_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD19_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD19_BITER_ELINKYES_WR((HW_DMA_TCD19_BITER_ELINKYES_RD() & ~BM_DMA_TCD19_BITER_ELINKYES_LINKCH) | BF_DMA_TCD19_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD19_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD19_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD19_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD19_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD19_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD19_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD19_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD19_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD19_BITER_ELINKYES_ADDR, BP_DMA_TCD19_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD19_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD19_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD19_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD19_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_BITER_ELINKYES_ADDR, BP_DMA_TCD19_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD19_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD19_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd19_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd19_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd19_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD19_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD19_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x127eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD19_BITER_ELINKNO           (*(__IO hw_dma_tcd19_biter_elinkno_t *) HW_DMA_TCD19_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD19_BITER_ELINKNO_RD()      (HW_DMA_TCD19_BITER_ELINKNO.U)
#define HW_DMA_TCD19_BITER_ELINKNO_WR(v)     (HW_DMA_TCD19_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD19_BITER_ELINKNO_SET(v)    (HW_DMA_TCD19_BITER_ELINKNO_WR(HW_DMA_TCD19_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD19_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD19_BITER_ELINKNO_WR(HW_DMA_TCD19_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD19_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD19_BITER_ELINKNO_WR(HW_DMA_TCD19_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD19_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD19_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD19_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD19_BITER_ELINKNO_BITER.
#define BM_DMA_TCD19_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD19_BITER_ELINKNO_BITER.
#define BS_DMA_TCD19_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD19_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD19_BITER_ELINKNO_BITER()   (HW_DMA_TCD19_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD19_BITER_ELINKNO_BITER.
#define BF_DMA_TCD19_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD19_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD19_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD19_BITER_ELINKNO_WR((HW_DMA_TCD19_BITER_ELINKNO_RD() & ~BM_DMA_TCD19_BITER_ELINKNO_BITER) | BF_DMA_TCD19_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD19_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD19_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD19_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD19_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD19_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD19_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD19_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD19_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD19_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD19_BITER_ELINKNO_ADDR, BP_DMA_TCD19_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD19_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD19_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD19_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD19_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD19_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD19_BITER_ELINKNO_ADDR, BP_DMA_TCD19_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd20_saddr
{
    uint32_t U;
    struct _hw_dma_tcd20_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd20_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_SADDR register
 */
//@{
#define HW_DMA_TCD20_SADDR_ADDR      (REGS_DMA_BASE + 0x1280U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_SADDR           (*(__IO hw_dma_tcd20_saddr_t *) HW_DMA_TCD20_SADDR_ADDR)
#define HW_DMA_TCD20_SADDR_RD()      (HW_DMA_TCD20_SADDR.U)
#define HW_DMA_TCD20_SADDR_WR(v)     (HW_DMA_TCD20_SADDR.U = (v))
#define HW_DMA_TCD20_SADDR_SET(v)    (HW_DMA_TCD20_SADDR_WR(HW_DMA_TCD20_SADDR_RD() |  (v)))
#define HW_DMA_TCD20_SADDR_CLR(v)    (HW_DMA_TCD20_SADDR_WR(HW_DMA_TCD20_SADDR_RD() & ~(v)))
#define HW_DMA_TCD20_SADDR_TOG(v)    (HW_DMA_TCD20_SADDR_WR(HW_DMA_TCD20_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_SADDR bitfields
 */

/*! @name Register DMA_TCD20_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD20_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD20_SADDR_SADDR.
#define BM_DMA_TCD20_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD20_SADDR_SADDR.
#define BS_DMA_TCD20_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD20_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_SADDR_SADDR field.
#define BR_DMA_TCD20_SADDR_SADDR()   (HW_DMA_TCD20_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD20_SADDR_SADDR.
#define BF_DMA_TCD20_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_SADDR_SADDR), uint32_t) & BM_DMA_TCD20_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD20_SADDR_SADDR(v)   (HW_DMA_TCD20_SADDR_WR((HW_DMA_TCD20_SADDR_RD() & ~BM_DMA_TCD20_SADDR_SADDR) | BF_DMA_TCD20_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd20_soff
{
    uint16_t U;
    struct _hw_dma_tcd20_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd20_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_SOFF register
 */
//@{
#define HW_DMA_TCD20_SOFF_ADDR      (REGS_DMA_BASE + 0x1284U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_SOFF           (*(__IO hw_dma_tcd20_soff_t *) HW_DMA_TCD20_SOFF_ADDR)
#define HW_DMA_TCD20_SOFF_RD()      (HW_DMA_TCD20_SOFF.U)
#define HW_DMA_TCD20_SOFF_WR(v)     (HW_DMA_TCD20_SOFF.U = (v))
#define HW_DMA_TCD20_SOFF_SET(v)    (HW_DMA_TCD20_SOFF_WR(HW_DMA_TCD20_SOFF_RD() |  (v)))
#define HW_DMA_TCD20_SOFF_CLR(v)    (HW_DMA_TCD20_SOFF_WR(HW_DMA_TCD20_SOFF_RD() & ~(v)))
#define HW_DMA_TCD20_SOFF_TOG(v)    (HW_DMA_TCD20_SOFF_WR(HW_DMA_TCD20_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_SOFF bitfields
 */

/*! @name Register DMA_TCD20_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD20_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD20_SOFF_SOFF.
#define BM_DMA_TCD20_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD20_SOFF_SOFF.
#define BS_DMA_TCD20_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD20_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_SOFF_SOFF field.
#define BR_DMA_TCD20_SOFF_SOFF()   (HW_DMA_TCD20_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD20_SOFF_SOFF.
#define BF_DMA_TCD20_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_SOFF_SOFF), uint16_t) & BM_DMA_TCD20_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD20_SOFF_SOFF(v)   (HW_DMA_TCD20_SOFF_WR((HW_DMA_TCD20_SOFF_RD() & ~BM_DMA_TCD20_SOFF_SOFF) | BF_DMA_TCD20_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd20_attr
{
    uint16_t U;
    struct _hw_dma_tcd20_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd20_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_ATTR register
 */
//@{
#define HW_DMA_TCD20_ATTR_ADDR      (REGS_DMA_BASE + 0x1286U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_ATTR           (*(__IO hw_dma_tcd20_attr_t *) HW_DMA_TCD20_ATTR_ADDR)
#define HW_DMA_TCD20_ATTR_RD()      (HW_DMA_TCD20_ATTR.U)
#define HW_DMA_TCD20_ATTR_WR(v)     (HW_DMA_TCD20_ATTR.U = (v))
#define HW_DMA_TCD20_ATTR_SET(v)    (HW_DMA_TCD20_ATTR_WR(HW_DMA_TCD20_ATTR_RD() |  (v)))
#define HW_DMA_TCD20_ATTR_CLR(v)    (HW_DMA_TCD20_ATTR_WR(HW_DMA_TCD20_ATTR_RD() & ~(v)))
#define HW_DMA_TCD20_ATTR_TOG(v)    (HW_DMA_TCD20_ATTR_WR(HW_DMA_TCD20_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_ATTR bitfields
 */

/*! @name Register DMA_TCD20_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD20_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD20_ATTR_DSIZE.
#define BM_DMA_TCD20_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD20_ATTR_DSIZE.
#define BS_DMA_TCD20_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD20_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_ATTR_DSIZE field.
#define BR_DMA_TCD20_ATTR_DSIZE()   (HW_DMA_TCD20_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD20_ATTR_DSIZE.
#define BF_DMA_TCD20_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_ATTR_DSIZE), uint16_t) & BM_DMA_TCD20_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD20_ATTR_DSIZE(v)   (HW_DMA_TCD20_ATTR_WR((HW_DMA_TCD20_ATTR_RD() & ~BM_DMA_TCD20_ATTR_DSIZE) | BF_DMA_TCD20_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD20_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD20_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD20_ATTR_DMOD.
#define BM_DMA_TCD20_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD20_ATTR_DMOD.
#define BS_DMA_TCD20_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD20_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_ATTR_DMOD field.
#define BR_DMA_TCD20_ATTR_DMOD()   (HW_DMA_TCD20_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD20_ATTR_DMOD.
#define BF_DMA_TCD20_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_ATTR_DMOD), uint16_t) & BM_DMA_TCD20_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD20_ATTR_DMOD(v)   (HW_DMA_TCD20_ATTR_WR((HW_DMA_TCD20_ATTR_RD() & ~BM_DMA_TCD20_ATTR_DMOD) | BF_DMA_TCD20_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD20_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD20_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD20_ATTR_SSIZE.
#define BM_DMA_TCD20_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD20_ATTR_SSIZE.
#define BS_DMA_TCD20_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD20_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_ATTR_SSIZE field.
#define BR_DMA_TCD20_ATTR_SSIZE()   (HW_DMA_TCD20_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD20_ATTR_SSIZE.
#define BF_DMA_TCD20_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_ATTR_SSIZE), uint16_t) & BM_DMA_TCD20_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD20_ATTR_SSIZE(v)   (HW_DMA_TCD20_ATTR_WR((HW_DMA_TCD20_ATTR_RD() & ~BM_DMA_TCD20_ATTR_SSIZE) | BF_DMA_TCD20_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD20_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD20_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD20_ATTR_SMOD.
#define BM_DMA_TCD20_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD20_ATTR_SMOD.
#define BS_DMA_TCD20_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD20_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_ATTR_SMOD field.
#define BR_DMA_TCD20_ATTR_SMOD()   (HW_DMA_TCD20_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD20_ATTR_SMOD.
#define BF_DMA_TCD20_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_ATTR_SMOD), uint16_t) & BM_DMA_TCD20_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD20_ATTR_SMOD(v)   (HW_DMA_TCD20_ATTR_WR((HW_DMA_TCD20_ATTR_RD() & ~BM_DMA_TCD20_ATTR_SMOD) | BF_DMA_TCD20_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd20_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd20_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd20_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD20_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1288U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_NBYTES_MLNO           (*(__IO hw_dma_tcd20_nbytes_mlno_t *) HW_DMA_TCD20_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD20_NBYTES_MLNO_RD()      (HW_DMA_TCD20_NBYTES_MLNO.U)
#define HW_DMA_TCD20_NBYTES_MLNO_WR(v)     (HW_DMA_TCD20_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD20_NBYTES_MLNO_SET(v)    (HW_DMA_TCD20_NBYTES_MLNO_WR(HW_DMA_TCD20_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD20_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD20_NBYTES_MLNO_WR(HW_DMA_TCD20_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD20_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD20_NBYTES_MLNO_WR(HW_DMA_TCD20_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD20_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD20_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD20_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD20_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD20_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD20_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD20_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD20_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD20_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD20_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD20_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD20_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD20_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD20_NBYTES_MLNO_WR((HW_DMA_TCD20_NBYTES_MLNO_RD() & ~BM_DMA_TCD20_NBYTES_MLNO_NBYTES) | BF_DMA_TCD20_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd20_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd20_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd20_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD20_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1288U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd20_nbytes_mloffno_t *) HW_DMA_TCD20_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD20_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD20_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD20_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD20_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD20_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD20_NBYTES_MLOFFNO_WR(HW_DMA_TCD20_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD20_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD20_NBYTES_MLOFFNO_WR(HW_DMA_TCD20_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD20_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD20_NBYTES_MLOFFNO_WR(HW_DMA_TCD20_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD20_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD20_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD20_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD20_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD20_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD20_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD20_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD20_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD20_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD20_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD20_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD20_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD20_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD20_NBYTES_MLOFFNO_WR((HW_DMA_TCD20_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD20_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD20_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD20_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD20_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD20_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD20_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD20_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD20_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD20_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD20_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD20_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD20_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD20_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD20_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD20_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD20_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD20_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD20_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD20_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD20_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD20_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD20_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD20_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD20_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD20_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD20_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD20_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD20_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD20_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD20_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD20_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD20_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD20_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd20_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd20_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd20_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD20_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1288U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd20_nbytes_mloffyes_t *) HW_DMA_TCD20_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD20_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD20_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD20_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD20_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD20_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD20_NBYTES_MLOFFYES_WR(HW_DMA_TCD20_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD20_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD20_NBYTES_MLOFFYES_WR(HW_DMA_TCD20_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD20_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD20_NBYTES_MLOFFYES_WR(HW_DMA_TCD20_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD20_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD20_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD20_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD20_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD20_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD20_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD20_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD20_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD20_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD20_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD20_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD20_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD20_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD20_NBYTES_MLOFFYES_WR((HW_DMA_TCD20_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD20_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD20_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD20_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD20_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD20_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD20_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD20_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD20_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD20_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD20_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD20_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD20_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD20_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD20_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD20_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD20_NBYTES_MLOFFYES_WR((HW_DMA_TCD20_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD20_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD20_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD20_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD20_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD20_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD20_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD20_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD20_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD20_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD20_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD20_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD20_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD20_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD20_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD20_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD20_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD20_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD20_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD20_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD20_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD20_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD20_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD20_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD20_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD20_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD20_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD20_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD20_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD20_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD20_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD20_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD20_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD20_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd20_slast
{
    uint32_t U;
    struct _hw_dma_tcd20_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd20_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_SLAST register
 */
//@{
#define HW_DMA_TCD20_SLAST_ADDR      (REGS_DMA_BASE + 0x128cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_SLAST           (*(__IO hw_dma_tcd20_slast_t *) HW_DMA_TCD20_SLAST_ADDR)
#define HW_DMA_TCD20_SLAST_RD()      (HW_DMA_TCD20_SLAST.U)
#define HW_DMA_TCD20_SLAST_WR(v)     (HW_DMA_TCD20_SLAST.U = (v))
#define HW_DMA_TCD20_SLAST_SET(v)    (HW_DMA_TCD20_SLAST_WR(HW_DMA_TCD20_SLAST_RD() |  (v)))
#define HW_DMA_TCD20_SLAST_CLR(v)    (HW_DMA_TCD20_SLAST_WR(HW_DMA_TCD20_SLAST_RD() & ~(v)))
#define HW_DMA_TCD20_SLAST_TOG(v)    (HW_DMA_TCD20_SLAST_WR(HW_DMA_TCD20_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_SLAST bitfields
 */

/*! @name Register DMA_TCD20_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD20_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD20_SLAST_SLAST.
#define BM_DMA_TCD20_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD20_SLAST_SLAST.
#define BS_DMA_TCD20_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD20_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_SLAST_SLAST field.
#define BR_DMA_TCD20_SLAST_SLAST()   (HW_DMA_TCD20_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD20_SLAST_SLAST.
#define BF_DMA_TCD20_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_SLAST_SLAST), uint32_t) & BM_DMA_TCD20_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD20_SLAST_SLAST(v)   (HW_DMA_TCD20_SLAST_WR((HW_DMA_TCD20_SLAST_RD() & ~BM_DMA_TCD20_SLAST_SLAST) | BF_DMA_TCD20_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd20_daddr
{
    uint32_t U;
    struct _hw_dma_tcd20_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd20_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_DADDR register
 */
//@{
#define HW_DMA_TCD20_DADDR_ADDR      (REGS_DMA_BASE + 0x1290U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_DADDR           (*(__IO hw_dma_tcd20_daddr_t *) HW_DMA_TCD20_DADDR_ADDR)
#define HW_DMA_TCD20_DADDR_RD()      (HW_DMA_TCD20_DADDR.U)
#define HW_DMA_TCD20_DADDR_WR(v)     (HW_DMA_TCD20_DADDR.U = (v))
#define HW_DMA_TCD20_DADDR_SET(v)    (HW_DMA_TCD20_DADDR_WR(HW_DMA_TCD20_DADDR_RD() |  (v)))
#define HW_DMA_TCD20_DADDR_CLR(v)    (HW_DMA_TCD20_DADDR_WR(HW_DMA_TCD20_DADDR_RD() & ~(v)))
#define HW_DMA_TCD20_DADDR_TOG(v)    (HW_DMA_TCD20_DADDR_WR(HW_DMA_TCD20_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_DADDR bitfields
 */

/*! @name Register DMA_TCD20_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD20_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD20_DADDR_DADDR.
#define BM_DMA_TCD20_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD20_DADDR_DADDR.
#define BS_DMA_TCD20_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD20_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_DADDR_DADDR field.
#define BR_DMA_TCD20_DADDR_DADDR()   (HW_DMA_TCD20_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD20_DADDR_DADDR.
#define BF_DMA_TCD20_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_DADDR_DADDR), uint32_t) & BM_DMA_TCD20_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD20_DADDR_DADDR(v)   (HW_DMA_TCD20_DADDR_WR((HW_DMA_TCD20_DADDR_RD() & ~BM_DMA_TCD20_DADDR_DADDR) | BF_DMA_TCD20_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd20_doff
{
    uint16_t U;
    struct _hw_dma_tcd20_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd20_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_DOFF register
 */
//@{
#define HW_DMA_TCD20_DOFF_ADDR      (REGS_DMA_BASE + 0x1294U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_DOFF           (*(__IO hw_dma_tcd20_doff_t *) HW_DMA_TCD20_DOFF_ADDR)
#define HW_DMA_TCD20_DOFF_RD()      (HW_DMA_TCD20_DOFF.U)
#define HW_DMA_TCD20_DOFF_WR(v)     (HW_DMA_TCD20_DOFF.U = (v))
#define HW_DMA_TCD20_DOFF_SET(v)    (HW_DMA_TCD20_DOFF_WR(HW_DMA_TCD20_DOFF_RD() |  (v)))
#define HW_DMA_TCD20_DOFF_CLR(v)    (HW_DMA_TCD20_DOFF_WR(HW_DMA_TCD20_DOFF_RD() & ~(v)))
#define HW_DMA_TCD20_DOFF_TOG(v)    (HW_DMA_TCD20_DOFF_WR(HW_DMA_TCD20_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_DOFF bitfields
 */

/*! @name Register DMA_TCD20_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD20_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD20_DOFF_DOFF.
#define BM_DMA_TCD20_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD20_DOFF_DOFF.
#define BS_DMA_TCD20_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD20_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_DOFF_DOFF field.
#define BR_DMA_TCD20_DOFF_DOFF()   (HW_DMA_TCD20_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD20_DOFF_DOFF.
#define BF_DMA_TCD20_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_DOFF_DOFF), uint16_t) & BM_DMA_TCD20_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD20_DOFF_DOFF(v)   (HW_DMA_TCD20_DOFF_WR((HW_DMA_TCD20_DOFF_RD() & ~BM_DMA_TCD20_DOFF_DOFF) | BF_DMA_TCD20_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd20_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd20_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd20_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD20_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1296U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_CITER_ELINKYES           (*(__IO hw_dma_tcd20_citer_elinkyes_t *) HW_DMA_TCD20_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD20_CITER_ELINKYES_RD()      (HW_DMA_TCD20_CITER_ELINKYES.U)
#define HW_DMA_TCD20_CITER_ELINKYES_WR(v)     (HW_DMA_TCD20_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD20_CITER_ELINKYES_SET(v)    (HW_DMA_TCD20_CITER_ELINKYES_WR(HW_DMA_TCD20_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD20_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD20_CITER_ELINKYES_WR(HW_DMA_TCD20_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD20_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD20_CITER_ELINKYES_WR(HW_DMA_TCD20_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD20_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD20_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD20_CITER_ELINKYES_CITER.
#define BM_DMA_TCD20_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD20_CITER_ELINKYES_CITER.
#define BS_DMA_TCD20_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD20_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD20_CITER_ELINKYES_CITER()   (HW_DMA_TCD20_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD20_CITER_ELINKYES_CITER.
#define BF_DMA_TCD20_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD20_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD20_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD20_CITER_ELINKYES_WR((HW_DMA_TCD20_CITER_ELINKYES_RD() & ~BM_DMA_TCD20_CITER_ELINKYES_CITER) | BF_DMA_TCD20_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD20_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD20_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD20_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD20_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD20_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD20_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD20_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD20_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD20_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD20_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD20_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD20_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD20_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD20_CITER_ELINKYES_WR((HW_DMA_TCD20_CITER_ELINKYES_RD() & ~BM_DMA_TCD20_CITER_ELINKYES_LINKCH) | BF_DMA_TCD20_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD20_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD20_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD20_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD20_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD20_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD20_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD20_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD20_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD20_CITER_ELINKYES_ADDR, BP_DMA_TCD20_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD20_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD20_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD20_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD20_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CITER_ELINKYES_ADDR, BP_DMA_TCD20_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd20_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd20_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd20_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD20_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1296U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_CITER_ELINKNO           (*(__IO hw_dma_tcd20_citer_elinkno_t *) HW_DMA_TCD20_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD20_CITER_ELINKNO_RD()      (HW_DMA_TCD20_CITER_ELINKNO.U)
#define HW_DMA_TCD20_CITER_ELINKNO_WR(v)     (HW_DMA_TCD20_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD20_CITER_ELINKNO_SET(v)    (HW_DMA_TCD20_CITER_ELINKNO_WR(HW_DMA_TCD20_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD20_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD20_CITER_ELINKNO_WR(HW_DMA_TCD20_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD20_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD20_CITER_ELINKNO_WR(HW_DMA_TCD20_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD20_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD20_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD20_CITER_ELINKNO_CITER.
#define BM_DMA_TCD20_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD20_CITER_ELINKNO_CITER.
#define BS_DMA_TCD20_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD20_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD20_CITER_ELINKNO_CITER()   (HW_DMA_TCD20_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD20_CITER_ELINKNO_CITER.
#define BF_DMA_TCD20_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD20_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD20_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD20_CITER_ELINKNO_WR((HW_DMA_TCD20_CITER_ELINKNO_RD() & ~BM_DMA_TCD20_CITER_ELINKNO_CITER) | BF_DMA_TCD20_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD20_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD20_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD20_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD20_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD20_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD20_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD20_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD20_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD20_CITER_ELINKNO_ADDR, BP_DMA_TCD20_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD20_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD20_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD20_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD20_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CITER_ELINKNO_ADDR, BP_DMA_TCD20_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd20_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd20_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd20_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_DLASTSGA register
 */
//@{
#define HW_DMA_TCD20_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1298U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_DLASTSGA           (*(__IO hw_dma_tcd20_dlastsga_t *) HW_DMA_TCD20_DLASTSGA_ADDR)
#define HW_DMA_TCD20_DLASTSGA_RD()      (HW_DMA_TCD20_DLASTSGA.U)
#define HW_DMA_TCD20_DLASTSGA_WR(v)     (HW_DMA_TCD20_DLASTSGA.U = (v))
#define HW_DMA_TCD20_DLASTSGA_SET(v)    (HW_DMA_TCD20_DLASTSGA_WR(HW_DMA_TCD20_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD20_DLASTSGA_CLR(v)    (HW_DMA_TCD20_DLASTSGA_WR(HW_DMA_TCD20_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD20_DLASTSGA_TOG(v)    (HW_DMA_TCD20_DLASTSGA_WR(HW_DMA_TCD20_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD20_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD20_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD20_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD20_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD20_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD20_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD20_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD20_DLASTSGA_DLASTSGA()   (HW_DMA_TCD20_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD20_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD20_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD20_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD20_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD20_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD20_DLASTSGA_WR((HW_DMA_TCD20_DLASTSGA_RD() & ~BM_DMA_TCD20_DLASTSGA_DLASTSGA) | BF_DMA_TCD20_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd20_csr
{
    uint16_t U;
    struct _hw_dma_tcd20_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd20_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_CSR register
 */
//@{
#define HW_DMA_TCD20_CSR_ADDR      (REGS_DMA_BASE + 0x129cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_CSR           (*(__IO hw_dma_tcd20_csr_t *) HW_DMA_TCD20_CSR_ADDR)
#define HW_DMA_TCD20_CSR_RD()      (HW_DMA_TCD20_CSR.U)
#define HW_DMA_TCD20_CSR_WR(v)     (HW_DMA_TCD20_CSR.U = (v))
#define HW_DMA_TCD20_CSR_SET(v)    (HW_DMA_TCD20_CSR_WR(HW_DMA_TCD20_CSR_RD() |  (v)))
#define HW_DMA_TCD20_CSR_CLR(v)    (HW_DMA_TCD20_CSR_WR(HW_DMA_TCD20_CSR_RD() & ~(v)))
#define HW_DMA_TCD20_CSR_TOG(v)    (HW_DMA_TCD20_CSR_WR(HW_DMA_TCD20_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_CSR bitfields
 */

/*! @name Register DMA_TCD20_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD20_CSR_START      (0U)      //!< Bit position for DMA_TCD20_CSR_START.
#define BM_DMA_TCD20_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD20_CSR_START.
#define BS_DMA_TCD20_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD20_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_START field.
#define BR_DMA_TCD20_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_START.
#define BF_DMA_TCD20_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_START), uint16_t) & BM_DMA_TCD20_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD20_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD20_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD20_CSR_INTMAJOR.
#define BM_DMA_TCD20_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD20_CSR_INTMAJOR.
#define BS_DMA_TCD20_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD20_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_INTMAJOR field.
#define BR_DMA_TCD20_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_INTMAJOR.
#define BF_DMA_TCD20_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD20_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD20_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD20_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD20_CSR_INTHALF.
#define BM_DMA_TCD20_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD20_CSR_INTHALF.
#define BS_DMA_TCD20_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD20_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_INTHALF field.
#define BR_DMA_TCD20_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_INTHALF.
#define BF_DMA_TCD20_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_INTHALF), uint16_t) & BM_DMA_TCD20_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD20_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD20_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD20_CSR_DREQ.
#define BM_DMA_TCD20_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD20_CSR_DREQ.
#define BS_DMA_TCD20_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD20_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_DREQ field.
#define BR_DMA_TCD20_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_DREQ.
#define BF_DMA_TCD20_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_DREQ), uint16_t) & BM_DMA_TCD20_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD20_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD20_CSR_ESG      (4U)      //!< Bit position for DMA_TCD20_CSR_ESG.
#define BM_DMA_TCD20_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD20_CSR_ESG.
#define BS_DMA_TCD20_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD20_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_ESG field.
#define BR_DMA_TCD20_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_ESG.
#define BF_DMA_TCD20_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_ESG), uint16_t) & BM_DMA_TCD20_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD20_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD20_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD20_CSR_MAJORELINK.
#define BM_DMA_TCD20_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD20_CSR_MAJORELINK.
#define BS_DMA_TCD20_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD20_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_MAJORELINK field.
#define BR_DMA_TCD20_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_MAJORELINK.
#define BF_DMA_TCD20_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD20_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD20_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD20_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD20_CSR_ACTIVE.
#define BM_DMA_TCD20_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD20_CSR_ACTIVE.
#define BS_DMA_TCD20_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD20_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_ACTIVE field.
#define BR_DMA_TCD20_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_ACTIVE.
#define BF_DMA_TCD20_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_ACTIVE), uint16_t) & BM_DMA_TCD20_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD20_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD20_CSR_DONE      (7U)      //!< Bit position for DMA_TCD20_CSR_DONE.
#define BM_DMA_TCD20_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD20_CSR_DONE.
#define BS_DMA_TCD20_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD20_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_DONE field.
#define BR_DMA_TCD20_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_DONE.
#define BF_DMA_TCD20_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_DONE), uint16_t) & BM_DMA_TCD20_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD20_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_CSR_ADDR, BP_DMA_TCD20_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD20_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD20_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD20_CSR_MAJORLINKCH.
#define BM_DMA_TCD20_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD20_CSR_MAJORLINKCH.
#define BS_DMA_TCD20_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD20_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_MAJORLINKCH field.
#define BR_DMA_TCD20_CSR_MAJORLINKCH()   (HW_DMA_TCD20_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_MAJORLINKCH.
#define BF_DMA_TCD20_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD20_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD20_CSR_MAJORLINKCH(v)   (HW_DMA_TCD20_CSR_WR((HW_DMA_TCD20_CSR_RD() & ~BM_DMA_TCD20_CSR_MAJORLINKCH) | BF_DMA_TCD20_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD20_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD20_CSR_BWC      (14U)      //!< Bit position for DMA_TCD20_CSR_BWC.
#define BM_DMA_TCD20_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD20_CSR_BWC.
#define BS_DMA_TCD20_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD20_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_CSR_BWC field.
#define BR_DMA_TCD20_CSR_BWC()   (HW_DMA_TCD20_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD20_CSR_BWC.
#define BF_DMA_TCD20_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_CSR_BWC), uint16_t) & BM_DMA_TCD20_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD20_CSR_BWC(v)   (HW_DMA_TCD20_CSR_WR((HW_DMA_TCD20_CSR_RD() & ~BM_DMA_TCD20_CSR_BWC) | BF_DMA_TCD20_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd20_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd20_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd20_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD20_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x129eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_BITER_ELINKYES           (*(__IO hw_dma_tcd20_biter_elinkyes_t *) HW_DMA_TCD20_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD20_BITER_ELINKYES_RD()      (HW_DMA_TCD20_BITER_ELINKYES.U)
#define HW_DMA_TCD20_BITER_ELINKYES_WR(v)     (HW_DMA_TCD20_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD20_BITER_ELINKYES_SET(v)    (HW_DMA_TCD20_BITER_ELINKYES_WR(HW_DMA_TCD20_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD20_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD20_BITER_ELINKYES_WR(HW_DMA_TCD20_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD20_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD20_BITER_ELINKYES_WR(HW_DMA_TCD20_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD20_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD20_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD20_BITER_ELINKYES_BITER.
#define BM_DMA_TCD20_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD20_BITER_ELINKYES_BITER.
#define BS_DMA_TCD20_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD20_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD20_BITER_ELINKYES_BITER()   (HW_DMA_TCD20_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD20_BITER_ELINKYES_BITER.
#define BF_DMA_TCD20_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD20_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD20_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD20_BITER_ELINKYES_WR((HW_DMA_TCD20_BITER_ELINKYES_RD() & ~BM_DMA_TCD20_BITER_ELINKYES_BITER) | BF_DMA_TCD20_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD20_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD20_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD20_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD20_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD20_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD20_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD20_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD20_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD20_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD20_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD20_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD20_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD20_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD20_BITER_ELINKYES_WR((HW_DMA_TCD20_BITER_ELINKYES_RD() & ~BM_DMA_TCD20_BITER_ELINKYES_LINKCH) | BF_DMA_TCD20_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD20_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD20_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD20_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD20_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD20_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD20_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD20_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD20_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD20_BITER_ELINKYES_ADDR, BP_DMA_TCD20_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD20_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD20_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD20_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD20_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_BITER_ELINKYES_ADDR, BP_DMA_TCD20_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD20_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD20_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd20_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd20_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd20_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD20_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD20_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x129eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD20_BITER_ELINKNO           (*(__IO hw_dma_tcd20_biter_elinkno_t *) HW_DMA_TCD20_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD20_BITER_ELINKNO_RD()      (HW_DMA_TCD20_BITER_ELINKNO.U)
#define HW_DMA_TCD20_BITER_ELINKNO_WR(v)     (HW_DMA_TCD20_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD20_BITER_ELINKNO_SET(v)    (HW_DMA_TCD20_BITER_ELINKNO_WR(HW_DMA_TCD20_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD20_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD20_BITER_ELINKNO_WR(HW_DMA_TCD20_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD20_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD20_BITER_ELINKNO_WR(HW_DMA_TCD20_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD20_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD20_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD20_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD20_BITER_ELINKNO_BITER.
#define BM_DMA_TCD20_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD20_BITER_ELINKNO_BITER.
#define BS_DMA_TCD20_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD20_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD20_BITER_ELINKNO_BITER()   (HW_DMA_TCD20_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD20_BITER_ELINKNO_BITER.
#define BF_DMA_TCD20_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD20_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD20_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD20_BITER_ELINKNO_WR((HW_DMA_TCD20_BITER_ELINKNO_RD() & ~BM_DMA_TCD20_BITER_ELINKNO_BITER) | BF_DMA_TCD20_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD20_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD20_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD20_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD20_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD20_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD20_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD20_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD20_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD20_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD20_BITER_ELINKNO_ADDR, BP_DMA_TCD20_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD20_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD20_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD20_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD20_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD20_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD20_BITER_ELINKNO_ADDR, BP_DMA_TCD20_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd21_saddr
{
    uint32_t U;
    struct _hw_dma_tcd21_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd21_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_SADDR register
 */
//@{
#define HW_DMA_TCD21_SADDR_ADDR      (REGS_DMA_BASE + 0x12a0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_SADDR           (*(__IO hw_dma_tcd21_saddr_t *) HW_DMA_TCD21_SADDR_ADDR)
#define HW_DMA_TCD21_SADDR_RD()      (HW_DMA_TCD21_SADDR.U)
#define HW_DMA_TCD21_SADDR_WR(v)     (HW_DMA_TCD21_SADDR.U = (v))
#define HW_DMA_TCD21_SADDR_SET(v)    (HW_DMA_TCD21_SADDR_WR(HW_DMA_TCD21_SADDR_RD() |  (v)))
#define HW_DMA_TCD21_SADDR_CLR(v)    (HW_DMA_TCD21_SADDR_WR(HW_DMA_TCD21_SADDR_RD() & ~(v)))
#define HW_DMA_TCD21_SADDR_TOG(v)    (HW_DMA_TCD21_SADDR_WR(HW_DMA_TCD21_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_SADDR bitfields
 */

/*! @name Register DMA_TCD21_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD21_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD21_SADDR_SADDR.
#define BM_DMA_TCD21_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD21_SADDR_SADDR.
#define BS_DMA_TCD21_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD21_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_SADDR_SADDR field.
#define BR_DMA_TCD21_SADDR_SADDR()   (HW_DMA_TCD21_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD21_SADDR_SADDR.
#define BF_DMA_TCD21_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_SADDR_SADDR), uint32_t) & BM_DMA_TCD21_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD21_SADDR_SADDR(v)   (HW_DMA_TCD21_SADDR_WR((HW_DMA_TCD21_SADDR_RD() & ~BM_DMA_TCD21_SADDR_SADDR) | BF_DMA_TCD21_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd21_soff
{
    uint16_t U;
    struct _hw_dma_tcd21_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd21_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_SOFF register
 */
//@{
#define HW_DMA_TCD21_SOFF_ADDR      (REGS_DMA_BASE + 0x12a4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_SOFF           (*(__IO hw_dma_tcd21_soff_t *) HW_DMA_TCD21_SOFF_ADDR)
#define HW_DMA_TCD21_SOFF_RD()      (HW_DMA_TCD21_SOFF.U)
#define HW_DMA_TCD21_SOFF_WR(v)     (HW_DMA_TCD21_SOFF.U = (v))
#define HW_DMA_TCD21_SOFF_SET(v)    (HW_DMA_TCD21_SOFF_WR(HW_DMA_TCD21_SOFF_RD() |  (v)))
#define HW_DMA_TCD21_SOFF_CLR(v)    (HW_DMA_TCD21_SOFF_WR(HW_DMA_TCD21_SOFF_RD() & ~(v)))
#define HW_DMA_TCD21_SOFF_TOG(v)    (HW_DMA_TCD21_SOFF_WR(HW_DMA_TCD21_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_SOFF bitfields
 */

/*! @name Register DMA_TCD21_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD21_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD21_SOFF_SOFF.
#define BM_DMA_TCD21_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD21_SOFF_SOFF.
#define BS_DMA_TCD21_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD21_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_SOFF_SOFF field.
#define BR_DMA_TCD21_SOFF_SOFF()   (HW_DMA_TCD21_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD21_SOFF_SOFF.
#define BF_DMA_TCD21_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_SOFF_SOFF), uint16_t) & BM_DMA_TCD21_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD21_SOFF_SOFF(v)   (HW_DMA_TCD21_SOFF_WR((HW_DMA_TCD21_SOFF_RD() & ~BM_DMA_TCD21_SOFF_SOFF) | BF_DMA_TCD21_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd21_attr
{
    uint16_t U;
    struct _hw_dma_tcd21_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd21_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_ATTR register
 */
//@{
#define HW_DMA_TCD21_ATTR_ADDR      (REGS_DMA_BASE + 0x12a6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_ATTR           (*(__IO hw_dma_tcd21_attr_t *) HW_DMA_TCD21_ATTR_ADDR)
#define HW_DMA_TCD21_ATTR_RD()      (HW_DMA_TCD21_ATTR.U)
#define HW_DMA_TCD21_ATTR_WR(v)     (HW_DMA_TCD21_ATTR.U = (v))
#define HW_DMA_TCD21_ATTR_SET(v)    (HW_DMA_TCD21_ATTR_WR(HW_DMA_TCD21_ATTR_RD() |  (v)))
#define HW_DMA_TCD21_ATTR_CLR(v)    (HW_DMA_TCD21_ATTR_WR(HW_DMA_TCD21_ATTR_RD() & ~(v)))
#define HW_DMA_TCD21_ATTR_TOG(v)    (HW_DMA_TCD21_ATTR_WR(HW_DMA_TCD21_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_ATTR bitfields
 */

/*! @name Register DMA_TCD21_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD21_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD21_ATTR_DSIZE.
#define BM_DMA_TCD21_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD21_ATTR_DSIZE.
#define BS_DMA_TCD21_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD21_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_ATTR_DSIZE field.
#define BR_DMA_TCD21_ATTR_DSIZE()   (HW_DMA_TCD21_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD21_ATTR_DSIZE.
#define BF_DMA_TCD21_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_ATTR_DSIZE), uint16_t) & BM_DMA_TCD21_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD21_ATTR_DSIZE(v)   (HW_DMA_TCD21_ATTR_WR((HW_DMA_TCD21_ATTR_RD() & ~BM_DMA_TCD21_ATTR_DSIZE) | BF_DMA_TCD21_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD21_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD21_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD21_ATTR_DMOD.
#define BM_DMA_TCD21_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD21_ATTR_DMOD.
#define BS_DMA_TCD21_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD21_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_ATTR_DMOD field.
#define BR_DMA_TCD21_ATTR_DMOD()   (HW_DMA_TCD21_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD21_ATTR_DMOD.
#define BF_DMA_TCD21_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_ATTR_DMOD), uint16_t) & BM_DMA_TCD21_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD21_ATTR_DMOD(v)   (HW_DMA_TCD21_ATTR_WR((HW_DMA_TCD21_ATTR_RD() & ~BM_DMA_TCD21_ATTR_DMOD) | BF_DMA_TCD21_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD21_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD21_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD21_ATTR_SSIZE.
#define BM_DMA_TCD21_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD21_ATTR_SSIZE.
#define BS_DMA_TCD21_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD21_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_ATTR_SSIZE field.
#define BR_DMA_TCD21_ATTR_SSIZE()   (HW_DMA_TCD21_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD21_ATTR_SSIZE.
#define BF_DMA_TCD21_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_ATTR_SSIZE), uint16_t) & BM_DMA_TCD21_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD21_ATTR_SSIZE(v)   (HW_DMA_TCD21_ATTR_WR((HW_DMA_TCD21_ATTR_RD() & ~BM_DMA_TCD21_ATTR_SSIZE) | BF_DMA_TCD21_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD21_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD21_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD21_ATTR_SMOD.
#define BM_DMA_TCD21_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD21_ATTR_SMOD.
#define BS_DMA_TCD21_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD21_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_ATTR_SMOD field.
#define BR_DMA_TCD21_ATTR_SMOD()   (HW_DMA_TCD21_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD21_ATTR_SMOD.
#define BF_DMA_TCD21_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_ATTR_SMOD), uint16_t) & BM_DMA_TCD21_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD21_ATTR_SMOD(v)   (HW_DMA_TCD21_ATTR_WR((HW_DMA_TCD21_ATTR_RD() & ~BM_DMA_TCD21_ATTR_SMOD) | BF_DMA_TCD21_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd21_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd21_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd21_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD21_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x12a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_NBYTES_MLNO           (*(__IO hw_dma_tcd21_nbytes_mlno_t *) HW_DMA_TCD21_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD21_NBYTES_MLNO_RD()      (HW_DMA_TCD21_NBYTES_MLNO.U)
#define HW_DMA_TCD21_NBYTES_MLNO_WR(v)     (HW_DMA_TCD21_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD21_NBYTES_MLNO_SET(v)    (HW_DMA_TCD21_NBYTES_MLNO_WR(HW_DMA_TCD21_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD21_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD21_NBYTES_MLNO_WR(HW_DMA_TCD21_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD21_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD21_NBYTES_MLNO_WR(HW_DMA_TCD21_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD21_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD21_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD21_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD21_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD21_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD21_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD21_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD21_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD21_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD21_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD21_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD21_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD21_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD21_NBYTES_MLNO_WR((HW_DMA_TCD21_NBYTES_MLNO_RD() & ~BM_DMA_TCD21_NBYTES_MLNO_NBYTES) | BF_DMA_TCD21_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd21_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd21_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd21_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD21_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x12a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd21_nbytes_mloffno_t *) HW_DMA_TCD21_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD21_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD21_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD21_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD21_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD21_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD21_NBYTES_MLOFFNO_WR(HW_DMA_TCD21_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD21_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD21_NBYTES_MLOFFNO_WR(HW_DMA_TCD21_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD21_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD21_NBYTES_MLOFFNO_WR(HW_DMA_TCD21_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD21_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD21_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD21_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD21_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD21_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD21_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD21_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD21_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD21_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD21_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD21_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD21_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD21_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD21_NBYTES_MLOFFNO_WR((HW_DMA_TCD21_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD21_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD21_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD21_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD21_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD21_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD21_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD21_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD21_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD21_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD21_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD21_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD21_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD21_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD21_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD21_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD21_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD21_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD21_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD21_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD21_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD21_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD21_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD21_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD21_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD21_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD21_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD21_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD21_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD21_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD21_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD21_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD21_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD21_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd21_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd21_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd21_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD21_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x12a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd21_nbytes_mloffyes_t *) HW_DMA_TCD21_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD21_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD21_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD21_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD21_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD21_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD21_NBYTES_MLOFFYES_WR(HW_DMA_TCD21_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD21_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD21_NBYTES_MLOFFYES_WR(HW_DMA_TCD21_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD21_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD21_NBYTES_MLOFFYES_WR(HW_DMA_TCD21_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD21_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD21_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD21_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD21_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD21_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD21_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD21_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD21_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD21_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD21_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD21_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD21_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD21_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD21_NBYTES_MLOFFYES_WR((HW_DMA_TCD21_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD21_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD21_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD21_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD21_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD21_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD21_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD21_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD21_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD21_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD21_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD21_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD21_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD21_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD21_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD21_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD21_NBYTES_MLOFFYES_WR((HW_DMA_TCD21_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD21_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD21_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD21_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD21_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD21_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD21_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD21_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD21_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD21_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD21_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD21_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD21_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD21_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD21_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD21_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD21_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD21_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD21_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD21_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD21_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD21_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD21_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD21_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD21_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD21_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD21_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD21_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD21_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD21_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD21_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD21_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD21_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD21_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd21_slast
{
    uint32_t U;
    struct _hw_dma_tcd21_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd21_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_SLAST register
 */
//@{
#define HW_DMA_TCD21_SLAST_ADDR      (REGS_DMA_BASE + 0x12acU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_SLAST           (*(__IO hw_dma_tcd21_slast_t *) HW_DMA_TCD21_SLAST_ADDR)
#define HW_DMA_TCD21_SLAST_RD()      (HW_DMA_TCD21_SLAST.U)
#define HW_DMA_TCD21_SLAST_WR(v)     (HW_DMA_TCD21_SLAST.U = (v))
#define HW_DMA_TCD21_SLAST_SET(v)    (HW_DMA_TCD21_SLAST_WR(HW_DMA_TCD21_SLAST_RD() |  (v)))
#define HW_DMA_TCD21_SLAST_CLR(v)    (HW_DMA_TCD21_SLAST_WR(HW_DMA_TCD21_SLAST_RD() & ~(v)))
#define HW_DMA_TCD21_SLAST_TOG(v)    (HW_DMA_TCD21_SLAST_WR(HW_DMA_TCD21_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_SLAST bitfields
 */

/*! @name Register DMA_TCD21_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD21_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD21_SLAST_SLAST.
#define BM_DMA_TCD21_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD21_SLAST_SLAST.
#define BS_DMA_TCD21_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD21_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_SLAST_SLAST field.
#define BR_DMA_TCD21_SLAST_SLAST()   (HW_DMA_TCD21_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD21_SLAST_SLAST.
#define BF_DMA_TCD21_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_SLAST_SLAST), uint32_t) & BM_DMA_TCD21_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD21_SLAST_SLAST(v)   (HW_DMA_TCD21_SLAST_WR((HW_DMA_TCD21_SLAST_RD() & ~BM_DMA_TCD21_SLAST_SLAST) | BF_DMA_TCD21_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd21_daddr
{
    uint32_t U;
    struct _hw_dma_tcd21_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd21_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_DADDR register
 */
//@{
#define HW_DMA_TCD21_DADDR_ADDR      (REGS_DMA_BASE + 0x12b0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_DADDR           (*(__IO hw_dma_tcd21_daddr_t *) HW_DMA_TCD21_DADDR_ADDR)
#define HW_DMA_TCD21_DADDR_RD()      (HW_DMA_TCD21_DADDR.U)
#define HW_DMA_TCD21_DADDR_WR(v)     (HW_DMA_TCD21_DADDR.U = (v))
#define HW_DMA_TCD21_DADDR_SET(v)    (HW_DMA_TCD21_DADDR_WR(HW_DMA_TCD21_DADDR_RD() |  (v)))
#define HW_DMA_TCD21_DADDR_CLR(v)    (HW_DMA_TCD21_DADDR_WR(HW_DMA_TCD21_DADDR_RD() & ~(v)))
#define HW_DMA_TCD21_DADDR_TOG(v)    (HW_DMA_TCD21_DADDR_WR(HW_DMA_TCD21_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_DADDR bitfields
 */

/*! @name Register DMA_TCD21_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD21_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD21_DADDR_DADDR.
#define BM_DMA_TCD21_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD21_DADDR_DADDR.
#define BS_DMA_TCD21_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD21_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_DADDR_DADDR field.
#define BR_DMA_TCD21_DADDR_DADDR()   (HW_DMA_TCD21_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD21_DADDR_DADDR.
#define BF_DMA_TCD21_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_DADDR_DADDR), uint32_t) & BM_DMA_TCD21_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD21_DADDR_DADDR(v)   (HW_DMA_TCD21_DADDR_WR((HW_DMA_TCD21_DADDR_RD() & ~BM_DMA_TCD21_DADDR_DADDR) | BF_DMA_TCD21_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd21_doff
{
    uint16_t U;
    struct _hw_dma_tcd21_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd21_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_DOFF register
 */
//@{
#define HW_DMA_TCD21_DOFF_ADDR      (REGS_DMA_BASE + 0x12b4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_DOFF           (*(__IO hw_dma_tcd21_doff_t *) HW_DMA_TCD21_DOFF_ADDR)
#define HW_DMA_TCD21_DOFF_RD()      (HW_DMA_TCD21_DOFF.U)
#define HW_DMA_TCD21_DOFF_WR(v)     (HW_DMA_TCD21_DOFF.U = (v))
#define HW_DMA_TCD21_DOFF_SET(v)    (HW_DMA_TCD21_DOFF_WR(HW_DMA_TCD21_DOFF_RD() |  (v)))
#define HW_DMA_TCD21_DOFF_CLR(v)    (HW_DMA_TCD21_DOFF_WR(HW_DMA_TCD21_DOFF_RD() & ~(v)))
#define HW_DMA_TCD21_DOFF_TOG(v)    (HW_DMA_TCD21_DOFF_WR(HW_DMA_TCD21_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_DOFF bitfields
 */

/*! @name Register DMA_TCD21_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD21_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD21_DOFF_DOFF.
#define BM_DMA_TCD21_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD21_DOFF_DOFF.
#define BS_DMA_TCD21_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD21_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_DOFF_DOFF field.
#define BR_DMA_TCD21_DOFF_DOFF()   (HW_DMA_TCD21_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD21_DOFF_DOFF.
#define BF_DMA_TCD21_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_DOFF_DOFF), uint16_t) & BM_DMA_TCD21_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD21_DOFF_DOFF(v)   (HW_DMA_TCD21_DOFF_WR((HW_DMA_TCD21_DOFF_RD() & ~BM_DMA_TCD21_DOFF_DOFF) | BF_DMA_TCD21_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd21_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd21_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd21_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD21_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x12b6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_CITER_ELINKYES           (*(__IO hw_dma_tcd21_citer_elinkyes_t *) HW_DMA_TCD21_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD21_CITER_ELINKYES_RD()      (HW_DMA_TCD21_CITER_ELINKYES.U)
#define HW_DMA_TCD21_CITER_ELINKYES_WR(v)     (HW_DMA_TCD21_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD21_CITER_ELINKYES_SET(v)    (HW_DMA_TCD21_CITER_ELINKYES_WR(HW_DMA_TCD21_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD21_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD21_CITER_ELINKYES_WR(HW_DMA_TCD21_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD21_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD21_CITER_ELINKYES_WR(HW_DMA_TCD21_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD21_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD21_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD21_CITER_ELINKYES_CITER.
#define BM_DMA_TCD21_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD21_CITER_ELINKYES_CITER.
#define BS_DMA_TCD21_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD21_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD21_CITER_ELINKYES_CITER()   (HW_DMA_TCD21_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD21_CITER_ELINKYES_CITER.
#define BF_DMA_TCD21_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD21_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD21_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD21_CITER_ELINKYES_WR((HW_DMA_TCD21_CITER_ELINKYES_RD() & ~BM_DMA_TCD21_CITER_ELINKYES_CITER) | BF_DMA_TCD21_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD21_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD21_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD21_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD21_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD21_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD21_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD21_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD21_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD21_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD21_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD21_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD21_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD21_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD21_CITER_ELINKYES_WR((HW_DMA_TCD21_CITER_ELINKYES_RD() & ~BM_DMA_TCD21_CITER_ELINKYES_LINKCH) | BF_DMA_TCD21_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD21_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD21_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD21_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD21_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD21_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD21_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD21_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD21_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD21_CITER_ELINKYES_ADDR, BP_DMA_TCD21_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD21_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD21_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD21_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD21_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CITER_ELINKYES_ADDR, BP_DMA_TCD21_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd21_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd21_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd21_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD21_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x12b6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_CITER_ELINKNO           (*(__IO hw_dma_tcd21_citer_elinkno_t *) HW_DMA_TCD21_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD21_CITER_ELINKNO_RD()      (HW_DMA_TCD21_CITER_ELINKNO.U)
#define HW_DMA_TCD21_CITER_ELINKNO_WR(v)     (HW_DMA_TCD21_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD21_CITER_ELINKNO_SET(v)    (HW_DMA_TCD21_CITER_ELINKNO_WR(HW_DMA_TCD21_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD21_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD21_CITER_ELINKNO_WR(HW_DMA_TCD21_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD21_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD21_CITER_ELINKNO_WR(HW_DMA_TCD21_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD21_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD21_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD21_CITER_ELINKNO_CITER.
#define BM_DMA_TCD21_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD21_CITER_ELINKNO_CITER.
#define BS_DMA_TCD21_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD21_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD21_CITER_ELINKNO_CITER()   (HW_DMA_TCD21_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD21_CITER_ELINKNO_CITER.
#define BF_DMA_TCD21_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD21_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD21_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD21_CITER_ELINKNO_WR((HW_DMA_TCD21_CITER_ELINKNO_RD() & ~BM_DMA_TCD21_CITER_ELINKNO_CITER) | BF_DMA_TCD21_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD21_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD21_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD21_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD21_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD21_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD21_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD21_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD21_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD21_CITER_ELINKNO_ADDR, BP_DMA_TCD21_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD21_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD21_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD21_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD21_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CITER_ELINKNO_ADDR, BP_DMA_TCD21_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd21_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd21_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd21_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_DLASTSGA register
 */
//@{
#define HW_DMA_TCD21_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x12b8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_DLASTSGA           (*(__IO hw_dma_tcd21_dlastsga_t *) HW_DMA_TCD21_DLASTSGA_ADDR)
#define HW_DMA_TCD21_DLASTSGA_RD()      (HW_DMA_TCD21_DLASTSGA.U)
#define HW_DMA_TCD21_DLASTSGA_WR(v)     (HW_DMA_TCD21_DLASTSGA.U = (v))
#define HW_DMA_TCD21_DLASTSGA_SET(v)    (HW_DMA_TCD21_DLASTSGA_WR(HW_DMA_TCD21_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD21_DLASTSGA_CLR(v)    (HW_DMA_TCD21_DLASTSGA_WR(HW_DMA_TCD21_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD21_DLASTSGA_TOG(v)    (HW_DMA_TCD21_DLASTSGA_WR(HW_DMA_TCD21_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD21_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD21_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD21_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD21_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD21_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD21_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD21_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD21_DLASTSGA_DLASTSGA()   (HW_DMA_TCD21_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD21_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD21_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD21_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD21_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD21_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD21_DLASTSGA_WR((HW_DMA_TCD21_DLASTSGA_RD() & ~BM_DMA_TCD21_DLASTSGA_DLASTSGA) | BF_DMA_TCD21_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd21_csr
{
    uint16_t U;
    struct _hw_dma_tcd21_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd21_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_CSR register
 */
//@{
#define HW_DMA_TCD21_CSR_ADDR      (REGS_DMA_BASE + 0x12bcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_CSR           (*(__IO hw_dma_tcd21_csr_t *) HW_DMA_TCD21_CSR_ADDR)
#define HW_DMA_TCD21_CSR_RD()      (HW_DMA_TCD21_CSR.U)
#define HW_DMA_TCD21_CSR_WR(v)     (HW_DMA_TCD21_CSR.U = (v))
#define HW_DMA_TCD21_CSR_SET(v)    (HW_DMA_TCD21_CSR_WR(HW_DMA_TCD21_CSR_RD() |  (v)))
#define HW_DMA_TCD21_CSR_CLR(v)    (HW_DMA_TCD21_CSR_WR(HW_DMA_TCD21_CSR_RD() & ~(v)))
#define HW_DMA_TCD21_CSR_TOG(v)    (HW_DMA_TCD21_CSR_WR(HW_DMA_TCD21_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_CSR bitfields
 */

/*! @name Register DMA_TCD21_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD21_CSR_START      (0U)      //!< Bit position for DMA_TCD21_CSR_START.
#define BM_DMA_TCD21_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD21_CSR_START.
#define BS_DMA_TCD21_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD21_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_START field.
#define BR_DMA_TCD21_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_START.
#define BF_DMA_TCD21_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_START), uint16_t) & BM_DMA_TCD21_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD21_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD21_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD21_CSR_INTMAJOR.
#define BM_DMA_TCD21_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD21_CSR_INTMAJOR.
#define BS_DMA_TCD21_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD21_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_INTMAJOR field.
#define BR_DMA_TCD21_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_INTMAJOR.
#define BF_DMA_TCD21_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD21_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD21_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD21_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD21_CSR_INTHALF.
#define BM_DMA_TCD21_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD21_CSR_INTHALF.
#define BS_DMA_TCD21_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD21_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_INTHALF field.
#define BR_DMA_TCD21_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_INTHALF.
#define BF_DMA_TCD21_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_INTHALF), uint16_t) & BM_DMA_TCD21_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD21_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD21_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD21_CSR_DREQ.
#define BM_DMA_TCD21_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD21_CSR_DREQ.
#define BS_DMA_TCD21_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD21_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_DREQ field.
#define BR_DMA_TCD21_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_DREQ.
#define BF_DMA_TCD21_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_DREQ), uint16_t) & BM_DMA_TCD21_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD21_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD21_CSR_ESG      (4U)      //!< Bit position for DMA_TCD21_CSR_ESG.
#define BM_DMA_TCD21_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD21_CSR_ESG.
#define BS_DMA_TCD21_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD21_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_ESG field.
#define BR_DMA_TCD21_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_ESG.
#define BF_DMA_TCD21_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_ESG), uint16_t) & BM_DMA_TCD21_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD21_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD21_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD21_CSR_MAJORELINK.
#define BM_DMA_TCD21_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD21_CSR_MAJORELINK.
#define BS_DMA_TCD21_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD21_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_MAJORELINK field.
#define BR_DMA_TCD21_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_MAJORELINK.
#define BF_DMA_TCD21_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD21_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD21_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD21_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD21_CSR_ACTIVE.
#define BM_DMA_TCD21_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD21_CSR_ACTIVE.
#define BS_DMA_TCD21_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD21_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_ACTIVE field.
#define BR_DMA_TCD21_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_ACTIVE.
#define BF_DMA_TCD21_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_ACTIVE), uint16_t) & BM_DMA_TCD21_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD21_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD21_CSR_DONE      (7U)      //!< Bit position for DMA_TCD21_CSR_DONE.
#define BM_DMA_TCD21_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD21_CSR_DONE.
#define BS_DMA_TCD21_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD21_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_DONE field.
#define BR_DMA_TCD21_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_DONE.
#define BF_DMA_TCD21_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_DONE), uint16_t) & BM_DMA_TCD21_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD21_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_CSR_ADDR, BP_DMA_TCD21_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD21_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD21_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD21_CSR_MAJORLINKCH.
#define BM_DMA_TCD21_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD21_CSR_MAJORLINKCH.
#define BS_DMA_TCD21_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD21_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_MAJORLINKCH field.
#define BR_DMA_TCD21_CSR_MAJORLINKCH()   (HW_DMA_TCD21_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_MAJORLINKCH.
#define BF_DMA_TCD21_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD21_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD21_CSR_MAJORLINKCH(v)   (HW_DMA_TCD21_CSR_WR((HW_DMA_TCD21_CSR_RD() & ~BM_DMA_TCD21_CSR_MAJORLINKCH) | BF_DMA_TCD21_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD21_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD21_CSR_BWC      (14U)      //!< Bit position for DMA_TCD21_CSR_BWC.
#define BM_DMA_TCD21_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD21_CSR_BWC.
#define BS_DMA_TCD21_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD21_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_CSR_BWC field.
#define BR_DMA_TCD21_CSR_BWC()   (HW_DMA_TCD21_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD21_CSR_BWC.
#define BF_DMA_TCD21_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_CSR_BWC), uint16_t) & BM_DMA_TCD21_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD21_CSR_BWC(v)   (HW_DMA_TCD21_CSR_WR((HW_DMA_TCD21_CSR_RD() & ~BM_DMA_TCD21_CSR_BWC) | BF_DMA_TCD21_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd21_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd21_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd21_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD21_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x12beU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_BITER_ELINKYES           (*(__IO hw_dma_tcd21_biter_elinkyes_t *) HW_DMA_TCD21_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD21_BITER_ELINKYES_RD()      (HW_DMA_TCD21_BITER_ELINKYES.U)
#define HW_DMA_TCD21_BITER_ELINKYES_WR(v)     (HW_DMA_TCD21_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD21_BITER_ELINKYES_SET(v)    (HW_DMA_TCD21_BITER_ELINKYES_WR(HW_DMA_TCD21_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD21_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD21_BITER_ELINKYES_WR(HW_DMA_TCD21_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD21_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD21_BITER_ELINKYES_WR(HW_DMA_TCD21_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD21_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD21_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD21_BITER_ELINKYES_BITER.
#define BM_DMA_TCD21_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD21_BITER_ELINKYES_BITER.
#define BS_DMA_TCD21_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD21_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD21_BITER_ELINKYES_BITER()   (HW_DMA_TCD21_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD21_BITER_ELINKYES_BITER.
#define BF_DMA_TCD21_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD21_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD21_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD21_BITER_ELINKYES_WR((HW_DMA_TCD21_BITER_ELINKYES_RD() & ~BM_DMA_TCD21_BITER_ELINKYES_BITER) | BF_DMA_TCD21_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD21_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD21_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD21_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD21_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD21_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD21_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD21_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD21_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD21_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD21_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD21_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD21_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD21_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD21_BITER_ELINKYES_WR((HW_DMA_TCD21_BITER_ELINKYES_RD() & ~BM_DMA_TCD21_BITER_ELINKYES_LINKCH) | BF_DMA_TCD21_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD21_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD21_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD21_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD21_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD21_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD21_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD21_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD21_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD21_BITER_ELINKYES_ADDR, BP_DMA_TCD21_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD21_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD21_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD21_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD21_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_BITER_ELINKYES_ADDR, BP_DMA_TCD21_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD21_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD21_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd21_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd21_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd21_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD21_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD21_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x12beU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD21_BITER_ELINKNO           (*(__IO hw_dma_tcd21_biter_elinkno_t *) HW_DMA_TCD21_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD21_BITER_ELINKNO_RD()      (HW_DMA_TCD21_BITER_ELINKNO.U)
#define HW_DMA_TCD21_BITER_ELINKNO_WR(v)     (HW_DMA_TCD21_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD21_BITER_ELINKNO_SET(v)    (HW_DMA_TCD21_BITER_ELINKNO_WR(HW_DMA_TCD21_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD21_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD21_BITER_ELINKNO_WR(HW_DMA_TCD21_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD21_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD21_BITER_ELINKNO_WR(HW_DMA_TCD21_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD21_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD21_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD21_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD21_BITER_ELINKNO_BITER.
#define BM_DMA_TCD21_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD21_BITER_ELINKNO_BITER.
#define BS_DMA_TCD21_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD21_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD21_BITER_ELINKNO_BITER()   (HW_DMA_TCD21_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD21_BITER_ELINKNO_BITER.
#define BF_DMA_TCD21_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD21_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD21_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD21_BITER_ELINKNO_WR((HW_DMA_TCD21_BITER_ELINKNO_RD() & ~BM_DMA_TCD21_BITER_ELINKNO_BITER) | BF_DMA_TCD21_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD21_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD21_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD21_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD21_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD21_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD21_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD21_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD21_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD21_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD21_BITER_ELINKNO_ADDR, BP_DMA_TCD21_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD21_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD21_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD21_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD21_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD21_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD21_BITER_ELINKNO_ADDR, BP_DMA_TCD21_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd22_saddr
{
    uint32_t U;
    struct _hw_dma_tcd22_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd22_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_SADDR register
 */
//@{
#define HW_DMA_TCD22_SADDR_ADDR      (REGS_DMA_BASE + 0x12c0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_SADDR           (*(__IO hw_dma_tcd22_saddr_t *) HW_DMA_TCD22_SADDR_ADDR)
#define HW_DMA_TCD22_SADDR_RD()      (HW_DMA_TCD22_SADDR.U)
#define HW_DMA_TCD22_SADDR_WR(v)     (HW_DMA_TCD22_SADDR.U = (v))
#define HW_DMA_TCD22_SADDR_SET(v)    (HW_DMA_TCD22_SADDR_WR(HW_DMA_TCD22_SADDR_RD() |  (v)))
#define HW_DMA_TCD22_SADDR_CLR(v)    (HW_DMA_TCD22_SADDR_WR(HW_DMA_TCD22_SADDR_RD() & ~(v)))
#define HW_DMA_TCD22_SADDR_TOG(v)    (HW_DMA_TCD22_SADDR_WR(HW_DMA_TCD22_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_SADDR bitfields
 */

/*! @name Register DMA_TCD22_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD22_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD22_SADDR_SADDR.
#define BM_DMA_TCD22_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD22_SADDR_SADDR.
#define BS_DMA_TCD22_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD22_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_SADDR_SADDR field.
#define BR_DMA_TCD22_SADDR_SADDR()   (HW_DMA_TCD22_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD22_SADDR_SADDR.
#define BF_DMA_TCD22_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_SADDR_SADDR), uint32_t) & BM_DMA_TCD22_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD22_SADDR_SADDR(v)   (HW_DMA_TCD22_SADDR_WR((HW_DMA_TCD22_SADDR_RD() & ~BM_DMA_TCD22_SADDR_SADDR) | BF_DMA_TCD22_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd22_soff
{
    uint16_t U;
    struct _hw_dma_tcd22_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd22_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_SOFF register
 */
//@{
#define HW_DMA_TCD22_SOFF_ADDR      (REGS_DMA_BASE + 0x12c4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_SOFF           (*(__IO hw_dma_tcd22_soff_t *) HW_DMA_TCD22_SOFF_ADDR)
#define HW_DMA_TCD22_SOFF_RD()      (HW_DMA_TCD22_SOFF.U)
#define HW_DMA_TCD22_SOFF_WR(v)     (HW_DMA_TCD22_SOFF.U = (v))
#define HW_DMA_TCD22_SOFF_SET(v)    (HW_DMA_TCD22_SOFF_WR(HW_DMA_TCD22_SOFF_RD() |  (v)))
#define HW_DMA_TCD22_SOFF_CLR(v)    (HW_DMA_TCD22_SOFF_WR(HW_DMA_TCD22_SOFF_RD() & ~(v)))
#define HW_DMA_TCD22_SOFF_TOG(v)    (HW_DMA_TCD22_SOFF_WR(HW_DMA_TCD22_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_SOFF bitfields
 */

/*! @name Register DMA_TCD22_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD22_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD22_SOFF_SOFF.
#define BM_DMA_TCD22_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD22_SOFF_SOFF.
#define BS_DMA_TCD22_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD22_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_SOFF_SOFF field.
#define BR_DMA_TCD22_SOFF_SOFF()   (HW_DMA_TCD22_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD22_SOFF_SOFF.
#define BF_DMA_TCD22_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_SOFF_SOFF), uint16_t) & BM_DMA_TCD22_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD22_SOFF_SOFF(v)   (HW_DMA_TCD22_SOFF_WR((HW_DMA_TCD22_SOFF_RD() & ~BM_DMA_TCD22_SOFF_SOFF) | BF_DMA_TCD22_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd22_attr
{
    uint16_t U;
    struct _hw_dma_tcd22_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd22_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_ATTR register
 */
//@{
#define HW_DMA_TCD22_ATTR_ADDR      (REGS_DMA_BASE + 0x12c6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_ATTR           (*(__IO hw_dma_tcd22_attr_t *) HW_DMA_TCD22_ATTR_ADDR)
#define HW_DMA_TCD22_ATTR_RD()      (HW_DMA_TCD22_ATTR.U)
#define HW_DMA_TCD22_ATTR_WR(v)     (HW_DMA_TCD22_ATTR.U = (v))
#define HW_DMA_TCD22_ATTR_SET(v)    (HW_DMA_TCD22_ATTR_WR(HW_DMA_TCD22_ATTR_RD() |  (v)))
#define HW_DMA_TCD22_ATTR_CLR(v)    (HW_DMA_TCD22_ATTR_WR(HW_DMA_TCD22_ATTR_RD() & ~(v)))
#define HW_DMA_TCD22_ATTR_TOG(v)    (HW_DMA_TCD22_ATTR_WR(HW_DMA_TCD22_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_ATTR bitfields
 */

/*! @name Register DMA_TCD22_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD22_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD22_ATTR_DSIZE.
#define BM_DMA_TCD22_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD22_ATTR_DSIZE.
#define BS_DMA_TCD22_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD22_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_ATTR_DSIZE field.
#define BR_DMA_TCD22_ATTR_DSIZE()   (HW_DMA_TCD22_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD22_ATTR_DSIZE.
#define BF_DMA_TCD22_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_ATTR_DSIZE), uint16_t) & BM_DMA_TCD22_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD22_ATTR_DSIZE(v)   (HW_DMA_TCD22_ATTR_WR((HW_DMA_TCD22_ATTR_RD() & ~BM_DMA_TCD22_ATTR_DSIZE) | BF_DMA_TCD22_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD22_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD22_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD22_ATTR_DMOD.
#define BM_DMA_TCD22_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD22_ATTR_DMOD.
#define BS_DMA_TCD22_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD22_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_ATTR_DMOD field.
#define BR_DMA_TCD22_ATTR_DMOD()   (HW_DMA_TCD22_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD22_ATTR_DMOD.
#define BF_DMA_TCD22_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_ATTR_DMOD), uint16_t) & BM_DMA_TCD22_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD22_ATTR_DMOD(v)   (HW_DMA_TCD22_ATTR_WR((HW_DMA_TCD22_ATTR_RD() & ~BM_DMA_TCD22_ATTR_DMOD) | BF_DMA_TCD22_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD22_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD22_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD22_ATTR_SSIZE.
#define BM_DMA_TCD22_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD22_ATTR_SSIZE.
#define BS_DMA_TCD22_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD22_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_ATTR_SSIZE field.
#define BR_DMA_TCD22_ATTR_SSIZE()   (HW_DMA_TCD22_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD22_ATTR_SSIZE.
#define BF_DMA_TCD22_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_ATTR_SSIZE), uint16_t) & BM_DMA_TCD22_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD22_ATTR_SSIZE(v)   (HW_DMA_TCD22_ATTR_WR((HW_DMA_TCD22_ATTR_RD() & ~BM_DMA_TCD22_ATTR_SSIZE) | BF_DMA_TCD22_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD22_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD22_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD22_ATTR_SMOD.
#define BM_DMA_TCD22_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD22_ATTR_SMOD.
#define BS_DMA_TCD22_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD22_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_ATTR_SMOD field.
#define BR_DMA_TCD22_ATTR_SMOD()   (HW_DMA_TCD22_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD22_ATTR_SMOD.
#define BF_DMA_TCD22_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_ATTR_SMOD), uint16_t) & BM_DMA_TCD22_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD22_ATTR_SMOD(v)   (HW_DMA_TCD22_ATTR_WR((HW_DMA_TCD22_ATTR_RD() & ~BM_DMA_TCD22_ATTR_SMOD) | BF_DMA_TCD22_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd22_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd22_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd22_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD22_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x12c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_NBYTES_MLNO           (*(__IO hw_dma_tcd22_nbytes_mlno_t *) HW_DMA_TCD22_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD22_NBYTES_MLNO_RD()      (HW_DMA_TCD22_NBYTES_MLNO.U)
#define HW_DMA_TCD22_NBYTES_MLNO_WR(v)     (HW_DMA_TCD22_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD22_NBYTES_MLNO_SET(v)    (HW_DMA_TCD22_NBYTES_MLNO_WR(HW_DMA_TCD22_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD22_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD22_NBYTES_MLNO_WR(HW_DMA_TCD22_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD22_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD22_NBYTES_MLNO_WR(HW_DMA_TCD22_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD22_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD22_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD22_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD22_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD22_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD22_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD22_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD22_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD22_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD22_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD22_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD22_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD22_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD22_NBYTES_MLNO_WR((HW_DMA_TCD22_NBYTES_MLNO_RD() & ~BM_DMA_TCD22_NBYTES_MLNO_NBYTES) | BF_DMA_TCD22_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd22_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd22_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd22_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD22_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x12c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd22_nbytes_mloffno_t *) HW_DMA_TCD22_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD22_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD22_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD22_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD22_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD22_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD22_NBYTES_MLOFFNO_WR(HW_DMA_TCD22_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD22_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD22_NBYTES_MLOFFNO_WR(HW_DMA_TCD22_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD22_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD22_NBYTES_MLOFFNO_WR(HW_DMA_TCD22_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD22_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD22_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD22_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD22_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD22_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD22_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD22_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD22_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD22_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD22_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD22_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD22_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD22_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD22_NBYTES_MLOFFNO_WR((HW_DMA_TCD22_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD22_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD22_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD22_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD22_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD22_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD22_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD22_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD22_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD22_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD22_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD22_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD22_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD22_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD22_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD22_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD22_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD22_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD22_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD22_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD22_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD22_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD22_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD22_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD22_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD22_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD22_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD22_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD22_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD22_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD22_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD22_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD22_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD22_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd22_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd22_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd22_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD22_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x12c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd22_nbytes_mloffyes_t *) HW_DMA_TCD22_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD22_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD22_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD22_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD22_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD22_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD22_NBYTES_MLOFFYES_WR(HW_DMA_TCD22_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD22_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD22_NBYTES_MLOFFYES_WR(HW_DMA_TCD22_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD22_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD22_NBYTES_MLOFFYES_WR(HW_DMA_TCD22_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD22_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD22_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD22_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD22_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD22_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD22_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD22_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD22_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD22_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD22_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD22_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD22_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD22_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD22_NBYTES_MLOFFYES_WR((HW_DMA_TCD22_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD22_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD22_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD22_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD22_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD22_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD22_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD22_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD22_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD22_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD22_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD22_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD22_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD22_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD22_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD22_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD22_NBYTES_MLOFFYES_WR((HW_DMA_TCD22_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD22_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD22_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD22_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD22_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD22_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD22_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD22_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD22_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD22_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD22_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD22_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD22_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD22_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD22_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD22_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD22_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD22_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD22_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD22_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD22_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD22_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD22_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD22_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD22_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD22_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD22_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD22_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD22_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD22_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD22_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD22_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD22_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD22_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd22_slast
{
    uint32_t U;
    struct _hw_dma_tcd22_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd22_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_SLAST register
 */
//@{
#define HW_DMA_TCD22_SLAST_ADDR      (REGS_DMA_BASE + 0x12ccU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_SLAST           (*(__IO hw_dma_tcd22_slast_t *) HW_DMA_TCD22_SLAST_ADDR)
#define HW_DMA_TCD22_SLAST_RD()      (HW_DMA_TCD22_SLAST.U)
#define HW_DMA_TCD22_SLAST_WR(v)     (HW_DMA_TCD22_SLAST.U = (v))
#define HW_DMA_TCD22_SLAST_SET(v)    (HW_DMA_TCD22_SLAST_WR(HW_DMA_TCD22_SLAST_RD() |  (v)))
#define HW_DMA_TCD22_SLAST_CLR(v)    (HW_DMA_TCD22_SLAST_WR(HW_DMA_TCD22_SLAST_RD() & ~(v)))
#define HW_DMA_TCD22_SLAST_TOG(v)    (HW_DMA_TCD22_SLAST_WR(HW_DMA_TCD22_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_SLAST bitfields
 */

/*! @name Register DMA_TCD22_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD22_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD22_SLAST_SLAST.
#define BM_DMA_TCD22_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD22_SLAST_SLAST.
#define BS_DMA_TCD22_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD22_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_SLAST_SLAST field.
#define BR_DMA_TCD22_SLAST_SLAST()   (HW_DMA_TCD22_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD22_SLAST_SLAST.
#define BF_DMA_TCD22_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_SLAST_SLAST), uint32_t) & BM_DMA_TCD22_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD22_SLAST_SLAST(v)   (HW_DMA_TCD22_SLAST_WR((HW_DMA_TCD22_SLAST_RD() & ~BM_DMA_TCD22_SLAST_SLAST) | BF_DMA_TCD22_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd22_daddr
{
    uint32_t U;
    struct _hw_dma_tcd22_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd22_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_DADDR register
 */
//@{
#define HW_DMA_TCD22_DADDR_ADDR      (REGS_DMA_BASE + 0x12d0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_DADDR           (*(__IO hw_dma_tcd22_daddr_t *) HW_DMA_TCD22_DADDR_ADDR)
#define HW_DMA_TCD22_DADDR_RD()      (HW_DMA_TCD22_DADDR.U)
#define HW_DMA_TCD22_DADDR_WR(v)     (HW_DMA_TCD22_DADDR.U = (v))
#define HW_DMA_TCD22_DADDR_SET(v)    (HW_DMA_TCD22_DADDR_WR(HW_DMA_TCD22_DADDR_RD() |  (v)))
#define HW_DMA_TCD22_DADDR_CLR(v)    (HW_DMA_TCD22_DADDR_WR(HW_DMA_TCD22_DADDR_RD() & ~(v)))
#define HW_DMA_TCD22_DADDR_TOG(v)    (HW_DMA_TCD22_DADDR_WR(HW_DMA_TCD22_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_DADDR bitfields
 */

/*! @name Register DMA_TCD22_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD22_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD22_DADDR_DADDR.
#define BM_DMA_TCD22_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD22_DADDR_DADDR.
#define BS_DMA_TCD22_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD22_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_DADDR_DADDR field.
#define BR_DMA_TCD22_DADDR_DADDR()   (HW_DMA_TCD22_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD22_DADDR_DADDR.
#define BF_DMA_TCD22_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_DADDR_DADDR), uint32_t) & BM_DMA_TCD22_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD22_DADDR_DADDR(v)   (HW_DMA_TCD22_DADDR_WR((HW_DMA_TCD22_DADDR_RD() & ~BM_DMA_TCD22_DADDR_DADDR) | BF_DMA_TCD22_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd22_doff
{
    uint16_t U;
    struct _hw_dma_tcd22_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd22_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_DOFF register
 */
//@{
#define HW_DMA_TCD22_DOFF_ADDR      (REGS_DMA_BASE + 0x12d4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_DOFF           (*(__IO hw_dma_tcd22_doff_t *) HW_DMA_TCD22_DOFF_ADDR)
#define HW_DMA_TCD22_DOFF_RD()      (HW_DMA_TCD22_DOFF.U)
#define HW_DMA_TCD22_DOFF_WR(v)     (HW_DMA_TCD22_DOFF.U = (v))
#define HW_DMA_TCD22_DOFF_SET(v)    (HW_DMA_TCD22_DOFF_WR(HW_DMA_TCD22_DOFF_RD() |  (v)))
#define HW_DMA_TCD22_DOFF_CLR(v)    (HW_DMA_TCD22_DOFF_WR(HW_DMA_TCD22_DOFF_RD() & ~(v)))
#define HW_DMA_TCD22_DOFF_TOG(v)    (HW_DMA_TCD22_DOFF_WR(HW_DMA_TCD22_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_DOFF bitfields
 */

/*! @name Register DMA_TCD22_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD22_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD22_DOFF_DOFF.
#define BM_DMA_TCD22_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD22_DOFF_DOFF.
#define BS_DMA_TCD22_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD22_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_DOFF_DOFF field.
#define BR_DMA_TCD22_DOFF_DOFF()   (HW_DMA_TCD22_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD22_DOFF_DOFF.
#define BF_DMA_TCD22_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_DOFF_DOFF), uint16_t) & BM_DMA_TCD22_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD22_DOFF_DOFF(v)   (HW_DMA_TCD22_DOFF_WR((HW_DMA_TCD22_DOFF_RD() & ~BM_DMA_TCD22_DOFF_DOFF) | BF_DMA_TCD22_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd22_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd22_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd22_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD22_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x12d6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_CITER_ELINKYES           (*(__IO hw_dma_tcd22_citer_elinkyes_t *) HW_DMA_TCD22_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD22_CITER_ELINKYES_RD()      (HW_DMA_TCD22_CITER_ELINKYES.U)
#define HW_DMA_TCD22_CITER_ELINKYES_WR(v)     (HW_DMA_TCD22_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD22_CITER_ELINKYES_SET(v)    (HW_DMA_TCD22_CITER_ELINKYES_WR(HW_DMA_TCD22_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD22_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD22_CITER_ELINKYES_WR(HW_DMA_TCD22_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD22_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD22_CITER_ELINKYES_WR(HW_DMA_TCD22_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD22_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD22_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD22_CITER_ELINKYES_CITER.
#define BM_DMA_TCD22_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD22_CITER_ELINKYES_CITER.
#define BS_DMA_TCD22_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD22_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD22_CITER_ELINKYES_CITER()   (HW_DMA_TCD22_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD22_CITER_ELINKYES_CITER.
#define BF_DMA_TCD22_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD22_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD22_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD22_CITER_ELINKYES_WR((HW_DMA_TCD22_CITER_ELINKYES_RD() & ~BM_DMA_TCD22_CITER_ELINKYES_CITER) | BF_DMA_TCD22_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD22_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD22_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD22_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD22_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD22_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD22_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD22_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD22_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD22_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD22_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD22_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD22_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD22_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD22_CITER_ELINKYES_WR((HW_DMA_TCD22_CITER_ELINKYES_RD() & ~BM_DMA_TCD22_CITER_ELINKYES_LINKCH) | BF_DMA_TCD22_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD22_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD22_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD22_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD22_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD22_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD22_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD22_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD22_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD22_CITER_ELINKYES_ADDR, BP_DMA_TCD22_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD22_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD22_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD22_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD22_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CITER_ELINKYES_ADDR, BP_DMA_TCD22_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd22_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd22_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd22_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD22_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x12d6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_CITER_ELINKNO           (*(__IO hw_dma_tcd22_citer_elinkno_t *) HW_DMA_TCD22_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD22_CITER_ELINKNO_RD()      (HW_DMA_TCD22_CITER_ELINKNO.U)
#define HW_DMA_TCD22_CITER_ELINKNO_WR(v)     (HW_DMA_TCD22_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD22_CITER_ELINKNO_SET(v)    (HW_DMA_TCD22_CITER_ELINKNO_WR(HW_DMA_TCD22_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD22_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD22_CITER_ELINKNO_WR(HW_DMA_TCD22_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD22_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD22_CITER_ELINKNO_WR(HW_DMA_TCD22_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD22_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD22_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD22_CITER_ELINKNO_CITER.
#define BM_DMA_TCD22_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD22_CITER_ELINKNO_CITER.
#define BS_DMA_TCD22_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD22_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD22_CITER_ELINKNO_CITER()   (HW_DMA_TCD22_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD22_CITER_ELINKNO_CITER.
#define BF_DMA_TCD22_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD22_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD22_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD22_CITER_ELINKNO_WR((HW_DMA_TCD22_CITER_ELINKNO_RD() & ~BM_DMA_TCD22_CITER_ELINKNO_CITER) | BF_DMA_TCD22_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD22_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD22_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD22_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD22_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD22_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD22_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD22_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD22_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD22_CITER_ELINKNO_ADDR, BP_DMA_TCD22_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD22_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD22_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD22_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD22_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CITER_ELINKNO_ADDR, BP_DMA_TCD22_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd22_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd22_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd22_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_DLASTSGA register
 */
//@{
#define HW_DMA_TCD22_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x12d8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_DLASTSGA           (*(__IO hw_dma_tcd22_dlastsga_t *) HW_DMA_TCD22_DLASTSGA_ADDR)
#define HW_DMA_TCD22_DLASTSGA_RD()      (HW_DMA_TCD22_DLASTSGA.U)
#define HW_DMA_TCD22_DLASTSGA_WR(v)     (HW_DMA_TCD22_DLASTSGA.U = (v))
#define HW_DMA_TCD22_DLASTSGA_SET(v)    (HW_DMA_TCD22_DLASTSGA_WR(HW_DMA_TCD22_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD22_DLASTSGA_CLR(v)    (HW_DMA_TCD22_DLASTSGA_WR(HW_DMA_TCD22_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD22_DLASTSGA_TOG(v)    (HW_DMA_TCD22_DLASTSGA_WR(HW_DMA_TCD22_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD22_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD22_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD22_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD22_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD22_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD22_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD22_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD22_DLASTSGA_DLASTSGA()   (HW_DMA_TCD22_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD22_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD22_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD22_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD22_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD22_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD22_DLASTSGA_WR((HW_DMA_TCD22_DLASTSGA_RD() & ~BM_DMA_TCD22_DLASTSGA_DLASTSGA) | BF_DMA_TCD22_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd22_csr
{
    uint16_t U;
    struct _hw_dma_tcd22_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd22_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_CSR register
 */
//@{
#define HW_DMA_TCD22_CSR_ADDR      (REGS_DMA_BASE + 0x12dcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_CSR           (*(__IO hw_dma_tcd22_csr_t *) HW_DMA_TCD22_CSR_ADDR)
#define HW_DMA_TCD22_CSR_RD()      (HW_DMA_TCD22_CSR.U)
#define HW_DMA_TCD22_CSR_WR(v)     (HW_DMA_TCD22_CSR.U = (v))
#define HW_DMA_TCD22_CSR_SET(v)    (HW_DMA_TCD22_CSR_WR(HW_DMA_TCD22_CSR_RD() |  (v)))
#define HW_DMA_TCD22_CSR_CLR(v)    (HW_DMA_TCD22_CSR_WR(HW_DMA_TCD22_CSR_RD() & ~(v)))
#define HW_DMA_TCD22_CSR_TOG(v)    (HW_DMA_TCD22_CSR_WR(HW_DMA_TCD22_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_CSR bitfields
 */

/*! @name Register DMA_TCD22_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD22_CSR_START      (0U)      //!< Bit position for DMA_TCD22_CSR_START.
#define BM_DMA_TCD22_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD22_CSR_START.
#define BS_DMA_TCD22_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD22_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_START field.
#define BR_DMA_TCD22_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_START.
#define BF_DMA_TCD22_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_START), uint16_t) & BM_DMA_TCD22_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD22_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD22_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD22_CSR_INTMAJOR.
#define BM_DMA_TCD22_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD22_CSR_INTMAJOR.
#define BS_DMA_TCD22_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD22_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_INTMAJOR field.
#define BR_DMA_TCD22_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_INTMAJOR.
#define BF_DMA_TCD22_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD22_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD22_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD22_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD22_CSR_INTHALF.
#define BM_DMA_TCD22_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD22_CSR_INTHALF.
#define BS_DMA_TCD22_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD22_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_INTHALF field.
#define BR_DMA_TCD22_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_INTHALF.
#define BF_DMA_TCD22_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_INTHALF), uint16_t) & BM_DMA_TCD22_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD22_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD22_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD22_CSR_DREQ.
#define BM_DMA_TCD22_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD22_CSR_DREQ.
#define BS_DMA_TCD22_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD22_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_DREQ field.
#define BR_DMA_TCD22_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_DREQ.
#define BF_DMA_TCD22_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_DREQ), uint16_t) & BM_DMA_TCD22_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD22_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD22_CSR_ESG      (4U)      //!< Bit position for DMA_TCD22_CSR_ESG.
#define BM_DMA_TCD22_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD22_CSR_ESG.
#define BS_DMA_TCD22_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD22_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_ESG field.
#define BR_DMA_TCD22_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_ESG.
#define BF_DMA_TCD22_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_ESG), uint16_t) & BM_DMA_TCD22_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD22_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD22_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD22_CSR_MAJORELINK.
#define BM_DMA_TCD22_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD22_CSR_MAJORELINK.
#define BS_DMA_TCD22_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD22_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_MAJORELINK field.
#define BR_DMA_TCD22_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_MAJORELINK.
#define BF_DMA_TCD22_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD22_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD22_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD22_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD22_CSR_ACTIVE.
#define BM_DMA_TCD22_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD22_CSR_ACTIVE.
#define BS_DMA_TCD22_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD22_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_ACTIVE field.
#define BR_DMA_TCD22_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_ACTIVE.
#define BF_DMA_TCD22_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_ACTIVE), uint16_t) & BM_DMA_TCD22_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD22_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD22_CSR_DONE      (7U)      //!< Bit position for DMA_TCD22_CSR_DONE.
#define BM_DMA_TCD22_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD22_CSR_DONE.
#define BS_DMA_TCD22_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD22_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_DONE field.
#define BR_DMA_TCD22_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_DONE.
#define BF_DMA_TCD22_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_DONE), uint16_t) & BM_DMA_TCD22_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD22_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_CSR_ADDR, BP_DMA_TCD22_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD22_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD22_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD22_CSR_MAJORLINKCH.
#define BM_DMA_TCD22_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD22_CSR_MAJORLINKCH.
#define BS_DMA_TCD22_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD22_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_MAJORLINKCH field.
#define BR_DMA_TCD22_CSR_MAJORLINKCH()   (HW_DMA_TCD22_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_MAJORLINKCH.
#define BF_DMA_TCD22_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD22_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD22_CSR_MAJORLINKCH(v)   (HW_DMA_TCD22_CSR_WR((HW_DMA_TCD22_CSR_RD() & ~BM_DMA_TCD22_CSR_MAJORLINKCH) | BF_DMA_TCD22_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD22_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD22_CSR_BWC      (14U)      //!< Bit position for DMA_TCD22_CSR_BWC.
#define BM_DMA_TCD22_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD22_CSR_BWC.
#define BS_DMA_TCD22_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD22_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_CSR_BWC field.
#define BR_DMA_TCD22_CSR_BWC()   (HW_DMA_TCD22_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD22_CSR_BWC.
#define BF_DMA_TCD22_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_CSR_BWC), uint16_t) & BM_DMA_TCD22_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD22_CSR_BWC(v)   (HW_DMA_TCD22_CSR_WR((HW_DMA_TCD22_CSR_RD() & ~BM_DMA_TCD22_CSR_BWC) | BF_DMA_TCD22_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd22_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd22_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd22_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD22_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x12deU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_BITER_ELINKYES           (*(__IO hw_dma_tcd22_biter_elinkyes_t *) HW_DMA_TCD22_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD22_BITER_ELINKYES_RD()      (HW_DMA_TCD22_BITER_ELINKYES.U)
#define HW_DMA_TCD22_BITER_ELINKYES_WR(v)     (HW_DMA_TCD22_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD22_BITER_ELINKYES_SET(v)    (HW_DMA_TCD22_BITER_ELINKYES_WR(HW_DMA_TCD22_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD22_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD22_BITER_ELINKYES_WR(HW_DMA_TCD22_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD22_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD22_BITER_ELINKYES_WR(HW_DMA_TCD22_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD22_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD22_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD22_BITER_ELINKYES_BITER.
#define BM_DMA_TCD22_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD22_BITER_ELINKYES_BITER.
#define BS_DMA_TCD22_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD22_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD22_BITER_ELINKYES_BITER()   (HW_DMA_TCD22_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD22_BITER_ELINKYES_BITER.
#define BF_DMA_TCD22_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD22_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD22_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD22_BITER_ELINKYES_WR((HW_DMA_TCD22_BITER_ELINKYES_RD() & ~BM_DMA_TCD22_BITER_ELINKYES_BITER) | BF_DMA_TCD22_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD22_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD22_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD22_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD22_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD22_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD22_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD22_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD22_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD22_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD22_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD22_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD22_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD22_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD22_BITER_ELINKYES_WR((HW_DMA_TCD22_BITER_ELINKYES_RD() & ~BM_DMA_TCD22_BITER_ELINKYES_LINKCH) | BF_DMA_TCD22_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD22_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD22_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD22_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD22_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD22_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD22_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD22_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD22_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD22_BITER_ELINKYES_ADDR, BP_DMA_TCD22_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD22_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD22_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD22_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD22_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_BITER_ELINKYES_ADDR, BP_DMA_TCD22_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD22_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD22_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd22_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd22_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd22_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD22_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD22_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x12deU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD22_BITER_ELINKNO           (*(__IO hw_dma_tcd22_biter_elinkno_t *) HW_DMA_TCD22_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD22_BITER_ELINKNO_RD()      (HW_DMA_TCD22_BITER_ELINKNO.U)
#define HW_DMA_TCD22_BITER_ELINKNO_WR(v)     (HW_DMA_TCD22_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD22_BITER_ELINKNO_SET(v)    (HW_DMA_TCD22_BITER_ELINKNO_WR(HW_DMA_TCD22_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD22_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD22_BITER_ELINKNO_WR(HW_DMA_TCD22_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD22_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD22_BITER_ELINKNO_WR(HW_DMA_TCD22_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD22_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD22_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD22_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD22_BITER_ELINKNO_BITER.
#define BM_DMA_TCD22_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD22_BITER_ELINKNO_BITER.
#define BS_DMA_TCD22_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD22_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD22_BITER_ELINKNO_BITER()   (HW_DMA_TCD22_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD22_BITER_ELINKNO_BITER.
#define BF_DMA_TCD22_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD22_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD22_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD22_BITER_ELINKNO_WR((HW_DMA_TCD22_BITER_ELINKNO_RD() & ~BM_DMA_TCD22_BITER_ELINKNO_BITER) | BF_DMA_TCD22_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD22_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD22_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD22_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD22_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD22_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD22_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD22_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD22_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD22_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD22_BITER_ELINKNO_ADDR, BP_DMA_TCD22_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD22_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD22_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD22_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD22_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD22_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD22_BITER_ELINKNO_ADDR, BP_DMA_TCD22_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd23_saddr
{
    uint32_t U;
    struct _hw_dma_tcd23_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd23_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_SADDR register
 */
//@{
#define HW_DMA_TCD23_SADDR_ADDR      (REGS_DMA_BASE + 0x12e0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_SADDR           (*(__IO hw_dma_tcd23_saddr_t *) HW_DMA_TCD23_SADDR_ADDR)
#define HW_DMA_TCD23_SADDR_RD()      (HW_DMA_TCD23_SADDR.U)
#define HW_DMA_TCD23_SADDR_WR(v)     (HW_DMA_TCD23_SADDR.U = (v))
#define HW_DMA_TCD23_SADDR_SET(v)    (HW_DMA_TCD23_SADDR_WR(HW_DMA_TCD23_SADDR_RD() |  (v)))
#define HW_DMA_TCD23_SADDR_CLR(v)    (HW_DMA_TCD23_SADDR_WR(HW_DMA_TCD23_SADDR_RD() & ~(v)))
#define HW_DMA_TCD23_SADDR_TOG(v)    (HW_DMA_TCD23_SADDR_WR(HW_DMA_TCD23_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_SADDR bitfields
 */

/*! @name Register DMA_TCD23_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD23_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD23_SADDR_SADDR.
#define BM_DMA_TCD23_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD23_SADDR_SADDR.
#define BS_DMA_TCD23_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD23_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_SADDR_SADDR field.
#define BR_DMA_TCD23_SADDR_SADDR()   (HW_DMA_TCD23_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD23_SADDR_SADDR.
#define BF_DMA_TCD23_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_SADDR_SADDR), uint32_t) & BM_DMA_TCD23_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD23_SADDR_SADDR(v)   (HW_DMA_TCD23_SADDR_WR((HW_DMA_TCD23_SADDR_RD() & ~BM_DMA_TCD23_SADDR_SADDR) | BF_DMA_TCD23_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd23_soff
{
    uint16_t U;
    struct _hw_dma_tcd23_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd23_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_SOFF register
 */
//@{
#define HW_DMA_TCD23_SOFF_ADDR      (REGS_DMA_BASE + 0x12e4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_SOFF           (*(__IO hw_dma_tcd23_soff_t *) HW_DMA_TCD23_SOFF_ADDR)
#define HW_DMA_TCD23_SOFF_RD()      (HW_DMA_TCD23_SOFF.U)
#define HW_DMA_TCD23_SOFF_WR(v)     (HW_DMA_TCD23_SOFF.U = (v))
#define HW_DMA_TCD23_SOFF_SET(v)    (HW_DMA_TCD23_SOFF_WR(HW_DMA_TCD23_SOFF_RD() |  (v)))
#define HW_DMA_TCD23_SOFF_CLR(v)    (HW_DMA_TCD23_SOFF_WR(HW_DMA_TCD23_SOFF_RD() & ~(v)))
#define HW_DMA_TCD23_SOFF_TOG(v)    (HW_DMA_TCD23_SOFF_WR(HW_DMA_TCD23_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_SOFF bitfields
 */

/*! @name Register DMA_TCD23_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD23_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD23_SOFF_SOFF.
#define BM_DMA_TCD23_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD23_SOFF_SOFF.
#define BS_DMA_TCD23_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD23_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_SOFF_SOFF field.
#define BR_DMA_TCD23_SOFF_SOFF()   (HW_DMA_TCD23_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD23_SOFF_SOFF.
#define BF_DMA_TCD23_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_SOFF_SOFF), uint16_t) & BM_DMA_TCD23_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD23_SOFF_SOFF(v)   (HW_DMA_TCD23_SOFF_WR((HW_DMA_TCD23_SOFF_RD() & ~BM_DMA_TCD23_SOFF_SOFF) | BF_DMA_TCD23_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd23_attr
{
    uint16_t U;
    struct _hw_dma_tcd23_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd23_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_ATTR register
 */
//@{
#define HW_DMA_TCD23_ATTR_ADDR      (REGS_DMA_BASE + 0x12e6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_ATTR           (*(__IO hw_dma_tcd23_attr_t *) HW_DMA_TCD23_ATTR_ADDR)
#define HW_DMA_TCD23_ATTR_RD()      (HW_DMA_TCD23_ATTR.U)
#define HW_DMA_TCD23_ATTR_WR(v)     (HW_DMA_TCD23_ATTR.U = (v))
#define HW_DMA_TCD23_ATTR_SET(v)    (HW_DMA_TCD23_ATTR_WR(HW_DMA_TCD23_ATTR_RD() |  (v)))
#define HW_DMA_TCD23_ATTR_CLR(v)    (HW_DMA_TCD23_ATTR_WR(HW_DMA_TCD23_ATTR_RD() & ~(v)))
#define HW_DMA_TCD23_ATTR_TOG(v)    (HW_DMA_TCD23_ATTR_WR(HW_DMA_TCD23_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_ATTR bitfields
 */

/*! @name Register DMA_TCD23_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD23_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD23_ATTR_DSIZE.
#define BM_DMA_TCD23_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD23_ATTR_DSIZE.
#define BS_DMA_TCD23_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD23_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_ATTR_DSIZE field.
#define BR_DMA_TCD23_ATTR_DSIZE()   (HW_DMA_TCD23_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD23_ATTR_DSIZE.
#define BF_DMA_TCD23_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_ATTR_DSIZE), uint16_t) & BM_DMA_TCD23_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD23_ATTR_DSIZE(v)   (HW_DMA_TCD23_ATTR_WR((HW_DMA_TCD23_ATTR_RD() & ~BM_DMA_TCD23_ATTR_DSIZE) | BF_DMA_TCD23_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD23_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD23_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD23_ATTR_DMOD.
#define BM_DMA_TCD23_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD23_ATTR_DMOD.
#define BS_DMA_TCD23_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD23_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_ATTR_DMOD field.
#define BR_DMA_TCD23_ATTR_DMOD()   (HW_DMA_TCD23_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD23_ATTR_DMOD.
#define BF_DMA_TCD23_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_ATTR_DMOD), uint16_t) & BM_DMA_TCD23_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD23_ATTR_DMOD(v)   (HW_DMA_TCD23_ATTR_WR((HW_DMA_TCD23_ATTR_RD() & ~BM_DMA_TCD23_ATTR_DMOD) | BF_DMA_TCD23_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD23_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD23_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD23_ATTR_SSIZE.
#define BM_DMA_TCD23_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD23_ATTR_SSIZE.
#define BS_DMA_TCD23_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD23_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_ATTR_SSIZE field.
#define BR_DMA_TCD23_ATTR_SSIZE()   (HW_DMA_TCD23_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD23_ATTR_SSIZE.
#define BF_DMA_TCD23_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_ATTR_SSIZE), uint16_t) & BM_DMA_TCD23_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD23_ATTR_SSIZE(v)   (HW_DMA_TCD23_ATTR_WR((HW_DMA_TCD23_ATTR_RD() & ~BM_DMA_TCD23_ATTR_SSIZE) | BF_DMA_TCD23_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD23_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD23_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD23_ATTR_SMOD.
#define BM_DMA_TCD23_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD23_ATTR_SMOD.
#define BS_DMA_TCD23_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD23_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_ATTR_SMOD field.
#define BR_DMA_TCD23_ATTR_SMOD()   (HW_DMA_TCD23_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD23_ATTR_SMOD.
#define BF_DMA_TCD23_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_ATTR_SMOD), uint16_t) & BM_DMA_TCD23_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD23_ATTR_SMOD(v)   (HW_DMA_TCD23_ATTR_WR((HW_DMA_TCD23_ATTR_RD() & ~BM_DMA_TCD23_ATTR_SMOD) | BF_DMA_TCD23_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd23_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd23_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd23_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD23_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x12e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_NBYTES_MLNO           (*(__IO hw_dma_tcd23_nbytes_mlno_t *) HW_DMA_TCD23_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD23_NBYTES_MLNO_RD()      (HW_DMA_TCD23_NBYTES_MLNO.U)
#define HW_DMA_TCD23_NBYTES_MLNO_WR(v)     (HW_DMA_TCD23_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD23_NBYTES_MLNO_SET(v)    (HW_DMA_TCD23_NBYTES_MLNO_WR(HW_DMA_TCD23_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD23_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD23_NBYTES_MLNO_WR(HW_DMA_TCD23_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD23_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD23_NBYTES_MLNO_WR(HW_DMA_TCD23_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD23_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD23_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD23_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD23_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD23_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD23_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD23_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD23_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD23_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD23_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD23_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD23_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD23_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD23_NBYTES_MLNO_WR((HW_DMA_TCD23_NBYTES_MLNO_RD() & ~BM_DMA_TCD23_NBYTES_MLNO_NBYTES) | BF_DMA_TCD23_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd23_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd23_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd23_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD23_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x12e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd23_nbytes_mloffno_t *) HW_DMA_TCD23_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD23_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD23_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD23_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD23_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD23_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD23_NBYTES_MLOFFNO_WR(HW_DMA_TCD23_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD23_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD23_NBYTES_MLOFFNO_WR(HW_DMA_TCD23_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD23_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD23_NBYTES_MLOFFNO_WR(HW_DMA_TCD23_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD23_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD23_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD23_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD23_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD23_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD23_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD23_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD23_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD23_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD23_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD23_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD23_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD23_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD23_NBYTES_MLOFFNO_WR((HW_DMA_TCD23_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD23_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD23_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD23_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD23_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD23_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD23_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD23_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD23_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD23_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD23_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD23_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD23_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD23_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD23_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD23_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD23_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD23_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD23_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD23_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD23_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD23_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD23_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD23_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD23_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD23_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD23_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD23_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD23_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD23_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD23_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD23_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD23_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD23_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd23_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd23_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd23_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD23_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x12e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd23_nbytes_mloffyes_t *) HW_DMA_TCD23_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD23_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD23_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD23_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD23_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD23_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD23_NBYTES_MLOFFYES_WR(HW_DMA_TCD23_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD23_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD23_NBYTES_MLOFFYES_WR(HW_DMA_TCD23_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD23_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD23_NBYTES_MLOFFYES_WR(HW_DMA_TCD23_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD23_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD23_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD23_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD23_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD23_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD23_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD23_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD23_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD23_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD23_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD23_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD23_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD23_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD23_NBYTES_MLOFFYES_WR((HW_DMA_TCD23_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD23_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD23_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD23_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD23_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD23_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD23_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD23_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD23_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD23_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD23_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD23_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD23_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD23_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD23_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD23_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD23_NBYTES_MLOFFYES_WR((HW_DMA_TCD23_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD23_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD23_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD23_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD23_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD23_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD23_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD23_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD23_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD23_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD23_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD23_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD23_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD23_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD23_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD23_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD23_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD23_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD23_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD23_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD23_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD23_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD23_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD23_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD23_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD23_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD23_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD23_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD23_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD23_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD23_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD23_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD23_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD23_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd23_slast
{
    uint32_t U;
    struct _hw_dma_tcd23_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd23_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_SLAST register
 */
//@{
#define HW_DMA_TCD23_SLAST_ADDR      (REGS_DMA_BASE + 0x12ecU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_SLAST           (*(__IO hw_dma_tcd23_slast_t *) HW_DMA_TCD23_SLAST_ADDR)
#define HW_DMA_TCD23_SLAST_RD()      (HW_DMA_TCD23_SLAST.U)
#define HW_DMA_TCD23_SLAST_WR(v)     (HW_DMA_TCD23_SLAST.U = (v))
#define HW_DMA_TCD23_SLAST_SET(v)    (HW_DMA_TCD23_SLAST_WR(HW_DMA_TCD23_SLAST_RD() |  (v)))
#define HW_DMA_TCD23_SLAST_CLR(v)    (HW_DMA_TCD23_SLAST_WR(HW_DMA_TCD23_SLAST_RD() & ~(v)))
#define HW_DMA_TCD23_SLAST_TOG(v)    (HW_DMA_TCD23_SLAST_WR(HW_DMA_TCD23_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_SLAST bitfields
 */

/*! @name Register DMA_TCD23_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD23_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD23_SLAST_SLAST.
#define BM_DMA_TCD23_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD23_SLAST_SLAST.
#define BS_DMA_TCD23_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD23_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_SLAST_SLAST field.
#define BR_DMA_TCD23_SLAST_SLAST()   (HW_DMA_TCD23_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD23_SLAST_SLAST.
#define BF_DMA_TCD23_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_SLAST_SLAST), uint32_t) & BM_DMA_TCD23_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD23_SLAST_SLAST(v)   (HW_DMA_TCD23_SLAST_WR((HW_DMA_TCD23_SLAST_RD() & ~BM_DMA_TCD23_SLAST_SLAST) | BF_DMA_TCD23_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd23_daddr
{
    uint32_t U;
    struct _hw_dma_tcd23_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd23_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_DADDR register
 */
//@{
#define HW_DMA_TCD23_DADDR_ADDR      (REGS_DMA_BASE + 0x12f0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_DADDR           (*(__IO hw_dma_tcd23_daddr_t *) HW_DMA_TCD23_DADDR_ADDR)
#define HW_DMA_TCD23_DADDR_RD()      (HW_DMA_TCD23_DADDR.U)
#define HW_DMA_TCD23_DADDR_WR(v)     (HW_DMA_TCD23_DADDR.U = (v))
#define HW_DMA_TCD23_DADDR_SET(v)    (HW_DMA_TCD23_DADDR_WR(HW_DMA_TCD23_DADDR_RD() |  (v)))
#define HW_DMA_TCD23_DADDR_CLR(v)    (HW_DMA_TCD23_DADDR_WR(HW_DMA_TCD23_DADDR_RD() & ~(v)))
#define HW_DMA_TCD23_DADDR_TOG(v)    (HW_DMA_TCD23_DADDR_WR(HW_DMA_TCD23_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_DADDR bitfields
 */

/*! @name Register DMA_TCD23_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD23_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD23_DADDR_DADDR.
#define BM_DMA_TCD23_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD23_DADDR_DADDR.
#define BS_DMA_TCD23_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD23_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_DADDR_DADDR field.
#define BR_DMA_TCD23_DADDR_DADDR()   (HW_DMA_TCD23_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD23_DADDR_DADDR.
#define BF_DMA_TCD23_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_DADDR_DADDR), uint32_t) & BM_DMA_TCD23_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD23_DADDR_DADDR(v)   (HW_DMA_TCD23_DADDR_WR((HW_DMA_TCD23_DADDR_RD() & ~BM_DMA_TCD23_DADDR_DADDR) | BF_DMA_TCD23_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd23_doff
{
    uint16_t U;
    struct _hw_dma_tcd23_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd23_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_DOFF register
 */
//@{
#define HW_DMA_TCD23_DOFF_ADDR      (REGS_DMA_BASE + 0x12f4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_DOFF           (*(__IO hw_dma_tcd23_doff_t *) HW_DMA_TCD23_DOFF_ADDR)
#define HW_DMA_TCD23_DOFF_RD()      (HW_DMA_TCD23_DOFF.U)
#define HW_DMA_TCD23_DOFF_WR(v)     (HW_DMA_TCD23_DOFF.U = (v))
#define HW_DMA_TCD23_DOFF_SET(v)    (HW_DMA_TCD23_DOFF_WR(HW_DMA_TCD23_DOFF_RD() |  (v)))
#define HW_DMA_TCD23_DOFF_CLR(v)    (HW_DMA_TCD23_DOFF_WR(HW_DMA_TCD23_DOFF_RD() & ~(v)))
#define HW_DMA_TCD23_DOFF_TOG(v)    (HW_DMA_TCD23_DOFF_WR(HW_DMA_TCD23_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_DOFF bitfields
 */

/*! @name Register DMA_TCD23_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD23_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD23_DOFF_DOFF.
#define BM_DMA_TCD23_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD23_DOFF_DOFF.
#define BS_DMA_TCD23_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD23_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_DOFF_DOFF field.
#define BR_DMA_TCD23_DOFF_DOFF()   (HW_DMA_TCD23_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD23_DOFF_DOFF.
#define BF_DMA_TCD23_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_DOFF_DOFF), uint16_t) & BM_DMA_TCD23_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD23_DOFF_DOFF(v)   (HW_DMA_TCD23_DOFF_WR((HW_DMA_TCD23_DOFF_RD() & ~BM_DMA_TCD23_DOFF_DOFF) | BF_DMA_TCD23_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd23_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd23_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd23_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD23_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x12f6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_CITER_ELINKYES           (*(__IO hw_dma_tcd23_citer_elinkyes_t *) HW_DMA_TCD23_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD23_CITER_ELINKYES_RD()      (HW_DMA_TCD23_CITER_ELINKYES.U)
#define HW_DMA_TCD23_CITER_ELINKYES_WR(v)     (HW_DMA_TCD23_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD23_CITER_ELINKYES_SET(v)    (HW_DMA_TCD23_CITER_ELINKYES_WR(HW_DMA_TCD23_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD23_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD23_CITER_ELINKYES_WR(HW_DMA_TCD23_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD23_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD23_CITER_ELINKYES_WR(HW_DMA_TCD23_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD23_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD23_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD23_CITER_ELINKYES_CITER.
#define BM_DMA_TCD23_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD23_CITER_ELINKYES_CITER.
#define BS_DMA_TCD23_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD23_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD23_CITER_ELINKYES_CITER()   (HW_DMA_TCD23_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD23_CITER_ELINKYES_CITER.
#define BF_DMA_TCD23_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD23_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD23_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD23_CITER_ELINKYES_WR((HW_DMA_TCD23_CITER_ELINKYES_RD() & ~BM_DMA_TCD23_CITER_ELINKYES_CITER) | BF_DMA_TCD23_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD23_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD23_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD23_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD23_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD23_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD23_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD23_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD23_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD23_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD23_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD23_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD23_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD23_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD23_CITER_ELINKYES_WR((HW_DMA_TCD23_CITER_ELINKYES_RD() & ~BM_DMA_TCD23_CITER_ELINKYES_LINKCH) | BF_DMA_TCD23_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD23_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD23_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD23_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD23_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD23_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD23_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD23_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD23_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD23_CITER_ELINKYES_ADDR, BP_DMA_TCD23_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD23_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD23_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD23_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD23_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CITER_ELINKYES_ADDR, BP_DMA_TCD23_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd23_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd23_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd23_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD23_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x12f6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_CITER_ELINKNO           (*(__IO hw_dma_tcd23_citer_elinkno_t *) HW_DMA_TCD23_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD23_CITER_ELINKNO_RD()      (HW_DMA_TCD23_CITER_ELINKNO.U)
#define HW_DMA_TCD23_CITER_ELINKNO_WR(v)     (HW_DMA_TCD23_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD23_CITER_ELINKNO_SET(v)    (HW_DMA_TCD23_CITER_ELINKNO_WR(HW_DMA_TCD23_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD23_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD23_CITER_ELINKNO_WR(HW_DMA_TCD23_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD23_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD23_CITER_ELINKNO_WR(HW_DMA_TCD23_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD23_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD23_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD23_CITER_ELINKNO_CITER.
#define BM_DMA_TCD23_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD23_CITER_ELINKNO_CITER.
#define BS_DMA_TCD23_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD23_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD23_CITER_ELINKNO_CITER()   (HW_DMA_TCD23_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD23_CITER_ELINKNO_CITER.
#define BF_DMA_TCD23_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD23_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD23_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD23_CITER_ELINKNO_WR((HW_DMA_TCD23_CITER_ELINKNO_RD() & ~BM_DMA_TCD23_CITER_ELINKNO_CITER) | BF_DMA_TCD23_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD23_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD23_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD23_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD23_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD23_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD23_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD23_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD23_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD23_CITER_ELINKNO_ADDR, BP_DMA_TCD23_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD23_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD23_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD23_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD23_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CITER_ELINKNO_ADDR, BP_DMA_TCD23_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd23_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd23_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd23_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_DLASTSGA register
 */
//@{
#define HW_DMA_TCD23_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x12f8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_DLASTSGA           (*(__IO hw_dma_tcd23_dlastsga_t *) HW_DMA_TCD23_DLASTSGA_ADDR)
#define HW_DMA_TCD23_DLASTSGA_RD()      (HW_DMA_TCD23_DLASTSGA.U)
#define HW_DMA_TCD23_DLASTSGA_WR(v)     (HW_DMA_TCD23_DLASTSGA.U = (v))
#define HW_DMA_TCD23_DLASTSGA_SET(v)    (HW_DMA_TCD23_DLASTSGA_WR(HW_DMA_TCD23_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD23_DLASTSGA_CLR(v)    (HW_DMA_TCD23_DLASTSGA_WR(HW_DMA_TCD23_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD23_DLASTSGA_TOG(v)    (HW_DMA_TCD23_DLASTSGA_WR(HW_DMA_TCD23_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD23_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD23_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD23_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD23_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD23_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD23_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD23_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD23_DLASTSGA_DLASTSGA()   (HW_DMA_TCD23_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD23_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD23_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD23_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD23_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD23_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD23_DLASTSGA_WR((HW_DMA_TCD23_DLASTSGA_RD() & ~BM_DMA_TCD23_DLASTSGA_DLASTSGA) | BF_DMA_TCD23_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd23_csr
{
    uint16_t U;
    struct _hw_dma_tcd23_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd23_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_CSR register
 */
//@{
#define HW_DMA_TCD23_CSR_ADDR      (REGS_DMA_BASE + 0x12fcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_CSR           (*(__IO hw_dma_tcd23_csr_t *) HW_DMA_TCD23_CSR_ADDR)
#define HW_DMA_TCD23_CSR_RD()      (HW_DMA_TCD23_CSR.U)
#define HW_DMA_TCD23_CSR_WR(v)     (HW_DMA_TCD23_CSR.U = (v))
#define HW_DMA_TCD23_CSR_SET(v)    (HW_DMA_TCD23_CSR_WR(HW_DMA_TCD23_CSR_RD() |  (v)))
#define HW_DMA_TCD23_CSR_CLR(v)    (HW_DMA_TCD23_CSR_WR(HW_DMA_TCD23_CSR_RD() & ~(v)))
#define HW_DMA_TCD23_CSR_TOG(v)    (HW_DMA_TCD23_CSR_WR(HW_DMA_TCD23_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_CSR bitfields
 */

/*! @name Register DMA_TCD23_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD23_CSR_START      (0U)      //!< Bit position for DMA_TCD23_CSR_START.
#define BM_DMA_TCD23_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD23_CSR_START.
#define BS_DMA_TCD23_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD23_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_START field.
#define BR_DMA_TCD23_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_START.
#define BF_DMA_TCD23_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_START), uint16_t) & BM_DMA_TCD23_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD23_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD23_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD23_CSR_INTMAJOR.
#define BM_DMA_TCD23_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD23_CSR_INTMAJOR.
#define BS_DMA_TCD23_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD23_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_INTMAJOR field.
#define BR_DMA_TCD23_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_INTMAJOR.
#define BF_DMA_TCD23_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD23_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD23_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD23_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD23_CSR_INTHALF.
#define BM_DMA_TCD23_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD23_CSR_INTHALF.
#define BS_DMA_TCD23_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD23_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_INTHALF field.
#define BR_DMA_TCD23_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_INTHALF.
#define BF_DMA_TCD23_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_INTHALF), uint16_t) & BM_DMA_TCD23_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD23_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD23_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD23_CSR_DREQ.
#define BM_DMA_TCD23_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD23_CSR_DREQ.
#define BS_DMA_TCD23_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD23_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_DREQ field.
#define BR_DMA_TCD23_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_DREQ.
#define BF_DMA_TCD23_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_DREQ), uint16_t) & BM_DMA_TCD23_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD23_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD23_CSR_ESG      (4U)      //!< Bit position for DMA_TCD23_CSR_ESG.
#define BM_DMA_TCD23_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD23_CSR_ESG.
#define BS_DMA_TCD23_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD23_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_ESG field.
#define BR_DMA_TCD23_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_ESG.
#define BF_DMA_TCD23_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_ESG), uint16_t) & BM_DMA_TCD23_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD23_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD23_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD23_CSR_MAJORELINK.
#define BM_DMA_TCD23_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD23_CSR_MAJORELINK.
#define BS_DMA_TCD23_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD23_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_MAJORELINK field.
#define BR_DMA_TCD23_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_MAJORELINK.
#define BF_DMA_TCD23_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD23_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD23_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD23_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD23_CSR_ACTIVE.
#define BM_DMA_TCD23_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD23_CSR_ACTIVE.
#define BS_DMA_TCD23_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD23_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_ACTIVE field.
#define BR_DMA_TCD23_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_ACTIVE.
#define BF_DMA_TCD23_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_ACTIVE), uint16_t) & BM_DMA_TCD23_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD23_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD23_CSR_DONE      (7U)      //!< Bit position for DMA_TCD23_CSR_DONE.
#define BM_DMA_TCD23_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD23_CSR_DONE.
#define BS_DMA_TCD23_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD23_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_DONE field.
#define BR_DMA_TCD23_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_DONE.
#define BF_DMA_TCD23_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_DONE), uint16_t) & BM_DMA_TCD23_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD23_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_CSR_ADDR, BP_DMA_TCD23_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD23_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD23_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD23_CSR_MAJORLINKCH.
#define BM_DMA_TCD23_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD23_CSR_MAJORLINKCH.
#define BS_DMA_TCD23_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD23_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_MAJORLINKCH field.
#define BR_DMA_TCD23_CSR_MAJORLINKCH()   (HW_DMA_TCD23_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_MAJORLINKCH.
#define BF_DMA_TCD23_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD23_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD23_CSR_MAJORLINKCH(v)   (HW_DMA_TCD23_CSR_WR((HW_DMA_TCD23_CSR_RD() & ~BM_DMA_TCD23_CSR_MAJORLINKCH) | BF_DMA_TCD23_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD23_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD23_CSR_BWC      (14U)      //!< Bit position for DMA_TCD23_CSR_BWC.
#define BM_DMA_TCD23_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD23_CSR_BWC.
#define BS_DMA_TCD23_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD23_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_CSR_BWC field.
#define BR_DMA_TCD23_CSR_BWC()   (HW_DMA_TCD23_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD23_CSR_BWC.
#define BF_DMA_TCD23_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_CSR_BWC), uint16_t) & BM_DMA_TCD23_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD23_CSR_BWC(v)   (HW_DMA_TCD23_CSR_WR((HW_DMA_TCD23_CSR_RD() & ~BM_DMA_TCD23_CSR_BWC) | BF_DMA_TCD23_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd23_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd23_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd23_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD23_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x12feU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_BITER_ELINKYES           (*(__IO hw_dma_tcd23_biter_elinkyes_t *) HW_DMA_TCD23_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD23_BITER_ELINKYES_RD()      (HW_DMA_TCD23_BITER_ELINKYES.U)
#define HW_DMA_TCD23_BITER_ELINKYES_WR(v)     (HW_DMA_TCD23_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD23_BITER_ELINKYES_SET(v)    (HW_DMA_TCD23_BITER_ELINKYES_WR(HW_DMA_TCD23_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD23_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD23_BITER_ELINKYES_WR(HW_DMA_TCD23_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD23_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD23_BITER_ELINKYES_WR(HW_DMA_TCD23_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD23_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD23_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD23_BITER_ELINKYES_BITER.
#define BM_DMA_TCD23_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD23_BITER_ELINKYES_BITER.
#define BS_DMA_TCD23_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD23_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD23_BITER_ELINKYES_BITER()   (HW_DMA_TCD23_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD23_BITER_ELINKYES_BITER.
#define BF_DMA_TCD23_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD23_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD23_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD23_BITER_ELINKYES_WR((HW_DMA_TCD23_BITER_ELINKYES_RD() & ~BM_DMA_TCD23_BITER_ELINKYES_BITER) | BF_DMA_TCD23_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD23_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD23_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD23_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD23_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD23_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD23_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD23_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD23_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD23_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD23_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD23_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD23_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD23_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD23_BITER_ELINKYES_WR((HW_DMA_TCD23_BITER_ELINKYES_RD() & ~BM_DMA_TCD23_BITER_ELINKYES_LINKCH) | BF_DMA_TCD23_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD23_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD23_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD23_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD23_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD23_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD23_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD23_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD23_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD23_BITER_ELINKYES_ADDR, BP_DMA_TCD23_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD23_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD23_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD23_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD23_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_BITER_ELINKYES_ADDR, BP_DMA_TCD23_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD23_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD23_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd23_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd23_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd23_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD23_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD23_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x12feU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD23_BITER_ELINKNO           (*(__IO hw_dma_tcd23_biter_elinkno_t *) HW_DMA_TCD23_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD23_BITER_ELINKNO_RD()      (HW_DMA_TCD23_BITER_ELINKNO.U)
#define HW_DMA_TCD23_BITER_ELINKNO_WR(v)     (HW_DMA_TCD23_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD23_BITER_ELINKNO_SET(v)    (HW_DMA_TCD23_BITER_ELINKNO_WR(HW_DMA_TCD23_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD23_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD23_BITER_ELINKNO_WR(HW_DMA_TCD23_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD23_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD23_BITER_ELINKNO_WR(HW_DMA_TCD23_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD23_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD23_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD23_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD23_BITER_ELINKNO_BITER.
#define BM_DMA_TCD23_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD23_BITER_ELINKNO_BITER.
#define BS_DMA_TCD23_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD23_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD23_BITER_ELINKNO_BITER()   (HW_DMA_TCD23_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD23_BITER_ELINKNO_BITER.
#define BF_DMA_TCD23_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD23_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD23_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD23_BITER_ELINKNO_WR((HW_DMA_TCD23_BITER_ELINKNO_RD() & ~BM_DMA_TCD23_BITER_ELINKNO_BITER) | BF_DMA_TCD23_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD23_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD23_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD23_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD23_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD23_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD23_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD23_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD23_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD23_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD23_BITER_ELINKNO_ADDR, BP_DMA_TCD23_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD23_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD23_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD23_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD23_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD23_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD23_BITER_ELINKNO_ADDR, BP_DMA_TCD23_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd24_saddr
{
    uint32_t U;
    struct _hw_dma_tcd24_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd24_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_SADDR register
 */
//@{
#define HW_DMA_TCD24_SADDR_ADDR      (REGS_DMA_BASE + 0x1300U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_SADDR           (*(__IO hw_dma_tcd24_saddr_t *) HW_DMA_TCD24_SADDR_ADDR)
#define HW_DMA_TCD24_SADDR_RD()      (HW_DMA_TCD24_SADDR.U)
#define HW_DMA_TCD24_SADDR_WR(v)     (HW_DMA_TCD24_SADDR.U = (v))
#define HW_DMA_TCD24_SADDR_SET(v)    (HW_DMA_TCD24_SADDR_WR(HW_DMA_TCD24_SADDR_RD() |  (v)))
#define HW_DMA_TCD24_SADDR_CLR(v)    (HW_DMA_TCD24_SADDR_WR(HW_DMA_TCD24_SADDR_RD() & ~(v)))
#define HW_DMA_TCD24_SADDR_TOG(v)    (HW_DMA_TCD24_SADDR_WR(HW_DMA_TCD24_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_SADDR bitfields
 */

/*! @name Register DMA_TCD24_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD24_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD24_SADDR_SADDR.
#define BM_DMA_TCD24_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD24_SADDR_SADDR.
#define BS_DMA_TCD24_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD24_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_SADDR_SADDR field.
#define BR_DMA_TCD24_SADDR_SADDR()   (HW_DMA_TCD24_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD24_SADDR_SADDR.
#define BF_DMA_TCD24_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_SADDR_SADDR), uint32_t) & BM_DMA_TCD24_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD24_SADDR_SADDR(v)   (HW_DMA_TCD24_SADDR_WR((HW_DMA_TCD24_SADDR_RD() & ~BM_DMA_TCD24_SADDR_SADDR) | BF_DMA_TCD24_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd24_soff
{
    uint16_t U;
    struct _hw_dma_tcd24_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd24_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_SOFF register
 */
//@{
#define HW_DMA_TCD24_SOFF_ADDR      (REGS_DMA_BASE + 0x1304U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_SOFF           (*(__IO hw_dma_tcd24_soff_t *) HW_DMA_TCD24_SOFF_ADDR)
#define HW_DMA_TCD24_SOFF_RD()      (HW_DMA_TCD24_SOFF.U)
#define HW_DMA_TCD24_SOFF_WR(v)     (HW_DMA_TCD24_SOFF.U = (v))
#define HW_DMA_TCD24_SOFF_SET(v)    (HW_DMA_TCD24_SOFF_WR(HW_DMA_TCD24_SOFF_RD() |  (v)))
#define HW_DMA_TCD24_SOFF_CLR(v)    (HW_DMA_TCD24_SOFF_WR(HW_DMA_TCD24_SOFF_RD() & ~(v)))
#define HW_DMA_TCD24_SOFF_TOG(v)    (HW_DMA_TCD24_SOFF_WR(HW_DMA_TCD24_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_SOFF bitfields
 */

/*! @name Register DMA_TCD24_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD24_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD24_SOFF_SOFF.
#define BM_DMA_TCD24_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD24_SOFF_SOFF.
#define BS_DMA_TCD24_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD24_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_SOFF_SOFF field.
#define BR_DMA_TCD24_SOFF_SOFF()   (HW_DMA_TCD24_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD24_SOFF_SOFF.
#define BF_DMA_TCD24_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_SOFF_SOFF), uint16_t) & BM_DMA_TCD24_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD24_SOFF_SOFF(v)   (HW_DMA_TCD24_SOFF_WR((HW_DMA_TCD24_SOFF_RD() & ~BM_DMA_TCD24_SOFF_SOFF) | BF_DMA_TCD24_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd24_attr
{
    uint16_t U;
    struct _hw_dma_tcd24_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd24_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_ATTR register
 */
//@{
#define HW_DMA_TCD24_ATTR_ADDR      (REGS_DMA_BASE + 0x1306U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_ATTR           (*(__IO hw_dma_tcd24_attr_t *) HW_DMA_TCD24_ATTR_ADDR)
#define HW_DMA_TCD24_ATTR_RD()      (HW_DMA_TCD24_ATTR.U)
#define HW_DMA_TCD24_ATTR_WR(v)     (HW_DMA_TCD24_ATTR.U = (v))
#define HW_DMA_TCD24_ATTR_SET(v)    (HW_DMA_TCD24_ATTR_WR(HW_DMA_TCD24_ATTR_RD() |  (v)))
#define HW_DMA_TCD24_ATTR_CLR(v)    (HW_DMA_TCD24_ATTR_WR(HW_DMA_TCD24_ATTR_RD() & ~(v)))
#define HW_DMA_TCD24_ATTR_TOG(v)    (HW_DMA_TCD24_ATTR_WR(HW_DMA_TCD24_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_ATTR bitfields
 */

/*! @name Register DMA_TCD24_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD24_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD24_ATTR_DSIZE.
#define BM_DMA_TCD24_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD24_ATTR_DSIZE.
#define BS_DMA_TCD24_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD24_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_ATTR_DSIZE field.
#define BR_DMA_TCD24_ATTR_DSIZE()   (HW_DMA_TCD24_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD24_ATTR_DSIZE.
#define BF_DMA_TCD24_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_ATTR_DSIZE), uint16_t) & BM_DMA_TCD24_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD24_ATTR_DSIZE(v)   (HW_DMA_TCD24_ATTR_WR((HW_DMA_TCD24_ATTR_RD() & ~BM_DMA_TCD24_ATTR_DSIZE) | BF_DMA_TCD24_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD24_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD24_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD24_ATTR_DMOD.
#define BM_DMA_TCD24_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD24_ATTR_DMOD.
#define BS_DMA_TCD24_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD24_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_ATTR_DMOD field.
#define BR_DMA_TCD24_ATTR_DMOD()   (HW_DMA_TCD24_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD24_ATTR_DMOD.
#define BF_DMA_TCD24_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_ATTR_DMOD), uint16_t) & BM_DMA_TCD24_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD24_ATTR_DMOD(v)   (HW_DMA_TCD24_ATTR_WR((HW_DMA_TCD24_ATTR_RD() & ~BM_DMA_TCD24_ATTR_DMOD) | BF_DMA_TCD24_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD24_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD24_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD24_ATTR_SSIZE.
#define BM_DMA_TCD24_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD24_ATTR_SSIZE.
#define BS_DMA_TCD24_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD24_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_ATTR_SSIZE field.
#define BR_DMA_TCD24_ATTR_SSIZE()   (HW_DMA_TCD24_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD24_ATTR_SSIZE.
#define BF_DMA_TCD24_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_ATTR_SSIZE), uint16_t) & BM_DMA_TCD24_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD24_ATTR_SSIZE(v)   (HW_DMA_TCD24_ATTR_WR((HW_DMA_TCD24_ATTR_RD() & ~BM_DMA_TCD24_ATTR_SSIZE) | BF_DMA_TCD24_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD24_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD24_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD24_ATTR_SMOD.
#define BM_DMA_TCD24_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD24_ATTR_SMOD.
#define BS_DMA_TCD24_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD24_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_ATTR_SMOD field.
#define BR_DMA_TCD24_ATTR_SMOD()   (HW_DMA_TCD24_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD24_ATTR_SMOD.
#define BF_DMA_TCD24_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_ATTR_SMOD), uint16_t) & BM_DMA_TCD24_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD24_ATTR_SMOD(v)   (HW_DMA_TCD24_ATTR_WR((HW_DMA_TCD24_ATTR_RD() & ~BM_DMA_TCD24_ATTR_SMOD) | BF_DMA_TCD24_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd24_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd24_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd24_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD24_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1308U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_NBYTES_MLNO           (*(__IO hw_dma_tcd24_nbytes_mlno_t *) HW_DMA_TCD24_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD24_NBYTES_MLNO_RD()      (HW_DMA_TCD24_NBYTES_MLNO.U)
#define HW_DMA_TCD24_NBYTES_MLNO_WR(v)     (HW_DMA_TCD24_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD24_NBYTES_MLNO_SET(v)    (HW_DMA_TCD24_NBYTES_MLNO_WR(HW_DMA_TCD24_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD24_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD24_NBYTES_MLNO_WR(HW_DMA_TCD24_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD24_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD24_NBYTES_MLNO_WR(HW_DMA_TCD24_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD24_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD24_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD24_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD24_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD24_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD24_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD24_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD24_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD24_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD24_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD24_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD24_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD24_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD24_NBYTES_MLNO_WR((HW_DMA_TCD24_NBYTES_MLNO_RD() & ~BM_DMA_TCD24_NBYTES_MLNO_NBYTES) | BF_DMA_TCD24_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd24_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd24_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd24_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD24_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1308U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd24_nbytes_mloffno_t *) HW_DMA_TCD24_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD24_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD24_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD24_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD24_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD24_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD24_NBYTES_MLOFFNO_WR(HW_DMA_TCD24_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD24_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD24_NBYTES_MLOFFNO_WR(HW_DMA_TCD24_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD24_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD24_NBYTES_MLOFFNO_WR(HW_DMA_TCD24_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD24_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD24_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD24_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD24_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD24_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD24_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD24_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD24_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD24_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD24_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD24_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD24_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD24_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD24_NBYTES_MLOFFNO_WR((HW_DMA_TCD24_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD24_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD24_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD24_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD24_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD24_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD24_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD24_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD24_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD24_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD24_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD24_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD24_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD24_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD24_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD24_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD24_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD24_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD24_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD24_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD24_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD24_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD24_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD24_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD24_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD24_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD24_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD24_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD24_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD24_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD24_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD24_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD24_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD24_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd24_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd24_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd24_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD24_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1308U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd24_nbytes_mloffyes_t *) HW_DMA_TCD24_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD24_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD24_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD24_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD24_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD24_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD24_NBYTES_MLOFFYES_WR(HW_DMA_TCD24_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD24_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD24_NBYTES_MLOFFYES_WR(HW_DMA_TCD24_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD24_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD24_NBYTES_MLOFFYES_WR(HW_DMA_TCD24_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD24_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD24_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD24_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD24_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD24_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD24_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD24_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD24_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD24_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD24_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD24_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD24_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD24_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD24_NBYTES_MLOFFYES_WR((HW_DMA_TCD24_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD24_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD24_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD24_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD24_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD24_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD24_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD24_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD24_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD24_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD24_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD24_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD24_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD24_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD24_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD24_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD24_NBYTES_MLOFFYES_WR((HW_DMA_TCD24_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD24_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD24_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD24_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD24_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD24_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD24_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD24_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD24_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD24_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD24_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD24_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD24_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD24_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD24_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD24_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD24_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD24_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD24_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD24_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD24_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD24_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD24_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD24_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD24_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD24_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD24_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD24_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD24_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD24_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD24_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD24_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD24_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD24_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd24_slast
{
    uint32_t U;
    struct _hw_dma_tcd24_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd24_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_SLAST register
 */
//@{
#define HW_DMA_TCD24_SLAST_ADDR      (REGS_DMA_BASE + 0x130cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_SLAST           (*(__IO hw_dma_tcd24_slast_t *) HW_DMA_TCD24_SLAST_ADDR)
#define HW_DMA_TCD24_SLAST_RD()      (HW_DMA_TCD24_SLAST.U)
#define HW_DMA_TCD24_SLAST_WR(v)     (HW_DMA_TCD24_SLAST.U = (v))
#define HW_DMA_TCD24_SLAST_SET(v)    (HW_DMA_TCD24_SLAST_WR(HW_DMA_TCD24_SLAST_RD() |  (v)))
#define HW_DMA_TCD24_SLAST_CLR(v)    (HW_DMA_TCD24_SLAST_WR(HW_DMA_TCD24_SLAST_RD() & ~(v)))
#define HW_DMA_TCD24_SLAST_TOG(v)    (HW_DMA_TCD24_SLAST_WR(HW_DMA_TCD24_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_SLAST bitfields
 */

/*! @name Register DMA_TCD24_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD24_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD24_SLAST_SLAST.
#define BM_DMA_TCD24_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD24_SLAST_SLAST.
#define BS_DMA_TCD24_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD24_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_SLAST_SLAST field.
#define BR_DMA_TCD24_SLAST_SLAST()   (HW_DMA_TCD24_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD24_SLAST_SLAST.
#define BF_DMA_TCD24_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_SLAST_SLAST), uint32_t) & BM_DMA_TCD24_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD24_SLAST_SLAST(v)   (HW_DMA_TCD24_SLAST_WR((HW_DMA_TCD24_SLAST_RD() & ~BM_DMA_TCD24_SLAST_SLAST) | BF_DMA_TCD24_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd24_daddr
{
    uint32_t U;
    struct _hw_dma_tcd24_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd24_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_DADDR register
 */
//@{
#define HW_DMA_TCD24_DADDR_ADDR      (REGS_DMA_BASE + 0x1310U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_DADDR           (*(__IO hw_dma_tcd24_daddr_t *) HW_DMA_TCD24_DADDR_ADDR)
#define HW_DMA_TCD24_DADDR_RD()      (HW_DMA_TCD24_DADDR.U)
#define HW_DMA_TCD24_DADDR_WR(v)     (HW_DMA_TCD24_DADDR.U = (v))
#define HW_DMA_TCD24_DADDR_SET(v)    (HW_DMA_TCD24_DADDR_WR(HW_DMA_TCD24_DADDR_RD() |  (v)))
#define HW_DMA_TCD24_DADDR_CLR(v)    (HW_DMA_TCD24_DADDR_WR(HW_DMA_TCD24_DADDR_RD() & ~(v)))
#define HW_DMA_TCD24_DADDR_TOG(v)    (HW_DMA_TCD24_DADDR_WR(HW_DMA_TCD24_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_DADDR bitfields
 */

/*! @name Register DMA_TCD24_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD24_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD24_DADDR_DADDR.
#define BM_DMA_TCD24_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD24_DADDR_DADDR.
#define BS_DMA_TCD24_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD24_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_DADDR_DADDR field.
#define BR_DMA_TCD24_DADDR_DADDR()   (HW_DMA_TCD24_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD24_DADDR_DADDR.
#define BF_DMA_TCD24_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_DADDR_DADDR), uint32_t) & BM_DMA_TCD24_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD24_DADDR_DADDR(v)   (HW_DMA_TCD24_DADDR_WR((HW_DMA_TCD24_DADDR_RD() & ~BM_DMA_TCD24_DADDR_DADDR) | BF_DMA_TCD24_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd24_doff
{
    uint16_t U;
    struct _hw_dma_tcd24_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd24_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_DOFF register
 */
//@{
#define HW_DMA_TCD24_DOFF_ADDR      (REGS_DMA_BASE + 0x1314U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_DOFF           (*(__IO hw_dma_tcd24_doff_t *) HW_DMA_TCD24_DOFF_ADDR)
#define HW_DMA_TCD24_DOFF_RD()      (HW_DMA_TCD24_DOFF.U)
#define HW_DMA_TCD24_DOFF_WR(v)     (HW_DMA_TCD24_DOFF.U = (v))
#define HW_DMA_TCD24_DOFF_SET(v)    (HW_DMA_TCD24_DOFF_WR(HW_DMA_TCD24_DOFF_RD() |  (v)))
#define HW_DMA_TCD24_DOFF_CLR(v)    (HW_DMA_TCD24_DOFF_WR(HW_DMA_TCD24_DOFF_RD() & ~(v)))
#define HW_DMA_TCD24_DOFF_TOG(v)    (HW_DMA_TCD24_DOFF_WR(HW_DMA_TCD24_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_DOFF bitfields
 */

/*! @name Register DMA_TCD24_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD24_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD24_DOFF_DOFF.
#define BM_DMA_TCD24_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD24_DOFF_DOFF.
#define BS_DMA_TCD24_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD24_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_DOFF_DOFF field.
#define BR_DMA_TCD24_DOFF_DOFF()   (HW_DMA_TCD24_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD24_DOFF_DOFF.
#define BF_DMA_TCD24_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_DOFF_DOFF), uint16_t) & BM_DMA_TCD24_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD24_DOFF_DOFF(v)   (HW_DMA_TCD24_DOFF_WR((HW_DMA_TCD24_DOFF_RD() & ~BM_DMA_TCD24_DOFF_DOFF) | BF_DMA_TCD24_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd24_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd24_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd24_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD24_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1316U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_CITER_ELINKYES           (*(__IO hw_dma_tcd24_citer_elinkyes_t *) HW_DMA_TCD24_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD24_CITER_ELINKYES_RD()      (HW_DMA_TCD24_CITER_ELINKYES.U)
#define HW_DMA_TCD24_CITER_ELINKYES_WR(v)     (HW_DMA_TCD24_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD24_CITER_ELINKYES_SET(v)    (HW_DMA_TCD24_CITER_ELINKYES_WR(HW_DMA_TCD24_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD24_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD24_CITER_ELINKYES_WR(HW_DMA_TCD24_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD24_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD24_CITER_ELINKYES_WR(HW_DMA_TCD24_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD24_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD24_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD24_CITER_ELINKYES_CITER.
#define BM_DMA_TCD24_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD24_CITER_ELINKYES_CITER.
#define BS_DMA_TCD24_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD24_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD24_CITER_ELINKYES_CITER()   (HW_DMA_TCD24_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD24_CITER_ELINKYES_CITER.
#define BF_DMA_TCD24_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD24_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD24_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD24_CITER_ELINKYES_WR((HW_DMA_TCD24_CITER_ELINKYES_RD() & ~BM_DMA_TCD24_CITER_ELINKYES_CITER) | BF_DMA_TCD24_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD24_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD24_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD24_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD24_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD24_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD24_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD24_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD24_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD24_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD24_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD24_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD24_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD24_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD24_CITER_ELINKYES_WR((HW_DMA_TCD24_CITER_ELINKYES_RD() & ~BM_DMA_TCD24_CITER_ELINKYES_LINKCH) | BF_DMA_TCD24_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD24_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD24_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD24_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD24_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD24_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD24_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD24_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD24_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD24_CITER_ELINKYES_ADDR, BP_DMA_TCD24_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD24_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD24_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD24_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD24_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CITER_ELINKYES_ADDR, BP_DMA_TCD24_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd24_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd24_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd24_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD24_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1316U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_CITER_ELINKNO           (*(__IO hw_dma_tcd24_citer_elinkno_t *) HW_DMA_TCD24_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD24_CITER_ELINKNO_RD()      (HW_DMA_TCD24_CITER_ELINKNO.U)
#define HW_DMA_TCD24_CITER_ELINKNO_WR(v)     (HW_DMA_TCD24_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD24_CITER_ELINKNO_SET(v)    (HW_DMA_TCD24_CITER_ELINKNO_WR(HW_DMA_TCD24_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD24_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD24_CITER_ELINKNO_WR(HW_DMA_TCD24_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD24_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD24_CITER_ELINKNO_WR(HW_DMA_TCD24_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD24_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD24_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD24_CITER_ELINKNO_CITER.
#define BM_DMA_TCD24_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD24_CITER_ELINKNO_CITER.
#define BS_DMA_TCD24_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD24_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD24_CITER_ELINKNO_CITER()   (HW_DMA_TCD24_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD24_CITER_ELINKNO_CITER.
#define BF_DMA_TCD24_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD24_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD24_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD24_CITER_ELINKNO_WR((HW_DMA_TCD24_CITER_ELINKNO_RD() & ~BM_DMA_TCD24_CITER_ELINKNO_CITER) | BF_DMA_TCD24_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD24_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD24_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD24_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD24_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD24_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD24_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD24_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD24_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD24_CITER_ELINKNO_ADDR, BP_DMA_TCD24_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD24_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD24_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD24_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD24_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CITER_ELINKNO_ADDR, BP_DMA_TCD24_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd24_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd24_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd24_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_DLASTSGA register
 */
//@{
#define HW_DMA_TCD24_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1318U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_DLASTSGA           (*(__IO hw_dma_tcd24_dlastsga_t *) HW_DMA_TCD24_DLASTSGA_ADDR)
#define HW_DMA_TCD24_DLASTSGA_RD()      (HW_DMA_TCD24_DLASTSGA.U)
#define HW_DMA_TCD24_DLASTSGA_WR(v)     (HW_DMA_TCD24_DLASTSGA.U = (v))
#define HW_DMA_TCD24_DLASTSGA_SET(v)    (HW_DMA_TCD24_DLASTSGA_WR(HW_DMA_TCD24_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD24_DLASTSGA_CLR(v)    (HW_DMA_TCD24_DLASTSGA_WR(HW_DMA_TCD24_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD24_DLASTSGA_TOG(v)    (HW_DMA_TCD24_DLASTSGA_WR(HW_DMA_TCD24_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD24_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD24_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD24_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD24_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD24_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD24_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD24_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD24_DLASTSGA_DLASTSGA()   (HW_DMA_TCD24_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD24_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD24_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD24_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD24_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD24_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD24_DLASTSGA_WR((HW_DMA_TCD24_DLASTSGA_RD() & ~BM_DMA_TCD24_DLASTSGA_DLASTSGA) | BF_DMA_TCD24_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd24_csr
{
    uint16_t U;
    struct _hw_dma_tcd24_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd24_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_CSR register
 */
//@{
#define HW_DMA_TCD24_CSR_ADDR      (REGS_DMA_BASE + 0x131cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_CSR           (*(__IO hw_dma_tcd24_csr_t *) HW_DMA_TCD24_CSR_ADDR)
#define HW_DMA_TCD24_CSR_RD()      (HW_DMA_TCD24_CSR.U)
#define HW_DMA_TCD24_CSR_WR(v)     (HW_DMA_TCD24_CSR.U = (v))
#define HW_DMA_TCD24_CSR_SET(v)    (HW_DMA_TCD24_CSR_WR(HW_DMA_TCD24_CSR_RD() |  (v)))
#define HW_DMA_TCD24_CSR_CLR(v)    (HW_DMA_TCD24_CSR_WR(HW_DMA_TCD24_CSR_RD() & ~(v)))
#define HW_DMA_TCD24_CSR_TOG(v)    (HW_DMA_TCD24_CSR_WR(HW_DMA_TCD24_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_CSR bitfields
 */

/*! @name Register DMA_TCD24_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD24_CSR_START      (0U)      //!< Bit position for DMA_TCD24_CSR_START.
#define BM_DMA_TCD24_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD24_CSR_START.
#define BS_DMA_TCD24_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD24_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_START field.
#define BR_DMA_TCD24_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_START.
#define BF_DMA_TCD24_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_START), uint16_t) & BM_DMA_TCD24_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD24_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD24_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD24_CSR_INTMAJOR.
#define BM_DMA_TCD24_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD24_CSR_INTMAJOR.
#define BS_DMA_TCD24_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD24_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_INTMAJOR field.
#define BR_DMA_TCD24_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_INTMAJOR.
#define BF_DMA_TCD24_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD24_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD24_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD24_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD24_CSR_INTHALF.
#define BM_DMA_TCD24_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD24_CSR_INTHALF.
#define BS_DMA_TCD24_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD24_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_INTHALF field.
#define BR_DMA_TCD24_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_INTHALF.
#define BF_DMA_TCD24_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_INTHALF), uint16_t) & BM_DMA_TCD24_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD24_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD24_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD24_CSR_DREQ.
#define BM_DMA_TCD24_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD24_CSR_DREQ.
#define BS_DMA_TCD24_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD24_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_DREQ field.
#define BR_DMA_TCD24_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_DREQ.
#define BF_DMA_TCD24_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_DREQ), uint16_t) & BM_DMA_TCD24_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD24_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD24_CSR_ESG      (4U)      //!< Bit position for DMA_TCD24_CSR_ESG.
#define BM_DMA_TCD24_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD24_CSR_ESG.
#define BS_DMA_TCD24_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD24_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_ESG field.
#define BR_DMA_TCD24_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_ESG.
#define BF_DMA_TCD24_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_ESG), uint16_t) & BM_DMA_TCD24_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD24_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD24_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD24_CSR_MAJORELINK.
#define BM_DMA_TCD24_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD24_CSR_MAJORELINK.
#define BS_DMA_TCD24_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD24_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_MAJORELINK field.
#define BR_DMA_TCD24_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_MAJORELINK.
#define BF_DMA_TCD24_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD24_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD24_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD24_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD24_CSR_ACTIVE.
#define BM_DMA_TCD24_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD24_CSR_ACTIVE.
#define BS_DMA_TCD24_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD24_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_ACTIVE field.
#define BR_DMA_TCD24_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_ACTIVE.
#define BF_DMA_TCD24_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_ACTIVE), uint16_t) & BM_DMA_TCD24_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD24_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD24_CSR_DONE      (7U)      //!< Bit position for DMA_TCD24_CSR_DONE.
#define BM_DMA_TCD24_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD24_CSR_DONE.
#define BS_DMA_TCD24_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD24_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_DONE field.
#define BR_DMA_TCD24_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_DONE.
#define BF_DMA_TCD24_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_DONE), uint16_t) & BM_DMA_TCD24_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD24_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_CSR_ADDR, BP_DMA_TCD24_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD24_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD24_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD24_CSR_MAJORLINKCH.
#define BM_DMA_TCD24_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD24_CSR_MAJORLINKCH.
#define BS_DMA_TCD24_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD24_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_MAJORLINKCH field.
#define BR_DMA_TCD24_CSR_MAJORLINKCH()   (HW_DMA_TCD24_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_MAJORLINKCH.
#define BF_DMA_TCD24_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD24_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD24_CSR_MAJORLINKCH(v)   (HW_DMA_TCD24_CSR_WR((HW_DMA_TCD24_CSR_RD() & ~BM_DMA_TCD24_CSR_MAJORLINKCH) | BF_DMA_TCD24_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD24_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD24_CSR_BWC      (14U)      //!< Bit position for DMA_TCD24_CSR_BWC.
#define BM_DMA_TCD24_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD24_CSR_BWC.
#define BS_DMA_TCD24_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD24_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_CSR_BWC field.
#define BR_DMA_TCD24_CSR_BWC()   (HW_DMA_TCD24_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD24_CSR_BWC.
#define BF_DMA_TCD24_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_CSR_BWC), uint16_t) & BM_DMA_TCD24_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD24_CSR_BWC(v)   (HW_DMA_TCD24_CSR_WR((HW_DMA_TCD24_CSR_RD() & ~BM_DMA_TCD24_CSR_BWC) | BF_DMA_TCD24_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd24_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd24_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd24_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD24_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x131eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_BITER_ELINKYES           (*(__IO hw_dma_tcd24_biter_elinkyes_t *) HW_DMA_TCD24_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD24_BITER_ELINKYES_RD()      (HW_DMA_TCD24_BITER_ELINKYES.U)
#define HW_DMA_TCD24_BITER_ELINKYES_WR(v)     (HW_DMA_TCD24_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD24_BITER_ELINKYES_SET(v)    (HW_DMA_TCD24_BITER_ELINKYES_WR(HW_DMA_TCD24_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD24_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD24_BITER_ELINKYES_WR(HW_DMA_TCD24_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD24_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD24_BITER_ELINKYES_WR(HW_DMA_TCD24_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD24_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD24_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD24_BITER_ELINKYES_BITER.
#define BM_DMA_TCD24_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD24_BITER_ELINKYES_BITER.
#define BS_DMA_TCD24_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD24_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD24_BITER_ELINKYES_BITER()   (HW_DMA_TCD24_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD24_BITER_ELINKYES_BITER.
#define BF_DMA_TCD24_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD24_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD24_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD24_BITER_ELINKYES_WR((HW_DMA_TCD24_BITER_ELINKYES_RD() & ~BM_DMA_TCD24_BITER_ELINKYES_BITER) | BF_DMA_TCD24_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD24_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD24_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD24_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD24_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD24_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD24_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD24_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD24_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD24_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD24_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD24_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD24_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD24_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD24_BITER_ELINKYES_WR((HW_DMA_TCD24_BITER_ELINKYES_RD() & ~BM_DMA_TCD24_BITER_ELINKYES_LINKCH) | BF_DMA_TCD24_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD24_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD24_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD24_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD24_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD24_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD24_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD24_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD24_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD24_BITER_ELINKYES_ADDR, BP_DMA_TCD24_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD24_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD24_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD24_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD24_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_BITER_ELINKYES_ADDR, BP_DMA_TCD24_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD24_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD24_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd24_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd24_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd24_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD24_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD24_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x131eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD24_BITER_ELINKNO           (*(__IO hw_dma_tcd24_biter_elinkno_t *) HW_DMA_TCD24_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD24_BITER_ELINKNO_RD()      (HW_DMA_TCD24_BITER_ELINKNO.U)
#define HW_DMA_TCD24_BITER_ELINKNO_WR(v)     (HW_DMA_TCD24_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD24_BITER_ELINKNO_SET(v)    (HW_DMA_TCD24_BITER_ELINKNO_WR(HW_DMA_TCD24_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD24_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD24_BITER_ELINKNO_WR(HW_DMA_TCD24_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD24_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD24_BITER_ELINKNO_WR(HW_DMA_TCD24_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD24_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD24_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD24_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD24_BITER_ELINKNO_BITER.
#define BM_DMA_TCD24_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD24_BITER_ELINKNO_BITER.
#define BS_DMA_TCD24_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD24_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD24_BITER_ELINKNO_BITER()   (HW_DMA_TCD24_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD24_BITER_ELINKNO_BITER.
#define BF_DMA_TCD24_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD24_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD24_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD24_BITER_ELINKNO_WR((HW_DMA_TCD24_BITER_ELINKNO_RD() & ~BM_DMA_TCD24_BITER_ELINKNO_BITER) | BF_DMA_TCD24_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD24_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD24_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD24_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD24_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD24_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD24_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD24_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD24_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD24_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD24_BITER_ELINKNO_ADDR, BP_DMA_TCD24_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD24_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD24_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD24_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD24_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD24_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD24_BITER_ELINKNO_ADDR, BP_DMA_TCD24_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd25_saddr
{
    uint32_t U;
    struct _hw_dma_tcd25_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd25_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_SADDR register
 */
//@{
#define HW_DMA_TCD25_SADDR_ADDR      (REGS_DMA_BASE + 0x1320U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_SADDR           (*(__IO hw_dma_tcd25_saddr_t *) HW_DMA_TCD25_SADDR_ADDR)
#define HW_DMA_TCD25_SADDR_RD()      (HW_DMA_TCD25_SADDR.U)
#define HW_DMA_TCD25_SADDR_WR(v)     (HW_DMA_TCD25_SADDR.U = (v))
#define HW_DMA_TCD25_SADDR_SET(v)    (HW_DMA_TCD25_SADDR_WR(HW_DMA_TCD25_SADDR_RD() |  (v)))
#define HW_DMA_TCD25_SADDR_CLR(v)    (HW_DMA_TCD25_SADDR_WR(HW_DMA_TCD25_SADDR_RD() & ~(v)))
#define HW_DMA_TCD25_SADDR_TOG(v)    (HW_DMA_TCD25_SADDR_WR(HW_DMA_TCD25_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_SADDR bitfields
 */

/*! @name Register DMA_TCD25_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD25_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD25_SADDR_SADDR.
#define BM_DMA_TCD25_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD25_SADDR_SADDR.
#define BS_DMA_TCD25_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD25_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_SADDR_SADDR field.
#define BR_DMA_TCD25_SADDR_SADDR()   (HW_DMA_TCD25_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD25_SADDR_SADDR.
#define BF_DMA_TCD25_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_SADDR_SADDR), uint32_t) & BM_DMA_TCD25_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD25_SADDR_SADDR(v)   (HW_DMA_TCD25_SADDR_WR((HW_DMA_TCD25_SADDR_RD() & ~BM_DMA_TCD25_SADDR_SADDR) | BF_DMA_TCD25_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd25_soff
{
    uint16_t U;
    struct _hw_dma_tcd25_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd25_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_SOFF register
 */
//@{
#define HW_DMA_TCD25_SOFF_ADDR      (REGS_DMA_BASE + 0x1324U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_SOFF           (*(__IO hw_dma_tcd25_soff_t *) HW_DMA_TCD25_SOFF_ADDR)
#define HW_DMA_TCD25_SOFF_RD()      (HW_DMA_TCD25_SOFF.U)
#define HW_DMA_TCD25_SOFF_WR(v)     (HW_DMA_TCD25_SOFF.U = (v))
#define HW_DMA_TCD25_SOFF_SET(v)    (HW_DMA_TCD25_SOFF_WR(HW_DMA_TCD25_SOFF_RD() |  (v)))
#define HW_DMA_TCD25_SOFF_CLR(v)    (HW_DMA_TCD25_SOFF_WR(HW_DMA_TCD25_SOFF_RD() & ~(v)))
#define HW_DMA_TCD25_SOFF_TOG(v)    (HW_DMA_TCD25_SOFF_WR(HW_DMA_TCD25_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_SOFF bitfields
 */

/*! @name Register DMA_TCD25_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD25_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD25_SOFF_SOFF.
#define BM_DMA_TCD25_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD25_SOFF_SOFF.
#define BS_DMA_TCD25_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD25_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_SOFF_SOFF field.
#define BR_DMA_TCD25_SOFF_SOFF()   (HW_DMA_TCD25_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD25_SOFF_SOFF.
#define BF_DMA_TCD25_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_SOFF_SOFF), uint16_t) & BM_DMA_TCD25_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD25_SOFF_SOFF(v)   (HW_DMA_TCD25_SOFF_WR((HW_DMA_TCD25_SOFF_RD() & ~BM_DMA_TCD25_SOFF_SOFF) | BF_DMA_TCD25_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd25_attr
{
    uint16_t U;
    struct _hw_dma_tcd25_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd25_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_ATTR register
 */
//@{
#define HW_DMA_TCD25_ATTR_ADDR      (REGS_DMA_BASE + 0x1326U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_ATTR           (*(__IO hw_dma_tcd25_attr_t *) HW_DMA_TCD25_ATTR_ADDR)
#define HW_DMA_TCD25_ATTR_RD()      (HW_DMA_TCD25_ATTR.U)
#define HW_DMA_TCD25_ATTR_WR(v)     (HW_DMA_TCD25_ATTR.U = (v))
#define HW_DMA_TCD25_ATTR_SET(v)    (HW_DMA_TCD25_ATTR_WR(HW_DMA_TCD25_ATTR_RD() |  (v)))
#define HW_DMA_TCD25_ATTR_CLR(v)    (HW_DMA_TCD25_ATTR_WR(HW_DMA_TCD25_ATTR_RD() & ~(v)))
#define HW_DMA_TCD25_ATTR_TOG(v)    (HW_DMA_TCD25_ATTR_WR(HW_DMA_TCD25_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_ATTR bitfields
 */

/*! @name Register DMA_TCD25_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD25_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD25_ATTR_DSIZE.
#define BM_DMA_TCD25_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD25_ATTR_DSIZE.
#define BS_DMA_TCD25_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD25_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_ATTR_DSIZE field.
#define BR_DMA_TCD25_ATTR_DSIZE()   (HW_DMA_TCD25_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD25_ATTR_DSIZE.
#define BF_DMA_TCD25_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_ATTR_DSIZE), uint16_t) & BM_DMA_TCD25_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD25_ATTR_DSIZE(v)   (HW_DMA_TCD25_ATTR_WR((HW_DMA_TCD25_ATTR_RD() & ~BM_DMA_TCD25_ATTR_DSIZE) | BF_DMA_TCD25_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD25_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD25_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD25_ATTR_DMOD.
#define BM_DMA_TCD25_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD25_ATTR_DMOD.
#define BS_DMA_TCD25_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD25_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_ATTR_DMOD field.
#define BR_DMA_TCD25_ATTR_DMOD()   (HW_DMA_TCD25_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD25_ATTR_DMOD.
#define BF_DMA_TCD25_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_ATTR_DMOD), uint16_t) & BM_DMA_TCD25_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD25_ATTR_DMOD(v)   (HW_DMA_TCD25_ATTR_WR((HW_DMA_TCD25_ATTR_RD() & ~BM_DMA_TCD25_ATTR_DMOD) | BF_DMA_TCD25_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD25_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD25_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD25_ATTR_SSIZE.
#define BM_DMA_TCD25_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD25_ATTR_SSIZE.
#define BS_DMA_TCD25_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD25_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_ATTR_SSIZE field.
#define BR_DMA_TCD25_ATTR_SSIZE()   (HW_DMA_TCD25_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD25_ATTR_SSIZE.
#define BF_DMA_TCD25_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_ATTR_SSIZE), uint16_t) & BM_DMA_TCD25_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD25_ATTR_SSIZE(v)   (HW_DMA_TCD25_ATTR_WR((HW_DMA_TCD25_ATTR_RD() & ~BM_DMA_TCD25_ATTR_SSIZE) | BF_DMA_TCD25_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD25_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD25_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD25_ATTR_SMOD.
#define BM_DMA_TCD25_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD25_ATTR_SMOD.
#define BS_DMA_TCD25_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD25_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_ATTR_SMOD field.
#define BR_DMA_TCD25_ATTR_SMOD()   (HW_DMA_TCD25_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD25_ATTR_SMOD.
#define BF_DMA_TCD25_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_ATTR_SMOD), uint16_t) & BM_DMA_TCD25_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD25_ATTR_SMOD(v)   (HW_DMA_TCD25_ATTR_WR((HW_DMA_TCD25_ATTR_RD() & ~BM_DMA_TCD25_ATTR_SMOD) | BF_DMA_TCD25_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd25_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd25_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd25_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD25_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1328U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_NBYTES_MLNO           (*(__IO hw_dma_tcd25_nbytes_mlno_t *) HW_DMA_TCD25_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD25_NBYTES_MLNO_RD()      (HW_DMA_TCD25_NBYTES_MLNO.U)
#define HW_DMA_TCD25_NBYTES_MLNO_WR(v)     (HW_DMA_TCD25_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD25_NBYTES_MLNO_SET(v)    (HW_DMA_TCD25_NBYTES_MLNO_WR(HW_DMA_TCD25_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD25_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD25_NBYTES_MLNO_WR(HW_DMA_TCD25_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD25_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD25_NBYTES_MLNO_WR(HW_DMA_TCD25_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD25_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD25_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD25_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD25_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD25_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD25_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD25_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD25_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD25_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD25_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD25_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD25_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD25_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD25_NBYTES_MLNO_WR((HW_DMA_TCD25_NBYTES_MLNO_RD() & ~BM_DMA_TCD25_NBYTES_MLNO_NBYTES) | BF_DMA_TCD25_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd25_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd25_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd25_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD25_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1328U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd25_nbytes_mloffno_t *) HW_DMA_TCD25_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD25_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD25_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD25_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD25_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD25_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD25_NBYTES_MLOFFNO_WR(HW_DMA_TCD25_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD25_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD25_NBYTES_MLOFFNO_WR(HW_DMA_TCD25_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD25_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD25_NBYTES_MLOFFNO_WR(HW_DMA_TCD25_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD25_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD25_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD25_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD25_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD25_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD25_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD25_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD25_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD25_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD25_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD25_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD25_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD25_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD25_NBYTES_MLOFFNO_WR((HW_DMA_TCD25_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD25_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD25_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD25_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD25_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD25_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD25_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD25_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD25_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD25_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD25_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD25_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD25_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD25_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD25_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD25_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD25_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD25_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD25_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD25_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD25_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD25_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD25_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD25_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD25_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD25_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD25_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD25_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD25_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD25_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD25_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD25_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD25_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD25_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd25_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd25_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd25_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD25_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1328U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd25_nbytes_mloffyes_t *) HW_DMA_TCD25_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD25_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD25_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD25_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD25_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD25_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD25_NBYTES_MLOFFYES_WR(HW_DMA_TCD25_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD25_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD25_NBYTES_MLOFFYES_WR(HW_DMA_TCD25_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD25_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD25_NBYTES_MLOFFYES_WR(HW_DMA_TCD25_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD25_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD25_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD25_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD25_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD25_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD25_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD25_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD25_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD25_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD25_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD25_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD25_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD25_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD25_NBYTES_MLOFFYES_WR((HW_DMA_TCD25_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD25_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD25_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD25_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD25_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD25_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD25_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD25_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD25_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD25_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD25_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD25_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD25_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD25_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD25_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD25_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD25_NBYTES_MLOFFYES_WR((HW_DMA_TCD25_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD25_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD25_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD25_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD25_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD25_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD25_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD25_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD25_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD25_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD25_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD25_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD25_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD25_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD25_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD25_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD25_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD25_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD25_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD25_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD25_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD25_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD25_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD25_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD25_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD25_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD25_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD25_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD25_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD25_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD25_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD25_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD25_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD25_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd25_slast
{
    uint32_t U;
    struct _hw_dma_tcd25_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd25_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_SLAST register
 */
//@{
#define HW_DMA_TCD25_SLAST_ADDR      (REGS_DMA_BASE + 0x132cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_SLAST           (*(__IO hw_dma_tcd25_slast_t *) HW_DMA_TCD25_SLAST_ADDR)
#define HW_DMA_TCD25_SLAST_RD()      (HW_DMA_TCD25_SLAST.U)
#define HW_DMA_TCD25_SLAST_WR(v)     (HW_DMA_TCD25_SLAST.U = (v))
#define HW_DMA_TCD25_SLAST_SET(v)    (HW_DMA_TCD25_SLAST_WR(HW_DMA_TCD25_SLAST_RD() |  (v)))
#define HW_DMA_TCD25_SLAST_CLR(v)    (HW_DMA_TCD25_SLAST_WR(HW_DMA_TCD25_SLAST_RD() & ~(v)))
#define HW_DMA_TCD25_SLAST_TOG(v)    (HW_DMA_TCD25_SLAST_WR(HW_DMA_TCD25_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_SLAST bitfields
 */

/*! @name Register DMA_TCD25_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD25_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD25_SLAST_SLAST.
#define BM_DMA_TCD25_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD25_SLAST_SLAST.
#define BS_DMA_TCD25_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD25_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_SLAST_SLAST field.
#define BR_DMA_TCD25_SLAST_SLAST()   (HW_DMA_TCD25_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD25_SLAST_SLAST.
#define BF_DMA_TCD25_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_SLAST_SLAST), uint32_t) & BM_DMA_TCD25_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD25_SLAST_SLAST(v)   (HW_DMA_TCD25_SLAST_WR((HW_DMA_TCD25_SLAST_RD() & ~BM_DMA_TCD25_SLAST_SLAST) | BF_DMA_TCD25_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd25_daddr
{
    uint32_t U;
    struct _hw_dma_tcd25_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd25_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_DADDR register
 */
//@{
#define HW_DMA_TCD25_DADDR_ADDR      (REGS_DMA_BASE + 0x1330U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_DADDR           (*(__IO hw_dma_tcd25_daddr_t *) HW_DMA_TCD25_DADDR_ADDR)
#define HW_DMA_TCD25_DADDR_RD()      (HW_DMA_TCD25_DADDR.U)
#define HW_DMA_TCD25_DADDR_WR(v)     (HW_DMA_TCD25_DADDR.U = (v))
#define HW_DMA_TCD25_DADDR_SET(v)    (HW_DMA_TCD25_DADDR_WR(HW_DMA_TCD25_DADDR_RD() |  (v)))
#define HW_DMA_TCD25_DADDR_CLR(v)    (HW_DMA_TCD25_DADDR_WR(HW_DMA_TCD25_DADDR_RD() & ~(v)))
#define HW_DMA_TCD25_DADDR_TOG(v)    (HW_DMA_TCD25_DADDR_WR(HW_DMA_TCD25_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_DADDR bitfields
 */

/*! @name Register DMA_TCD25_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD25_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD25_DADDR_DADDR.
#define BM_DMA_TCD25_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD25_DADDR_DADDR.
#define BS_DMA_TCD25_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD25_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_DADDR_DADDR field.
#define BR_DMA_TCD25_DADDR_DADDR()   (HW_DMA_TCD25_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD25_DADDR_DADDR.
#define BF_DMA_TCD25_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_DADDR_DADDR), uint32_t) & BM_DMA_TCD25_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD25_DADDR_DADDR(v)   (HW_DMA_TCD25_DADDR_WR((HW_DMA_TCD25_DADDR_RD() & ~BM_DMA_TCD25_DADDR_DADDR) | BF_DMA_TCD25_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd25_doff
{
    uint16_t U;
    struct _hw_dma_tcd25_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd25_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_DOFF register
 */
//@{
#define HW_DMA_TCD25_DOFF_ADDR      (REGS_DMA_BASE + 0x1334U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_DOFF           (*(__IO hw_dma_tcd25_doff_t *) HW_DMA_TCD25_DOFF_ADDR)
#define HW_DMA_TCD25_DOFF_RD()      (HW_DMA_TCD25_DOFF.U)
#define HW_DMA_TCD25_DOFF_WR(v)     (HW_DMA_TCD25_DOFF.U = (v))
#define HW_DMA_TCD25_DOFF_SET(v)    (HW_DMA_TCD25_DOFF_WR(HW_DMA_TCD25_DOFF_RD() |  (v)))
#define HW_DMA_TCD25_DOFF_CLR(v)    (HW_DMA_TCD25_DOFF_WR(HW_DMA_TCD25_DOFF_RD() & ~(v)))
#define HW_DMA_TCD25_DOFF_TOG(v)    (HW_DMA_TCD25_DOFF_WR(HW_DMA_TCD25_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_DOFF bitfields
 */

/*! @name Register DMA_TCD25_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD25_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD25_DOFF_DOFF.
#define BM_DMA_TCD25_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD25_DOFF_DOFF.
#define BS_DMA_TCD25_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD25_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_DOFF_DOFF field.
#define BR_DMA_TCD25_DOFF_DOFF()   (HW_DMA_TCD25_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD25_DOFF_DOFF.
#define BF_DMA_TCD25_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_DOFF_DOFF), uint16_t) & BM_DMA_TCD25_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD25_DOFF_DOFF(v)   (HW_DMA_TCD25_DOFF_WR((HW_DMA_TCD25_DOFF_RD() & ~BM_DMA_TCD25_DOFF_DOFF) | BF_DMA_TCD25_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd25_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd25_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd25_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD25_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1336U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_CITER_ELINKYES           (*(__IO hw_dma_tcd25_citer_elinkyes_t *) HW_DMA_TCD25_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD25_CITER_ELINKYES_RD()      (HW_DMA_TCD25_CITER_ELINKYES.U)
#define HW_DMA_TCD25_CITER_ELINKYES_WR(v)     (HW_DMA_TCD25_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD25_CITER_ELINKYES_SET(v)    (HW_DMA_TCD25_CITER_ELINKYES_WR(HW_DMA_TCD25_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD25_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD25_CITER_ELINKYES_WR(HW_DMA_TCD25_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD25_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD25_CITER_ELINKYES_WR(HW_DMA_TCD25_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD25_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD25_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD25_CITER_ELINKYES_CITER.
#define BM_DMA_TCD25_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD25_CITER_ELINKYES_CITER.
#define BS_DMA_TCD25_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD25_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD25_CITER_ELINKYES_CITER()   (HW_DMA_TCD25_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD25_CITER_ELINKYES_CITER.
#define BF_DMA_TCD25_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD25_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD25_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD25_CITER_ELINKYES_WR((HW_DMA_TCD25_CITER_ELINKYES_RD() & ~BM_DMA_TCD25_CITER_ELINKYES_CITER) | BF_DMA_TCD25_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD25_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD25_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD25_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD25_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD25_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD25_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD25_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD25_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD25_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD25_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD25_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD25_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD25_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD25_CITER_ELINKYES_WR((HW_DMA_TCD25_CITER_ELINKYES_RD() & ~BM_DMA_TCD25_CITER_ELINKYES_LINKCH) | BF_DMA_TCD25_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD25_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD25_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD25_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD25_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD25_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD25_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD25_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD25_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD25_CITER_ELINKYES_ADDR, BP_DMA_TCD25_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD25_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD25_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD25_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD25_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CITER_ELINKYES_ADDR, BP_DMA_TCD25_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd25_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd25_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd25_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD25_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1336U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_CITER_ELINKNO           (*(__IO hw_dma_tcd25_citer_elinkno_t *) HW_DMA_TCD25_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD25_CITER_ELINKNO_RD()      (HW_DMA_TCD25_CITER_ELINKNO.U)
#define HW_DMA_TCD25_CITER_ELINKNO_WR(v)     (HW_DMA_TCD25_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD25_CITER_ELINKNO_SET(v)    (HW_DMA_TCD25_CITER_ELINKNO_WR(HW_DMA_TCD25_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD25_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD25_CITER_ELINKNO_WR(HW_DMA_TCD25_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD25_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD25_CITER_ELINKNO_WR(HW_DMA_TCD25_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD25_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD25_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD25_CITER_ELINKNO_CITER.
#define BM_DMA_TCD25_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD25_CITER_ELINKNO_CITER.
#define BS_DMA_TCD25_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD25_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD25_CITER_ELINKNO_CITER()   (HW_DMA_TCD25_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD25_CITER_ELINKNO_CITER.
#define BF_DMA_TCD25_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD25_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD25_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD25_CITER_ELINKNO_WR((HW_DMA_TCD25_CITER_ELINKNO_RD() & ~BM_DMA_TCD25_CITER_ELINKNO_CITER) | BF_DMA_TCD25_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD25_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD25_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD25_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD25_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD25_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD25_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD25_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD25_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD25_CITER_ELINKNO_ADDR, BP_DMA_TCD25_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD25_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD25_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD25_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD25_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CITER_ELINKNO_ADDR, BP_DMA_TCD25_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd25_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd25_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd25_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_DLASTSGA register
 */
//@{
#define HW_DMA_TCD25_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1338U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_DLASTSGA           (*(__IO hw_dma_tcd25_dlastsga_t *) HW_DMA_TCD25_DLASTSGA_ADDR)
#define HW_DMA_TCD25_DLASTSGA_RD()      (HW_DMA_TCD25_DLASTSGA.U)
#define HW_DMA_TCD25_DLASTSGA_WR(v)     (HW_DMA_TCD25_DLASTSGA.U = (v))
#define HW_DMA_TCD25_DLASTSGA_SET(v)    (HW_DMA_TCD25_DLASTSGA_WR(HW_DMA_TCD25_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD25_DLASTSGA_CLR(v)    (HW_DMA_TCD25_DLASTSGA_WR(HW_DMA_TCD25_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD25_DLASTSGA_TOG(v)    (HW_DMA_TCD25_DLASTSGA_WR(HW_DMA_TCD25_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD25_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD25_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD25_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD25_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD25_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD25_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD25_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD25_DLASTSGA_DLASTSGA()   (HW_DMA_TCD25_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD25_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD25_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD25_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD25_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD25_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD25_DLASTSGA_WR((HW_DMA_TCD25_DLASTSGA_RD() & ~BM_DMA_TCD25_DLASTSGA_DLASTSGA) | BF_DMA_TCD25_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd25_csr
{
    uint16_t U;
    struct _hw_dma_tcd25_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd25_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_CSR register
 */
//@{
#define HW_DMA_TCD25_CSR_ADDR      (REGS_DMA_BASE + 0x133cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_CSR           (*(__IO hw_dma_tcd25_csr_t *) HW_DMA_TCD25_CSR_ADDR)
#define HW_DMA_TCD25_CSR_RD()      (HW_DMA_TCD25_CSR.U)
#define HW_DMA_TCD25_CSR_WR(v)     (HW_DMA_TCD25_CSR.U = (v))
#define HW_DMA_TCD25_CSR_SET(v)    (HW_DMA_TCD25_CSR_WR(HW_DMA_TCD25_CSR_RD() |  (v)))
#define HW_DMA_TCD25_CSR_CLR(v)    (HW_DMA_TCD25_CSR_WR(HW_DMA_TCD25_CSR_RD() & ~(v)))
#define HW_DMA_TCD25_CSR_TOG(v)    (HW_DMA_TCD25_CSR_WR(HW_DMA_TCD25_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_CSR bitfields
 */

/*! @name Register DMA_TCD25_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD25_CSR_START      (0U)      //!< Bit position for DMA_TCD25_CSR_START.
#define BM_DMA_TCD25_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD25_CSR_START.
#define BS_DMA_TCD25_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD25_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_START field.
#define BR_DMA_TCD25_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_START.
#define BF_DMA_TCD25_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_START), uint16_t) & BM_DMA_TCD25_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD25_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD25_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD25_CSR_INTMAJOR.
#define BM_DMA_TCD25_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD25_CSR_INTMAJOR.
#define BS_DMA_TCD25_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD25_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_INTMAJOR field.
#define BR_DMA_TCD25_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_INTMAJOR.
#define BF_DMA_TCD25_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD25_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD25_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD25_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD25_CSR_INTHALF.
#define BM_DMA_TCD25_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD25_CSR_INTHALF.
#define BS_DMA_TCD25_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD25_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_INTHALF field.
#define BR_DMA_TCD25_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_INTHALF.
#define BF_DMA_TCD25_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_INTHALF), uint16_t) & BM_DMA_TCD25_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD25_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD25_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD25_CSR_DREQ.
#define BM_DMA_TCD25_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD25_CSR_DREQ.
#define BS_DMA_TCD25_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD25_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_DREQ field.
#define BR_DMA_TCD25_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_DREQ.
#define BF_DMA_TCD25_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_DREQ), uint16_t) & BM_DMA_TCD25_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD25_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD25_CSR_ESG      (4U)      //!< Bit position for DMA_TCD25_CSR_ESG.
#define BM_DMA_TCD25_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD25_CSR_ESG.
#define BS_DMA_TCD25_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD25_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_ESG field.
#define BR_DMA_TCD25_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_ESG.
#define BF_DMA_TCD25_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_ESG), uint16_t) & BM_DMA_TCD25_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD25_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD25_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD25_CSR_MAJORELINK.
#define BM_DMA_TCD25_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD25_CSR_MAJORELINK.
#define BS_DMA_TCD25_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD25_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_MAJORELINK field.
#define BR_DMA_TCD25_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_MAJORELINK.
#define BF_DMA_TCD25_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD25_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD25_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD25_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD25_CSR_ACTIVE.
#define BM_DMA_TCD25_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD25_CSR_ACTIVE.
#define BS_DMA_TCD25_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD25_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_ACTIVE field.
#define BR_DMA_TCD25_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_ACTIVE.
#define BF_DMA_TCD25_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_ACTIVE), uint16_t) & BM_DMA_TCD25_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD25_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD25_CSR_DONE      (7U)      //!< Bit position for DMA_TCD25_CSR_DONE.
#define BM_DMA_TCD25_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD25_CSR_DONE.
#define BS_DMA_TCD25_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD25_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_DONE field.
#define BR_DMA_TCD25_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_DONE.
#define BF_DMA_TCD25_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_DONE), uint16_t) & BM_DMA_TCD25_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD25_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_CSR_ADDR, BP_DMA_TCD25_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD25_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD25_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD25_CSR_MAJORLINKCH.
#define BM_DMA_TCD25_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD25_CSR_MAJORLINKCH.
#define BS_DMA_TCD25_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD25_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_MAJORLINKCH field.
#define BR_DMA_TCD25_CSR_MAJORLINKCH()   (HW_DMA_TCD25_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_MAJORLINKCH.
#define BF_DMA_TCD25_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD25_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD25_CSR_MAJORLINKCH(v)   (HW_DMA_TCD25_CSR_WR((HW_DMA_TCD25_CSR_RD() & ~BM_DMA_TCD25_CSR_MAJORLINKCH) | BF_DMA_TCD25_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD25_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD25_CSR_BWC      (14U)      //!< Bit position for DMA_TCD25_CSR_BWC.
#define BM_DMA_TCD25_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD25_CSR_BWC.
#define BS_DMA_TCD25_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD25_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_CSR_BWC field.
#define BR_DMA_TCD25_CSR_BWC()   (HW_DMA_TCD25_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD25_CSR_BWC.
#define BF_DMA_TCD25_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_CSR_BWC), uint16_t) & BM_DMA_TCD25_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD25_CSR_BWC(v)   (HW_DMA_TCD25_CSR_WR((HW_DMA_TCD25_CSR_RD() & ~BM_DMA_TCD25_CSR_BWC) | BF_DMA_TCD25_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd25_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd25_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd25_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD25_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x133eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_BITER_ELINKYES           (*(__IO hw_dma_tcd25_biter_elinkyes_t *) HW_DMA_TCD25_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD25_BITER_ELINKYES_RD()      (HW_DMA_TCD25_BITER_ELINKYES.U)
#define HW_DMA_TCD25_BITER_ELINKYES_WR(v)     (HW_DMA_TCD25_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD25_BITER_ELINKYES_SET(v)    (HW_DMA_TCD25_BITER_ELINKYES_WR(HW_DMA_TCD25_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD25_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD25_BITER_ELINKYES_WR(HW_DMA_TCD25_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD25_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD25_BITER_ELINKYES_WR(HW_DMA_TCD25_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD25_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD25_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD25_BITER_ELINKYES_BITER.
#define BM_DMA_TCD25_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD25_BITER_ELINKYES_BITER.
#define BS_DMA_TCD25_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD25_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD25_BITER_ELINKYES_BITER()   (HW_DMA_TCD25_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD25_BITER_ELINKYES_BITER.
#define BF_DMA_TCD25_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD25_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD25_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD25_BITER_ELINKYES_WR((HW_DMA_TCD25_BITER_ELINKYES_RD() & ~BM_DMA_TCD25_BITER_ELINKYES_BITER) | BF_DMA_TCD25_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD25_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD25_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD25_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD25_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD25_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD25_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD25_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD25_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD25_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD25_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD25_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD25_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD25_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD25_BITER_ELINKYES_WR((HW_DMA_TCD25_BITER_ELINKYES_RD() & ~BM_DMA_TCD25_BITER_ELINKYES_LINKCH) | BF_DMA_TCD25_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD25_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD25_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD25_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD25_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD25_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD25_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD25_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD25_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD25_BITER_ELINKYES_ADDR, BP_DMA_TCD25_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD25_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD25_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD25_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD25_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_BITER_ELINKYES_ADDR, BP_DMA_TCD25_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD25_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD25_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd25_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd25_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd25_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD25_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD25_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x133eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD25_BITER_ELINKNO           (*(__IO hw_dma_tcd25_biter_elinkno_t *) HW_DMA_TCD25_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD25_BITER_ELINKNO_RD()      (HW_DMA_TCD25_BITER_ELINKNO.U)
#define HW_DMA_TCD25_BITER_ELINKNO_WR(v)     (HW_DMA_TCD25_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD25_BITER_ELINKNO_SET(v)    (HW_DMA_TCD25_BITER_ELINKNO_WR(HW_DMA_TCD25_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD25_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD25_BITER_ELINKNO_WR(HW_DMA_TCD25_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD25_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD25_BITER_ELINKNO_WR(HW_DMA_TCD25_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD25_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD25_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD25_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD25_BITER_ELINKNO_BITER.
#define BM_DMA_TCD25_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD25_BITER_ELINKNO_BITER.
#define BS_DMA_TCD25_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD25_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD25_BITER_ELINKNO_BITER()   (HW_DMA_TCD25_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD25_BITER_ELINKNO_BITER.
#define BF_DMA_TCD25_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD25_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD25_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD25_BITER_ELINKNO_WR((HW_DMA_TCD25_BITER_ELINKNO_RD() & ~BM_DMA_TCD25_BITER_ELINKNO_BITER) | BF_DMA_TCD25_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD25_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD25_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD25_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD25_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD25_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD25_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD25_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD25_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD25_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD25_BITER_ELINKNO_ADDR, BP_DMA_TCD25_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD25_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD25_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD25_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD25_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD25_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD25_BITER_ELINKNO_ADDR, BP_DMA_TCD25_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd26_saddr
{
    uint32_t U;
    struct _hw_dma_tcd26_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd26_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_SADDR register
 */
//@{
#define HW_DMA_TCD26_SADDR_ADDR      (REGS_DMA_BASE + 0x1340U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_SADDR           (*(__IO hw_dma_tcd26_saddr_t *) HW_DMA_TCD26_SADDR_ADDR)
#define HW_DMA_TCD26_SADDR_RD()      (HW_DMA_TCD26_SADDR.U)
#define HW_DMA_TCD26_SADDR_WR(v)     (HW_DMA_TCD26_SADDR.U = (v))
#define HW_DMA_TCD26_SADDR_SET(v)    (HW_DMA_TCD26_SADDR_WR(HW_DMA_TCD26_SADDR_RD() |  (v)))
#define HW_DMA_TCD26_SADDR_CLR(v)    (HW_DMA_TCD26_SADDR_WR(HW_DMA_TCD26_SADDR_RD() & ~(v)))
#define HW_DMA_TCD26_SADDR_TOG(v)    (HW_DMA_TCD26_SADDR_WR(HW_DMA_TCD26_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_SADDR bitfields
 */

/*! @name Register DMA_TCD26_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD26_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD26_SADDR_SADDR.
#define BM_DMA_TCD26_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD26_SADDR_SADDR.
#define BS_DMA_TCD26_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD26_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_SADDR_SADDR field.
#define BR_DMA_TCD26_SADDR_SADDR()   (HW_DMA_TCD26_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD26_SADDR_SADDR.
#define BF_DMA_TCD26_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_SADDR_SADDR), uint32_t) & BM_DMA_TCD26_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD26_SADDR_SADDR(v)   (HW_DMA_TCD26_SADDR_WR((HW_DMA_TCD26_SADDR_RD() & ~BM_DMA_TCD26_SADDR_SADDR) | BF_DMA_TCD26_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd26_soff
{
    uint16_t U;
    struct _hw_dma_tcd26_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd26_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_SOFF register
 */
//@{
#define HW_DMA_TCD26_SOFF_ADDR      (REGS_DMA_BASE + 0x1344U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_SOFF           (*(__IO hw_dma_tcd26_soff_t *) HW_DMA_TCD26_SOFF_ADDR)
#define HW_DMA_TCD26_SOFF_RD()      (HW_DMA_TCD26_SOFF.U)
#define HW_DMA_TCD26_SOFF_WR(v)     (HW_DMA_TCD26_SOFF.U = (v))
#define HW_DMA_TCD26_SOFF_SET(v)    (HW_DMA_TCD26_SOFF_WR(HW_DMA_TCD26_SOFF_RD() |  (v)))
#define HW_DMA_TCD26_SOFF_CLR(v)    (HW_DMA_TCD26_SOFF_WR(HW_DMA_TCD26_SOFF_RD() & ~(v)))
#define HW_DMA_TCD26_SOFF_TOG(v)    (HW_DMA_TCD26_SOFF_WR(HW_DMA_TCD26_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_SOFF bitfields
 */

/*! @name Register DMA_TCD26_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD26_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD26_SOFF_SOFF.
#define BM_DMA_TCD26_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD26_SOFF_SOFF.
#define BS_DMA_TCD26_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD26_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_SOFF_SOFF field.
#define BR_DMA_TCD26_SOFF_SOFF()   (HW_DMA_TCD26_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD26_SOFF_SOFF.
#define BF_DMA_TCD26_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_SOFF_SOFF), uint16_t) & BM_DMA_TCD26_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD26_SOFF_SOFF(v)   (HW_DMA_TCD26_SOFF_WR((HW_DMA_TCD26_SOFF_RD() & ~BM_DMA_TCD26_SOFF_SOFF) | BF_DMA_TCD26_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd26_attr
{
    uint16_t U;
    struct _hw_dma_tcd26_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd26_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_ATTR register
 */
//@{
#define HW_DMA_TCD26_ATTR_ADDR      (REGS_DMA_BASE + 0x1346U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_ATTR           (*(__IO hw_dma_tcd26_attr_t *) HW_DMA_TCD26_ATTR_ADDR)
#define HW_DMA_TCD26_ATTR_RD()      (HW_DMA_TCD26_ATTR.U)
#define HW_DMA_TCD26_ATTR_WR(v)     (HW_DMA_TCD26_ATTR.U = (v))
#define HW_DMA_TCD26_ATTR_SET(v)    (HW_DMA_TCD26_ATTR_WR(HW_DMA_TCD26_ATTR_RD() |  (v)))
#define HW_DMA_TCD26_ATTR_CLR(v)    (HW_DMA_TCD26_ATTR_WR(HW_DMA_TCD26_ATTR_RD() & ~(v)))
#define HW_DMA_TCD26_ATTR_TOG(v)    (HW_DMA_TCD26_ATTR_WR(HW_DMA_TCD26_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_ATTR bitfields
 */

/*! @name Register DMA_TCD26_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD26_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD26_ATTR_DSIZE.
#define BM_DMA_TCD26_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD26_ATTR_DSIZE.
#define BS_DMA_TCD26_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD26_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_ATTR_DSIZE field.
#define BR_DMA_TCD26_ATTR_DSIZE()   (HW_DMA_TCD26_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD26_ATTR_DSIZE.
#define BF_DMA_TCD26_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_ATTR_DSIZE), uint16_t) & BM_DMA_TCD26_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD26_ATTR_DSIZE(v)   (HW_DMA_TCD26_ATTR_WR((HW_DMA_TCD26_ATTR_RD() & ~BM_DMA_TCD26_ATTR_DSIZE) | BF_DMA_TCD26_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD26_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD26_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD26_ATTR_DMOD.
#define BM_DMA_TCD26_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD26_ATTR_DMOD.
#define BS_DMA_TCD26_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD26_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_ATTR_DMOD field.
#define BR_DMA_TCD26_ATTR_DMOD()   (HW_DMA_TCD26_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD26_ATTR_DMOD.
#define BF_DMA_TCD26_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_ATTR_DMOD), uint16_t) & BM_DMA_TCD26_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD26_ATTR_DMOD(v)   (HW_DMA_TCD26_ATTR_WR((HW_DMA_TCD26_ATTR_RD() & ~BM_DMA_TCD26_ATTR_DMOD) | BF_DMA_TCD26_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD26_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD26_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD26_ATTR_SSIZE.
#define BM_DMA_TCD26_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD26_ATTR_SSIZE.
#define BS_DMA_TCD26_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD26_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_ATTR_SSIZE field.
#define BR_DMA_TCD26_ATTR_SSIZE()   (HW_DMA_TCD26_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD26_ATTR_SSIZE.
#define BF_DMA_TCD26_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_ATTR_SSIZE), uint16_t) & BM_DMA_TCD26_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD26_ATTR_SSIZE(v)   (HW_DMA_TCD26_ATTR_WR((HW_DMA_TCD26_ATTR_RD() & ~BM_DMA_TCD26_ATTR_SSIZE) | BF_DMA_TCD26_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD26_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD26_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD26_ATTR_SMOD.
#define BM_DMA_TCD26_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD26_ATTR_SMOD.
#define BS_DMA_TCD26_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD26_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_ATTR_SMOD field.
#define BR_DMA_TCD26_ATTR_SMOD()   (HW_DMA_TCD26_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD26_ATTR_SMOD.
#define BF_DMA_TCD26_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_ATTR_SMOD), uint16_t) & BM_DMA_TCD26_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD26_ATTR_SMOD(v)   (HW_DMA_TCD26_ATTR_WR((HW_DMA_TCD26_ATTR_RD() & ~BM_DMA_TCD26_ATTR_SMOD) | BF_DMA_TCD26_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd26_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd26_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd26_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD26_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1348U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_NBYTES_MLNO           (*(__IO hw_dma_tcd26_nbytes_mlno_t *) HW_DMA_TCD26_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD26_NBYTES_MLNO_RD()      (HW_DMA_TCD26_NBYTES_MLNO.U)
#define HW_DMA_TCD26_NBYTES_MLNO_WR(v)     (HW_DMA_TCD26_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD26_NBYTES_MLNO_SET(v)    (HW_DMA_TCD26_NBYTES_MLNO_WR(HW_DMA_TCD26_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD26_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD26_NBYTES_MLNO_WR(HW_DMA_TCD26_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD26_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD26_NBYTES_MLNO_WR(HW_DMA_TCD26_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD26_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD26_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD26_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD26_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD26_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD26_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD26_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD26_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD26_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD26_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD26_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD26_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD26_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD26_NBYTES_MLNO_WR((HW_DMA_TCD26_NBYTES_MLNO_RD() & ~BM_DMA_TCD26_NBYTES_MLNO_NBYTES) | BF_DMA_TCD26_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd26_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd26_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd26_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD26_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1348U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd26_nbytes_mloffno_t *) HW_DMA_TCD26_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD26_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD26_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD26_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD26_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD26_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD26_NBYTES_MLOFFNO_WR(HW_DMA_TCD26_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD26_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD26_NBYTES_MLOFFNO_WR(HW_DMA_TCD26_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD26_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD26_NBYTES_MLOFFNO_WR(HW_DMA_TCD26_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD26_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD26_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD26_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD26_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD26_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD26_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD26_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD26_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD26_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD26_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD26_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD26_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD26_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD26_NBYTES_MLOFFNO_WR((HW_DMA_TCD26_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD26_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD26_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD26_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD26_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD26_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD26_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD26_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD26_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD26_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD26_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD26_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD26_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD26_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD26_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD26_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD26_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD26_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD26_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD26_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD26_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD26_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD26_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD26_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD26_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD26_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD26_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD26_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD26_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD26_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD26_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD26_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD26_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD26_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd26_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd26_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd26_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD26_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1348U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd26_nbytes_mloffyes_t *) HW_DMA_TCD26_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD26_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD26_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD26_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD26_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD26_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD26_NBYTES_MLOFFYES_WR(HW_DMA_TCD26_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD26_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD26_NBYTES_MLOFFYES_WR(HW_DMA_TCD26_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD26_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD26_NBYTES_MLOFFYES_WR(HW_DMA_TCD26_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD26_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD26_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD26_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD26_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD26_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD26_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD26_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD26_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD26_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD26_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD26_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD26_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD26_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD26_NBYTES_MLOFFYES_WR((HW_DMA_TCD26_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD26_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD26_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD26_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD26_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD26_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD26_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD26_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD26_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD26_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD26_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD26_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD26_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD26_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD26_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD26_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD26_NBYTES_MLOFFYES_WR((HW_DMA_TCD26_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD26_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD26_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD26_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD26_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD26_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD26_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD26_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD26_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD26_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD26_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD26_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD26_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD26_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD26_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD26_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD26_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD26_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD26_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD26_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD26_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD26_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD26_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD26_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD26_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD26_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD26_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD26_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD26_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD26_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD26_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD26_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD26_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD26_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd26_slast
{
    uint32_t U;
    struct _hw_dma_tcd26_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd26_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_SLAST register
 */
//@{
#define HW_DMA_TCD26_SLAST_ADDR      (REGS_DMA_BASE + 0x134cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_SLAST           (*(__IO hw_dma_tcd26_slast_t *) HW_DMA_TCD26_SLAST_ADDR)
#define HW_DMA_TCD26_SLAST_RD()      (HW_DMA_TCD26_SLAST.U)
#define HW_DMA_TCD26_SLAST_WR(v)     (HW_DMA_TCD26_SLAST.U = (v))
#define HW_DMA_TCD26_SLAST_SET(v)    (HW_DMA_TCD26_SLAST_WR(HW_DMA_TCD26_SLAST_RD() |  (v)))
#define HW_DMA_TCD26_SLAST_CLR(v)    (HW_DMA_TCD26_SLAST_WR(HW_DMA_TCD26_SLAST_RD() & ~(v)))
#define HW_DMA_TCD26_SLAST_TOG(v)    (HW_DMA_TCD26_SLAST_WR(HW_DMA_TCD26_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_SLAST bitfields
 */

/*! @name Register DMA_TCD26_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD26_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD26_SLAST_SLAST.
#define BM_DMA_TCD26_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD26_SLAST_SLAST.
#define BS_DMA_TCD26_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD26_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_SLAST_SLAST field.
#define BR_DMA_TCD26_SLAST_SLAST()   (HW_DMA_TCD26_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD26_SLAST_SLAST.
#define BF_DMA_TCD26_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_SLAST_SLAST), uint32_t) & BM_DMA_TCD26_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD26_SLAST_SLAST(v)   (HW_DMA_TCD26_SLAST_WR((HW_DMA_TCD26_SLAST_RD() & ~BM_DMA_TCD26_SLAST_SLAST) | BF_DMA_TCD26_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd26_daddr
{
    uint32_t U;
    struct _hw_dma_tcd26_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd26_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_DADDR register
 */
//@{
#define HW_DMA_TCD26_DADDR_ADDR      (REGS_DMA_BASE + 0x1350U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_DADDR           (*(__IO hw_dma_tcd26_daddr_t *) HW_DMA_TCD26_DADDR_ADDR)
#define HW_DMA_TCD26_DADDR_RD()      (HW_DMA_TCD26_DADDR.U)
#define HW_DMA_TCD26_DADDR_WR(v)     (HW_DMA_TCD26_DADDR.U = (v))
#define HW_DMA_TCD26_DADDR_SET(v)    (HW_DMA_TCD26_DADDR_WR(HW_DMA_TCD26_DADDR_RD() |  (v)))
#define HW_DMA_TCD26_DADDR_CLR(v)    (HW_DMA_TCD26_DADDR_WR(HW_DMA_TCD26_DADDR_RD() & ~(v)))
#define HW_DMA_TCD26_DADDR_TOG(v)    (HW_DMA_TCD26_DADDR_WR(HW_DMA_TCD26_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_DADDR bitfields
 */

/*! @name Register DMA_TCD26_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD26_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD26_DADDR_DADDR.
#define BM_DMA_TCD26_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD26_DADDR_DADDR.
#define BS_DMA_TCD26_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD26_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_DADDR_DADDR field.
#define BR_DMA_TCD26_DADDR_DADDR()   (HW_DMA_TCD26_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD26_DADDR_DADDR.
#define BF_DMA_TCD26_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_DADDR_DADDR), uint32_t) & BM_DMA_TCD26_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD26_DADDR_DADDR(v)   (HW_DMA_TCD26_DADDR_WR((HW_DMA_TCD26_DADDR_RD() & ~BM_DMA_TCD26_DADDR_DADDR) | BF_DMA_TCD26_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd26_doff
{
    uint16_t U;
    struct _hw_dma_tcd26_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd26_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_DOFF register
 */
//@{
#define HW_DMA_TCD26_DOFF_ADDR      (REGS_DMA_BASE + 0x1354U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_DOFF           (*(__IO hw_dma_tcd26_doff_t *) HW_DMA_TCD26_DOFF_ADDR)
#define HW_DMA_TCD26_DOFF_RD()      (HW_DMA_TCD26_DOFF.U)
#define HW_DMA_TCD26_DOFF_WR(v)     (HW_DMA_TCD26_DOFF.U = (v))
#define HW_DMA_TCD26_DOFF_SET(v)    (HW_DMA_TCD26_DOFF_WR(HW_DMA_TCD26_DOFF_RD() |  (v)))
#define HW_DMA_TCD26_DOFF_CLR(v)    (HW_DMA_TCD26_DOFF_WR(HW_DMA_TCD26_DOFF_RD() & ~(v)))
#define HW_DMA_TCD26_DOFF_TOG(v)    (HW_DMA_TCD26_DOFF_WR(HW_DMA_TCD26_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_DOFF bitfields
 */

/*! @name Register DMA_TCD26_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD26_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD26_DOFF_DOFF.
#define BM_DMA_TCD26_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD26_DOFF_DOFF.
#define BS_DMA_TCD26_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD26_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_DOFF_DOFF field.
#define BR_DMA_TCD26_DOFF_DOFF()   (HW_DMA_TCD26_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD26_DOFF_DOFF.
#define BF_DMA_TCD26_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_DOFF_DOFF), uint16_t) & BM_DMA_TCD26_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD26_DOFF_DOFF(v)   (HW_DMA_TCD26_DOFF_WR((HW_DMA_TCD26_DOFF_RD() & ~BM_DMA_TCD26_DOFF_DOFF) | BF_DMA_TCD26_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd26_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd26_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd26_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD26_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1356U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_CITER_ELINKYES           (*(__IO hw_dma_tcd26_citer_elinkyes_t *) HW_DMA_TCD26_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD26_CITER_ELINKYES_RD()      (HW_DMA_TCD26_CITER_ELINKYES.U)
#define HW_DMA_TCD26_CITER_ELINKYES_WR(v)     (HW_DMA_TCD26_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD26_CITER_ELINKYES_SET(v)    (HW_DMA_TCD26_CITER_ELINKYES_WR(HW_DMA_TCD26_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD26_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD26_CITER_ELINKYES_WR(HW_DMA_TCD26_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD26_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD26_CITER_ELINKYES_WR(HW_DMA_TCD26_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD26_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD26_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD26_CITER_ELINKYES_CITER.
#define BM_DMA_TCD26_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD26_CITER_ELINKYES_CITER.
#define BS_DMA_TCD26_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD26_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD26_CITER_ELINKYES_CITER()   (HW_DMA_TCD26_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD26_CITER_ELINKYES_CITER.
#define BF_DMA_TCD26_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD26_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD26_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD26_CITER_ELINKYES_WR((HW_DMA_TCD26_CITER_ELINKYES_RD() & ~BM_DMA_TCD26_CITER_ELINKYES_CITER) | BF_DMA_TCD26_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD26_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD26_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD26_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD26_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD26_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD26_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD26_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD26_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD26_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD26_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD26_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD26_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD26_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD26_CITER_ELINKYES_WR((HW_DMA_TCD26_CITER_ELINKYES_RD() & ~BM_DMA_TCD26_CITER_ELINKYES_LINKCH) | BF_DMA_TCD26_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD26_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD26_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD26_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD26_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD26_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD26_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD26_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD26_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD26_CITER_ELINKYES_ADDR, BP_DMA_TCD26_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD26_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD26_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD26_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD26_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CITER_ELINKYES_ADDR, BP_DMA_TCD26_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd26_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd26_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd26_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD26_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1356U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_CITER_ELINKNO           (*(__IO hw_dma_tcd26_citer_elinkno_t *) HW_DMA_TCD26_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD26_CITER_ELINKNO_RD()      (HW_DMA_TCD26_CITER_ELINKNO.U)
#define HW_DMA_TCD26_CITER_ELINKNO_WR(v)     (HW_DMA_TCD26_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD26_CITER_ELINKNO_SET(v)    (HW_DMA_TCD26_CITER_ELINKNO_WR(HW_DMA_TCD26_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD26_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD26_CITER_ELINKNO_WR(HW_DMA_TCD26_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD26_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD26_CITER_ELINKNO_WR(HW_DMA_TCD26_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD26_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD26_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD26_CITER_ELINKNO_CITER.
#define BM_DMA_TCD26_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD26_CITER_ELINKNO_CITER.
#define BS_DMA_TCD26_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD26_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD26_CITER_ELINKNO_CITER()   (HW_DMA_TCD26_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD26_CITER_ELINKNO_CITER.
#define BF_DMA_TCD26_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD26_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD26_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD26_CITER_ELINKNO_WR((HW_DMA_TCD26_CITER_ELINKNO_RD() & ~BM_DMA_TCD26_CITER_ELINKNO_CITER) | BF_DMA_TCD26_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD26_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD26_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD26_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD26_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD26_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD26_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD26_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD26_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD26_CITER_ELINKNO_ADDR, BP_DMA_TCD26_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD26_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD26_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD26_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD26_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CITER_ELINKNO_ADDR, BP_DMA_TCD26_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd26_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd26_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd26_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_DLASTSGA register
 */
//@{
#define HW_DMA_TCD26_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1358U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_DLASTSGA           (*(__IO hw_dma_tcd26_dlastsga_t *) HW_DMA_TCD26_DLASTSGA_ADDR)
#define HW_DMA_TCD26_DLASTSGA_RD()      (HW_DMA_TCD26_DLASTSGA.U)
#define HW_DMA_TCD26_DLASTSGA_WR(v)     (HW_DMA_TCD26_DLASTSGA.U = (v))
#define HW_DMA_TCD26_DLASTSGA_SET(v)    (HW_DMA_TCD26_DLASTSGA_WR(HW_DMA_TCD26_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD26_DLASTSGA_CLR(v)    (HW_DMA_TCD26_DLASTSGA_WR(HW_DMA_TCD26_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD26_DLASTSGA_TOG(v)    (HW_DMA_TCD26_DLASTSGA_WR(HW_DMA_TCD26_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD26_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD26_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD26_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD26_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD26_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD26_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD26_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD26_DLASTSGA_DLASTSGA()   (HW_DMA_TCD26_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD26_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD26_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD26_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD26_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD26_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD26_DLASTSGA_WR((HW_DMA_TCD26_DLASTSGA_RD() & ~BM_DMA_TCD26_DLASTSGA_DLASTSGA) | BF_DMA_TCD26_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd26_csr
{
    uint16_t U;
    struct _hw_dma_tcd26_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd26_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_CSR register
 */
//@{
#define HW_DMA_TCD26_CSR_ADDR      (REGS_DMA_BASE + 0x135cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_CSR           (*(__IO hw_dma_tcd26_csr_t *) HW_DMA_TCD26_CSR_ADDR)
#define HW_DMA_TCD26_CSR_RD()      (HW_DMA_TCD26_CSR.U)
#define HW_DMA_TCD26_CSR_WR(v)     (HW_DMA_TCD26_CSR.U = (v))
#define HW_DMA_TCD26_CSR_SET(v)    (HW_DMA_TCD26_CSR_WR(HW_DMA_TCD26_CSR_RD() |  (v)))
#define HW_DMA_TCD26_CSR_CLR(v)    (HW_DMA_TCD26_CSR_WR(HW_DMA_TCD26_CSR_RD() & ~(v)))
#define HW_DMA_TCD26_CSR_TOG(v)    (HW_DMA_TCD26_CSR_WR(HW_DMA_TCD26_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_CSR bitfields
 */

/*! @name Register DMA_TCD26_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD26_CSR_START      (0U)      //!< Bit position for DMA_TCD26_CSR_START.
#define BM_DMA_TCD26_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD26_CSR_START.
#define BS_DMA_TCD26_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD26_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_START field.
#define BR_DMA_TCD26_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_START.
#define BF_DMA_TCD26_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_START), uint16_t) & BM_DMA_TCD26_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD26_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD26_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD26_CSR_INTMAJOR.
#define BM_DMA_TCD26_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD26_CSR_INTMAJOR.
#define BS_DMA_TCD26_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD26_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_INTMAJOR field.
#define BR_DMA_TCD26_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_INTMAJOR.
#define BF_DMA_TCD26_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD26_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD26_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD26_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD26_CSR_INTHALF.
#define BM_DMA_TCD26_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD26_CSR_INTHALF.
#define BS_DMA_TCD26_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD26_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_INTHALF field.
#define BR_DMA_TCD26_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_INTHALF.
#define BF_DMA_TCD26_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_INTHALF), uint16_t) & BM_DMA_TCD26_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD26_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD26_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD26_CSR_DREQ.
#define BM_DMA_TCD26_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD26_CSR_DREQ.
#define BS_DMA_TCD26_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD26_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_DREQ field.
#define BR_DMA_TCD26_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_DREQ.
#define BF_DMA_TCD26_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_DREQ), uint16_t) & BM_DMA_TCD26_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD26_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD26_CSR_ESG      (4U)      //!< Bit position for DMA_TCD26_CSR_ESG.
#define BM_DMA_TCD26_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD26_CSR_ESG.
#define BS_DMA_TCD26_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD26_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_ESG field.
#define BR_DMA_TCD26_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_ESG.
#define BF_DMA_TCD26_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_ESG), uint16_t) & BM_DMA_TCD26_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD26_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD26_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD26_CSR_MAJORELINK.
#define BM_DMA_TCD26_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD26_CSR_MAJORELINK.
#define BS_DMA_TCD26_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD26_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_MAJORELINK field.
#define BR_DMA_TCD26_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_MAJORELINK.
#define BF_DMA_TCD26_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD26_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD26_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD26_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD26_CSR_ACTIVE.
#define BM_DMA_TCD26_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD26_CSR_ACTIVE.
#define BS_DMA_TCD26_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD26_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_ACTIVE field.
#define BR_DMA_TCD26_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_ACTIVE.
#define BF_DMA_TCD26_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_ACTIVE), uint16_t) & BM_DMA_TCD26_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD26_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD26_CSR_DONE      (7U)      //!< Bit position for DMA_TCD26_CSR_DONE.
#define BM_DMA_TCD26_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD26_CSR_DONE.
#define BS_DMA_TCD26_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD26_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_DONE field.
#define BR_DMA_TCD26_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_DONE.
#define BF_DMA_TCD26_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_DONE), uint16_t) & BM_DMA_TCD26_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD26_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_CSR_ADDR, BP_DMA_TCD26_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD26_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD26_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD26_CSR_MAJORLINKCH.
#define BM_DMA_TCD26_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD26_CSR_MAJORLINKCH.
#define BS_DMA_TCD26_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD26_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_MAJORLINKCH field.
#define BR_DMA_TCD26_CSR_MAJORLINKCH()   (HW_DMA_TCD26_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_MAJORLINKCH.
#define BF_DMA_TCD26_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD26_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD26_CSR_MAJORLINKCH(v)   (HW_DMA_TCD26_CSR_WR((HW_DMA_TCD26_CSR_RD() & ~BM_DMA_TCD26_CSR_MAJORLINKCH) | BF_DMA_TCD26_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD26_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD26_CSR_BWC      (14U)      //!< Bit position for DMA_TCD26_CSR_BWC.
#define BM_DMA_TCD26_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD26_CSR_BWC.
#define BS_DMA_TCD26_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD26_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_CSR_BWC field.
#define BR_DMA_TCD26_CSR_BWC()   (HW_DMA_TCD26_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD26_CSR_BWC.
#define BF_DMA_TCD26_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_CSR_BWC), uint16_t) & BM_DMA_TCD26_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD26_CSR_BWC(v)   (HW_DMA_TCD26_CSR_WR((HW_DMA_TCD26_CSR_RD() & ~BM_DMA_TCD26_CSR_BWC) | BF_DMA_TCD26_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd26_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd26_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd26_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD26_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x135eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_BITER_ELINKYES           (*(__IO hw_dma_tcd26_biter_elinkyes_t *) HW_DMA_TCD26_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD26_BITER_ELINKYES_RD()      (HW_DMA_TCD26_BITER_ELINKYES.U)
#define HW_DMA_TCD26_BITER_ELINKYES_WR(v)     (HW_DMA_TCD26_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD26_BITER_ELINKYES_SET(v)    (HW_DMA_TCD26_BITER_ELINKYES_WR(HW_DMA_TCD26_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD26_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD26_BITER_ELINKYES_WR(HW_DMA_TCD26_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD26_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD26_BITER_ELINKYES_WR(HW_DMA_TCD26_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD26_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD26_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD26_BITER_ELINKYES_BITER.
#define BM_DMA_TCD26_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD26_BITER_ELINKYES_BITER.
#define BS_DMA_TCD26_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD26_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD26_BITER_ELINKYES_BITER()   (HW_DMA_TCD26_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD26_BITER_ELINKYES_BITER.
#define BF_DMA_TCD26_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD26_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD26_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD26_BITER_ELINKYES_WR((HW_DMA_TCD26_BITER_ELINKYES_RD() & ~BM_DMA_TCD26_BITER_ELINKYES_BITER) | BF_DMA_TCD26_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD26_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD26_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD26_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD26_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD26_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD26_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD26_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD26_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD26_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD26_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD26_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD26_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD26_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD26_BITER_ELINKYES_WR((HW_DMA_TCD26_BITER_ELINKYES_RD() & ~BM_DMA_TCD26_BITER_ELINKYES_LINKCH) | BF_DMA_TCD26_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD26_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD26_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD26_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD26_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD26_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD26_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD26_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD26_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD26_BITER_ELINKYES_ADDR, BP_DMA_TCD26_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD26_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD26_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD26_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD26_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_BITER_ELINKYES_ADDR, BP_DMA_TCD26_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD26_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD26_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd26_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd26_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd26_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD26_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD26_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x135eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD26_BITER_ELINKNO           (*(__IO hw_dma_tcd26_biter_elinkno_t *) HW_DMA_TCD26_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD26_BITER_ELINKNO_RD()      (HW_DMA_TCD26_BITER_ELINKNO.U)
#define HW_DMA_TCD26_BITER_ELINKNO_WR(v)     (HW_DMA_TCD26_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD26_BITER_ELINKNO_SET(v)    (HW_DMA_TCD26_BITER_ELINKNO_WR(HW_DMA_TCD26_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD26_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD26_BITER_ELINKNO_WR(HW_DMA_TCD26_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD26_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD26_BITER_ELINKNO_WR(HW_DMA_TCD26_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD26_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD26_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD26_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD26_BITER_ELINKNO_BITER.
#define BM_DMA_TCD26_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD26_BITER_ELINKNO_BITER.
#define BS_DMA_TCD26_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD26_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD26_BITER_ELINKNO_BITER()   (HW_DMA_TCD26_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD26_BITER_ELINKNO_BITER.
#define BF_DMA_TCD26_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD26_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD26_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD26_BITER_ELINKNO_WR((HW_DMA_TCD26_BITER_ELINKNO_RD() & ~BM_DMA_TCD26_BITER_ELINKNO_BITER) | BF_DMA_TCD26_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD26_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD26_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD26_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD26_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD26_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD26_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD26_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD26_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD26_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD26_BITER_ELINKNO_ADDR, BP_DMA_TCD26_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD26_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD26_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD26_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD26_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD26_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD26_BITER_ELINKNO_ADDR, BP_DMA_TCD26_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd27_saddr
{
    uint32_t U;
    struct _hw_dma_tcd27_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd27_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_SADDR register
 */
//@{
#define HW_DMA_TCD27_SADDR_ADDR      (REGS_DMA_BASE + 0x1360U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_SADDR           (*(__IO hw_dma_tcd27_saddr_t *) HW_DMA_TCD27_SADDR_ADDR)
#define HW_DMA_TCD27_SADDR_RD()      (HW_DMA_TCD27_SADDR.U)
#define HW_DMA_TCD27_SADDR_WR(v)     (HW_DMA_TCD27_SADDR.U = (v))
#define HW_DMA_TCD27_SADDR_SET(v)    (HW_DMA_TCD27_SADDR_WR(HW_DMA_TCD27_SADDR_RD() |  (v)))
#define HW_DMA_TCD27_SADDR_CLR(v)    (HW_DMA_TCD27_SADDR_WR(HW_DMA_TCD27_SADDR_RD() & ~(v)))
#define HW_DMA_TCD27_SADDR_TOG(v)    (HW_DMA_TCD27_SADDR_WR(HW_DMA_TCD27_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_SADDR bitfields
 */

/*! @name Register DMA_TCD27_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD27_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD27_SADDR_SADDR.
#define BM_DMA_TCD27_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD27_SADDR_SADDR.
#define BS_DMA_TCD27_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD27_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_SADDR_SADDR field.
#define BR_DMA_TCD27_SADDR_SADDR()   (HW_DMA_TCD27_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD27_SADDR_SADDR.
#define BF_DMA_TCD27_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_SADDR_SADDR), uint32_t) & BM_DMA_TCD27_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD27_SADDR_SADDR(v)   (HW_DMA_TCD27_SADDR_WR((HW_DMA_TCD27_SADDR_RD() & ~BM_DMA_TCD27_SADDR_SADDR) | BF_DMA_TCD27_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd27_soff
{
    uint16_t U;
    struct _hw_dma_tcd27_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd27_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_SOFF register
 */
//@{
#define HW_DMA_TCD27_SOFF_ADDR      (REGS_DMA_BASE + 0x1364U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_SOFF           (*(__IO hw_dma_tcd27_soff_t *) HW_DMA_TCD27_SOFF_ADDR)
#define HW_DMA_TCD27_SOFF_RD()      (HW_DMA_TCD27_SOFF.U)
#define HW_DMA_TCD27_SOFF_WR(v)     (HW_DMA_TCD27_SOFF.U = (v))
#define HW_DMA_TCD27_SOFF_SET(v)    (HW_DMA_TCD27_SOFF_WR(HW_DMA_TCD27_SOFF_RD() |  (v)))
#define HW_DMA_TCD27_SOFF_CLR(v)    (HW_DMA_TCD27_SOFF_WR(HW_DMA_TCD27_SOFF_RD() & ~(v)))
#define HW_DMA_TCD27_SOFF_TOG(v)    (HW_DMA_TCD27_SOFF_WR(HW_DMA_TCD27_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_SOFF bitfields
 */

/*! @name Register DMA_TCD27_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD27_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD27_SOFF_SOFF.
#define BM_DMA_TCD27_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD27_SOFF_SOFF.
#define BS_DMA_TCD27_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD27_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_SOFF_SOFF field.
#define BR_DMA_TCD27_SOFF_SOFF()   (HW_DMA_TCD27_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD27_SOFF_SOFF.
#define BF_DMA_TCD27_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_SOFF_SOFF), uint16_t) & BM_DMA_TCD27_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD27_SOFF_SOFF(v)   (HW_DMA_TCD27_SOFF_WR((HW_DMA_TCD27_SOFF_RD() & ~BM_DMA_TCD27_SOFF_SOFF) | BF_DMA_TCD27_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd27_attr
{
    uint16_t U;
    struct _hw_dma_tcd27_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd27_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_ATTR register
 */
//@{
#define HW_DMA_TCD27_ATTR_ADDR      (REGS_DMA_BASE + 0x1366U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_ATTR           (*(__IO hw_dma_tcd27_attr_t *) HW_DMA_TCD27_ATTR_ADDR)
#define HW_DMA_TCD27_ATTR_RD()      (HW_DMA_TCD27_ATTR.U)
#define HW_DMA_TCD27_ATTR_WR(v)     (HW_DMA_TCD27_ATTR.U = (v))
#define HW_DMA_TCD27_ATTR_SET(v)    (HW_DMA_TCD27_ATTR_WR(HW_DMA_TCD27_ATTR_RD() |  (v)))
#define HW_DMA_TCD27_ATTR_CLR(v)    (HW_DMA_TCD27_ATTR_WR(HW_DMA_TCD27_ATTR_RD() & ~(v)))
#define HW_DMA_TCD27_ATTR_TOG(v)    (HW_DMA_TCD27_ATTR_WR(HW_DMA_TCD27_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_ATTR bitfields
 */

/*! @name Register DMA_TCD27_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD27_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD27_ATTR_DSIZE.
#define BM_DMA_TCD27_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD27_ATTR_DSIZE.
#define BS_DMA_TCD27_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD27_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_ATTR_DSIZE field.
#define BR_DMA_TCD27_ATTR_DSIZE()   (HW_DMA_TCD27_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD27_ATTR_DSIZE.
#define BF_DMA_TCD27_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_ATTR_DSIZE), uint16_t) & BM_DMA_TCD27_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD27_ATTR_DSIZE(v)   (HW_DMA_TCD27_ATTR_WR((HW_DMA_TCD27_ATTR_RD() & ~BM_DMA_TCD27_ATTR_DSIZE) | BF_DMA_TCD27_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD27_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD27_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD27_ATTR_DMOD.
#define BM_DMA_TCD27_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD27_ATTR_DMOD.
#define BS_DMA_TCD27_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD27_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_ATTR_DMOD field.
#define BR_DMA_TCD27_ATTR_DMOD()   (HW_DMA_TCD27_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD27_ATTR_DMOD.
#define BF_DMA_TCD27_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_ATTR_DMOD), uint16_t) & BM_DMA_TCD27_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD27_ATTR_DMOD(v)   (HW_DMA_TCD27_ATTR_WR((HW_DMA_TCD27_ATTR_RD() & ~BM_DMA_TCD27_ATTR_DMOD) | BF_DMA_TCD27_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD27_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD27_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD27_ATTR_SSIZE.
#define BM_DMA_TCD27_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD27_ATTR_SSIZE.
#define BS_DMA_TCD27_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD27_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_ATTR_SSIZE field.
#define BR_DMA_TCD27_ATTR_SSIZE()   (HW_DMA_TCD27_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD27_ATTR_SSIZE.
#define BF_DMA_TCD27_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_ATTR_SSIZE), uint16_t) & BM_DMA_TCD27_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD27_ATTR_SSIZE(v)   (HW_DMA_TCD27_ATTR_WR((HW_DMA_TCD27_ATTR_RD() & ~BM_DMA_TCD27_ATTR_SSIZE) | BF_DMA_TCD27_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD27_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD27_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD27_ATTR_SMOD.
#define BM_DMA_TCD27_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD27_ATTR_SMOD.
#define BS_DMA_TCD27_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD27_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_ATTR_SMOD field.
#define BR_DMA_TCD27_ATTR_SMOD()   (HW_DMA_TCD27_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD27_ATTR_SMOD.
#define BF_DMA_TCD27_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_ATTR_SMOD), uint16_t) & BM_DMA_TCD27_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD27_ATTR_SMOD(v)   (HW_DMA_TCD27_ATTR_WR((HW_DMA_TCD27_ATTR_RD() & ~BM_DMA_TCD27_ATTR_SMOD) | BF_DMA_TCD27_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd27_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd27_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd27_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD27_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1368U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_NBYTES_MLNO           (*(__IO hw_dma_tcd27_nbytes_mlno_t *) HW_DMA_TCD27_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD27_NBYTES_MLNO_RD()      (HW_DMA_TCD27_NBYTES_MLNO.U)
#define HW_DMA_TCD27_NBYTES_MLNO_WR(v)     (HW_DMA_TCD27_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD27_NBYTES_MLNO_SET(v)    (HW_DMA_TCD27_NBYTES_MLNO_WR(HW_DMA_TCD27_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD27_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD27_NBYTES_MLNO_WR(HW_DMA_TCD27_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD27_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD27_NBYTES_MLNO_WR(HW_DMA_TCD27_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD27_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD27_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD27_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD27_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD27_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD27_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD27_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD27_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD27_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD27_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD27_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD27_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD27_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD27_NBYTES_MLNO_WR((HW_DMA_TCD27_NBYTES_MLNO_RD() & ~BM_DMA_TCD27_NBYTES_MLNO_NBYTES) | BF_DMA_TCD27_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd27_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd27_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd27_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD27_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1368U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd27_nbytes_mloffno_t *) HW_DMA_TCD27_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD27_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD27_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD27_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD27_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD27_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD27_NBYTES_MLOFFNO_WR(HW_DMA_TCD27_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD27_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD27_NBYTES_MLOFFNO_WR(HW_DMA_TCD27_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD27_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD27_NBYTES_MLOFFNO_WR(HW_DMA_TCD27_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD27_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD27_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD27_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD27_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD27_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD27_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD27_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD27_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD27_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD27_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD27_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD27_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD27_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD27_NBYTES_MLOFFNO_WR((HW_DMA_TCD27_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD27_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD27_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD27_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD27_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD27_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD27_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD27_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD27_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD27_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD27_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD27_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD27_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD27_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD27_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD27_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD27_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD27_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD27_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD27_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD27_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD27_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD27_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD27_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD27_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD27_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD27_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD27_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD27_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD27_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD27_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD27_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD27_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD27_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd27_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd27_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd27_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD27_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1368U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd27_nbytes_mloffyes_t *) HW_DMA_TCD27_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD27_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD27_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD27_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD27_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD27_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD27_NBYTES_MLOFFYES_WR(HW_DMA_TCD27_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD27_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD27_NBYTES_MLOFFYES_WR(HW_DMA_TCD27_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD27_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD27_NBYTES_MLOFFYES_WR(HW_DMA_TCD27_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD27_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD27_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD27_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD27_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD27_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD27_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD27_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD27_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD27_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD27_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD27_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD27_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD27_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD27_NBYTES_MLOFFYES_WR((HW_DMA_TCD27_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD27_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD27_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD27_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD27_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD27_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD27_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD27_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD27_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD27_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD27_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD27_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD27_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD27_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD27_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD27_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD27_NBYTES_MLOFFYES_WR((HW_DMA_TCD27_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD27_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD27_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD27_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD27_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD27_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD27_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD27_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD27_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD27_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD27_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD27_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD27_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD27_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD27_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD27_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD27_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD27_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD27_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD27_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD27_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD27_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD27_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD27_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD27_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD27_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD27_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD27_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD27_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD27_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD27_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD27_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD27_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD27_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd27_slast
{
    uint32_t U;
    struct _hw_dma_tcd27_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd27_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_SLAST register
 */
//@{
#define HW_DMA_TCD27_SLAST_ADDR      (REGS_DMA_BASE + 0x136cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_SLAST           (*(__IO hw_dma_tcd27_slast_t *) HW_DMA_TCD27_SLAST_ADDR)
#define HW_DMA_TCD27_SLAST_RD()      (HW_DMA_TCD27_SLAST.U)
#define HW_DMA_TCD27_SLAST_WR(v)     (HW_DMA_TCD27_SLAST.U = (v))
#define HW_DMA_TCD27_SLAST_SET(v)    (HW_DMA_TCD27_SLAST_WR(HW_DMA_TCD27_SLAST_RD() |  (v)))
#define HW_DMA_TCD27_SLAST_CLR(v)    (HW_DMA_TCD27_SLAST_WR(HW_DMA_TCD27_SLAST_RD() & ~(v)))
#define HW_DMA_TCD27_SLAST_TOG(v)    (HW_DMA_TCD27_SLAST_WR(HW_DMA_TCD27_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_SLAST bitfields
 */

/*! @name Register DMA_TCD27_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD27_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD27_SLAST_SLAST.
#define BM_DMA_TCD27_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD27_SLAST_SLAST.
#define BS_DMA_TCD27_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD27_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_SLAST_SLAST field.
#define BR_DMA_TCD27_SLAST_SLAST()   (HW_DMA_TCD27_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD27_SLAST_SLAST.
#define BF_DMA_TCD27_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_SLAST_SLAST), uint32_t) & BM_DMA_TCD27_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD27_SLAST_SLAST(v)   (HW_DMA_TCD27_SLAST_WR((HW_DMA_TCD27_SLAST_RD() & ~BM_DMA_TCD27_SLAST_SLAST) | BF_DMA_TCD27_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd27_daddr
{
    uint32_t U;
    struct _hw_dma_tcd27_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd27_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_DADDR register
 */
//@{
#define HW_DMA_TCD27_DADDR_ADDR      (REGS_DMA_BASE + 0x1370U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_DADDR           (*(__IO hw_dma_tcd27_daddr_t *) HW_DMA_TCD27_DADDR_ADDR)
#define HW_DMA_TCD27_DADDR_RD()      (HW_DMA_TCD27_DADDR.U)
#define HW_DMA_TCD27_DADDR_WR(v)     (HW_DMA_TCD27_DADDR.U = (v))
#define HW_DMA_TCD27_DADDR_SET(v)    (HW_DMA_TCD27_DADDR_WR(HW_DMA_TCD27_DADDR_RD() |  (v)))
#define HW_DMA_TCD27_DADDR_CLR(v)    (HW_DMA_TCD27_DADDR_WR(HW_DMA_TCD27_DADDR_RD() & ~(v)))
#define HW_DMA_TCD27_DADDR_TOG(v)    (HW_DMA_TCD27_DADDR_WR(HW_DMA_TCD27_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_DADDR bitfields
 */

/*! @name Register DMA_TCD27_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD27_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD27_DADDR_DADDR.
#define BM_DMA_TCD27_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD27_DADDR_DADDR.
#define BS_DMA_TCD27_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD27_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_DADDR_DADDR field.
#define BR_DMA_TCD27_DADDR_DADDR()   (HW_DMA_TCD27_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD27_DADDR_DADDR.
#define BF_DMA_TCD27_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_DADDR_DADDR), uint32_t) & BM_DMA_TCD27_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD27_DADDR_DADDR(v)   (HW_DMA_TCD27_DADDR_WR((HW_DMA_TCD27_DADDR_RD() & ~BM_DMA_TCD27_DADDR_DADDR) | BF_DMA_TCD27_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd27_doff
{
    uint16_t U;
    struct _hw_dma_tcd27_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd27_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_DOFF register
 */
//@{
#define HW_DMA_TCD27_DOFF_ADDR      (REGS_DMA_BASE + 0x1374U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_DOFF           (*(__IO hw_dma_tcd27_doff_t *) HW_DMA_TCD27_DOFF_ADDR)
#define HW_DMA_TCD27_DOFF_RD()      (HW_DMA_TCD27_DOFF.U)
#define HW_DMA_TCD27_DOFF_WR(v)     (HW_DMA_TCD27_DOFF.U = (v))
#define HW_DMA_TCD27_DOFF_SET(v)    (HW_DMA_TCD27_DOFF_WR(HW_DMA_TCD27_DOFF_RD() |  (v)))
#define HW_DMA_TCD27_DOFF_CLR(v)    (HW_DMA_TCD27_DOFF_WR(HW_DMA_TCD27_DOFF_RD() & ~(v)))
#define HW_DMA_TCD27_DOFF_TOG(v)    (HW_DMA_TCD27_DOFF_WR(HW_DMA_TCD27_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_DOFF bitfields
 */

/*! @name Register DMA_TCD27_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD27_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD27_DOFF_DOFF.
#define BM_DMA_TCD27_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD27_DOFF_DOFF.
#define BS_DMA_TCD27_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD27_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_DOFF_DOFF field.
#define BR_DMA_TCD27_DOFF_DOFF()   (HW_DMA_TCD27_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD27_DOFF_DOFF.
#define BF_DMA_TCD27_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_DOFF_DOFF), uint16_t) & BM_DMA_TCD27_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD27_DOFF_DOFF(v)   (HW_DMA_TCD27_DOFF_WR((HW_DMA_TCD27_DOFF_RD() & ~BM_DMA_TCD27_DOFF_DOFF) | BF_DMA_TCD27_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd27_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd27_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd27_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD27_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1376U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_CITER_ELINKYES           (*(__IO hw_dma_tcd27_citer_elinkyes_t *) HW_DMA_TCD27_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD27_CITER_ELINKYES_RD()      (HW_DMA_TCD27_CITER_ELINKYES.U)
#define HW_DMA_TCD27_CITER_ELINKYES_WR(v)     (HW_DMA_TCD27_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD27_CITER_ELINKYES_SET(v)    (HW_DMA_TCD27_CITER_ELINKYES_WR(HW_DMA_TCD27_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD27_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD27_CITER_ELINKYES_WR(HW_DMA_TCD27_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD27_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD27_CITER_ELINKYES_WR(HW_DMA_TCD27_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD27_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD27_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD27_CITER_ELINKYES_CITER.
#define BM_DMA_TCD27_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD27_CITER_ELINKYES_CITER.
#define BS_DMA_TCD27_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD27_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD27_CITER_ELINKYES_CITER()   (HW_DMA_TCD27_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD27_CITER_ELINKYES_CITER.
#define BF_DMA_TCD27_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD27_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD27_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD27_CITER_ELINKYES_WR((HW_DMA_TCD27_CITER_ELINKYES_RD() & ~BM_DMA_TCD27_CITER_ELINKYES_CITER) | BF_DMA_TCD27_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD27_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD27_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD27_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD27_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD27_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD27_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD27_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD27_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD27_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD27_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD27_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD27_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD27_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD27_CITER_ELINKYES_WR((HW_DMA_TCD27_CITER_ELINKYES_RD() & ~BM_DMA_TCD27_CITER_ELINKYES_LINKCH) | BF_DMA_TCD27_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD27_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD27_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD27_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD27_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD27_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD27_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD27_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD27_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD27_CITER_ELINKYES_ADDR, BP_DMA_TCD27_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD27_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD27_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD27_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD27_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CITER_ELINKYES_ADDR, BP_DMA_TCD27_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd27_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd27_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd27_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD27_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1376U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_CITER_ELINKNO           (*(__IO hw_dma_tcd27_citer_elinkno_t *) HW_DMA_TCD27_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD27_CITER_ELINKNO_RD()      (HW_DMA_TCD27_CITER_ELINKNO.U)
#define HW_DMA_TCD27_CITER_ELINKNO_WR(v)     (HW_DMA_TCD27_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD27_CITER_ELINKNO_SET(v)    (HW_DMA_TCD27_CITER_ELINKNO_WR(HW_DMA_TCD27_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD27_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD27_CITER_ELINKNO_WR(HW_DMA_TCD27_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD27_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD27_CITER_ELINKNO_WR(HW_DMA_TCD27_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD27_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD27_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD27_CITER_ELINKNO_CITER.
#define BM_DMA_TCD27_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD27_CITER_ELINKNO_CITER.
#define BS_DMA_TCD27_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD27_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD27_CITER_ELINKNO_CITER()   (HW_DMA_TCD27_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD27_CITER_ELINKNO_CITER.
#define BF_DMA_TCD27_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD27_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD27_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD27_CITER_ELINKNO_WR((HW_DMA_TCD27_CITER_ELINKNO_RD() & ~BM_DMA_TCD27_CITER_ELINKNO_CITER) | BF_DMA_TCD27_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD27_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD27_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD27_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD27_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD27_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD27_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD27_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD27_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD27_CITER_ELINKNO_ADDR, BP_DMA_TCD27_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD27_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD27_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD27_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD27_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CITER_ELINKNO_ADDR, BP_DMA_TCD27_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd27_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd27_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd27_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_DLASTSGA register
 */
//@{
#define HW_DMA_TCD27_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1378U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_DLASTSGA           (*(__IO hw_dma_tcd27_dlastsga_t *) HW_DMA_TCD27_DLASTSGA_ADDR)
#define HW_DMA_TCD27_DLASTSGA_RD()      (HW_DMA_TCD27_DLASTSGA.U)
#define HW_DMA_TCD27_DLASTSGA_WR(v)     (HW_DMA_TCD27_DLASTSGA.U = (v))
#define HW_DMA_TCD27_DLASTSGA_SET(v)    (HW_DMA_TCD27_DLASTSGA_WR(HW_DMA_TCD27_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD27_DLASTSGA_CLR(v)    (HW_DMA_TCD27_DLASTSGA_WR(HW_DMA_TCD27_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD27_DLASTSGA_TOG(v)    (HW_DMA_TCD27_DLASTSGA_WR(HW_DMA_TCD27_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD27_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD27_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD27_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD27_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD27_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD27_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD27_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD27_DLASTSGA_DLASTSGA()   (HW_DMA_TCD27_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD27_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD27_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD27_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD27_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD27_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD27_DLASTSGA_WR((HW_DMA_TCD27_DLASTSGA_RD() & ~BM_DMA_TCD27_DLASTSGA_DLASTSGA) | BF_DMA_TCD27_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd27_csr
{
    uint16_t U;
    struct _hw_dma_tcd27_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd27_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_CSR register
 */
//@{
#define HW_DMA_TCD27_CSR_ADDR      (REGS_DMA_BASE + 0x137cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_CSR           (*(__IO hw_dma_tcd27_csr_t *) HW_DMA_TCD27_CSR_ADDR)
#define HW_DMA_TCD27_CSR_RD()      (HW_DMA_TCD27_CSR.U)
#define HW_DMA_TCD27_CSR_WR(v)     (HW_DMA_TCD27_CSR.U = (v))
#define HW_DMA_TCD27_CSR_SET(v)    (HW_DMA_TCD27_CSR_WR(HW_DMA_TCD27_CSR_RD() |  (v)))
#define HW_DMA_TCD27_CSR_CLR(v)    (HW_DMA_TCD27_CSR_WR(HW_DMA_TCD27_CSR_RD() & ~(v)))
#define HW_DMA_TCD27_CSR_TOG(v)    (HW_DMA_TCD27_CSR_WR(HW_DMA_TCD27_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_CSR bitfields
 */

/*! @name Register DMA_TCD27_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD27_CSR_START      (0U)      //!< Bit position for DMA_TCD27_CSR_START.
#define BM_DMA_TCD27_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD27_CSR_START.
#define BS_DMA_TCD27_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD27_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_START field.
#define BR_DMA_TCD27_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_START.
#define BF_DMA_TCD27_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_START), uint16_t) & BM_DMA_TCD27_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD27_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD27_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD27_CSR_INTMAJOR.
#define BM_DMA_TCD27_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD27_CSR_INTMAJOR.
#define BS_DMA_TCD27_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD27_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_INTMAJOR field.
#define BR_DMA_TCD27_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_INTMAJOR.
#define BF_DMA_TCD27_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD27_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD27_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD27_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD27_CSR_INTHALF.
#define BM_DMA_TCD27_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD27_CSR_INTHALF.
#define BS_DMA_TCD27_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD27_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_INTHALF field.
#define BR_DMA_TCD27_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_INTHALF.
#define BF_DMA_TCD27_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_INTHALF), uint16_t) & BM_DMA_TCD27_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD27_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD27_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD27_CSR_DREQ.
#define BM_DMA_TCD27_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD27_CSR_DREQ.
#define BS_DMA_TCD27_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD27_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_DREQ field.
#define BR_DMA_TCD27_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_DREQ.
#define BF_DMA_TCD27_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_DREQ), uint16_t) & BM_DMA_TCD27_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD27_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD27_CSR_ESG      (4U)      //!< Bit position for DMA_TCD27_CSR_ESG.
#define BM_DMA_TCD27_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD27_CSR_ESG.
#define BS_DMA_TCD27_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD27_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_ESG field.
#define BR_DMA_TCD27_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_ESG.
#define BF_DMA_TCD27_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_ESG), uint16_t) & BM_DMA_TCD27_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD27_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD27_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD27_CSR_MAJORELINK.
#define BM_DMA_TCD27_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD27_CSR_MAJORELINK.
#define BS_DMA_TCD27_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD27_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_MAJORELINK field.
#define BR_DMA_TCD27_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_MAJORELINK.
#define BF_DMA_TCD27_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD27_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD27_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD27_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD27_CSR_ACTIVE.
#define BM_DMA_TCD27_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD27_CSR_ACTIVE.
#define BS_DMA_TCD27_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD27_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_ACTIVE field.
#define BR_DMA_TCD27_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_ACTIVE.
#define BF_DMA_TCD27_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_ACTIVE), uint16_t) & BM_DMA_TCD27_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD27_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD27_CSR_DONE      (7U)      //!< Bit position for DMA_TCD27_CSR_DONE.
#define BM_DMA_TCD27_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD27_CSR_DONE.
#define BS_DMA_TCD27_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD27_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_DONE field.
#define BR_DMA_TCD27_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_DONE.
#define BF_DMA_TCD27_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_DONE), uint16_t) & BM_DMA_TCD27_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD27_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_CSR_ADDR, BP_DMA_TCD27_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD27_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD27_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD27_CSR_MAJORLINKCH.
#define BM_DMA_TCD27_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD27_CSR_MAJORLINKCH.
#define BS_DMA_TCD27_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD27_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_MAJORLINKCH field.
#define BR_DMA_TCD27_CSR_MAJORLINKCH()   (HW_DMA_TCD27_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_MAJORLINKCH.
#define BF_DMA_TCD27_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD27_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD27_CSR_MAJORLINKCH(v)   (HW_DMA_TCD27_CSR_WR((HW_DMA_TCD27_CSR_RD() & ~BM_DMA_TCD27_CSR_MAJORLINKCH) | BF_DMA_TCD27_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD27_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD27_CSR_BWC      (14U)      //!< Bit position for DMA_TCD27_CSR_BWC.
#define BM_DMA_TCD27_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD27_CSR_BWC.
#define BS_DMA_TCD27_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD27_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_CSR_BWC field.
#define BR_DMA_TCD27_CSR_BWC()   (HW_DMA_TCD27_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD27_CSR_BWC.
#define BF_DMA_TCD27_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_CSR_BWC), uint16_t) & BM_DMA_TCD27_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD27_CSR_BWC(v)   (HW_DMA_TCD27_CSR_WR((HW_DMA_TCD27_CSR_RD() & ~BM_DMA_TCD27_CSR_BWC) | BF_DMA_TCD27_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd27_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd27_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd27_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD27_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x137eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_BITER_ELINKYES           (*(__IO hw_dma_tcd27_biter_elinkyes_t *) HW_DMA_TCD27_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD27_BITER_ELINKYES_RD()      (HW_DMA_TCD27_BITER_ELINKYES.U)
#define HW_DMA_TCD27_BITER_ELINKYES_WR(v)     (HW_DMA_TCD27_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD27_BITER_ELINKYES_SET(v)    (HW_DMA_TCD27_BITER_ELINKYES_WR(HW_DMA_TCD27_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD27_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD27_BITER_ELINKYES_WR(HW_DMA_TCD27_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD27_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD27_BITER_ELINKYES_WR(HW_DMA_TCD27_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD27_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD27_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD27_BITER_ELINKYES_BITER.
#define BM_DMA_TCD27_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD27_BITER_ELINKYES_BITER.
#define BS_DMA_TCD27_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD27_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD27_BITER_ELINKYES_BITER()   (HW_DMA_TCD27_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD27_BITER_ELINKYES_BITER.
#define BF_DMA_TCD27_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD27_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD27_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD27_BITER_ELINKYES_WR((HW_DMA_TCD27_BITER_ELINKYES_RD() & ~BM_DMA_TCD27_BITER_ELINKYES_BITER) | BF_DMA_TCD27_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD27_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD27_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD27_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD27_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD27_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD27_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD27_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD27_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD27_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD27_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD27_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD27_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD27_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD27_BITER_ELINKYES_WR((HW_DMA_TCD27_BITER_ELINKYES_RD() & ~BM_DMA_TCD27_BITER_ELINKYES_LINKCH) | BF_DMA_TCD27_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD27_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD27_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD27_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD27_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD27_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD27_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD27_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD27_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD27_BITER_ELINKYES_ADDR, BP_DMA_TCD27_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD27_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD27_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD27_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD27_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_BITER_ELINKYES_ADDR, BP_DMA_TCD27_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD27_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD27_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd27_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd27_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd27_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD27_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD27_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x137eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD27_BITER_ELINKNO           (*(__IO hw_dma_tcd27_biter_elinkno_t *) HW_DMA_TCD27_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD27_BITER_ELINKNO_RD()      (HW_DMA_TCD27_BITER_ELINKNO.U)
#define HW_DMA_TCD27_BITER_ELINKNO_WR(v)     (HW_DMA_TCD27_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD27_BITER_ELINKNO_SET(v)    (HW_DMA_TCD27_BITER_ELINKNO_WR(HW_DMA_TCD27_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD27_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD27_BITER_ELINKNO_WR(HW_DMA_TCD27_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD27_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD27_BITER_ELINKNO_WR(HW_DMA_TCD27_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD27_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD27_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD27_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD27_BITER_ELINKNO_BITER.
#define BM_DMA_TCD27_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD27_BITER_ELINKNO_BITER.
#define BS_DMA_TCD27_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD27_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD27_BITER_ELINKNO_BITER()   (HW_DMA_TCD27_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD27_BITER_ELINKNO_BITER.
#define BF_DMA_TCD27_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD27_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD27_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD27_BITER_ELINKNO_WR((HW_DMA_TCD27_BITER_ELINKNO_RD() & ~BM_DMA_TCD27_BITER_ELINKNO_BITER) | BF_DMA_TCD27_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD27_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD27_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD27_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD27_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD27_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD27_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD27_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD27_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD27_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD27_BITER_ELINKNO_ADDR, BP_DMA_TCD27_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD27_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD27_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD27_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD27_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD27_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD27_BITER_ELINKNO_ADDR, BP_DMA_TCD27_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd28_saddr
{
    uint32_t U;
    struct _hw_dma_tcd28_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd28_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_SADDR register
 */
//@{
#define HW_DMA_TCD28_SADDR_ADDR      (REGS_DMA_BASE + 0x1380U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_SADDR           (*(__IO hw_dma_tcd28_saddr_t *) HW_DMA_TCD28_SADDR_ADDR)
#define HW_DMA_TCD28_SADDR_RD()      (HW_DMA_TCD28_SADDR.U)
#define HW_DMA_TCD28_SADDR_WR(v)     (HW_DMA_TCD28_SADDR.U = (v))
#define HW_DMA_TCD28_SADDR_SET(v)    (HW_DMA_TCD28_SADDR_WR(HW_DMA_TCD28_SADDR_RD() |  (v)))
#define HW_DMA_TCD28_SADDR_CLR(v)    (HW_DMA_TCD28_SADDR_WR(HW_DMA_TCD28_SADDR_RD() & ~(v)))
#define HW_DMA_TCD28_SADDR_TOG(v)    (HW_DMA_TCD28_SADDR_WR(HW_DMA_TCD28_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_SADDR bitfields
 */

/*! @name Register DMA_TCD28_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD28_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD28_SADDR_SADDR.
#define BM_DMA_TCD28_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD28_SADDR_SADDR.
#define BS_DMA_TCD28_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD28_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_SADDR_SADDR field.
#define BR_DMA_TCD28_SADDR_SADDR()   (HW_DMA_TCD28_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD28_SADDR_SADDR.
#define BF_DMA_TCD28_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_SADDR_SADDR), uint32_t) & BM_DMA_TCD28_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD28_SADDR_SADDR(v)   (HW_DMA_TCD28_SADDR_WR((HW_DMA_TCD28_SADDR_RD() & ~BM_DMA_TCD28_SADDR_SADDR) | BF_DMA_TCD28_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd28_soff
{
    uint16_t U;
    struct _hw_dma_tcd28_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd28_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_SOFF register
 */
//@{
#define HW_DMA_TCD28_SOFF_ADDR      (REGS_DMA_BASE + 0x1384U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_SOFF           (*(__IO hw_dma_tcd28_soff_t *) HW_DMA_TCD28_SOFF_ADDR)
#define HW_DMA_TCD28_SOFF_RD()      (HW_DMA_TCD28_SOFF.U)
#define HW_DMA_TCD28_SOFF_WR(v)     (HW_DMA_TCD28_SOFF.U = (v))
#define HW_DMA_TCD28_SOFF_SET(v)    (HW_DMA_TCD28_SOFF_WR(HW_DMA_TCD28_SOFF_RD() |  (v)))
#define HW_DMA_TCD28_SOFF_CLR(v)    (HW_DMA_TCD28_SOFF_WR(HW_DMA_TCD28_SOFF_RD() & ~(v)))
#define HW_DMA_TCD28_SOFF_TOG(v)    (HW_DMA_TCD28_SOFF_WR(HW_DMA_TCD28_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_SOFF bitfields
 */

/*! @name Register DMA_TCD28_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD28_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD28_SOFF_SOFF.
#define BM_DMA_TCD28_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD28_SOFF_SOFF.
#define BS_DMA_TCD28_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD28_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_SOFF_SOFF field.
#define BR_DMA_TCD28_SOFF_SOFF()   (HW_DMA_TCD28_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD28_SOFF_SOFF.
#define BF_DMA_TCD28_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_SOFF_SOFF), uint16_t) & BM_DMA_TCD28_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD28_SOFF_SOFF(v)   (HW_DMA_TCD28_SOFF_WR((HW_DMA_TCD28_SOFF_RD() & ~BM_DMA_TCD28_SOFF_SOFF) | BF_DMA_TCD28_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd28_attr
{
    uint16_t U;
    struct _hw_dma_tcd28_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd28_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_ATTR register
 */
//@{
#define HW_DMA_TCD28_ATTR_ADDR      (REGS_DMA_BASE + 0x1386U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_ATTR           (*(__IO hw_dma_tcd28_attr_t *) HW_DMA_TCD28_ATTR_ADDR)
#define HW_DMA_TCD28_ATTR_RD()      (HW_DMA_TCD28_ATTR.U)
#define HW_DMA_TCD28_ATTR_WR(v)     (HW_DMA_TCD28_ATTR.U = (v))
#define HW_DMA_TCD28_ATTR_SET(v)    (HW_DMA_TCD28_ATTR_WR(HW_DMA_TCD28_ATTR_RD() |  (v)))
#define HW_DMA_TCD28_ATTR_CLR(v)    (HW_DMA_TCD28_ATTR_WR(HW_DMA_TCD28_ATTR_RD() & ~(v)))
#define HW_DMA_TCD28_ATTR_TOG(v)    (HW_DMA_TCD28_ATTR_WR(HW_DMA_TCD28_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_ATTR bitfields
 */

/*! @name Register DMA_TCD28_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD28_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD28_ATTR_DSIZE.
#define BM_DMA_TCD28_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD28_ATTR_DSIZE.
#define BS_DMA_TCD28_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD28_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_ATTR_DSIZE field.
#define BR_DMA_TCD28_ATTR_DSIZE()   (HW_DMA_TCD28_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD28_ATTR_DSIZE.
#define BF_DMA_TCD28_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_ATTR_DSIZE), uint16_t) & BM_DMA_TCD28_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD28_ATTR_DSIZE(v)   (HW_DMA_TCD28_ATTR_WR((HW_DMA_TCD28_ATTR_RD() & ~BM_DMA_TCD28_ATTR_DSIZE) | BF_DMA_TCD28_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD28_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD28_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD28_ATTR_DMOD.
#define BM_DMA_TCD28_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD28_ATTR_DMOD.
#define BS_DMA_TCD28_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD28_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_ATTR_DMOD field.
#define BR_DMA_TCD28_ATTR_DMOD()   (HW_DMA_TCD28_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD28_ATTR_DMOD.
#define BF_DMA_TCD28_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_ATTR_DMOD), uint16_t) & BM_DMA_TCD28_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD28_ATTR_DMOD(v)   (HW_DMA_TCD28_ATTR_WR((HW_DMA_TCD28_ATTR_RD() & ~BM_DMA_TCD28_ATTR_DMOD) | BF_DMA_TCD28_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD28_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD28_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD28_ATTR_SSIZE.
#define BM_DMA_TCD28_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD28_ATTR_SSIZE.
#define BS_DMA_TCD28_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD28_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_ATTR_SSIZE field.
#define BR_DMA_TCD28_ATTR_SSIZE()   (HW_DMA_TCD28_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD28_ATTR_SSIZE.
#define BF_DMA_TCD28_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_ATTR_SSIZE), uint16_t) & BM_DMA_TCD28_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD28_ATTR_SSIZE(v)   (HW_DMA_TCD28_ATTR_WR((HW_DMA_TCD28_ATTR_RD() & ~BM_DMA_TCD28_ATTR_SSIZE) | BF_DMA_TCD28_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD28_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD28_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD28_ATTR_SMOD.
#define BM_DMA_TCD28_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD28_ATTR_SMOD.
#define BS_DMA_TCD28_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD28_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_ATTR_SMOD field.
#define BR_DMA_TCD28_ATTR_SMOD()   (HW_DMA_TCD28_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD28_ATTR_SMOD.
#define BF_DMA_TCD28_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_ATTR_SMOD), uint16_t) & BM_DMA_TCD28_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD28_ATTR_SMOD(v)   (HW_DMA_TCD28_ATTR_WR((HW_DMA_TCD28_ATTR_RD() & ~BM_DMA_TCD28_ATTR_SMOD) | BF_DMA_TCD28_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd28_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd28_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd28_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD28_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x1388U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_NBYTES_MLNO           (*(__IO hw_dma_tcd28_nbytes_mlno_t *) HW_DMA_TCD28_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD28_NBYTES_MLNO_RD()      (HW_DMA_TCD28_NBYTES_MLNO.U)
#define HW_DMA_TCD28_NBYTES_MLNO_WR(v)     (HW_DMA_TCD28_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD28_NBYTES_MLNO_SET(v)    (HW_DMA_TCD28_NBYTES_MLNO_WR(HW_DMA_TCD28_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD28_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD28_NBYTES_MLNO_WR(HW_DMA_TCD28_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD28_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD28_NBYTES_MLNO_WR(HW_DMA_TCD28_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD28_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD28_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD28_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD28_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD28_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD28_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD28_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD28_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD28_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD28_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD28_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD28_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD28_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD28_NBYTES_MLNO_WR((HW_DMA_TCD28_NBYTES_MLNO_RD() & ~BM_DMA_TCD28_NBYTES_MLNO_NBYTES) | BF_DMA_TCD28_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd28_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd28_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd28_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD28_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x1388U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd28_nbytes_mloffno_t *) HW_DMA_TCD28_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD28_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD28_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD28_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD28_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD28_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD28_NBYTES_MLOFFNO_WR(HW_DMA_TCD28_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD28_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD28_NBYTES_MLOFFNO_WR(HW_DMA_TCD28_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD28_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD28_NBYTES_MLOFFNO_WR(HW_DMA_TCD28_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD28_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD28_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD28_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD28_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD28_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD28_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD28_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD28_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD28_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD28_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD28_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD28_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD28_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD28_NBYTES_MLOFFNO_WR((HW_DMA_TCD28_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD28_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD28_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD28_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD28_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD28_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD28_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD28_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD28_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD28_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD28_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD28_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD28_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD28_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD28_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD28_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD28_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD28_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD28_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD28_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD28_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD28_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD28_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD28_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD28_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD28_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD28_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD28_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD28_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD28_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD28_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD28_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD28_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD28_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd28_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd28_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd28_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD28_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x1388U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd28_nbytes_mloffyes_t *) HW_DMA_TCD28_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD28_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD28_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD28_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD28_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD28_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD28_NBYTES_MLOFFYES_WR(HW_DMA_TCD28_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD28_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD28_NBYTES_MLOFFYES_WR(HW_DMA_TCD28_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD28_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD28_NBYTES_MLOFFYES_WR(HW_DMA_TCD28_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD28_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD28_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD28_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD28_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD28_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD28_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD28_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD28_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD28_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD28_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD28_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD28_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD28_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD28_NBYTES_MLOFFYES_WR((HW_DMA_TCD28_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD28_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD28_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD28_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD28_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD28_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD28_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD28_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD28_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD28_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD28_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD28_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD28_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD28_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD28_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD28_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD28_NBYTES_MLOFFYES_WR((HW_DMA_TCD28_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD28_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD28_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD28_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD28_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD28_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD28_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD28_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD28_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD28_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD28_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD28_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD28_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD28_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD28_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD28_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD28_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD28_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD28_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD28_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD28_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD28_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD28_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD28_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD28_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD28_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD28_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD28_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD28_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD28_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD28_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD28_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD28_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD28_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd28_slast
{
    uint32_t U;
    struct _hw_dma_tcd28_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd28_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_SLAST register
 */
//@{
#define HW_DMA_TCD28_SLAST_ADDR      (REGS_DMA_BASE + 0x138cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_SLAST           (*(__IO hw_dma_tcd28_slast_t *) HW_DMA_TCD28_SLAST_ADDR)
#define HW_DMA_TCD28_SLAST_RD()      (HW_DMA_TCD28_SLAST.U)
#define HW_DMA_TCD28_SLAST_WR(v)     (HW_DMA_TCD28_SLAST.U = (v))
#define HW_DMA_TCD28_SLAST_SET(v)    (HW_DMA_TCD28_SLAST_WR(HW_DMA_TCD28_SLAST_RD() |  (v)))
#define HW_DMA_TCD28_SLAST_CLR(v)    (HW_DMA_TCD28_SLAST_WR(HW_DMA_TCD28_SLAST_RD() & ~(v)))
#define HW_DMA_TCD28_SLAST_TOG(v)    (HW_DMA_TCD28_SLAST_WR(HW_DMA_TCD28_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_SLAST bitfields
 */

/*! @name Register DMA_TCD28_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD28_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD28_SLAST_SLAST.
#define BM_DMA_TCD28_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD28_SLAST_SLAST.
#define BS_DMA_TCD28_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD28_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_SLAST_SLAST field.
#define BR_DMA_TCD28_SLAST_SLAST()   (HW_DMA_TCD28_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD28_SLAST_SLAST.
#define BF_DMA_TCD28_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_SLAST_SLAST), uint32_t) & BM_DMA_TCD28_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD28_SLAST_SLAST(v)   (HW_DMA_TCD28_SLAST_WR((HW_DMA_TCD28_SLAST_RD() & ~BM_DMA_TCD28_SLAST_SLAST) | BF_DMA_TCD28_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd28_daddr
{
    uint32_t U;
    struct _hw_dma_tcd28_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd28_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_DADDR register
 */
//@{
#define HW_DMA_TCD28_DADDR_ADDR      (REGS_DMA_BASE + 0x1390U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_DADDR           (*(__IO hw_dma_tcd28_daddr_t *) HW_DMA_TCD28_DADDR_ADDR)
#define HW_DMA_TCD28_DADDR_RD()      (HW_DMA_TCD28_DADDR.U)
#define HW_DMA_TCD28_DADDR_WR(v)     (HW_DMA_TCD28_DADDR.U = (v))
#define HW_DMA_TCD28_DADDR_SET(v)    (HW_DMA_TCD28_DADDR_WR(HW_DMA_TCD28_DADDR_RD() |  (v)))
#define HW_DMA_TCD28_DADDR_CLR(v)    (HW_DMA_TCD28_DADDR_WR(HW_DMA_TCD28_DADDR_RD() & ~(v)))
#define HW_DMA_TCD28_DADDR_TOG(v)    (HW_DMA_TCD28_DADDR_WR(HW_DMA_TCD28_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_DADDR bitfields
 */

/*! @name Register DMA_TCD28_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD28_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD28_DADDR_DADDR.
#define BM_DMA_TCD28_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD28_DADDR_DADDR.
#define BS_DMA_TCD28_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD28_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_DADDR_DADDR field.
#define BR_DMA_TCD28_DADDR_DADDR()   (HW_DMA_TCD28_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD28_DADDR_DADDR.
#define BF_DMA_TCD28_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_DADDR_DADDR), uint32_t) & BM_DMA_TCD28_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD28_DADDR_DADDR(v)   (HW_DMA_TCD28_DADDR_WR((HW_DMA_TCD28_DADDR_RD() & ~BM_DMA_TCD28_DADDR_DADDR) | BF_DMA_TCD28_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd28_doff
{
    uint16_t U;
    struct _hw_dma_tcd28_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd28_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_DOFF register
 */
//@{
#define HW_DMA_TCD28_DOFF_ADDR      (REGS_DMA_BASE + 0x1394U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_DOFF           (*(__IO hw_dma_tcd28_doff_t *) HW_DMA_TCD28_DOFF_ADDR)
#define HW_DMA_TCD28_DOFF_RD()      (HW_DMA_TCD28_DOFF.U)
#define HW_DMA_TCD28_DOFF_WR(v)     (HW_DMA_TCD28_DOFF.U = (v))
#define HW_DMA_TCD28_DOFF_SET(v)    (HW_DMA_TCD28_DOFF_WR(HW_DMA_TCD28_DOFF_RD() |  (v)))
#define HW_DMA_TCD28_DOFF_CLR(v)    (HW_DMA_TCD28_DOFF_WR(HW_DMA_TCD28_DOFF_RD() & ~(v)))
#define HW_DMA_TCD28_DOFF_TOG(v)    (HW_DMA_TCD28_DOFF_WR(HW_DMA_TCD28_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_DOFF bitfields
 */

/*! @name Register DMA_TCD28_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD28_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD28_DOFF_DOFF.
#define BM_DMA_TCD28_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD28_DOFF_DOFF.
#define BS_DMA_TCD28_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD28_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_DOFF_DOFF field.
#define BR_DMA_TCD28_DOFF_DOFF()   (HW_DMA_TCD28_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD28_DOFF_DOFF.
#define BF_DMA_TCD28_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_DOFF_DOFF), uint16_t) & BM_DMA_TCD28_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD28_DOFF_DOFF(v)   (HW_DMA_TCD28_DOFF_WR((HW_DMA_TCD28_DOFF_RD() & ~BM_DMA_TCD28_DOFF_DOFF) | BF_DMA_TCD28_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd28_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd28_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd28_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD28_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x1396U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_CITER_ELINKYES           (*(__IO hw_dma_tcd28_citer_elinkyes_t *) HW_DMA_TCD28_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD28_CITER_ELINKYES_RD()      (HW_DMA_TCD28_CITER_ELINKYES.U)
#define HW_DMA_TCD28_CITER_ELINKYES_WR(v)     (HW_DMA_TCD28_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD28_CITER_ELINKYES_SET(v)    (HW_DMA_TCD28_CITER_ELINKYES_WR(HW_DMA_TCD28_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD28_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD28_CITER_ELINKYES_WR(HW_DMA_TCD28_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD28_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD28_CITER_ELINKYES_WR(HW_DMA_TCD28_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD28_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD28_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD28_CITER_ELINKYES_CITER.
#define BM_DMA_TCD28_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD28_CITER_ELINKYES_CITER.
#define BS_DMA_TCD28_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD28_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD28_CITER_ELINKYES_CITER()   (HW_DMA_TCD28_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD28_CITER_ELINKYES_CITER.
#define BF_DMA_TCD28_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD28_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD28_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD28_CITER_ELINKYES_WR((HW_DMA_TCD28_CITER_ELINKYES_RD() & ~BM_DMA_TCD28_CITER_ELINKYES_CITER) | BF_DMA_TCD28_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD28_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD28_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD28_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD28_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD28_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD28_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD28_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD28_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD28_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD28_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD28_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD28_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD28_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD28_CITER_ELINKYES_WR((HW_DMA_TCD28_CITER_ELINKYES_RD() & ~BM_DMA_TCD28_CITER_ELINKYES_LINKCH) | BF_DMA_TCD28_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD28_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD28_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD28_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD28_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD28_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD28_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD28_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD28_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD28_CITER_ELINKYES_ADDR, BP_DMA_TCD28_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD28_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD28_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD28_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD28_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CITER_ELINKYES_ADDR, BP_DMA_TCD28_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd28_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd28_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd28_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD28_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x1396U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_CITER_ELINKNO           (*(__IO hw_dma_tcd28_citer_elinkno_t *) HW_DMA_TCD28_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD28_CITER_ELINKNO_RD()      (HW_DMA_TCD28_CITER_ELINKNO.U)
#define HW_DMA_TCD28_CITER_ELINKNO_WR(v)     (HW_DMA_TCD28_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD28_CITER_ELINKNO_SET(v)    (HW_DMA_TCD28_CITER_ELINKNO_WR(HW_DMA_TCD28_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD28_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD28_CITER_ELINKNO_WR(HW_DMA_TCD28_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD28_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD28_CITER_ELINKNO_WR(HW_DMA_TCD28_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD28_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD28_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD28_CITER_ELINKNO_CITER.
#define BM_DMA_TCD28_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD28_CITER_ELINKNO_CITER.
#define BS_DMA_TCD28_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD28_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD28_CITER_ELINKNO_CITER()   (HW_DMA_TCD28_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD28_CITER_ELINKNO_CITER.
#define BF_DMA_TCD28_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD28_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD28_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD28_CITER_ELINKNO_WR((HW_DMA_TCD28_CITER_ELINKNO_RD() & ~BM_DMA_TCD28_CITER_ELINKNO_CITER) | BF_DMA_TCD28_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD28_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD28_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD28_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD28_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD28_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD28_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD28_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD28_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD28_CITER_ELINKNO_ADDR, BP_DMA_TCD28_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD28_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD28_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD28_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD28_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CITER_ELINKNO_ADDR, BP_DMA_TCD28_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd28_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd28_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd28_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_DLASTSGA register
 */
//@{
#define HW_DMA_TCD28_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x1398U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_DLASTSGA           (*(__IO hw_dma_tcd28_dlastsga_t *) HW_DMA_TCD28_DLASTSGA_ADDR)
#define HW_DMA_TCD28_DLASTSGA_RD()      (HW_DMA_TCD28_DLASTSGA.U)
#define HW_DMA_TCD28_DLASTSGA_WR(v)     (HW_DMA_TCD28_DLASTSGA.U = (v))
#define HW_DMA_TCD28_DLASTSGA_SET(v)    (HW_DMA_TCD28_DLASTSGA_WR(HW_DMA_TCD28_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD28_DLASTSGA_CLR(v)    (HW_DMA_TCD28_DLASTSGA_WR(HW_DMA_TCD28_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD28_DLASTSGA_TOG(v)    (HW_DMA_TCD28_DLASTSGA_WR(HW_DMA_TCD28_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD28_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD28_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD28_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD28_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD28_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD28_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD28_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD28_DLASTSGA_DLASTSGA()   (HW_DMA_TCD28_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD28_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD28_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD28_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD28_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD28_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD28_DLASTSGA_WR((HW_DMA_TCD28_DLASTSGA_RD() & ~BM_DMA_TCD28_DLASTSGA_DLASTSGA) | BF_DMA_TCD28_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd28_csr
{
    uint16_t U;
    struct _hw_dma_tcd28_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd28_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_CSR register
 */
//@{
#define HW_DMA_TCD28_CSR_ADDR      (REGS_DMA_BASE + 0x139cU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_CSR           (*(__IO hw_dma_tcd28_csr_t *) HW_DMA_TCD28_CSR_ADDR)
#define HW_DMA_TCD28_CSR_RD()      (HW_DMA_TCD28_CSR.U)
#define HW_DMA_TCD28_CSR_WR(v)     (HW_DMA_TCD28_CSR.U = (v))
#define HW_DMA_TCD28_CSR_SET(v)    (HW_DMA_TCD28_CSR_WR(HW_DMA_TCD28_CSR_RD() |  (v)))
#define HW_DMA_TCD28_CSR_CLR(v)    (HW_DMA_TCD28_CSR_WR(HW_DMA_TCD28_CSR_RD() & ~(v)))
#define HW_DMA_TCD28_CSR_TOG(v)    (HW_DMA_TCD28_CSR_WR(HW_DMA_TCD28_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_CSR bitfields
 */

/*! @name Register DMA_TCD28_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD28_CSR_START      (0U)      //!< Bit position for DMA_TCD28_CSR_START.
#define BM_DMA_TCD28_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD28_CSR_START.
#define BS_DMA_TCD28_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD28_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_START field.
#define BR_DMA_TCD28_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_START.
#define BF_DMA_TCD28_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_START), uint16_t) & BM_DMA_TCD28_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD28_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD28_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD28_CSR_INTMAJOR.
#define BM_DMA_TCD28_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD28_CSR_INTMAJOR.
#define BS_DMA_TCD28_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD28_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_INTMAJOR field.
#define BR_DMA_TCD28_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_INTMAJOR.
#define BF_DMA_TCD28_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD28_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD28_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD28_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD28_CSR_INTHALF.
#define BM_DMA_TCD28_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD28_CSR_INTHALF.
#define BS_DMA_TCD28_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD28_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_INTHALF field.
#define BR_DMA_TCD28_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_INTHALF.
#define BF_DMA_TCD28_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_INTHALF), uint16_t) & BM_DMA_TCD28_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD28_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD28_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD28_CSR_DREQ.
#define BM_DMA_TCD28_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD28_CSR_DREQ.
#define BS_DMA_TCD28_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD28_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_DREQ field.
#define BR_DMA_TCD28_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_DREQ.
#define BF_DMA_TCD28_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_DREQ), uint16_t) & BM_DMA_TCD28_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD28_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD28_CSR_ESG      (4U)      //!< Bit position for DMA_TCD28_CSR_ESG.
#define BM_DMA_TCD28_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD28_CSR_ESG.
#define BS_DMA_TCD28_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD28_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_ESG field.
#define BR_DMA_TCD28_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_ESG.
#define BF_DMA_TCD28_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_ESG), uint16_t) & BM_DMA_TCD28_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD28_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD28_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD28_CSR_MAJORELINK.
#define BM_DMA_TCD28_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD28_CSR_MAJORELINK.
#define BS_DMA_TCD28_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD28_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_MAJORELINK field.
#define BR_DMA_TCD28_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_MAJORELINK.
#define BF_DMA_TCD28_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD28_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD28_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD28_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD28_CSR_ACTIVE.
#define BM_DMA_TCD28_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD28_CSR_ACTIVE.
#define BS_DMA_TCD28_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD28_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_ACTIVE field.
#define BR_DMA_TCD28_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_ACTIVE.
#define BF_DMA_TCD28_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_ACTIVE), uint16_t) & BM_DMA_TCD28_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD28_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD28_CSR_DONE      (7U)      //!< Bit position for DMA_TCD28_CSR_DONE.
#define BM_DMA_TCD28_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD28_CSR_DONE.
#define BS_DMA_TCD28_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD28_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_DONE field.
#define BR_DMA_TCD28_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_DONE.
#define BF_DMA_TCD28_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_DONE), uint16_t) & BM_DMA_TCD28_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD28_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_CSR_ADDR, BP_DMA_TCD28_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD28_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD28_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD28_CSR_MAJORLINKCH.
#define BM_DMA_TCD28_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD28_CSR_MAJORLINKCH.
#define BS_DMA_TCD28_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD28_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_MAJORLINKCH field.
#define BR_DMA_TCD28_CSR_MAJORLINKCH()   (HW_DMA_TCD28_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_MAJORLINKCH.
#define BF_DMA_TCD28_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD28_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD28_CSR_MAJORLINKCH(v)   (HW_DMA_TCD28_CSR_WR((HW_DMA_TCD28_CSR_RD() & ~BM_DMA_TCD28_CSR_MAJORLINKCH) | BF_DMA_TCD28_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD28_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD28_CSR_BWC      (14U)      //!< Bit position for DMA_TCD28_CSR_BWC.
#define BM_DMA_TCD28_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD28_CSR_BWC.
#define BS_DMA_TCD28_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD28_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_CSR_BWC field.
#define BR_DMA_TCD28_CSR_BWC()   (HW_DMA_TCD28_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD28_CSR_BWC.
#define BF_DMA_TCD28_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_CSR_BWC), uint16_t) & BM_DMA_TCD28_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD28_CSR_BWC(v)   (HW_DMA_TCD28_CSR_WR((HW_DMA_TCD28_CSR_RD() & ~BM_DMA_TCD28_CSR_BWC) | BF_DMA_TCD28_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd28_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd28_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd28_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD28_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x139eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_BITER_ELINKYES           (*(__IO hw_dma_tcd28_biter_elinkyes_t *) HW_DMA_TCD28_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD28_BITER_ELINKYES_RD()      (HW_DMA_TCD28_BITER_ELINKYES.U)
#define HW_DMA_TCD28_BITER_ELINKYES_WR(v)     (HW_DMA_TCD28_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD28_BITER_ELINKYES_SET(v)    (HW_DMA_TCD28_BITER_ELINKYES_WR(HW_DMA_TCD28_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD28_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD28_BITER_ELINKYES_WR(HW_DMA_TCD28_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD28_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD28_BITER_ELINKYES_WR(HW_DMA_TCD28_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD28_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD28_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD28_BITER_ELINKYES_BITER.
#define BM_DMA_TCD28_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD28_BITER_ELINKYES_BITER.
#define BS_DMA_TCD28_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD28_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD28_BITER_ELINKYES_BITER()   (HW_DMA_TCD28_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD28_BITER_ELINKYES_BITER.
#define BF_DMA_TCD28_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD28_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD28_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD28_BITER_ELINKYES_WR((HW_DMA_TCD28_BITER_ELINKYES_RD() & ~BM_DMA_TCD28_BITER_ELINKYES_BITER) | BF_DMA_TCD28_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD28_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD28_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD28_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD28_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD28_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD28_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD28_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD28_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD28_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD28_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD28_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD28_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD28_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD28_BITER_ELINKYES_WR((HW_DMA_TCD28_BITER_ELINKYES_RD() & ~BM_DMA_TCD28_BITER_ELINKYES_LINKCH) | BF_DMA_TCD28_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD28_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD28_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD28_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD28_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD28_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD28_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD28_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD28_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD28_BITER_ELINKYES_ADDR, BP_DMA_TCD28_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD28_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD28_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD28_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD28_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_BITER_ELINKYES_ADDR, BP_DMA_TCD28_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD28_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD28_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd28_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd28_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd28_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD28_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD28_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x139eU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD28_BITER_ELINKNO           (*(__IO hw_dma_tcd28_biter_elinkno_t *) HW_DMA_TCD28_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD28_BITER_ELINKNO_RD()      (HW_DMA_TCD28_BITER_ELINKNO.U)
#define HW_DMA_TCD28_BITER_ELINKNO_WR(v)     (HW_DMA_TCD28_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD28_BITER_ELINKNO_SET(v)    (HW_DMA_TCD28_BITER_ELINKNO_WR(HW_DMA_TCD28_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD28_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD28_BITER_ELINKNO_WR(HW_DMA_TCD28_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD28_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD28_BITER_ELINKNO_WR(HW_DMA_TCD28_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD28_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD28_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD28_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD28_BITER_ELINKNO_BITER.
#define BM_DMA_TCD28_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD28_BITER_ELINKNO_BITER.
#define BS_DMA_TCD28_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD28_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD28_BITER_ELINKNO_BITER()   (HW_DMA_TCD28_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD28_BITER_ELINKNO_BITER.
#define BF_DMA_TCD28_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD28_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD28_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD28_BITER_ELINKNO_WR((HW_DMA_TCD28_BITER_ELINKNO_RD() & ~BM_DMA_TCD28_BITER_ELINKNO_BITER) | BF_DMA_TCD28_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD28_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD28_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD28_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD28_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD28_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD28_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD28_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD28_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD28_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD28_BITER_ELINKNO_ADDR, BP_DMA_TCD28_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD28_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD28_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD28_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD28_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD28_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD28_BITER_ELINKNO_ADDR, BP_DMA_TCD28_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd29_saddr
{
    uint32_t U;
    struct _hw_dma_tcd29_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd29_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_SADDR register
 */
//@{
#define HW_DMA_TCD29_SADDR_ADDR      (REGS_DMA_BASE + 0x13a0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_SADDR           (*(__IO hw_dma_tcd29_saddr_t *) HW_DMA_TCD29_SADDR_ADDR)
#define HW_DMA_TCD29_SADDR_RD()      (HW_DMA_TCD29_SADDR.U)
#define HW_DMA_TCD29_SADDR_WR(v)     (HW_DMA_TCD29_SADDR.U = (v))
#define HW_DMA_TCD29_SADDR_SET(v)    (HW_DMA_TCD29_SADDR_WR(HW_DMA_TCD29_SADDR_RD() |  (v)))
#define HW_DMA_TCD29_SADDR_CLR(v)    (HW_DMA_TCD29_SADDR_WR(HW_DMA_TCD29_SADDR_RD() & ~(v)))
#define HW_DMA_TCD29_SADDR_TOG(v)    (HW_DMA_TCD29_SADDR_WR(HW_DMA_TCD29_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_SADDR bitfields
 */

/*! @name Register DMA_TCD29_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD29_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD29_SADDR_SADDR.
#define BM_DMA_TCD29_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD29_SADDR_SADDR.
#define BS_DMA_TCD29_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD29_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_SADDR_SADDR field.
#define BR_DMA_TCD29_SADDR_SADDR()   (HW_DMA_TCD29_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD29_SADDR_SADDR.
#define BF_DMA_TCD29_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_SADDR_SADDR), uint32_t) & BM_DMA_TCD29_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD29_SADDR_SADDR(v)   (HW_DMA_TCD29_SADDR_WR((HW_DMA_TCD29_SADDR_RD() & ~BM_DMA_TCD29_SADDR_SADDR) | BF_DMA_TCD29_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd29_soff
{
    uint16_t U;
    struct _hw_dma_tcd29_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd29_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_SOFF register
 */
//@{
#define HW_DMA_TCD29_SOFF_ADDR      (REGS_DMA_BASE + 0x13a4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_SOFF           (*(__IO hw_dma_tcd29_soff_t *) HW_DMA_TCD29_SOFF_ADDR)
#define HW_DMA_TCD29_SOFF_RD()      (HW_DMA_TCD29_SOFF.U)
#define HW_DMA_TCD29_SOFF_WR(v)     (HW_DMA_TCD29_SOFF.U = (v))
#define HW_DMA_TCD29_SOFF_SET(v)    (HW_DMA_TCD29_SOFF_WR(HW_DMA_TCD29_SOFF_RD() |  (v)))
#define HW_DMA_TCD29_SOFF_CLR(v)    (HW_DMA_TCD29_SOFF_WR(HW_DMA_TCD29_SOFF_RD() & ~(v)))
#define HW_DMA_TCD29_SOFF_TOG(v)    (HW_DMA_TCD29_SOFF_WR(HW_DMA_TCD29_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_SOFF bitfields
 */

/*! @name Register DMA_TCD29_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD29_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD29_SOFF_SOFF.
#define BM_DMA_TCD29_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD29_SOFF_SOFF.
#define BS_DMA_TCD29_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD29_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_SOFF_SOFF field.
#define BR_DMA_TCD29_SOFF_SOFF()   (HW_DMA_TCD29_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD29_SOFF_SOFF.
#define BF_DMA_TCD29_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_SOFF_SOFF), uint16_t) & BM_DMA_TCD29_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD29_SOFF_SOFF(v)   (HW_DMA_TCD29_SOFF_WR((HW_DMA_TCD29_SOFF_RD() & ~BM_DMA_TCD29_SOFF_SOFF) | BF_DMA_TCD29_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd29_attr
{
    uint16_t U;
    struct _hw_dma_tcd29_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd29_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_ATTR register
 */
//@{
#define HW_DMA_TCD29_ATTR_ADDR      (REGS_DMA_BASE + 0x13a6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_ATTR           (*(__IO hw_dma_tcd29_attr_t *) HW_DMA_TCD29_ATTR_ADDR)
#define HW_DMA_TCD29_ATTR_RD()      (HW_DMA_TCD29_ATTR.U)
#define HW_DMA_TCD29_ATTR_WR(v)     (HW_DMA_TCD29_ATTR.U = (v))
#define HW_DMA_TCD29_ATTR_SET(v)    (HW_DMA_TCD29_ATTR_WR(HW_DMA_TCD29_ATTR_RD() |  (v)))
#define HW_DMA_TCD29_ATTR_CLR(v)    (HW_DMA_TCD29_ATTR_WR(HW_DMA_TCD29_ATTR_RD() & ~(v)))
#define HW_DMA_TCD29_ATTR_TOG(v)    (HW_DMA_TCD29_ATTR_WR(HW_DMA_TCD29_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_ATTR bitfields
 */

/*! @name Register DMA_TCD29_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD29_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD29_ATTR_DSIZE.
#define BM_DMA_TCD29_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD29_ATTR_DSIZE.
#define BS_DMA_TCD29_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD29_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_ATTR_DSIZE field.
#define BR_DMA_TCD29_ATTR_DSIZE()   (HW_DMA_TCD29_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD29_ATTR_DSIZE.
#define BF_DMA_TCD29_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_ATTR_DSIZE), uint16_t) & BM_DMA_TCD29_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD29_ATTR_DSIZE(v)   (HW_DMA_TCD29_ATTR_WR((HW_DMA_TCD29_ATTR_RD() & ~BM_DMA_TCD29_ATTR_DSIZE) | BF_DMA_TCD29_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD29_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD29_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD29_ATTR_DMOD.
#define BM_DMA_TCD29_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD29_ATTR_DMOD.
#define BS_DMA_TCD29_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD29_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_ATTR_DMOD field.
#define BR_DMA_TCD29_ATTR_DMOD()   (HW_DMA_TCD29_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD29_ATTR_DMOD.
#define BF_DMA_TCD29_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_ATTR_DMOD), uint16_t) & BM_DMA_TCD29_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD29_ATTR_DMOD(v)   (HW_DMA_TCD29_ATTR_WR((HW_DMA_TCD29_ATTR_RD() & ~BM_DMA_TCD29_ATTR_DMOD) | BF_DMA_TCD29_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD29_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD29_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD29_ATTR_SSIZE.
#define BM_DMA_TCD29_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD29_ATTR_SSIZE.
#define BS_DMA_TCD29_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD29_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_ATTR_SSIZE field.
#define BR_DMA_TCD29_ATTR_SSIZE()   (HW_DMA_TCD29_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD29_ATTR_SSIZE.
#define BF_DMA_TCD29_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_ATTR_SSIZE), uint16_t) & BM_DMA_TCD29_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD29_ATTR_SSIZE(v)   (HW_DMA_TCD29_ATTR_WR((HW_DMA_TCD29_ATTR_RD() & ~BM_DMA_TCD29_ATTR_SSIZE) | BF_DMA_TCD29_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD29_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD29_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD29_ATTR_SMOD.
#define BM_DMA_TCD29_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD29_ATTR_SMOD.
#define BS_DMA_TCD29_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD29_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_ATTR_SMOD field.
#define BR_DMA_TCD29_ATTR_SMOD()   (HW_DMA_TCD29_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD29_ATTR_SMOD.
#define BF_DMA_TCD29_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_ATTR_SMOD), uint16_t) & BM_DMA_TCD29_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD29_ATTR_SMOD(v)   (HW_DMA_TCD29_ATTR_WR((HW_DMA_TCD29_ATTR_RD() & ~BM_DMA_TCD29_ATTR_SMOD) | BF_DMA_TCD29_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd29_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd29_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd29_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD29_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x13a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_NBYTES_MLNO           (*(__IO hw_dma_tcd29_nbytes_mlno_t *) HW_DMA_TCD29_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD29_NBYTES_MLNO_RD()      (HW_DMA_TCD29_NBYTES_MLNO.U)
#define HW_DMA_TCD29_NBYTES_MLNO_WR(v)     (HW_DMA_TCD29_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD29_NBYTES_MLNO_SET(v)    (HW_DMA_TCD29_NBYTES_MLNO_WR(HW_DMA_TCD29_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD29_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD29_NBYTES_MLNO_WR(HW_DMA_TCD29_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD29_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD29_NBYTES_MLNO_WR(HW_DMA_TCD29_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD29_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD29_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD29_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD29_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD29_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD29_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD29_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD29_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD29_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD29_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD29_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD29_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD29_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD29_NBYTES_MLNO_WR((HW_DMA_TCD29_NBYTES_MLNO_RD() & ~BM_DMA_TCD29_NBYTES_MLNO_NBYTES) | BF_DMA_TCD29_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd29_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd29_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd29_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD29_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x13a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd29_nbytes_mloffno_t *) HW_DMA_TCD29_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD29_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD29_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD29_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD29_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD29_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD29_NBYTES_MLOFFNO_WR(HW_DMA_TCD29_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD29_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD29_NBYTES_MLOFFNO_WR(HW_DMA_TCD29_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD29_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD29_NBYTES_MLOFFNO_WR(HW_DMA_TCD29_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD29_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD29_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD29_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD29_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD29_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD29_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD29_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD29_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD29_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD29_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD29_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD29_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD29_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD29_NBYTES_MLOFFNO_WR((HW_DMA_TCD29_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD29_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD29_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD29_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD29_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD29_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD29_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD29_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD29_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD29_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD29_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD29_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD29_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD29_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD29_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD29_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD29_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD29_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD29_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD29_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD29_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD29_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD29_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD29_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD29_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD29_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD29_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD29_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD29_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD29_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD29_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD29_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD29_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD29_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd29_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd29_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd29_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD29_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x13a8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd29_nbytes_mloffyes_t *) HW_DMA_TCD29_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD29_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD29_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD29_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD29_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD29_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD29_NBYTES_MLOFFYES_WR(HW_DMA_TCD29_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD29_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD29_NBYTES_MLOFFYES_WR(HW_DMA_TCD29_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD29_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD29_NBYTES_MLOFFYES_WR(HW_DMA_TCD29_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD29_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD29_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD29_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD29_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD29_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD29_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD29_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD29_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD29_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD29_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD29_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD29_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD29_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD29_NBYTES_MLOFFYES_WR((HW_DMA_TCD29_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD29_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD29_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD29_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD29_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD29_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD29_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD29_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD29_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD29_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD29_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD29_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD29_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD29_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD29_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD29_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD29_NBYTES_MLOFFYES_WR((HW_DMA_TCD29_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD29_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD29_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD29_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD29_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD29_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD29_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD29_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD29_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD29_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD29_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD29_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD29_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD29_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD29_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD29_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD29_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD29_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD29_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD29_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD29_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD29_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD29_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD29_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD29_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD29_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD29_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD29_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD29_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD29_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD29_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD29_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD29_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD29_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd29_slast
{
    uint32_t U;
    struct _hw_dma_tcd29_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd29_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_SLAST register
 */
//@{
#define HW_DMA_TCD29_SLAST_ADDR      (REGS_DMA_BASE + 0x13acU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_SLAST           (*(__IO hw_dma_tcd29_slast_t *) HW_DMA_TCD29_SLAST_ADDR)
#define HW_DMA_TCD29_SLAST_RD()      (HW_DMA_TCD29_SLAST.U)
#define HW_DMA_TCD29_SLAST_WR(v)     (HW_DMA_TCD29_SLAST.U = (v))
#define HW_DMA_TCD29_SLAST_SET(v)    (HW_DMA_TCD29_SLAST_WR(HW_DMA_TCD29_SLAST_RD() |  (v)))
#define HW_DMA_TCD29_SLAST_CLR(v)    (HW_DMA_TCD29_SLAST_WR(HW_DMA_TCD29_SLAST_RD() & ~(v)))
#define HW_DMA_TCD29_SLAST_TOG(v)    (HW_DMA_TCD29_SLAST_WR(HW_DMA_TCD29_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_SLAST bitfields
 */

/*! @name Register DMA_TCD29_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD29_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD29_SLAST_SLAST.
#define BM_DMA_TCD29_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD29_SLAST_SLAST.
#define BS_DMA_TCD29_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD29_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_SLAST_SLAST field.
#define BR_DMA_TCD29_SLAST_SLAST()   (HW_DMA_TCD29_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD29_SLAST_SLAST.
#define BF_DMA_TCD29_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_SLAST_SLAST), uint32_t) & BM_DMA_TCD29_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD29_SLAST_SLAST(v)   (HW_DMA_TCD29_SLAST_WR((HW_DMA_TCD29_SLAST_RD() & ~BM_DMA_TCD29_SLAST_SLAST) | BF_DMA_TCD29_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd29_daddr
{
    uint32_t U;
    struct _hw_dma_tcd29_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd29_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_DADDR register
 */
//@{
#define HW_DMA_TCD29_DADDR_ADDR      (REGS_DMA_BASE + 0x13b0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_DADDR           (*(__IO hw_dma_tcd29_daddr_t *) HW_DMA_TCD29_DADDR_ADDR)
#define HW_DMA_TCD29_DADDR_RD()      (HW_DMA_TCD29_DADDR.U)
#define HW_DMA_TCD29_DADDR_WR(v)     (HW_DMA_TCD29_DADDR.U = (v))
#define HW_DMA_TCD29_DADDR_SET(v)    (HW_DMA_TCD29_DADDR_WR(HW_DMA_TCD29_DADDR_RD() |  (v)))
#define HW_DMA_TCD29_DADDR_CLR(v)    (HW_DMA_TCD29_DADDR_WR(HW_DMA_TCD29_DADDR_RD() & ~(v)))
#define HW_DMA_TCD29_DADDR_TOG(v)    (HW_DMA_TCD29_DADDR_WR(HW_DMA_TCD29_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_DADDR bitfields
 */

/*! @name Register DMA_TCD29_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD29_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD29_DADDR_DADDR.
#define BM_DMA_TCD29_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD29_DADDR_DADDR.
#define BS_DMA_TCD29_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD29_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_DADDR_DADDR field.
#define BR_DMA_TCD29_DADDR_DADDR()   (HW_DMA_TCD29_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD29_DADDR_DADDR.
#define BF_DMA_TCD29_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_DADDR_DADDR), uint32_t) & BM_DMA_TCD29_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD29_DADDR_DADDR(v)   (HW_DMA_TCD29_DADDR_WR((HW_DMA_TCD29_DADDR_RD() & ~BM_DMA_TCD29_DADDR_DADDR) | BF_DMA_TCD29_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd29_doff
{
    uint16_t U;
    struct _hw_dma_tcd29_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd29_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_DOFF register
 */
//@{
#define HW_DMA_TCD29_DOFF_ADDR      (REGS_DMA_BASE + 0x13b4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_DOFF           (*(__IO hw_dma_tcd29_doff_t *) HW_DMA_TCD29_DOFF_ADDR)
#define HW_DMA_TCD29_DOFF_RD()      (HW_DMA_TCD29_DOFF.U)
#define HW_DMA_TCD29_DOFF_WR(v)     (HW_DMA_TCD29_DOFF.U = (v))
#define HW_DMA_TCD29_DOFF_SET(v)    (HW_DMA_TCD29_DOFF_WR(HW_DMA_TCD29_DOFF_RD() |  (v)))
#define HW_DMA_TCD29_DOFF_CLR(v)    (HW_DMA_TCD29_DOFF_WR(HW_DMA_TCD29_DOFF_RD() & ~(v)))
#define HW_DMA_TCD29_DOFF_TOG(v)    (HW_DMA_TCD29_DOFF_WR(HW_DMA_TCD29_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_DOFF bitfields
 */

/*! @name Register DMA_TCD29_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD29_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD29_DOFF_DOFF.
#define BM_DMA_TCD29_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD29_DOFF_DOFF.
#define BS_DMA_TCD29_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD29_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_DOFF_DOFF field.
#define BR_DMA_TCD29_DOFF_DOFF()   (HW_DMA_TCD29_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD29_DOFF_DOFF.
#define BF_DMA_TCD29_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_DOFF_DOFF), uint16_t) & BM_DMA_TCD29_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD29_DOFF_DOFF(v)   (HW_DMA_TCD29_DOFF_WR((HW_DMA_TCD29_DOFF_RD() & ~BM_DMA_TCD29_DOFF_DOFF) | BF_DMA_TCD29_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd29_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd29_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd29_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD29_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x13b6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_CITER_ELINKYES           (*(__IO hw_dma_tcd29_citer_elinkyes_t *) HW_DMA_TCD29_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD29_CITER_ELINKYES_RD()      (HW_DMA_TCD29_CITER_ELINKYES.U)
#define HW_DMA_TCD29_CITER_ELINKYES_WR(v)     (HW_DMA_TCD29_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD29_CITER_ELINKYES_SET(v)    (HW_DMA_TCD29_CITER_ELINKYES_WR(HW_DMA_TCD29_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD29_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD29_CITER_ELINKYES_WR(HW_DMA_TCD29_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD29_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD29_CITER_ELINKYES_WR(HW_DMA_TCD29_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD29_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD29_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD29_CITER_ELINKYES_CITER.
#define BM_DMA_TCD29_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD29_CITER_ELINKYES_CITER.
#define BS_DMA_TCD29_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD29_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD29_CITER_ELINKYES_CITER()   (HW_DMA_TCD29_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD29_CITER_ELINKYES_CITER.
#define BF_DMA_TCD29_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD29_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD29_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD29_CITER_ELINKYES_WR((HW_DMA_TCD29_CITER_ELINKYES_RD() & ~BM_DMA_TCD29_CITER_ELINKYES_CITER) | BF_DMA_TCD29_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD29_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD29_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD29_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD29_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD29_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD29_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD29_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD29_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD29_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD29_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD29_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD29_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD29_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD29_CITER_ELINKYES_WR((HW_DMA_TCD29_CITER_ELINKYES_RD() & ~BM_DMA_TCD29_CITER_ELINKYES_LINKCH) | BF_DMA_TCD29_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD29_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD29_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD29_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD29_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD29_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD29_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD29_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD29_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD29_CITER_ELINKYES_ADDR, BP_DMA_TCD29_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD29_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD29_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD29_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD29_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CITER_ELINKYES_ADDR, BP_DMA_TCD29_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd29_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd29_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd29_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD29_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x13b6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_CITER_ELINKNO           (*(__IO hw_dma_tcd29_citer_elinkno_t *) HW_DMA_TCD29_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD29_CITER_ELINKNO_RD()      (HW_DMA_TCD29_CITER_ELINKNO.U)
#define HW_DMA_TCD29_CITER_ELINKNO_WR(v)     (HW_DMA_TCD29_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD29_CITER_ELINKNO_SET(v)    (HW_DMA_TCD29_CITER_ELINKNO_WR(HW_DMA_TCD29_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD29_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD29_CITER_ELINKNO_WR(HW_DMA_TCD29_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD29_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD29_CITER_ELINKNO_WR(HW_DMA_TCD29_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD29_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD29_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD29_CITER_ELINKNO_CITER.
#define BM_DMA_TCD29_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD29_CITER_ELINKNO_CITER.
#define BS_DMA_TCD29_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD29_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD29_CITER_ELINKNO_CITER()   (HW_DMA_TCD29_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD29_CITER_ELINKNO_CITER.
#define BF_DMA_TCD29_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD29_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD29_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD29_CITER_ELINKNO_WR((HW_DMA_TCD29_CITER_ELINKNO_RD() & ~BM_DMA_TCD29_CITER_ELINKNO_CITER) | BF_DMA_TCD29_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD29_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD29_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD29_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD29_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD29_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD29_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD29_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD29_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD29_CITER_ELINKNO_ADDR, BP_DMA_TCD29_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD29_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD29_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD29_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD29_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CITER_ELINKNO_ADDR, BP_DMA_TCD29_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd29_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd29_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd29_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_DLASTSGA register
 */
//@{
#define HW_DMA_TCD29_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x13b8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_DLASTSGA           (*(__IO hw_dma_tcd29_dlastsga_t *) HW_DMA_TCD29_DLASTSGA_ADDR)
#define HW_DMA_TCD29_DLASTSGA_RD()      (HW_DMA_TCD29_DLASTSGA.U)
#define HW_DMA_TCD29_DLASTSGA_WR(v)     (HW_DMA_TCD29_DLASTSGA.U = (v))
#define HW_DMA_TCD29_DLASTSGA_SET(v)    (HW_DMA_TCD29_DLASTSGA_WR(HW_DMA_TCD29_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD29_DLASTSGA_CLR(v)    (HW_DMA_TCD29_DLASTSGA_WR(HW_DMA_TCD29_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD29_DLASTSGA_TOG(v)    (HW_DMA_TCD29_DLASTSGA_WR(HW_DMA_TCD29_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD29_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD29_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD29_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD29_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD29_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD29_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD29_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD29_DLASTSGA_DLASTSGA()   (HW_DMA_TCD29_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD29_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD29_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD29_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD29_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD29_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD29_DLASTSGA_WR((HW_DMA_TCD29_DLASTSGA_RD() & ~BM_DMA_TCD29_DLASTSGA_DLASTSGA) | BF_DMA_TCD29_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd29_csr
{
    uint16_t U;
    struct _hw_dma_tcd29_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd29_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_CSR register
 */
//@{
#define HW_DMA_TCD29_CSR_ADDR      (REGS_DMA_BASE + 0x13bcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_CSR           (*(__IO hw_dma_tcd29_csr_t *) HW_DMA_TCD29_CSR_ADDR)
#define HW_DMA_TCD29_CSR_RD()      (HW_DMA_TCD29_CSR.U)
#define HW_DMA_TCD29_CSR_WR(v)     (HW_DMA_TCD29_CSR.U = (v))
#define HW_DMA_TCD29_CSR_SET(v)    (HW_DMA_TCD29_CSR_WR(HW_DMA_TCD29_CSR_RD() |  (v)))
#define HW_DMA_TCD29_CSR_CLR(v)    (HW_DMA_TCD29_CSR_WR(HW_DMA_TCD29_CSR_RD() & ~(v)))
#define HW_DMA_TCD29_CSR_TOG(v)    (HW_DMA_TCD29_CSR_WR(HW_DMA_TCD29_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_CSR bitfields
 */

/*! @name Register DMA_TCD29_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD29_CSR_START      (0U)      //!< Bit position for DMA_TCD29_CSR_START.
#define BM_DMA_TCD29_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD29_CSR_START.
#define BS_DMA_TCD29_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD29_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_START field.
#define BR_DMA_TCD29_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_START.
#define BF_DMA_TCD29_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_START), uint16_t) & BM_DMA_TCD29_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD29_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD29_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD29_CSR_INTMAJOR.
#define BM_DMA_TCD29_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD29_CSR_INTMAJOR.
#define BS_DMA_TCD29_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD29_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_INTMAJOR field.
#define BR_DMA_TCD29_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_INTMAJOR.
#define BF_DMA_TCD29_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD29_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD29_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD29_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD29_CSR_INTHALF.
#define BM_DMA_TCD29_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD29_CSR_INTHALF.
#define BS_DMA_TCD29_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD29_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_INTHALF field.
#define BR_DMA_TCD29_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_INTHALF.
#define BF_DMA_TCD29_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_INTHALF), uint16_t) & BM_DMA_TCD29_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD29_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD29_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD29_CSR_DREQ.
#define BM_DMA_TCD29_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD29_CSR_DREQ.
#define BS_DMA_TCD29_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD29_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_DREQ field.
#define BR_DMA_TCD29_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_DREQ.
#define BF_DMA_TCD29_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_DREQ), uint16_t) & BM_DMA_TCD29_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD29_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD29_CSR_ESG      (4U)      //!< Bit position for DMA_TCD29_CSR_ESG.
#define BM_DMA_TCD29_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD29_CSR_ESG.
#define BS_DMA_TCD29_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD29_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_ESG field.
#define BR_DMA_TCD29_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_ESG.
#define BF_DMA_TCD29_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_ESG), uint16_t) & BM_DMA_TCD29_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD29_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD29_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD29_CSR_MAJORELINK.
#define BM_DMA_TCD29_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD29_CSR_MAJORELINK.
#define BS_DMA_TCD29_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD29_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_MAJORELINK field.
#define BR_DMA_TCD29_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_MAJORELINK.
#define BF_DMA_TCD29_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD29_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD29_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD29_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD29_CSR_ACTIVE.
#define BM_DMA_TCD29_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD29_CSR_ACTIVE.
#define BS_DMA_TCD29_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD29_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_ACTIVE field.
#define BR_DMA_TCD29_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_ACTIVE.
#define BF_DMA_TCD29_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_ACTIVE), uint16_t) & BM_DMA_TCD29_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD29_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD29_CSR_DONE      (7U)      //!< Bit position for DMA_TCD29_CSR_DONE.
#define BM_DMA_TCD29_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD29_CSR_DONE.
#define BS_DMA_TCD29_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD29_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_DONE field.
#define BR_DMA_TCD29_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_DONE.
#define BF_DMA_TCD29_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_DONE), uint16_t) & BM_DMA_TCD29_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD29_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_CSR_ADDR, BP_DMA_TCD29_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD29_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD29_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD29_CSR_MAJORLINKCH.
#define BM_DMA_TCD29_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD29_CSR_MAJORLINKCH.
#define BS_DMA_TCD29_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD29_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_MAJORLINKCH field.
#define BR_DMA_TCD29_CSR_MAJORLINKCH()   (HW_DMA_TCD29_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_MAJORLINKCH.
#define BF_DMA_TCD29_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD29_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD29_CSR_MAJORLINKCH(v)   (HW_DMA_TCD29_CSR_WR((HW_DMA_TCD29_CSR_RD() & ~BM_DMA_TCD29_CSR_MAJORLINKCH) | BF_DMA_TCD29_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD29_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD29_CSR_BWC      (14U)      //!< Bit position for DMA_TCD29_CSR_BWC.
#define BM_DMA_TCD29_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD29_CSR_BWC.
#define BS_DMA_TCD29_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD29_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_CSR_BWC field.
#define BR_DMA_TCD29_CSR_BWC()   (HW_DMA_TCD29_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD29_CSR_BWC.
#define BF_DMA_TCD29_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_CSR_BWC), uint16_t) & BM_DMA_TCD29_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD29_CSR_BWC(v)   (HW_DMA_TCD29_CSR_WR((HW_DMA_TCD29_CSR_RD() & ~BM_DMA_TCD29_CSR_BWC) | BF_DMA_TCD29_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd29_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd29_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd29_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD29_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x13beU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_BITER_ELINKYES           (*(__IO hw_dma_tcd29_biter_elinkyes_t *) HW_DMA_TCD29_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD29_BITER_ELINKYES_RD()      (HW_DMA_TCD29_BITER_ELINKYES.U)
#define HW_DMA_TCD29_BITER_ELINKYES_WR(v)     (HW_DMA_TCD29_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD29_BITER_ELINKYES_SET(v)    (HW_DMA_TCD29_BITER_ELINKYES_WR(HW_DMA_TCD29_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD29_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD29_BITER_ELINKYES_WR(HW_DMA_TCD29_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD29_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD29_BITER_ELINKYES_WR(HW_DMA_TCD29_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD29_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD29_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD29_BITER_ELINKYES_BITER.
#define BM_DMA_TCD29_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD29_BITER_ELINKYES_BITER.
#define BS_DMA_TCD29_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD29_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD29_BITER_ELINKYES_BITER()   (HW_DMA_TCD29_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD29_BITER_ELINKYES_BITER.
#define BF_DMA_TCD29_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD29_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD29_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD29_BITER_ELINKYES_WR((HW_DMA_TCD29_BITER_ELINKYES_RD() & ~BM_DMA_TCD29_BITER_ELINKYES_BITER) | BF_DMA_TCD29_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD29_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD29_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD29_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD29_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD29_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD29_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD29_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD29_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD29_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD29_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD29_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD29_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD29_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD29_BITER_ELINKYES_WR((HW_DMA_TCD29_BITER_ELINKYES_RD() & ~BM_DMA_TCD29_BITER_ELINKYES_LINKCH) | BF_DMA_TCD29_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD29_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD29_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD29_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD29_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD29_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD29_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD29_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD29_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD29_BITER_ELINKYES_ADDR, BP_DMA_TCD29_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD29_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD29_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD29_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD29_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_BITER_ELINKYES_ADDR, BP_DMA_TCD29_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD29_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD29_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd29_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd29_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd29_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD29_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD29_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x13beU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD29_BITER_ELINKNO           (*(__IO hw_dma_tcd29_biter_elinkno_t *) HW_DMA_TCD29_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD29_BITER_ELINKNO_RD()      (HW_DMA_TCD29_BITER_ELINKNO.U)
#define HW_DMA_TCD29_BITER_ELINKNO_WR(v)     (HW_DMA_TCD29_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD29_BITER_ELINKNO_SET(v)    (HW_DMA_TCD29_BITER_ELINKNO_WR(HW_DMA_TCD29_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD29_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD29_BITER_ELINKNO_WR(HW_DMA_TCD29_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD29_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD29_BITER_ELINKNO_WR(HW_DMA_TCD29_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD29_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD29_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD29_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD29_BITER_ELINKNO_BITER.
#define BM_DMA_TCD29_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD29_BITER_ELINKNO_BITER.
#define BS_DMA_TCD29_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD29_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD29_BITER_ELINKNO_BITER()   (HW_DMA_TCD29_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD29_BITER_ELINKNO_BITER.
#define BF_DMA_TCD29_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD29_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD29_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD29_BITER_ELINKNO_WR((HW_DMA_TCD29_BITER_ELINKNO_RD() & ~BM_DMA_TCD29_BITER_ELINKNO_BITER) | BF_DMA_TCD29_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD29_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD29_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD29_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD29_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD29_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD29_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD29_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD29_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD29_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD29_BITER_ELINKNO_ADDR, BP_DMA_TCD29_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD29_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD29_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD29_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD29_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD29_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD29_BITER_ELINKNO_ADDR, BP_DMA_TCD29_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd30_saddr
{
    uint32_t U;
    struct _hw_dma_tcd30_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd30_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_SADDR register
 */
//@{
#define HW_DMA_TCD30_SADDR_ADDR      (REGS_DMA_BASE + 0x13c0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_SADDR           (*(__IO hw_dma_tcd30_saddr_t *) HW_DMA_TCD30_SADDR_ADDR)
#define HW_DMA_TCD30_SADDR_RD()      (HW_DMA_TCD30_SADDR.U)
#define HW_DMA_TCD30_SADDR_WR(v)     (HW_DMA_TCD30_SADDR.U = (v))
#define HW_DMA_TCD30_SADDR_SET(v)    (HW_DMA_TCD30_SADDR_WR(HW_DMA_TCD30_SADDR_RD() |  (v)))
#define HW_DMA_TCD30_SADDR_CLR(v)    (HW_DMA_TCD30_SADDR_WR(HW_DMA_TCD30_SADDR_RD() & ~(v)))
#define HW_DMA_TCD30_SADDR_TOG(v)    (HW_DMA_TCD30_SADDR_WR(HW_DMA_TCD30_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_SADDR bitfields
 */

/*! @name Register DMA_TCD30_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD30_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD30_SADDR_SADDR.
#define BM_DMA_TCD30_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD30_SADDR_SADDR.
#define BS_DMA_TCD30_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD30_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_SADDR_SADDR field.
#define BR_DMA_TCD30_SADDR_SADDR()   (HW_DMA_TCD30_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD30_SADDR_SADDR.
#define BF_DMA_TCD30_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_SADDR_SADDR), uint32_t) & BM_DMA_TCD30_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD30_SADDR_SADDR(v)   (HW_DMA_TCD30_SADDR_WR((HW_DMA_TCD30_SADDR_RD() & ~BM_DMA_TCD30_SADDR_SADDR) | BF_DMA_TCD30_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd30_soff
{
    uint16_t U;
    struct _hw_dma_tcd30_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd30_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_SOFF register
 */
//@{
#define HW_DMA_TCD30_SOFF_ADDR      (REGS_DMA_BASE + 0x13c4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_SOFF           (*(__IO hw_dma_tcd30_soff_t *) HW_DMA_TCD30_SOFF_ADDR)
#define HW_DMA_TCD30_SOFF_RD()      (HW_DMA_TCD30_SOFF.U)
#define HW_DMA_TCD30_SOFF_WR(v)     (HW_DMA_TCD30_SOFF.U = (v))
#define HW_DMA_TCD30_SOFF_SET(v)    (HW_DMA_TCD30_SOFF_WR(HW_DMA_TCD30_SOFF_RD() |  (v)))
#define HW_DMA_TCD30_SOFF_CLR(v)    (HW_DMA_TCD30_SOFF_WR(HW_DMA_TCD30_SOFF_RD() & ~(v)))
#define HW_DMA_TCD30_SOFF_TOG(v)    (HW_DMA_TCD30_SOFF_WR(HW_DMA_TCD30_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_SOFF bitfields
 */

/*! @name Register DMA_TCD30_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD30_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD30_SOFF_SOFF.
#define BM_DMA_TCD30_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD30_SOFF_SOFF.
#define BS_DMA_TCD30_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD30_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_SOFF_SOFF field.
#define BR_DMA_TCD30_SOFF_SOFF()   (HW_DMA_TCD30_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD30_SOFF_SOFF.
#define BF_DMA_TCD30_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_SOFF_SOFF), uint16_t) & BM_DMA_TCD30_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD30_SOFF_SOFF(v)   (HW_DMA_TCD30_SOFF_WR((HW_DMA_TCD30_SOFF_RD() & ~BM_DMA_TCD30_SOFF_SOFF) | BF_DMA_TCD30_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd30_attr
{
    uint16_t U;
    struct _hw_dma_tcd30_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd30_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_ATTR register
 */
//@{
#define HW_DMA_TCD30_ATTR_ADDR      (REGS_DMA_BASE + 0x13c6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_ATTR           (*(__IO hw_dma_tcd30_attr_t *) HW_DMA_TCD30_ATTR_ADDR)
#define HW_DMA_TCD30_ATTR_RD()      (HW_DMA_TCD30_ATTR.U)
#define HW_DMA_TCD30_ATTR_WR(v)     (HW_DMA_TCD30_ATTR.U = (v))
#define HW_DMA_TCD30_ATTR_SET(v)    (HW_DMA_TCD30_ATTR_WR(HW_DMA_TCD30_ATTR_RD() |  (v)))
#define HW_DMA_TCD30_ATTR_CLR(v)    (HW_DMA_TCD30_ATTR_WR(HW_DMA_TCD30_ATTR_RD() & ~(v)))
#define HW_DMA_TCD30_ATTR_TOG(v)    (HW_DMA_TCD30_ATTR_WR(HW_DMA_TCD30_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_ATTR bitfields
 */

/*! @name Register DMA_TCD30_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD30_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD30_ATTR_DSIZE.
#define BM_DMA_TCD30_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD30_ATTR_DSIZE.
#define BS_DMA_TCD30_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD30_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_ATTR_DSIZE field.
#define BR_DMA_TCD30_ATTR_DSIZE()   (HW_DMA_TCD30_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD30_ATTR_DSIZE.
#define BF_DMA_TCD30_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_ATTR_DSIZE), uint16_t) & BM_DMA_TCD30_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD30_ATTR_DSIZE(v)   (HW_DMA_TCD30_ATTR_WR((HW_DMA_TCD30_ATTR_RD() & ~BM_DMA_TCD30_ATTR_DSIZE) | BF_DMA_TCD30_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD30_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD30_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD30_ATTR_DMOD.
#define BM_DMA_TCD30_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD30_ATTR_DMOD.
#define BS_DMA_TCD30_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD30_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_ATTR_DMOD field.
#define BR_DMA_TCD30_ATTR_DMOD()   (HW_DMA_TCD30_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD30_ATTR_DMOD.
#define BF_DMA_TCD30_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_ATTR_DMOD), uint16_t) & BM_DMA_TCD30_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD30_ATTR_DMOD(v)   (HW_DMA_TCD30_ATTR_WR((HW_DMA_TCD30_ATTR_RD() & ~BM_DMA_TCD30_ATTR_DMOD) | BF_DMA_TCD30_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD30_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD30_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD30_ATTR_SSIZE.
#define BM_DMA_TCD30_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD30_ATTR_SSIZE.
#define BS_DMA_TCD30_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD30_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_ATTR_SSIZE field.
#define BR_DMA_TCD30_ATTR_SSIZE()   (HW_DMA_TCD30_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD30_ATTR_SSIZE.
#define BF_DMA_TCD30_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_ATTR_SSIZE), uint16_t) & BM_DMA_TCD30_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD30_ATTR_SSIZE(v)   (HW_DMA_TCD30_ATTR_WR((HW_DMA_TCD30_ATTR_RD() & ~BM_DMA_TCD30_ATTR_SSIZE) | BF_DMA_TCD30_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD30_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD30_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD30_ATTR_SMOD.
#define BM_DMA_TCD30_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD30_ATTR_SMOD.
#define BS_DMA_TCD30_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD30_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_ATTR_SMOD field.
#define BR_DMA_TCD30_ATTR_SMOD()   (HW_DMA_TCD30_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD30_ATTR_SMOD.
#define BF_DMA_TCD30_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_ATTR_SMOD), uint16_t) & BM_DMA_TCD30_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD30_ATTR_SMOD(v)   (HW_DMA_TCD30_ATTR_WR((HW_DMA_TCD30_ATTR_RD() & ~BM_DMA_TCD30_ATTR_SMOD) | BF_DMA_TCD30_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd30_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd30_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd30_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD30_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x13c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_NBYTES_MLNO           (*(__IO hw_dma_tcd30_nbytes_mlno_t *) HW_DMA_TCD30_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD30_NBYTES_MLNO_RD()      (HW_DMA_TCD30_NBYTES_MLNO.U)
#define HW_DMA_TCD30_NBYTES_MLNO_WR(v)     (HW_DMA_TCD30_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD30_NBYTES_MLNO_SET(v)    (HW_DMA_TCD30_NBYTES_MLNO_WR(HW_DMA_TCD30_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD30_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD30_NBYTES_MLNO_WR(HW_DMA_TCD30_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD30_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD30_NBYTES_MLNO_WR(HW_DMA_TCD30_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD30_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD30_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD30_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD30_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD30_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD30_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD30_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD30_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD30_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD30_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD30_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD30_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD30_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD30_NBYTES_MLNO_WR((HW_DMA_TCD30_NBYTES_MLNO_RD() & ~BM_DMA_TCD30_NBYTES_MLNO_NBYTES) | BF_DMA_TCD30_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd30_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd30_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd30_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD30_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x13c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd30_nbytes_mloffno_t *) HW_DMA_TCD30_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD30_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD30_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD30_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD30_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD30_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD30_NBYTES_MLOFFNO_WR(HW_DMA_TCD30_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD30_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD30_NBYTES_MLOFFNO_WR(HW_DMA_TCD30_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD30_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD30_NBYTES_MLOFFNO_WR(HW_DMA_TCD30_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD30_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD30_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD30_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD30_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD30_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD30_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD30_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD30_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD30_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD30_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD30_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD30_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD30_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD30_NBYTES_MLOFFNO_WR((HW_DMA_TCD30_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD30_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD30_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD30_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD30_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD30_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD30_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD30_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD30_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD30_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD30_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD30_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD30_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD30_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD30_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD30_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD30_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD30_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD30_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD30_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD30_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD30_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD30_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD30_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD30_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD30_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD30_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD30_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD30_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD30_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD30_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD30_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD30_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD30_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd30_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd30_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd30_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD30_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x13c8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd30_nbytes_mloffyes_t *) HW_DMA_TCD30_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD30_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD30_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD30_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD30_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD30_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD30_NBYTES_MLOFFYES_WR(HW_DMA_TCD30_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD30_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD30_NBYTES_MLOFFYES_WR(HW_DMA_TCD30_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD30_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD30_NBYTES_MLOFFYES_WR(HW_DMA_TCD30_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD30_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD30_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD30_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD30_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD30_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD30_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD30_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD30_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD30_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD30_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD30_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD30_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD30_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD30_NBYTES_MLOFFYES_WR((HW_DMA_TCD30_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD30_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD30_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD30_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD30_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD30_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD30_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD30_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD30_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD30_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD30_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD30_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD30_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD30_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD30_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD30_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD30_NBYTES_MLOFFYES_WR((HW_DMA_TCD30_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD30_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD30_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD30_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD30_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD30_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD30_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD30_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD30_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD30_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD30_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD30_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD30_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD30_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD30_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD30_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD30_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD30_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD30_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD30_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD30_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD30_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD30_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD30_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD30_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD30_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD30_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD30_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD30_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD30_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD30_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD30_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD30_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD30_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd30_slast
{
    uint32_t U;
    struct _hw_dma_tcd30_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd30_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_SLAST register
 */
//@{
#define HW_DMA_TCD30_SLAST_ADDR      (REGS_DMA_BASE + 0x13ccU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_SLAST           (*(__IO hw_dma_tcd30_slast_t *) HW_DMA_TCD30_SLAST_ADDR)
#define HW_DMA_TCD30_SLAST_RD()      (HW_DMA_TCD30_SLAST.U)
#define HW_DMA_TCD30_SLAST_WR(v)     (HW_DMA_TCD30_SLAST.U = (v))
#define HW_DMA_TCD30_SLAST_SET(v)    (HW_DMA_TCD30_SLAST_WR(HW_DMA_TCD30_SLAST_RD() |  (v)))
#define HW_DMA_TCD30_SLAST_CLR(v)    (HW_DMA_TCD30_SLAST_WR(HW_DMA_TCD30_SLAST_RD() & ~(v)))
#define HW_DMA_TCD30_SLAST_TOG(v)    (HW_DMA_TCD30_SLAST_WR(HW_DMA_TCD30_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_SLAST bitfields
 */

/*! @name Register DMA_TCD30_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD30_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD30_SLAST_SLAST.
#define BM_DMA_TCD30_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD30_SLAST_SLAST.
#define BS_DMA_TCD30_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD30_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_SLAST_SLAST field.
#define BR_DMA_TCD30_SLAST_SLAST()   (HW_DMA_TCD30_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD30_SLAST_SLAST.
#define BF_DMA_TCD30_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_SLAST_SLAST), uint32_t) & BM_DMA_TCD30_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD30_SLAST_SLAST(v)   (HW_DMA_TCD30_SLAST_WR((HW_DMA_TCD30_SLAST_RD() & ~BM_DMA_TCD30_SLAST_SLAST) | BF_DMA_TCD30_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd30_daddr
{
    uint32_t U;
    struct _hw_dma_tcd30_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd30_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_DADDR register
 */
//@{
#define HW_DMA_TCD30_DADDR_ADDR      (REGS_DMA_BASE + 0x13d0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_DADDR           (*(__IO hw_dma_tcd30_daddr_t *) HW_DMA_TCD30_DADDR_ADDR)
#define HW_DMA_TCD30_DADDR_RD()      (HW_DMA_TCD30_DADDR.U)
#define HW_DMA_TCD30_DADDR_WR(v)     (HW_DMA_TCD30_DADDR.U = (v))
#define HW_DMA_TCD30_DADDR_SET(v)    (HW_DMA_TCD30_DADDR_WR(HW_DMA_TCD30_DADDR_RD() |  (v)))
#define HW_DMA_TCD30_DADDR_CLR(v)    (HW_DMA_TCD30_DADDR_WR(HW_DMA_TCD30_DADDR_RD() & ~(v)))
#define HW_DMA_TCD30_DADDR_TOG(v)    (HW_DMA_TCD30_DADDR_WR(HW_DMA_TCD30_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_DADDR bitfields
 */

/*! @name Register DMA_TCD30_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD30_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD30_DADDR_DADDR.
#define BM_DMA_TCD30_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD30_DADDR_DADDR.
#define BS_DMA_TCD30_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD30_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_DADDR_DADDR field.
#define BR_DMA_TCD30_DADDR_DADDR()   (HW_DMA_TCD30_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD30_DADDR_DADDR.
#define BF_DMA_TCD30_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_DADDR_DADDR), uint32_t) & BM_DMA_TCD30_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD30_DADDR_DADDR(v)   (HW_DMA_TCD30_DADDR_WR((HW_DMA_TCD30_DADDR_RD() & ~BM_DMA_TCD30_DADDR_DADDR) | BF_DMA_TCD30_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd30_doff
{
    uint16_t U;
    struct _hw_dma_tcd30_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd30_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_DOFF register
 */
//@{
#define HW_DMA_TCD30_DOFF_ADDR      (REGS_DMA_BASE + 0x13d4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_DOFF           (*(__IO hw_dma_tcd30_doff_t *) HW_DMA_TCD30_DOFF_ADDR)
#define HW_DMA_TCD30_DOFF_RD()      (HW_DMA_TCD30_DOFF.U)
#define HW_DMA_TCD30_DOFF_WR(v)     (HW_DMA_TCD30_DOFF.U = (v))
#define HW_DMA_TCD30_DOFF_SET(v)    (HW_DMA_TCD30_DOFF_WR(HW_DMA_TCD30_DOFF_RD() |  (v)))
#define HW_DMA_TCD30_DOFF_CLR(v)    (HW_DMA_TCD30_DOFF_WR(HW_DMA_TCD30_DOFF_RD() & ~(v)))
#define HW_DMA_TCD30_DOFF_TOG(v)    (HW_DMA_TCD30_DOFF_WR(HW_DMA_TCD30_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_DOFF bitfields
 */

/*! @name Register DMA_TCD30_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD30_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD30_DOFF_DOFF.
#define BM_DMA_TCD30_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD30_DOFF_DOFF.
#define BS_DMA_TCD30_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD30_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_DOFF_DOFF field.
#define BR_DMA_TCD30_DOFF_DOFF()   (HW_DMA_TCD30_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD30_DOFF_DOFF.
#define BF_DMA_TCD30_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_DOFF_DOFF), uint16_t) & BM_DMA_TCD30_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD30_DOFF_DOFF(v)   (HW_DMA_TCD30_DOFF_WR((HW_DMA_TCD30_DOFF_RD() & ~BM_DMA_TCD30_DOFF_DOFF) | BF_DMA_TCD30_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd30_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd30_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd30_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD30_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x13d6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_CITER_ELINKYES           (*(__IO hw_dma_tcd30_citer_elinkyes_t *) HW_DMA_TCD30_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD30_CITER_ELINKYES_RD()      (HW_DMA_TCD30_CITER_ELINKYES.U)
#define HW_DMA_TCD30_CITER_ELINKYES_WR(v)     (HW_DMA_TCD30_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD30_CITER_ELINKYES_SET(v)    (HW_DMA_TCD30_CITER_ELINKYES_WR(HW_DMA_TCD30_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD30_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD30_CITER_ELINKYES_WR(HW_DMA_TCD30_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD30_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD30_CITER_ELINKYES_WR(HW_DMA_TCD30_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD30_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD30_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD30_CITER_ELINKYES_CITER.
#define BM_DMA_TCD30_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD30_CITER_ELINKYES_CITER.
#define BS_DMA_TCD30_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD30_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD30_CITER_ELINKYES_CITER()   (HW_DMA_TCD30_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD30_CITER_ELINKYES_CITER.
#define BF_DMA_TCD30_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD30_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD30_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD30_CITER_ELINKYES_WR((HW_DMA_TCD30_CITER_ELINKYES_RD() & ~BM_DMA_TCD30_CITER_ELINKYES_CITER) | BF_DMA_TCD30_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD30_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD30_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD30_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD30_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD30_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD30_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD30_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD30_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD30_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD30_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD30_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD30_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD30_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD30_CITER_ELINKYES_WR((HW_DMA_TCD30_CITER_ELINKYES_RD() & ~BM_DMA_TCD30_CITER_ELINKYES_LINKCH) | BF_DMA_TCD30_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD30_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD30_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD30_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD30_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD30_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD30_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD30_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD30_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD30_CITER_ELINKYES_ADDR, BP_DMA_TCD30_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD30_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD30_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD30_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD30_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CITER_ELINKYES_ADDR, BP_DMA_TCD30_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd30_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd30_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd30_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD30_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x13d6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_CITER_ELINKNO           (*(__IO hw_dma_tcd30_citer_elinkno_t *) HW_DMA_TCD30_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD30_CITER_ELINKNO_RD()      (HW_DMA_TCD30_CITER_ELINKNO.U)
#define HW_DMA_TCD30_CITER_ELINKNO_WR(v)     (HW_DMA_TCD30_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD30_CITER_ELINKNO_SET(v)    (HW_DMA_TCD30_CITER_ELINKNO_WR(HW_DMA_TCD30_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD30_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD30_CITER_ELINKNO_WR(HW_DMA_TCD30_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD30_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD30_CITER_ELINKNO_WR(HW_DMA_TCD30_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD30_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD30_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD30_CITER_ELINKNO_CITER.
#define BM_DMA_TCD30_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD30_CITER_ELINKNO_CITER.
#define BS_DMA_TCD30_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD30_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD30_CITER_ELINKNO_CITER()   (HW_DMA_TCD30_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD30_CITER_ELINKNO_CITER.
#define BF_DMA_TCD30_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD30_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD30_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD30_CITER_ELINKNO_WR((HW_DMA_TCD30_CITER_ELINKNO_RD() & ~BM_DMA_TCD30_CITER_ELINKNO_CITER) | BF_DMA_TCD30_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD30_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD30_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD30_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD30_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD30_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD30_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD30_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD30_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD30_CITER_ELINKNO_ADDR, BP_DMA_TCD30_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD30_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD30_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD30_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD30_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CITER_ELINKNO_ADDR, BP_DMA_TCD30_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd30_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd30_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd30_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_DLASTSGA register
 */
//@{
#define HW_DMA_TCD30_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x13d8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_DLASTSGA           (*(__IO hw_dma_tcd30_dlastsga_t *) HW_DMA_TCD30_DLASTSGA_ADDR)
#define HW_DMA_TCD30_DLASTSGA_RD()      (HW_DMA_TCD30_DLASTSGA.U)
#define HW_DMA_TCD30_DLASTSGA_WR(v)     (HW_DMA_TCD30_DLASTSGA.U = (v))
#define HW_DMA_TCD30_DLASTSGA_SET(v)    (HW_DMA_TCD30_DLASTSGA_WR(HW_DMA_TCD30_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD30_DLASTSGA_CLR(v)    (HW_DMA_TCD30_DLASTSGA_WR(HW_DMA_TCD30_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD30_DLASTSGA_TOG(v)    (HW_DMA_TCD30_DLASTSGA_WR(HW_DMA_TCD30_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD30_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD30_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD30_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD30_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD30_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD30_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD30_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD30_DLASTSGA_DLASTSGA()   (HW_DMA_TCD30_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD30_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD30_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD30_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD30_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD30_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD30_DLASTSGA_WR((HW_DMA_TCD30_DLASTSGA_RD() & ~BM_DMA_TCD30_DLASTSGA_DLASTSGA) | BF_DMA_TCD30_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd30_csr
{
    uint16_t U;
    struct _hw_dma_tcd30_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd30_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_CSR register
 */
//@{
#define HW_DMA_TCD30_CSR_ADDR      (REGS_DMA_BASE + 0x13dcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_CSR           (*(__IO hw_dma_tcd30_csr_t *) HW_DMA_TCD30_CSR_ADDR)
#define HW_DMA_TCD30_CSR_RD()      (HW_DMA_TCD30_CSR.U)
#define HW_DMA_TCD30_CSR_WR(v)     (HW_DMA_TCD30_CSR.U = (v))
#define HW_DMA_TCD30_CSR_SET(v)    (HW_DMA_TCD30_CSR_WR(HW_DMA_TCD30_CSR_RD() |  (v)))
#define HW_DMA_TCD30_CSR_CLR(v)    (HW_DMA_TCD30_CSR_WR(HW_DMA_TCD30_CSR_RD() & ~(v)))
#define HW_DMA_TCD30_CSR_TOG(v)    (HW_DMA_TCD30_CSR_WR(HW_DMA_TCD30_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_CSR bitfields
 */

/*! @name Register DMA_TCD30_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD30_CSR_START      (0U)      //!< Bit position for DMA_TCD30_CSR_START.
#define BM_DMA_TCD30_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD30_CSR_START.
#define BS_DMA_TCD30_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD30_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_START field.
#define BR_DMA_TCD30_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_START.
#define BF_DMA_TCD30_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_START), uint16_t) & BM_DMA_TCD30_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD30_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD30_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD30_CSR_INTMAJOR.
#define BM_DMA_TCD30_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD30_CSR_INTMAJOR.
#define BS_DMA_TCD30_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD30_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_INTMAJOR field.
#define BR_DMA_TCD30_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_INTMAJOR.
#define BF_DMA_TCD30_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD30_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD30_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD30_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD30_CSR_INTHALF.
#define BM_DMA_TCD30_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD30_CSR_INTHALF.
#define BS_DMA_TCD30_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD30_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_INTHALF field.
#define BR_DMA_TCD30_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_INTHALF.
#define BF_DMA_TCD30_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_INTHALF), uint16_t) & BM_DMA_TCD30_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD30_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD30_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD30_CSR_DREQ.
#define BM_DMA_TCD30_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD30_CSR_DREQ.
#define BS_DMA_TCD30_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD30_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_DREQ field.
#define BR_DMA_TCD30_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_DREQ.
#define BF_DMA_TCD30_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_DREQ), uint16_t) & BM_DMA_TCD30_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD30_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD30_CSR_ESG      (4U)      //!< Bit position for DMA_TCD30_CSR_ESG.
#define BM_DMA_TCD30_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD30_CSR_ESG.
#define BS_DMA_TCD30_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD30_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_ESG field.
#define BR_DMA_TCD30_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_ESG.
#define BF_DMA_TCD30_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_ESG), uint16_t) & BM_DMA_TCD30_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD30_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD30_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD30_CSR_MAJORELINK.
#define BM_DMA_TCD30_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD30_CSR_MAJORELINK.
#define BS_DMA_TCD30_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD30_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_MAJORELINK field.
#define BR_DMA_TCD30_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_MAJORELINK.
#define BF_DMA_TCD30_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD30_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD30_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD30_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD30_CSR_ACTIVE.
#define BM_DMA_TCD30_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD30_CSR_ACTIVE.
#define BS_DMA_TCD30_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD30_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_ACTIVE field.
#define BR_DMA_TCD30_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_ACTIVE.
#define BF_DMA_TCD30_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_ACTIVE), uint16_t) & BM_DMA_TCD30_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD30_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD30_CSR_DONE      (7U)      //!< Bit position for DMA_TCD30_CSR_DONE.
#define BM_DMA_TCD30_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD30_CSR_DONE.
#define BS_DMA_TCD30_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD30_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_DONE field.
#define BR_DMA_TCD30_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_DONE.
#define BF_DMA_TCD30_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_DONE), uint16_t) & BM_DMA_TCD30_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD30_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_CSR_ADDR, BP_DMA_TCD30_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD30_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD30_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD30_CSR_MAJORLINKCH.
#define BM_DMA_TCD30_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD30_CSR_MAJORLINKCH.
#define BS_DMA_TCD30_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD30_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_MAJORLINKCH field.
#define BR_DMA_TCD30_CSR_MAJORLINKCH()   (HW_DMA_TCD30_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_MAJORLINKCH.
#define BF_DMA_TCD30_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD30_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD30_CSR_MAJORLINKCH(v)   (HW_DMA_TCD30_CSR_WR((HW_DMA_TCD30_CSR_RD() & ~BM_DMA_TCD30_CSR_MAJORLINKCH) | BF_DMA_TCD30_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD30_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD30_CSR_BWC      (14U)      //!< Bit position for DMA_TCD30_CSR_BWC.
#define BM_DMA_TCD30_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD30_CSR_BWC.
#define BS_DMA_TCD30_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD30_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_CSR_BWC field.
#define BR_DMA_TCD30_CSR_BWC()   (HW_DMA_TCD30_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD30_CSR_BWC.
#define BF_DMA_TCD30_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_CSR_BWC), uint16_t) & BM_DMA_TCD30_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD30_CSR_BWC(v)   (HW_DMA_TCD30_CSR_WR((HW_DMA_TCD30_CSR_RD() & ~BM_DMA_TCD30_CSR_BWC) | BF_DMA_TCD30_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd30_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd30_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd30_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD30_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x13deU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_BITER_ELINKYES           (*(__IO hw_dma_tcd30_biter_elinkyes_t *) HW_DMA_TCD30_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD30_BITER_ELINKYES_RD()      (HW_DMA_TCD30_BITER_ELINKYES.U)
#define HW_DMA_TCD30_BITER_ELINKYES_WR(v)     (HW_DMA_TCD30_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD30_BITER_ELINKYES_SET(v)    (HW_DMA_TCD30_BITER_ELINKYES_WR(HW_DMA_TCD30_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD30_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD30_BITER_ELINKYES_WR(HW_DMA_TCD30_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD30_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD30_BITER_ELINKYES_WR(HW_DMA_TCD30_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD30_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD30_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD30_BITER_ELINKYES_BITER.
#define BM_DMA_TCD30_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD30_BITER_ELINKYES_BITER.
#define BS_DMA_TCD30_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD30_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD30_BITER_ELINKYES_BITER()   (HW_DMA_TCD30_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD30_BITER_ELINKYES_BITER.
#define BF_DMA_TCD30_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD30_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD30_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD30_BITER_ELINKYES_WR((HW_DMA_TCD30_BITER_ELINKYES_RD() & ~BM_DMA_TCD30_BITER_ELINKYES_BITER) | BF_DMA_TCD30_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD30_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD30_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD30_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD30_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD30_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD30_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD30_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD30_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD30_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD30_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD30_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD30_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD30_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD30_BITER_ELINKYES_WR((HW_DMA_TCD30_BITER_ELINKYES_RD() & ~BM_DMA_TCD30_BITER_ELINKYES_LINKCH) | BF_DMA_TCD30_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD30_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD30_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD30_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD30_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD30_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD30_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD30_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD30_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD30_BITER_ELINKYES_ADDR, BP_DMA_TCD30_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD30_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD30_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD30_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD30_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_BITER_ELINKYES_ADDR, BP_DMA_TCD30_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD30_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD30_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd30_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd30_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd30_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD30_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD30_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x13deU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD30_BITER_ELINKNO           (*(__IO hw_dma_tcd30_biter_elinkno_t *) HW_DMA_TCD30_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD30_BITER_ELINKNO_RD()      (HW_DMA_TCD30_BITER_ELINKNO.U)
#define HW_DMA_TCD30_BITER_ELINKNO_WR(v)     (HW_DMA_TCD30_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD30_BITER_ELINKNO_SET(v)    (HW_DMA_TCD30_BITER_ELINKNO_WR(HW_DMA_TCD30_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD30_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD30_BITER_ELINKNO_WR(HW_DMA_TCD30_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD30_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD30_BITER_ELINKNO_WR(HW_DMA_TCD30_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD30_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD30_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD30_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD30_BITER_ELINKNO_BITER.
#define BM_DMA_TCD30_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD30_BITER_ELINKNO_BITER.
#define BS_DMA_TCD30_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD30_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD30_BITER_ELINKNO_BITER()   (HW_DMA_TCD30_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD30_BITER_ELINKNO_BITER.
#define BF_DMA_TCD30_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD30_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD30_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD30_BITER_ELINKNO_WR((HW_DMA_TCD30_BITER_ELINKNO_RD() & ~BM_DMA_TCD30_BITER_ELINKNO_BITER) | BF_DMA_TCD30_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD30_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD30_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD30_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD30_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD30_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD30_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD30_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD30_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD30_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD30_BITER_ELINKNO_ADDR, BP_DMA_TCD30_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD30_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD30_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD30_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD30_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD30_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD30_BITER_ELINKNO_ADDR, BP_DMA_TCD30_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_SADDR - TCD Source Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd31_saddr
{
    uint32_t U;
    struct _hw_dma_tcd31_saddr_bitfields
    {
        uint32_t SADDR : 32; //!< [31:0] Source Address
    } B;
} hw_dma_tcd31_saddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_SADDR register
 */
//@{
#define HW_DMA_TCD31_SADDR_ADDR      (REGS_DMA_BASE + 0x13e0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_SADDR           (*(__IO hw_dma_tcd31_saddr_t *) HW_DMA_TCD31_SADDR_ADDR)
#define HW_DMA_TCD31_SADDR_RD()      (HW_DMA_TCD31_SADDR.U)
#define HW_DMA_TCD31_SADDR_WR(v)     (HW_DMA_TCD31_SADDR.U = (v))
#define HW_DMA_TCD31_SADDR_SET(v)    (HW_DMA_TCD31_SADDR_WR(HW_DMA_TCD31_SADDR_RD() |  (v)))
#define HW_DMA_TCD31_SADDR_CLR(v)    (HW_DMA_TCD31_SADDR_WR(HW_DMA_TCD31_SADDR_RD() & ~(v)))
#define HW_DMA_TCD31_SADDR_TOG(v)    (HW_DMA_TCD31_SADDR_WR(HW_DMA_TCD31_SADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_SADDR bitfields
 */

/*! @name Register DMA_TCD31_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
//@{
#define BP_DMA_TCD31_SADDR_SADDR      (0U)      //!< Bit position for DMA_TCD31_SADDR_SADDR.
#define BM_DMA_TCD31_SADDR_SADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD31_SADDR_SADDR.
#define BS_DMA_TCD31_SADDR_SADDR      (32U)  //!< Bitfield size in bits for DMA_TCD31_SADDR_SADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_SADDR_SADDR field.
#define BR_DMA_TCD31_SADDR_SADDR()   (HW_DMA_TCD31_SADDR.B.SADDR)
#endif

//! @brief Format value for bitfield DMA_TCD31_SADDR_SADDR.
#define BF_DMA_TCD31_SADDR_SADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_SADDR_SADDR), uint32_t) & BM_DMA_TCD31_SADDR_SADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SADDR field to a new value.
#define BW_DMA_TCD31_SADDR_SADDR(v)   (HW_DMA_TCD31_SADDR_WR((HW_DMA_TCD31_SADDR_RD() & ~BM_DMA_TCD31_SADDR_SADDR) | BF_DMA_TCD31_SADDR_SADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_SOFF - TCD Signed Source Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd31_soff
{
    uint16_t U;
    struct _hw_dma_tcd31_soff_bitfields
    {
        uint16_t SOFF : 16; //!< [15:0] Source Address Signed Offset
    } B;
} hw_dma_tcd31_soff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_SOFF register
 */
//@{
#define HW_DMA_TCD31_SOFF_ADDR      (REGS_DMA_BASE + 0x13e4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_SOFF           (*(__IO hw_dma_tcd31_soff_t *) HW_DMA_TCD31_SOFF_ADDR)
#define HW_DMA_TCD31_SOFF_RD()      (HW_DMA_TCD31_SOFF.U)
#define HW_DMA_TCD31_SOFF_WR(v)     (HW_DMA_TCD31_SOFF.U = (v))
#define HW_DMA_TCD31_SOFF_SET(v)    (HW_DMA_TCD31_SOFF_WR(HW_DMA_TCD31_SOFF_RD() |  (v)))
#define HW_DMA_TCD31_SOFF_CLR(v)    (HW_DMA_TCD31_SOFF_WR(HW_DMA_TCD31_SOFF_RD() & ~(v)))
#define HW_DMA_TCD31_SOFF_TOG(v)    (HW_DMA_TCD31_SOFF_WR(HW_DMA_TCD31_SOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_SOFF bitfields
 */

/*! @name Register DMA_TCD31_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the next-state value as each
 * source read is completed.
 */
//@{
#define BP_DMA_TCD31_SOFF_SOFF      (0U)      //!< Bit position for DMA_TCD31_SOFF_SOFF.
#define BM_DMA_TCD31_SOFF_SOFF      (0xffffU)  //!< Bit mask for DMA_TCD31_SOFF_SOFF.
#define BS_DMA_TCD31_SOFF_SOFF      (16U)  //!< Bitfield size in bits for DMA_TCD31_SOFF_SOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_SOFF_SOFF field.
#define BR_DMA_TCD31_SOFF_SOFF()   (HW_DMA_TCD31_SOFF.B.SOFF)
#endif

//! @brief Format value for bitfield DMA_TCD31_SOFF_SOFF.
#define BF_DMA_TCD31_SOFF_SOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_SOFF_SOFF), uint16_t) & BM_DMA_TCD31_SOFF_SOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SOFF field to a new value.
#define BW_DMA_TCD31_SOFF_SOFF(v)   (HW_DMA_TCD31_SOFF_WR((HW_DMA_TCD31_SOFF_RD() & ~BM_DMA_TCD31_SOFF_SOFF) | BF_DMA_TCD31_SOFF_SOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_ATTR - TCD Transfer Attributes
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd31_attr
{
    uint16_t U;
    struct _hw_dma_tcd31_attr_bitfields
    {
        uint16_t DSIZE : 3; //!< [2:0] Destination Data Transfer Size
        uint16_t DMOD : 5; //!< [7:3] Destination Address Modulo
        uint16_t SSIZE : 3; //!< [10:8] Source data transfer size
        uint16_t SMOD : 5; //!< [15:11] Source Address Modulo
    } B;
} hw_dma_tcd31_attr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_ATTR register
 */
//@{
#define HW_DMA_TCD31_ATTR_ADDR      (REGS_DMA_BASE + 0x13e6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_ATTR           (*(__IO hw_dma_tcd31_attr_t *) HW_DMA_TCD31_ATTR_ADDR)
#define HW_DMA_TCD31_ATTR_RD()      (HW_DMA_TCD31_ATTR.U)
#define HW_DMA_TCD31_ATTR_WR(v)     (HW_DMA_TCD31_ATTR.U = (v))
#define HW_DMA_TCD31_ATTR_SET(v)    (HW_DMA_TCD31_ATTR_WR(HW_DMA_TCD31_ATTR_RD() |  (v)))
#define HW_DMA_TCD31_ATTR_CLR(v)    (HW_DMA_TCD31_ATTR_WR(HW_DMA_TCD31_ATTR_RD() & ~(v)))
#define HW_DMA_TCD31_ATTR_TOG(v)    (HW_DMA_TCD31_ATTR_WR(HW_DMA_TCD31_ATTR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_ATTR bitfields
 */

/*! @name Register DMA_TCD31_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
//@{
#define BP_DMA_TCD31_ATTR_DSIZE      (0U)      //!< Bit position for DMA_TCD31_ATTR_DSIZE.
#define BM_DMA_TCD31_ATTR_DSIZE      (0x0007U)  //!< Bit mask for DMA_TCD31_ATTR_DSIZE.
#define BS_DMA_TCD31_ATTR_DSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD31_ATTR_DSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_ATTR_DSIZE field.
#define BR_DMA_TCD31_ATTR_DSIZE()   (HW_DMA_TCD31_ATTR.B.DSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD31_ATTR_DSIZE.
#define BF_DMA_TCD31_ATTR_DSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_ATTR_DSIZE), uint16_t) & BM_DMA_TCD31_ATTR_DSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DSIZE field to a new value.
#define BW_DMA_TCD31_ATTR_DSIZE(v)   (HW_DMA_TCD31_ATTR_WR((HW_DMA_TCD31_ATTR_RD() & ~BM_DMA_TCD31_ATTR_DSIZE) | BF_DMA_TCD31_ATTR_DSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD31_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
//@{
#define BP_DMA_TCD31_ATTR_DMOD      (3U)      //!< Bit position for DMA_TCD31_ATTR_DMOD.
#define BM_DMA_TCD31_ATTR_DMOD      (0x00f8U)  //!< Bit mask for DMA_TCD31_ATTR_DMOD.
#define BS_DMA_TCD31_ATTR_DMOD      (5U)  //!< Bitfield size in bits for DMA_TCD31_ATTR_DMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_ATTR_DMOD field.
#define BR_DMA_TCD31_ATTR_DMOD()   (HW_DMA_TCD31_ATTR.B.DMOD)
#endif

//! @brief Format value for bitfield DMA_TCD31_ATTR_DMOD.
#define BF_DMA_TCD31_ATTR_DMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_ATTR_DMOD), uint16_t) & BM_DMA_TCD31_ATTR_DMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMOD field to a new value.
#define BW_DMA_TCD31_ATTR_DMOD(v)   (HW_DMA_TCD31_ATTR_WR((HW_DMA_TCD31_ATTR_RD() & ~BM_DMA_TCD31_ATTR_DMOD) | BF_DMA_TCD31_ATTR_DMOD(v)))
#endif
//@}

/*! @name Register DMA_TCD31_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
//@{
#define BP_DMA_TCD31_ATTR_SSIZE      (8U)      //!< Bit position for DMA_TCD31_ATTR_SSIZE.
#define BM_DMA_TCD31_ATTR_SSIZE      (0x0700U)  //!< Bit mask for DMA_TCD31_ATTR_SSIZE.
#define BS_DMA_TCD31_ATTR_SSIZE      (3U)  //!< Bitfield size in bits for DMA_TCD31_ATTR_SSIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_ATTR_SSIZE field.
#define BR_DMA_TCD31_ATTR_SSIZE()   (HW_DMA_TCD31_ATTR.B.SSIZE)
#endif

//! @brief Format value for bitfield DMA_TCD31_ATTR_SSIZE.
#define BF_DMA_TCD31_ATTR_SSIZE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_ATTR_SSIZE), uint16_t) & BM_DMA_TCD31_ATTR_SSIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSIZE field to a new value.
#define BW_DMA_TCD31_ATTR_SSIZE(v)   (HW_DMA_TCD31_ATTR_WR((HW_DMA_TCD31_ATTR_RD() & ~BM_DMA_TCD31_ATTR_SSIZE) | BF_DMA_TCD31_ATTR_SSIZE(v)))
#endif
//@}

/*! @name Register DMA_TCD31_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 * - 0 - This value defines a specific address range specified to be the value after SADDR + SOFF calculation
 *     is performed on the original register value. Setting this field provides the ability to
 *     implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the
 *     queue should start at a 0-modulo-size address and the SMOD field should be set to the
 *     appropriate value for the queue, freezing the desired number of upper address bits. The value
 *     programmed into this field specifies the number of lower address bits allowed to change. For
 *     a circular queue application, the SOFF is typically set to the transfer size to implement
 *     post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-
 *     size range.
 */
//@{
#define BP_DMA_TCD31_ATTR_SMOD      (11U)      //!< Bit position for DMA_TCD31_ATTR_SMOD.
#define BM_DMA_TCD31_ATTR_SMOD      (0xf800U)  //!< Bit mask for DMA_TCD31_ATTR_SMOD.
#define BS_DMA_TCD31_ATTR_SMOD      (5U)  //!< Bitfield size in bits for DMA_TCD31_ATTR_SMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_ATTR_SMOD field.
#define BR_DMA_TCD31_ATTR_SMOD()   (HW_DMA_TCD31_ATTR.B.SMOD)
#endif

//! @brief Format value for bitfield DMA_TCD31_ATTR_SMOD.
#define BF_DMA_TCD31_ATTR_SMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_ATTR_SMOD), uint16_t) & BM_DMA_TCD31_ATTR_SMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMOD field to a new value.
#define BW_DMA_TCD31_ATTR_SMOD(v)   (HW_DMA_TCD31_ATTR_WR((HW_DMA_TCD31_ATTR_RD() & ~BM_DMA_TCD31_ATTR_SMOD) | BF_DMA_TCD31_ATTR_SMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, TCD_NBYTES_MLOFFYES),
 * defines the number of bytes to transfer per request. Which register to use depends on whether
 * minor loop mapping is disabled, enabled but not used for this channel, or enabled and used. TCD
 * word 2 is defined as follows if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop
 * mapping is enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions for
 * TCD word 2's definition.
 */
typedef union _hw_dma_tcd31_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcd31_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32; //!< [31:0] Minor Byte Transfer Count
    } B;
} hw_dma_tcd31_nbytes_mlno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_NBYTES_MLNO register
 */
//@{
#define HW_DMA_TCD31_NBYTES_MLNO_ADDR      (REGS_DMA_BASE + 0x13e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_NBYTES_MLNO           (*(__IO hw_dma_tcd31_nbytes_mlno_t *) HW_DMA_TCD31_NBYTES_MLNO_ADDR)
#define HW_DMA_TCD31_NBYTES_MLNO_RD()      (HW_DMA_TCD31_NBYTES_MLNO.U)
#define HW_DMA_TCD31_NBYTES_MLNO_WR(v)     (HW_DMA_TCD31_NBYTES_MLNO.U = (v))
#define HW_DMA_TCD31_NBYTES_MLNO_SET(v)    (HW_DMA_TCD31_NBYTES_MLNO_WR(HW_DMA_TCD31_NBYTES_MLNO_RD() |  (v)))
#define HW_DMA_TCD31_NBYTES_MLNO_CLR(v)    (HW_DMA_TCD31_NBYTES_MLNO_WR(HW_DMA_TCD31_NBYTES_MLNO_RD() & ~(v)))
#define HW_DMA_TCD31_NBYTES_MLNO_TOG(v)    (HW_DMA_TCD31_NBYTES_MLNO_WR(HW_DMA_TCD31_NBYTES_MLNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_NBYTES_MLNO bitfields
 */

/*! @name Register DMA_TCD31_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed. An NBYTES value of
 * 0x0000_0000 is interpreted as a 4 GB transfer.
 */
//@{
#define BP_DMA_TCD31_NBYTES_MLNO_NBYTES      (0U)      //!< Bit position for DMA_TCD31_NBYTES_MLNO_NBYTES.
#define BM_DMA_TCD31_NBYTES_MLNO_NBYTES      (0xffffffffU)  //!< Bit mask for DMA_TCD31_NBYTES_MLNO_NBYTES.
#define BS_DMA_TCD31_NBYTES_MLNO_NBYTES      (32U)  //!< Bitfield size in bits for DMA_TCD31_NBYTES_MLNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_NBYTES_MLNO_NBYTES field.
#define BR_DMA_TCD31_NBYTES_MLNO_NBYTES()   (HW_DMA_TCD31_NBYTES_MLNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD31_NBYTES_MLNO_NBYTES.
#define BF_DMA_TCD31_NBYTES_MLNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_NBYTES_MLNO_NBYTES), uint32_t) & BM_DMA_TCD31_NBYTES_MLNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD31_NBYTES_MLNO_NBYTES(v)   (HW_DMA_TCD31_NBYTES_MLNO_WR((HW_DMA_TCD31_NBYTES_MLNO_RD() & ~BM_DMA_TCD31_NBYTES_MLNO_NBYTES) | BF_DMA_TCD31_NBYTES_MLNO_NBYTES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFYES), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0
 * If minor loop mapping is enabled and SMLOE or DMLOE is set, then refer to the TCD_NBYTES_MLOFFYES
 * register description. If minor loop mapping is disabled, then refer to the TCD_NBYTES_MLNO
 * register description.
 */
typedef union _hw_dma_tcd31_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcd31_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30; //!< [29:0] Minor Byte Transfer Count
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd31_nbytes_mloffno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_NBYTES_MLOFFNO register
 */
//@{
#define HW_DMA_TCD31_NBYTES_MLOFFNO_ADDR      (REGS_DMA_BASE + 0x13e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_NBYTES_MLOFFNO           (*(__IO hw_dma_tcd31_nbytes_mloffno_t *) HW_DMA_TCD31_NBYTES_MLOFFNO_ADDR)
#define HW_DMA_TCD31_NBYTES_MLOFFNO_RD()      (HW_DMA_TCD31_NBYTES_MLOFFNO.U)
#define HW_DMA_TCD31_NBYTES_MLOFFNO_WR(v)     (HW_DMA_TCD31_NBYTES_MLOFFNO.U = (v))
#define HW_DMA_TCD31_NBYTES_MLOFFNO_SET(v)    (HW_DMA_TCD31_NBYTES_MLOFFNO_WR(HW_DMA_TCD31_NBYTES_MLOFFNO_RD() |  (v)))
#define HW_DMA_TCD31_NBYTES_MLOFFNO_CLR(v)    (HW_DMA_TCD31_NBYTES_MLOFFNO_WR(HW_DMA_TCD31_NBYTES_MLOFFNO_RD() & ~(v)))
#define HW_DMA_TCD31_NBYTES_MLOFFNO_TOG(v)    (HW_DMA_TCD31_NBYTES_MLOFFNO_WR(HW_DMA_TCD31_NBYTES_MLOFFNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_NBYTES_MLOFFNO bitfields
 */

/*! @name Register DMA_TCD31_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD31_NBYTES_MLOFFNO_NBYTES      (0U)      //!< Bit position for DMA_TCD31_NBYTES_MLOFFNO_NBYTES.
#define BM_DMA_TCD31_NBYTES_MLOFFNO_NBYTES      (0x3fffffffU)  //!< Bit mask for DMA_TCD31_NBYTES_MLOFFNO_NBYTES.
#define BS_DMA_TCD31_NBYTES_MLOFFNO_NBYTES      (30U)  //!< Bitfield size in bits for DMA_TCD31_NBYTES_MLOFFNO_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_NBYTES_MLOFFNO_NBYTES field.
#define BR_DMA_TCD31_NBYTES_MLOFFNO_NBYTES()   (HW_DMA_TCD31_NBYTES_MLOFFNO.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD31_NBYTES_MLOFFNO_NBYTES.
#define BF_DMA_TCD31_NBYTES_MLOFFNO_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_NBYTES_MLOFFNO_NBYTES), uint32_t) & BM_DMA_TCD31_NBYTES_MLOFFNO_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD31_NBYTES_MLOFFNO_NBYTES(v)   (HW_DMA_TCD31_NBYTES_MLOFFNO_WR((HW_DMA_TCD31_NBYTES_MLOFFNO_RD() & ~BM_DMA_TCD31_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCD31_NBYTES_MLOFFNO_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD31_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD31_NBYTES_MLOFFNO_DMLOE      (30U)      //!< Bit position for DMA_TCD31_NBYTES_MLOFFNO_DMLOE.
#define BM_DMA_TCD31_NBYTES_MLOFFNO_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD31_NBYTES_MLOFFNO_DMLOE.
#define BS_DMA_TCD31_NBYTES_MLOFFNO_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD31_NBYTES_MLOFFNO_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_NBYTES_MLOFFNO_DMLOE field.
#define BR_DMA_TCD31_NBYTES_MLOFFNO_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD31_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD31_NBYTES_MLOFFNO_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD31_NBYTES_MLOFFNO_DMLOE.
#define BF_DMA_TCD31_NBYTES_MLOFFNO_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_NBYTES_MLOFFNO_DMLOE), uint32_t) & BM_DMA_TCD31_NBYTES_MLOFFNO_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD31_NBYTES_MLOFFNO_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD31_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD31_NBYTES_MLOFFNO_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD31_NBYTES_MLOFFNO_SMLOE      (31U)      //!< Bit position for DMA_TCD31_NBYTES_MLOFFNO_SMLOE.
#define BM_DMA_TCD31_NBYTES_MLOFFNO_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD31_NBYTES_MLOFFNO_SMLOE.
#define BS_DMA_TCD31_NBYTES_MLOFFNO_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD31_NBYTES_MLOFFNO_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_NBYTES_MLOFFNO_SMLOE field.
#define BR_DMA_TCD31_NBYTES_MLOFFNO_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD31_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD31_NBYTES_MLOFFNO_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD31_NBYTES_MLOFFNO_SMLOE.
#define BF_DMA_TCD31_NBYTES_MLOFFNO_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_NBYTES_MLOFFNO_SMLOE), uint32_t) & BM_DMA_TCD31_NBYTES_MLOFFNO_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD31_NBYTES_MLOFFNO_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD31_NBYTES_MLOFFNO_ADDR, BP_DMA_TCD31_NBYTES_MLOFFNO_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_MLOFFNO), defines the
 * number of bytes to transfer per request. Which register to use depends on whether minor loop
 * mapping is disabled, enabled but not used for this channel, or enabled and used. TCD word 2 is
 * defined as follows if: Minor loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is
 * enabled (SMLOE or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop mapping is disabled,
 * then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcd31_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcd31_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10; //!< [9:0] Minor Byte Transfer Count
        uint32_t MLOFF : 20; //!< [29:10] If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
        uint32_t DMLOE : 1; //!< [30] Destination Minor Loop Offset Enable
        uint32_t SMLOE : 1; //!< [31] Source Minor Loop Offset Enable
    } B;
} hw_dma_tcd31_nbytes_mloffyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_NBYTES_MLOFFYES register
 */
//@{
#define HW_DMA_TCD31_NBYTES_MLOFFYES_ADDR      (REGS_DMA_BASE + 0x13e8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_NBYTES_MLOFFYES           (*(__IO hw_dma_tcd31_nbytes_mloffyes_t *) HW_DMA_TCD31_NBYTES_MLOFFYES_ADDR)
#define HW_DMA_TCD31_NBYTES_MLOFFYES_RD()      (HW_DMA_TCD31_NBYTES_MLOFFYES.U)
#define HW_DMA_TCD31_NBYTES_MLOFFYES_WR(v)     (HW_DMA_TCD31_NBYTES_MLOFFYES.U = (v))
#define HW_DMA_TCD31_NBYTES_MLOFFYES_SET(v)    (HW_DMA_TCD31_NBYTES_MLOFFYES_WR(HW_DMA_TCD31_NBYTES_MLOFFYES_RD() |  (v)))
#define HW_DMA_TCD31_NBYTES_MLOFFYES_CLR(v)    (HW_DMA_TCD31_NBYTES_MLOFFYES_WR(HW_DMA_TCD31_NBYTES_MLOFFYES_RD() & ~(v)))
#define HW_DMA_TCD31_NBYTES_MLOFFYES_TOG(v)    (HW_DMA_TCD31_NBYTES_MLOFFYES_WR(HW_DMA_TCD31_NBYTES_MLOFFYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_NBYTES_MLOFFYES bitfields
 */

/*! @name Register DMA_TCD31_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As a channel activates,
 * the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes
 * perform until the minor byte transfer count has transferred. This is an indivisible operation and
 * cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into
 * the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the
 * major iteration count is completed, additional processing is performed.
 */
//@{
#define BP_DMA_TCD31_NBYTES_MLOFFYES_NBYTES      (0U)      //!< Bit position for DMA_TCD31_NBYTES_MLOFFYES_NBYTES.
#define BM_DMA_TCD31_NBYTES_MLOFFYES_NBYTES      (0x000003ffU)  //!< Bit mask for DMA_TCD31_NBYTES_MLOFFYES_NBYTES.
#define BS_DMA_TCD31_NBYTES_MLOFFYES_NBYTES      (10U)  //!< Bitfield size in bits for DMA_TCD31_NBYTES_MLOFFYES_NBYTES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_NBYTES_MLOFFYES_NBYTES field.
#define BR_DMA_TCD31_NBYTES_MLOFFYES_NBYTES()   (HW_DMA_TCD31_NBYTES_MLOFFYES.B.NBYTES)
#endif

//! @brief Format value for bitfield DMA_TCD31_NBYTES_MLOFFYES_NBYTES.
#define BF_DMA_TCD31_NBYTES_MLOFFYES_NBYTES(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_NBYTES_MLOFFYES_NBYTES), uint32_t) & BM_DMA_TCD31_NBYTES_MLOFFYES_NBYTES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NBYTES field to a new value.
#define BW_DMA_TCD31_NBYTES_MLOFFYES_NBYTES(v)   (HW_DMA_TCD31_NBYTES_MLOFFYES_WR((HW_DMA_TCD31_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD31_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCD31_NBYTES_MLOFFYES_NBYTES(v)))
#endif
//@}

/*! @name Register DMA_TCD31_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
//@{
#define BP_DMA_TCD31_NBYTES_MLOFFYES_MLOFF      (10U)      //!< Bit position for DMA_TCD31_NBYTES_MLOFFYES_MLOFF.
#define BM_DMA_TCD31_NBYTES_MLOFFYES_MLOFF      (0x3ffffc00U)  //!< Bit mask for DMA_TCD31_NBYTES_MLOFFYES_MLOFF.
#define BS_DMA_TCD31_NBYTES_MLOFFYES_MLOFF      (20U)  //!< Bitfield size in bits for DMA_TCD31_NBYTES_MLOFFYES_MLOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_NBYTES_MLOFFYES_MLOFF field.
#define BR_DMA_TCD31_NBYTES_MLOFFYES_MLOFF()   (HW_DMA_TCD31_NBYTES_MLOFFYES.B.MLOFF)
#endif

//! @brief Format value for bitfield DMA_TCD31_NBYTES_MLOFFYES_MLOFF.
#define BF_DMA_TCD31_NBYTES_MLOFFYES_MLOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_NBYTES_MLOFFYES_MLOFF), uint32_t) & BM_DMA_TCD31_NBYTES_MLOFFYES_MLOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MLOFF field to a new value.
#define BW_DMA_TCD31_NBYTES_MLOFFYES_MLOFF(v)   (HW_DMA_TCD31_NBYTES_MLOFFYES_WR((HW_DMA_TCD31_NBYTES_MLOFFYES_RD() & ~BM_DMA_TCD31_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCD31_NBYTES_MLOFFYES_MLOFF(v)))
#endif
//@}

/*! @name Register DMA_TCD31_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
//@{
#define BP_DMA_TCD31_NBYTES_MLOFFYES_DMLOE      (30U)      //!< Bit position for DMA_TCD31_NBYTES_MLOFFYES_DMLOE.
#define BM_DMA_TCD31_NBYTES_MLOFFYES_DMLOE      (0x40000000U)  //!< Bit mask for DMA_TCD31_NBYTES_MLOFFYES_DMLOE.
#define BS_DMA_TCD31_NBYTES_MLOFFYES_DMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD31_NBYTES_MLOFFYES_DMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_NBYTES_MLOFFYES_DMLOE field.
#define BR_DMA_TCD31_NBYTES_MLOFFYES_DMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD31_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD31_NBYTES_MLOFFYES_DMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD31_NBYTES_MLOFFYES_DMLOE.
#define BF_DMA_TCD31_NBYTES_MLOFFYES_DMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_NBYTES_MLOFFYES_DMLOE), uint32_t) & BM_DMA_TCD31_NBYTES_MLOFFYES_DMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMLOE field to a new value.
#define BW_DMA_TCD31_NBYTES_MLOFFYES_DMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD31_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD31_NBYTES_MLOFFYES_DMLOE) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon minor loop
 * completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
//@{
#define BP_DMA_TCD31_NBYTES_MLOFFYES_SMLOE      (31U)      //!< Bit position for DMA_TCD31_NBYTES_MLOFFYES_SMLOE.
#define BM_DMA_TCD31_NBYTES_MLOFFYES_SMLOE      (0x80000000U)  //!< Bit mask for DMA_TCD31_NBYTES_MLOFFYES_SMLOE.
#define BS_DMA_TCD31_NBYTES_MLOFFYES_SMLOE      (1U)  //!< Bitfield size in bits for DMA_TCD31_NBYTES_MLOFFYES_SMLOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_NBYTES_MLOFFYES_SMLOE field.
#define BR_DMA_TCD31_NBYTES_MLOFFYES_SMLOE()   (BITBAND_ACCESS32(HW_DMA_TCD31_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD31_NBYTES_MLOFFYES_SMLOE))
#endif

//! @brief Format value for bitfield DMA_TCD31_NBYTES_MLOFFYES_SMLOE.
#define BF_DMA_TCD31_NBYTES_MLOFFYES_SMLOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_NBYTES_MLOFFYES_SMLOE), uint32_t) & BM_DMA_TCD31_NBYTES_MLOFFYES_SMLOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SMLOE field to a new value.
#define BW_DMA_TCD31_NBYTES_MLOFFYES_SMLOE(v)   (BITBAND_ACCESS32(HW_DMA_TCD31_NBYTES_MLOFFYES_ADDR, BP_DMA_TCD31_NBYTES_MLOFFYES_SMLOE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_SLAST - TCD Last Source Address Adjustment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd31_slast
{
    uint32_t U;
    struct _hw_dma_tcd31_slast_bitfields
    {
        uint32_t SLAST : 32; //!< [31:0] Last Source Address Adjustment
    } B;
} hw_dma_tcd31_slast_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_SLAST register
 */
//@{
#define HW_DMA_TCD31_SLAST_ADDR      (REGS_DMA_BASE + 0x13ecU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_SLAST           (*(__IO hw_dma_tcd31_slast_t *) HW_DMA_TCD31_SLAST_ADDR)
#define HW_DMA_TCD31_SLAST_RD()      (HW_DMA_TCD31_SLAST.U)
#define HW_DMA_TCD31_SLAST_WR(v)     (HW_DMA_TCD31_SLAST.U = (v))
#define HW_DMA_TCD31_SLAST_SET(v)    (HW_DMA_TCD31_SLAST_WR(HW_DMA_TCD31_SLAST_RD() |  (v)))
#define HW_DMA_TCD31_SLAST_CLR(v)    (HW_DMA_TCD31_SLAST_WR(HW_DMA_TCD31_SLAST_RD() & ~(v)))
#define HW_DMA_TCD31_SLAST_TOG(v)    (HW_DMA_TCD31_SLAST_WR(HW_DMA_TCD31_SLAST_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_SLAST bitfields
 */

/*! @name Register DMA_TCD31_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major iteration count. This
 * value can be applied to restore the source address to the initial value, or adjust the address to
 * reference the next data structure. This register uses two's complement notation; the overflow bit
 * is discarded.
 */
//@{
#define BP_DMA_TCD31_SLAST_SLAST      (0U)      //!< Bit position for DMA_TCD31_SLAST_SLAST.
#define BM_DMA_TCD31_SLAST_SLAST      (0xffffffffU)  //!< Bit mask for DMA_TCD31_SLAST_SLAST.
#define BS_DMA_TCD31_SLAST_SLAST      (32U)  //!< Bitfield size in bits for DMA_TCD31_SLAST_SLAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_SLAST_SLAST field.
#define BR_DMA_TCD31_SLAST_SLAST()   (HW_DMA_TCD31_SLAST.B.SLAST)
#endif

//! @brief Format value for bitfield DMA_TCD31_SLAST_SLAST.
#define BF_DMA_TCD31_SLAST_SLAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_SLAST_SLAST), uint32_t) & BM_DMA_TCD31_SLAST_SLAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLAST field to a new value.
#define BW_DMA_TCD31_SLAST_SLAST(v)   (HW_DMA_TCD31_SLAST_WR((HW_DMA_TCD31_SLAST_RD() & ~BM_DMA_TCD31_SLAST_SLAST) | BF_DMA_TCD31_SLAST_SLAST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_DADDR - TCD Destination Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd31_daddr
{
    uint32_t U;
    struct _hw_dma_tcd31_daddr_bitfields
    {
        uint32_t DADDR : 32; //!< [31:0] Destination Address
    } B;
} hw_dma_tcd31_daddr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_DADDR register
 */
//@{
#define HW_DMA_TCD31_DADDR_ADDR      (REGS_DMA_BASE + 0x13f0U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_DADDR           (*(__IO hw_dma_tcd31_daddr_t *) HW_DMA_TCD31_DADDR_ADDR)
#define HW_DMA_TCD31_DADDR_RD()      (HW_DMA_TCD31_DADDR.U)
#define HW_DMA_TCD31_DADDR_WR(v)     (HW_DMA_TCD31_DADDR.U = (v))
#define HW_DMA_TCD31_DADDR_SET(v)    (HW_DMA_TCD31_DADDR_WR(HW_DMA_TCD31_DADDR_RD() |  (v)))
#define HW_DMA_TCD31_DADDR_CLR(v)    (HW_DMA_TCD31_DADDR_WR(HW_DMA_TCD31_DADDR_RD() & ~(v)))
#define HW_DMA_TCD31_DADDR_TOG(v)    (HW_DMA_TCD31_DADDR_WR(HW_DMA_TCD31_DADDR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_DADDR bitfields
 */

/*! @name Register DMA_TCD31_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
//@{
#define BP_DMA_TCD31_DADDR_DADDR      (0U)      //!< Bit position for DMA_TCD31_DADDR_DADDR.
#define BM_DMA_TCD31_DADDR_DADDR      (0xffffffffU)  //!< Bit mask for DMA_TCD31_DADDR_DADDR.
#define BS_DMA_TCD31_DADDR_DADDR      (32U)  //!< Bitfield size in bits for DMA_TCD31_DADDR_DADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_DADDR_DADDR field.
#define BR_DMA_TCD31_DADDR_DADDR()   (HW_DMA_TCD31_DADDR.B.DADDR)
#endif

//! @brief Format value for bitfield DMA_TCD31_DADDR_DADDR.
#define BF_DMA_TCD31_DADDR_DADDR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_DADDR_DADDR), uint32_t) & BM_DMA_TCD31_DADDR_DADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DADDR field to a new value.
#define BW_DMA_TCD31_DADDR_DADDR(v)   (HW_DMA_TCD31_DADDR_WR((HW_DMA_TCD31_DADDR_RD() & ~BM_DMA_TCD31_DADDR_DADDR) | BF_DMA_TCD31_DADDR_DADDR(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_DOFF - TCD Signed Destination Address Offset
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd31_doff
{
    uint16_t U;
    struct _hw_dma_tcd31_doff_bitfields
    {
        uint16_t DOFF : 16; //!< [15:0] Destination Address Signed Offset
    } B;
} hw_dma_tcd31_doff_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_DOFF register
 */
//@{
#define HW_DMA_TCD31_DOFF_ADDR      (REGS_DMA_BASE + 0x13f4U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_DOFF           (*(__IO hw_dma_tcd31_doff_t *) HW_DMA_TCD31_DOFF_ADDR)
#define HW_DMA_TCD31_DOFF_RD()      (HW_DMA_TCD31_DOFF.U)
#define HW_DMA_TCD31_DOFF_WR(v)     (HW_DMA_TCD31_DOFF.U = (v))
#define HW_DMA_TCD31_DOFF_SET(v)    (HW_DMA_TCD31_DOFF_WR(HW_DMA_TCD31_DOFF_RD() |  (v)))
#define HW_DMA_TCD31_DOFF_CLR(v)    (HW_DMA_TCD31_DOFF_WR(HW_DMA_TCD31_DOFF_RD() & ~(v)))
#define HW_DMA_TCD31_DOFF_TOG(v)    (HW_DMA_TCD31_DOFF_WR(HW_DMA_TCD31_DOFF_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_DOFF bitfields
 */

/*! @name Register DMA_TCD31_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the next-state value as
 * each destination write is completed.
 */
//@{
#define BP_DMA_TCD31_DOFF_DOFF      (0U)      //!< Bit position for DMA_TCD31_DOFF_DOFF.
#define BM_DMA_TCD31_DOFF_DOFF      (0xffffU)  //!< Bit mask for DMA_TCD31_DOFF_DOFF.
#define BS_DMA_TCD31_DOFF_DOFF      (16U)  //!< Bitfield size in bits for DMA_TCD31_DOFF_DOFF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_DOFF_DOFF field.
#define BR_DMA_TCD31_DOFF_DOFF()   (HW_DMA_TCD31_DOFF.B.DOFF)
#endif

//! @brief Format value for bitfield DMA_TCD31_DOFF_DOFF.
#define BF_DMA_TCD31_DOFF_DOFF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_DOFF_DOFF), uint16_t) & BM_DMA_TCD31_DOFF_DOFF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOFF field to a new value.
#define BW_DMA_TCD31_DOFF_DOFF(v)   (HW_DMA_TCD31_DOFF_WR((HW_DMA_TCD31_DOFF_RD() & ~BM_DMA_TCD31_DOFF_DOFF) | BF_DMA_TCD31_DOFF_DOFF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd31_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd31_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9; //!< [8:0] Current Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd31_citer_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_CITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD31_CITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x13f6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_CITER_ELINKYES           (*(__IO hw_dma_tcd31_citer_elinkyes_t *) HW_DMA_TCD31_CITER_ELINKYES_ADDR)
#define HW_DMA_TCD31_CITER_ELINKYES_RD()      (HW_DMA_TCD31_CITER_ELINKYES.U)
#define HW_DMA_TCD31_CITER_ELINKYES_WR(v)     (HW_DMA_TCD31_CITER_ELINKYES.U = (v))
#define HW_DMA_TCD31_CITER_ELINKYES_SET(v)    (HW_DMA_TCD31_CITER_ELINKYES_WR(HW_DMA_TCD31_CITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD31_CITER_ELINKYES_CLR(v)    (HW_DMA_TCD31_CITER_ELINKYES_WR(HW_DMA_TCD31_CITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD31_CITER_ELINKYES_TOG(v)    (HW_DMA_TCD31_CITER_ELINKYES_WR(HW_DMA_TCD31_CITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_CITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD31_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD31_CITER_ELINKYES_CITER      (0U)      //!< Bit position for DMA_TCD31_CITER_ELINKYES_CITER.
#define BM_DMA_TCD31_CITER_ELINKYES_CITER      (0x01ffU)  //!< Bit mask for DMA_TCD31_CITER_ELINKYES_CITER.
#define BS_DMA_TCD31_CITER_ELINKYES_CITER      (9U)  //!< Bitfield size in bits for DMA_TCD31_CITER_ELINKYES_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CITER_ELINKYES_CITER field.
#define BR_DMA_TCD31_CITER_ELINKYES_CITER()   (HW_DMA_TCD31_CITER_ELINKYES.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD31_CITER_ELINKYES_CITER.
#define BF_DMA_TCD31_CITER_ELINKYES_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CITER_ELINKYES_CITER), uint16_t) & BM_DMA_TCD31_CITER_ELINKYES_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD31_CITER_ELINKYES_CITER(v)   (HW_DMA_TCD31_CITER_ELINKYES_WR((HW_DMA_TCD31_CITER_ELINKYES_RD() & ~BM_DMA_TCD31_CITER_ELINKYES_CITER) | BF_DMA_TCD31_CITER_ELINKYES_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD31_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request to the channel defined by these five bits by
 * setting that channels TCDn_CSR[START] bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_DMA_TCD31_CITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD31_CITER_ELINKYES_LINKCH.
#define BM_DMA_TCD31_CITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD31_CITER_ELINKYES_LINKCH.
#define BS_DMA_TCD31_CITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD31_CITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD31_CITER_ELINKYES_LINKCH()   (HW_DMA_TCD31_CITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD31_CITER_ELINKYES_LINKCH.
#define BF_DMA_TCD31_CITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD31_CITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD31_CITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD31_CITER_ELINKYES_WR((HW_DMA_TCD31_CITER_ELINKYES_RD() & ~BM_DMA_TCD31_CITER_ELINKYES_LINKCH) | BF_DMA_TCD31_CITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD31_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD31_CITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD31_CITER_ELINKYES_ELINK.
#define BM_DMA_TCD31_CITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD31_CITER_ELINKYES_ELINK.
#define BS_DMA_TCD31_CITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD31_CITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CITER_ELINKYES_ELINK field.
#define BR_DMA_TCD31_CITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD31_CITER_ELINKYES_ADDR, BP_DMA_TCD31_CITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD31_CITER_ELINKYES_ELINK.
#define BF_DMA_TCD31_CITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD31_CITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD31_CITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CITER_ELINKYES_ADDR, BP_DMA_TCD31_CITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_CITER_ELINKNO - 
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_CITER_ELINKNO -  (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcd31_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd31_citer_elinkno_bitfields
    {
        uint16_t CITER : 15; //!< [14:0] Current Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enable channel-to-channel linking on minor-loop complete
    } B;
} hw_dma_tcd31_citer_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_CITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD31_CITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x13f6U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_CITER_ELINKNO           (*(__IO hw_dma_tcd31_citer_elinkno_t *) HW_DMA_TCD31_CITER_ELINKNO_ADDR)
#define HW_DMA_TCD31_CITER_ELINKNO_RD()      (HW_DMA_TCD31_CITER_ELINKNO.U)
#define HW_DMA_TCD31_CITER_ELINKNO_WR(v)     (HW_DMA_TCD31_CITER_ELINKNO.U = (v))
#define HW_DMA_TCD31_CITER_ELINKNO_SET(v)    (HW_DMA_TCD31_CITER_ELINKNO_WR(HW_DMA_TCD31_CITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD31_CITER_ELINKNO_CLR(v)    (HW_DMA_TCD31_CITER_ELINKNO_WR(HW_DMA_TCD31_CITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD31_CITER_ELINKNO_TOG(v)    (HW_DMA_TCD31_CITER_ELINKNO_WR(HW_DMA_TCD31_CITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_CITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD31_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for
 * the channel. It is decremented each time the minor loop is completed and updated in the transfer
 * control descriptor memory. After the major iteration count is exhausted, the channel performs a
 * number of operations (e.g., final source and destination address calculations), optionally
 * generating an interrupt to signal channel completion before reloading the CITER field from the
 * beginning iteration count (BITER) field. When the CITER field is initially loaded by software, it
 * must be set to the same value as that contained in the BITER field. If the channel is configured
 * to execute a single service request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD31_CITER_ELINKNO_CITER      (0U)      //!< Bit position for DMA_TCD31_CITER_ELINKNO_CITER.
#define BM_DMA_TCD31_CITER_ELINKNO_CITER      (0x7fffU)  //!< Bit mask for DMA_TCD31_CITER_ELINKNO_CITER.
#define BS_DMA_TCD31_CITER_ELINKNO_CITER      (15U)  //!< Bitfield size in bits for DMA_TCD31_CITER_ELINKNO_CITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CITER_ELINKNO_CITER field.
#define BR_DMA_TCD31_CITER_ELINKNO_CITER()   (HW_DMA_TCD31_CITER_ELINKNO.B.CITER)
#endif

//! @brief Format value for bitfield DMA_TCD31_CITER_ELINKNO_CITER.
#define BF_DMA_TCD31_CITER_ELINKNO_CITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CITER_ELINKNO_CITER), uint16_t) & BM_DMA_TCD31_CITER_ELINKNO_CITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CITER field to a new value.
#define BW_DMA_TCD31_CITER_ELINKNO_CITER(v)   (HW_DMA_TCD31_CITER_ELINKNO_WR((HW_DMA_TCD31_CITER_ELINKNO_RD() & ~BM_DMA_TCD31_CITER_ELINKNO_CITER) | BF_DMA_TCD31_CITER_ELINKNO_CITER(v)))
#endif
//@}

/*! @name Register DMA_TCD31_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another channel, defined by
 * the LINKCH field. The link target channel initiates a channel service request via an internal
 * mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is
 * disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * This bit must be equal to the BITER[ELINK] bit; otherwise, a configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD31_CITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD31_CITER_ELINKNO_ELINK.
#define BM_DMA_TCD31_CITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD31_CITER_ELINKNO_ELINK.
#define BS_DMA_TCD31_CITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD31_CITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CITER_ELINKNO_ELINK field.
#define BR_DMA_TCD31_CITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD31_CITER_ELINKNO_ADDR, BP_DMA_TCD31_CITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD31_CITER_ELINKNO_ELINK.
#define BF_DMA_TCD31_CITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD31_CITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD31_CITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CITER_ELINKNO_ADDR, BP_DMA_TCD31_CITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcd31_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcd31_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32; //!< [31:0] Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).
    } B;
} hw_dma_tcd31_dlastsga_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_DLASTSGA register
 */
//@{
#define HW_DMA_TCD31_DLASTSGA_ADDR      (REGS_DMA_BASE + 0x13f8U)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_DLASTSGA           (*(__IO hw_dma_tcd31_dlastsga_t *) HW_DMA_TCD31_DLASTSGA_ADDR)
#define HW_DMA_TCD31_DLASTSGA_RD()      (HW_DMA_TCD31_DLASTSGA.U)
#define HW_DMA_TCD31_DLASTSGA_WR(v)     (HW_DMA_TCD31_DLASTSGA.U = (v))
#define HW_DMA_TCD31_DLASTSGA_SET(v)    (HW_DMA_TCD31_DLASTSGA_WR(HW_DMA_TCD31_DLASTSGA_RD() |  (v)))
#define HW_DMA_TCD31_DLASTSGA_CLR(v)    (HW_DMA_TCD31_DLASTSGA_WR(HW_DMA_TCD31_DLASTSGA_RD() & ~(v)))
#define HW_DMA_TCD31_DLASTSGA_TOG(v)    (HW_DMA_TCD31_DLASTSGA_WR(HW_DMA_TCD31_DLASTSGA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_DLASTSGA bitfields
 */

/*! @name Register DMA_TCD31_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next transfer control
 * descriptor to be loaded into this channel (scatter/gather). If (TCDn_CSR[ESG] = 0), then:
 * Adjustment value added to the destination address at the completion of the major iteration count.
 * This value can apply to restore the destination address to the initial value or adjust the
 * address to reference the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the beginning of a
 * 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this
 * channel. This channel reload is performed as the major iteration count completes. The
 * scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.
 */
//@{
#define BP_DMA_TCD31_DLASTSGA_DLASTSGA      (0U)      //!< Bit position for DMA_TCD31_DLASTSGA_DLASTSGA.
#define BM_DMA_TCD31_DLASTSGA_DLASTSGA      (0xffffffffU)  //!< Bit mask for DMA_TCD31_DLASTSGA_DLASTSGA.
#define BS_DMA_TCD31_DLASTSGA_DLASTSGA      (32U)  //!< Bitfield size in bits for DMA_TCD31_DLASTSGA_DLASTSGA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_DLASTSGA_DLASTSGA field.
#define BR_DMA_TCD31_DLASTSGA_DLASTSGA()   (HW_DMA_TCD31_DLASTSGA.B.DLASTSGA)
#endif

//! @brief Format value for bitfield DMA_TCD31_DLASTSGA_DLASTSGA.
#define BF_DMA_TCD31_DLASTSGA_DLASTSGA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_DMA_TCD31_DLASTSGA_DLASTSGA), uint32_t) & BM_DMA_TCD31_DLASTSGA_DLASTSGA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLASTSGA field to a new value.
#define BW_DMA_TCD31_DLASTSGA_DLASTSGA(v)   (HW_DMA_TCD31_DLASTSGA_WR((HW_DMA_TCD31_DLASTSGA_RD() & ~BM_DMA_TCD31_DLASTSGA_DLASTSGA) | BF_DMA_TCD31_DLASTSGA_DLASTSGA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_CSR - TCD Control and Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcd31_csr
{
    uint16_t U;
    struct _hw_dma_tcd31_csr_bitfields
    {
        uint16_t START : 1; //!< [0] Channel Start
        uint16_t INTMAJOR : 1; //!< [1] Enable an interrupt when major iteration count completes
        uint16_t INTHALF : 1; //!< [2] Enable an interrupt when major counter is half complete.
        uint16_t DREQ : 1; //!< [3] Disable Request
        uint16_t ESG : 1; //!< [4] Enable Scatter/Gather Processing
        uint16_t MAJORELINK : 1; //!< [5] Enable channel-to-channel linking on major loop complete
        uint16_t ACTIVE : 1; //!< [6] Channel Active
        uint16_t DONE : 1; //!< [7] Channel Done
        uint16_t MAJORLINKCH : 5; //!< [12:8] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [13] 
        uint16_t BWC : 2; //!< [15:14] Bandwidth Control
    } B;
} hw_dma_tcd31_csr_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_CSR register
 */
//@{
#define HW_DMA_TCD31_CSR_ADDR      (REGS_DMA_BASE + 0x13fcU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_CSR           (*(__IO hw_dma_tcd31_csr_t *) HW_DMA_TCD31_CSR_ADDR)
#define HW_DMA_TCD31_CSR_RD()      (HW_DMA_TCD31_CSR.U)
#define HW_DMA_TCD31_CSR_WR(v)     (HW_DMA_TCD31_CSR.U = (v))
#define HW_DMA_TCD31_CSR_SET(v)    (HW_DMA_TCD31_CSR_WR(HW_DMA_TCD31_CSR_RD() |  (v)))
#define HW_DMA_TCD31_CSR_CLR(v)    (HW_DMA_TCD31_CSR_WR(HW_DMA_TCD31_CSR_RD() & ~(v)))
#define HW_DMA_TCD31_CSR_TOG(v)    (HW_DMA_TCD31_CSR_WR(HW_DMA_TCD31_CSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_CSR bitfields
 */

/*! @name Register DMA_TCD31_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware automatically clears
 * this flag after the channel begins execution. This bit resets to zero.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service request
 */
//@{
#define BP_DMA_TCD31_CSR_START      (0U)      //!< Bit position for DMA_TCD31_CSR_START.
#define BM_DMA_TCD31_CSR_START      (0x0001U)  //!< Bit mask for DMA_TCD31_CSR_START.
#define BS_DMA_TCD31_CSR_START      (1U)  //!< Bitfield size in bits for DMA_TCD31_CSR_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_START field.
#define BR_DMA_TCD31_CSR_START()   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_START))
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_START.
#define BF_DMA_TCD31_CSR_START(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_START), uint16_t) & BM_DMA_TCD31_CSR_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the START field to a new value.
#define BW_DMA_TCD31_CSR_START(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_START) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
//@{
#define BP_DMA_TCD31_CSR_INTMAJOR      (1U)      //!< Bit position for DMA_TCD31_CSR_INTMAJOR.
#define BM_DMA_TCD31_CSR_INTMAJOR      (0x0002U)  //!< Bit mask for DMA_TCD31_CSR_INTMAJOR.
#define BS_DMA_TCD31_CSR_INTMAJOR      (1U)  //!< Bitfield size in bits for DMA_TCD31_CSR_INTMAJOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_INTMAJOR field.
#define BR_DMA_TCD31_CSR_INTMAJOR()   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_INTMAJOR))
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_INTMAJOR.
#define BF_DMA_TCD31_CSR_INTMAJOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_INTMAJOR), uint16_t) & BM_DMA_TCD31_CSR_INTMAJOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTMAJOR field to a new value.
#define BW_DMA_TCD31_CSR_INTMAJOR(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_INTMAJOR) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting the appropriate bit in
 * the INT register when the current major iteration count reaches the halfway point. Specifically,
 * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point
 * interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types
 * of data movement where the processor needs an early indication of the transfers progress. If
 * BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
//@{
#define BP_DMA_TCD31_CSR_INTHALF      (2U)      //!< Bit position for DMA_TCD31_CSR_INTHALF.
#define BM_DMA_TCD31_CSR_INTHALF      (0x0004U)  //!< Bit mask for DMA_TCD31_CSR_INTHALF.
#define BS_DMA_TCD31_CSR_INTHALF      (1U)  //!< Bitfield size in bits for DMA_TCD31_CSR_INTHALF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_INTHALF field.
#define BR_DMA_TCD31_CSR_INTHALF()   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_INTHALF))
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_INTHALF.
#define BF_DMA_TCD31_CSR_INTHALF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_INTHALF), uint16_t) & BM_DMA_TCD31_CSR_INTHALF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTHALF field to a new value.
#define BW_DMA_TCD31_CSR_INTHALF(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_INTHALF) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the
 * current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channels ERQ bit is not affected
 * - 1 - The channels ERQ bit is cleared when the major loop is complete
 */
//@{
#define BP_DMA_TCD31_CSR_DREQ      (3U)      //!< Bit position for DMA_TCD31_CSR_DREQ.
#define BM_DMA_TCD31_CSR_DREQ      (0x0008U)  //!< Bit mask for DMA_TCD31_CSR_DREQ.
#define BS_DMA_TCD31_CSR_DREQ      (1U)  //!< Bitfield size in bits for DMA_TCD31_CSR_DREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_DREQ field.
#define BR_DMA_TCD31_CSR_DREQ()   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_DREQ))
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_DREQ.
#define BF_DMA_TCD31_CSR_DREQ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_DREQ), uint16_t) & BM_DMA_TCD31_CSR_DREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DREQ field to a new value.
#define BW_DMA_TCD31_CSR_DREQ(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_DREQ) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather processing in the
 * current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32
 * address containing a 32-byte data structure loaded as the transfer control descriptor into the
 * local memory. To support the dynamic scatter/gather coherency model, this field is forced to zero
 * when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channels TCD is normal format.
 * - 1 - The current channels TCD specifies a scatter gather format. The DLASTSGA field provides a memory
 *     pointer to the next TCD to be loaded into this channel after the major loop completes its
 *     execution.
 */
//@{
#define BP_DMA_TCD31_CSR_ESG      (4U)      //!< Bit position for DMA_TCD31_CSR_ESG.
#define BM_DMA_TCD31_CSR_ESG      (0x0010U)  //!< Bit mask for DMA_TCD31_CSR_ESG.
#define BS_DMA_TCD31_CSR_ESG      (1U)  //!< Bitfield size in bits for DMA_TCD31_CSR_ESG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_ESG field.
#define BR_DMA_TCD31_CSR_ESG()   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_ESG))
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_ESG.
#define BF_DMA_TCD31_CSR_ESG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_ESG), uint16_t) & BM_DMA_TCD31_CSR_ESG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ESG field to a new value.
#define BW_DMA_TCD31_CSR_ESG(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_ESG) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to another channel,
 * defined by MAJORLINKCH. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. To support the
 * dynamic linking coherency model, this field is forced to zero when written to while the
 * TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD31_CSR_MAJORELINK      (5U)      //!< Bit position for DMA_TCD31_CSR_MAJORELINK.
#define BM_DMA_TCD31_CSR_MAJORELINK      (0x0020U)  //!< Bit mask for DMA_TCD31_CSR_MAJORELINK.
#define BS_DMA_TCD31_CSR_MAJORELINK      (1U)  //!< Bitfield size in bits for DMA_TCD31_CSR_MAJORELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_MAJORELINK field.
#define BR_DMA_TCD31_CSR_MAJORELINK()   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_MAJORELINK))
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_MAJORELINK.
#define BF_DMA_TCD31_CSR_MAJORELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_MAJORELINK), uint16_t) & BM_DMA_TCD31_CSR_MAJORELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORELINK field to a new value.
#define BW_DMA_TCD31_CSR_MAJORELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_MAJORELINK) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when channel service begins,
 * and the eDMA clears it as the minor loop completes or if any error condition is detected.
 */
//@{
#define BP_DMA_TCD31_CSR_ACTIVE      (6U)      //!< Bit position for DMA_TCD31_CSR_ACTIVE.
#define BM_DMA_TCD31_CSR_ACTIVE      (0x0040U)  //!< Bit mask for DMA_TCD31_CSR_ACTIVE.
#define BS_DMA_TCD31_CSR_ACTIVE      (1U)  //!< Bitfield size in bits for DMA_TCD31_CSR_ACTIVE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_ACTIVE field.
#define BR_DMA_TCD31_CSR_ACTIVE()   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_ACTIVE))
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_ACTIVE.
#define BF_DMA_TCD31_CSR_ACTIVE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_ACTIVE), uint16_t) & BM_DMA_TCD31_CSR_ACTIVE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACTIVE field to a new value.
#define BW_DMA_TCD31_CSR_ACTIVE(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_ACTIVE) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER
 * count reaches zero; The software clears it, or the hardware when the channel is activated. This
 * bit must be cleared to write the MAJORELINK or ESG bits. This bit resets to zero.
 */
//@{
#define BP_DMA_TCD31_CSR_DONE      (7U)      //!< Bit position for DMA_TCD31_CSR_DONE.
#define BM_DMA_TCD31_CSR_DONE      (0x0080U)  //!< Bit mask for DMA_TCD31_CSR_DONE.
#define BS_DMA_TCD31_CSR_DONE      (1U)  //!< Bitfield size in bits for DMA_TCD31_CSR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_DONE field.
#define BR_DMA_TCD31_CSR_DONE()   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_DONE))
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_DONE.
#define BF_DMA_TCD31_CSR_DONE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_DONE), uint16_t) & BM_DMA_TCD31_CSR_DONE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONE field to a new value.
#define BW_DMA_TCD31_CSR_DONE(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_CSR_ADDR, BP_DMA_TCD31_CSR_DONE) = (v))
#endif
//@}

/*! @name Register DMA_TCD31_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is performed after the major
 * loop counter is exhausted. else After the major loop counter is exhausted, the eDMA engine
 * initiates a channel service request at the channel defined by these five bits by setting that
 * channels TCDn_CSR[START] bit.
 */
//@{
#define BP_DMA_TCD31_CSR_MAJORLINKCH      (8U)      //!< Bit position for DMA_TCD31_CSR_MAJORLINKCH.
#define BM_DMA_TCD31_CSR_MAJORLINKCH      (0x1f00U)  //!< Bit mask for DMA_TCD31_CSR_MAJORLINKCH.
#define BS_DMA_TCD31_CSR_MAJORLINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD31_CSR_MAJORLINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_MAJORLINKCH field.
#define BR_DMA_TCD31_CSR_MAJORLINKCH()   (HW_DMA_TCD31_CSR.B.MAJORLINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_MAJORLINKCH.
#define BF_DMA_TCD31_CSR_MAJORLINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_MAJORLINKCH), uint16_t) & BM_DMA_TCD31_CSR_MAJORLINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MAJORLINKCH field to a new value.
#define BW_DMA_TCD31_CSR_MAJORLINKCH(v)   (HW_DMA_TCD31_CSR_WR((HW_DMA_TCD31_CSR_RD() & ~BM_DMA_TCD31_CSR_MAJORLINKCH) | BF_DMA_TCD31_CSR_MAJORLINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD31_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the
 * minor loop, it continuously generates read/write sequences until the minor count is exhausted.
 * This field forces the eDMA to stall after the completion of each read/write access to control the
 * bus request bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last write of each
 * minor loop. This behavior is a side effect of reducing start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
//@{
#define BP_DMA_TCD31_CSR_BWC      (14U)      //!< Bit position for DMA_TCD31_CSR_BWC.
#define BM_DMA_TCD31_CSR_BWC      (0xc000U)  //!< Bit mask for DMA_TCD31_CSR_BWC.
#define BS_DMA_TCD31_CSR_BWC      (2U)  //!< Bitfield size in bits for DMA_TCD31_CSR_BWC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_CSR_BWC field.
#define BR_DMA_TCD31_CSR_BWC()   (HW_DMA_TCD31_CSR.B.BWC)
#endif

//! @brief Format value for bitfield DMA_TCD31_CSR_BWC.
#define BF_DMA_TCD31_CSR_BWC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_CSR_BWC), uint16_t) & BM_DMA_TCD31_CSR_BWC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BWC field to a new value.
#define BW_DMA_TCD31_CSR_BWC(v)   (HW_DMA_TCD31_CSR_WR((HW_DMA_TCD31_CSR_RD() & ~BM_DMA_TCD31_CSR_BWC) | BF_DMA_TCD31_CSR_BWC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd31_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcd31_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9; //!< [8:0] Starting Major Iteration Count
        uint16_t LINKCH : 5; //!< [13:9] Link Channel Number
        uint16_t RESERVED0 : 1; //!< [14] 
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd31_biter_elinkyes_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_BITER_ELINKYES register
 */
//@{
#define HW_DMA_TCD31_BITER_ELINKYES_ADDR      (REGS_DMA_BASE + 0x13feU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_BITER_ELINKYES           (*(__IO hw_dma_tcd31_biter_elinkyes_t *) HW_DMA_TCD31_BITER_ELINKYES_ADDR)
#define HW_DMA_TCD31_BITER_ELINKYES_RD()      (HW_DMA_TCD31_BITER_ELINKYES.U)
#define HW_DMA_TCD31_BITER_ELINKYES_WR(v)     (HW_DMA_TCD31_BITER_ELINKYES.U = (v))
#define HW_DMA_TCD31_BITER_ELINKYES_SET(v)    (HW_DMA_TCD31_BITER_ELINKYES_WR(HW_DMA_TCD31_BITER_ELINKYES_RD() |  (v)))
#define HW_DMA_TCD31_BITER_ELINKYES_CLR(v)    (HW_DMA_TCD31_BITER_ELINKYES_WR(HW_DMA_TCD31_BITER_ELINKYES_RD() & ~(v)))
#define HW_DMA_TCD31_BITER_ELINKYES_TOG(v)    (HW_DMA_TCD31_BITER_ELINKYES_WR(HW_DMA_TCD31_BITER_ELINKYES_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_BITER_ELINKYES bitfields
 */

/*! @name Register DMA_TCD31_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD31_BITER_ELINKYES_BITER      (0U)      //!< Bit position for DMA_TCD31_BITER_ELINKYES_BITER.
#define BM_DMA_TCD31_BITER_ELINKYES_BITER      (0x01ffU)  //!< Bit mask for DMA_TCD31_BITER_ELINKYES_BITER.
#define BS_DMA_TCD31_BITER_ELINKYES_BITER      (9U)  //!< Bitfield size in bits for DMA_TCD31_BITER_ELINKYES_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_BITER_ELINKYES_BITER field.
#define BR_DMA_TCD31_BITER_ELINKYES_BITER()   (HW_DMA_TCD31_BITER_ELINKYES.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD31_BITER_ELINKYES_BITER.
#define BF_DMA_TCD31_BITER_ELINKYES_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_BITER_ELINKYES_BITER), uint16_t) & BM_DMA_TCD31_BITER_ELINKYES_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD31_BITER_ELINKYES_BITER(v)   (HW_DMA_TCD31_BITER_ELINKYES_WR((HW_DMA_TCD31_BITER_ELINKYES_RD() & ~BM_DMA_TCD31_BITER_ELINKYES_BITER) | BF_DMA_TCD31_BITER_ELINKYES_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD31_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the
 * eDMA engine initiates a channel service request at the channel defined by these six bits by
 * setting that channels TCDn_CSR[START] bit. When the software loads the TCD, this field must be
 * set equal to the corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into the CITER field.
 */
//@{
#define BP_DMA_TCD31_BITER_ELINKYES_LINKCH      (9U)      //!< Bit position for DMA_TCD31_BITER_ELINKYES_LINKCH.
#define BM_DMA_TCD31_BITER_ELINKYES_LINKCH      (0x3e00U)  //!< Bit mask for DMA_TCD31_BITER_ELINKYES_LINKCH.
#define BS_DMA_TCD31_BITER_ELINKYES_LINKCH      (5U)  //!< Bitfield size in bits for DMA_TCD31_BITER_ELINKYES_LINKCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_BITER_ELINKYES_LINKCH field.
#define BR_DMA_TCD31_BITER_ELINKYES_LINKCH()   (HW_DMA_TCD31_BITER_ELINKYES.B.LINKCH)
#endif

//! @brief Format value for bitfield DMA_TCD31_BITER_ELINKYES_LINKCH.
#define BF_DMA_TCD31_BITER_ELINKYES_LINKCH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_BITER_ELINKYES_LINKCH), uint16_t) & BM_DMA_TCD31_BITER_ELINKYES_LINKCH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LINKCH field to a new value.
#define BW_DMA_TCD31_BITER_ELINKYES_LINKCH(v)   (HW_DMA_TCD31_BITER_ELINKYES_WR((HW_DMA_TCD31_BITER_ELINKYES_RD() & ~BM_DMA_TCD31_BITER_ELINKYES_LINKCH) | BF_DMA_TCD31_BITER_ELINKYES_LINKCH(v)))
#endif
//@}

/*! @name Register DMA_TCD31_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * disables, the BITER value extends to 15 bits in place of a link channel number. If the major loop
 * is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. When
 * the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD31_BITER_ELINKYES_ELINK      (15U)      //!< Bit position for DMA_TCD31_BITER_ELINKYES_ELINK.
#define BM_DMA_TCD31_BITER_ELINKYES_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD31_BITER_ELINKYES_ELINK.
#define BS_DMA_TCD31_BITER_ELINKYES_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD31_BITER_ELINKYES_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_BITER_ELINKYES_ELINK field.
#define BR_DMA_TCD31_BITER_ELINKYES_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD31_BITER_ELINKYES_ADDR, BP_DMA_TCD31_BITER_ELINKYES_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD31_BITER_ELINKYES_ELINK.
#define BF_DMA_TCD31_BITER_ELINKYES_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_BITER_ELINKYES_ELINK), uint16_t) & BM_DMA_TCD31_BITER_ELINKYES_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD31_BITER_ELINKYES_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_BITER_ELINKYES_ADDR, BP_DMA_TCD31_BITER_ELINKYES_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_DMA_TCD31_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_DMA_TCD31_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined as follows.
 */
typedef union _hw_dma_tcd31_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcd31_biter_elinkno_bitfields
    {
        uint16_t BITER : 15; //!< [14:0] Starting Major Iteration Count
        uint16_t ELINK : 1; //!< [15] Enables channel-to-channel linking on minor loop complete
    } B;
} hw_dma_tcd31_biter_elinkno_t;
#endif

/*!
 * @name Constants and macros for entire DMA_TCD31_BITER_ELINKNO register
 */
//@{
#define HW_DMA_TCD31_BITER_ELINKNO_ADDR      (REGS_DMA_BASE + 0x13feU)

#ifndef __LANGUAGE_ASM__
#define HW_DMA_TCD31_BITER_ELINKNO           (*(__IO hw_dma_tcd31_biter_elinkno_t *) HW_DMA_TCD31_BITER_ELINKNO_ADDR)
#define HW_DMA_TCD31_BITER_ELINKNO_RD()      (HW_DMA_TCD31_BITER_ELINKNO.U)
#define HW_DMA_TCD31_BITER_ELINKNO_WR(v)     (HW_DMA_TCD31_BITER_ELINKNO.U = (v))
#define HW_DMA_TCD31_BITER_ELINKNO_SET(v)    (HW_DMA_TCD31_BITER_ELINKNO_WR(HW_DMA_TCD31_BITER_ELINKNO_RD() |  (v)))
#define HW_DMA_TCD31_BITER_ELINKNO_CLR(v)    (HW_DMA_TCD31_BITER_ELINKNO_WR(HW_DMA_TCD31_BITER_ELINKNO_RD() & ~(v)))
#define HW_DMA_TCD31_BITER_ELINKNO_TOG(v)    (HW_DMA_TCD31_BITER_ELINKNO_WR(HW_DMA_TCD31_BITER_ELINKNO_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual DMA_TCD31_BITER_ELINKNO bitfields
 */

/*! @name Register DMA_TCD31_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit (ELINK = 1) or 15-bit
 * (ELINK = 0) field must be equal to the value in the CITER field. As the major iteration count is
 * exhausted, the contents of this field are reloaded into the CITER field. When the software loads
 * the TCD, this field must be set equal to the corresponding CITER field; otherwise, a
 * configuration error is reported. As the major iteration count is exhausted, the contents of this
 * field is reloaded into the CITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
//@{
#define BP_DMA_TCD31_BITER_ELINKNO_BITER      (0U)      //!< Bit position for DMA_TCD31_BITER_ELINKNO_BITER.
#define BM_DMA_TCD31_BITER_ELINKNO_BITER      (0x7fffU)  //!< Bit mask for DMA_TCD31_BITER_ELINKNO_BITER.
#define BS_DMA_TCD31_BITER_ELINKNO_BITER      (15U)  //!< Bitfield size in bits for DMA_TCD31_BITER_ELINKNO_BITER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_BITER_ELINKNO_BITER field.
#define BR_DMA_TCD31_BITER_ELINKNO_BITER()   (HW_DMA_TCD31_BITER_ELINKNO.B.BITER)
#endif

//! @brief Format value for bitfield DMA_TCD31_BITER_ELINKNO_BITER.
#define BF_DMA_TCD31_BITER_ELINKNO_BITER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_BITER_ELINKNO_BITER), uint16_t) & BM_DMA_TCD31_BITER_ELINKNO_BITER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITER field to a new value.
#define BW_DMA_TCD31_BITER_ELINKNO_BITER(v)   (HW_DMA_TCD31_BITER_ELINKNO_WR((HW_DMA_TCD31_BITER_ELINKNO_RD() & ~BM_DMA_TCD31_BITER_ELINKNO_BITER) | BF_DMA_TCD31_BITER_ELINKNO_BITER(v)))
#endif
//@}

/*! @name Register DMA_TCD31_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to another channel,
 * defined by BITER[LINKCH]. The link target channel initiates a channel service request via an
 * internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking
 * is disabled, the BITER value extends to 15 bits in place of a link channel number. If the major
 * loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking.
 * When the software loads the TCD, this field must be set equal to the corresponding CITER field;
 * otherwise, a configuration error is reported. As the major iteration count is exhausted, the
 * contents of this field is reloaded into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
//@{
#define BP_DMA_TCD31_BITER_ELINKNO_ELINK      (15U)      //!< Bit position for DMA_TCD31_BITER_ELINKNO_ELINK.
#define BM_DMA_TCD31_BITER_ELINKNO_ELINK      (0x8000U)  //!< Bit mask for DMA_TCD31_BITER_ELINKNO_ELINK.
#define BS_DMA_TCD31_BITER_ELINKNO_ELINK      (1U)  //!< Bitfield size in bits for DMA_TCD31_BITER_ELINKNO_ELINK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the DMA_TCD31_BITER_ELINKNO_ELINK field.
#define BR_DMA_TCD31_BITER_ELINKNO_ELINK()   (BITBAND_ACCESS16(HW_DMA_TCD31_BITER_ELINKNO_ADDR, BP_DMA_TCD31_BITER_ELINKNO_ELINK))
#endif

//! @brief Format value for bitfield DMA_TCD31_BITER_ELINKNO_ELINK.
#define BF_DMA_TCD31_BITER_ELINKNO_ELINK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint16_t) << BP_DMA_TCD31_BITER_ELINKNO_ELINK), uint16_t) & BM_DMA_TCD31_BITER_ELINKNO_ELINK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELINK field to a new value.
#define BW_DMA_TCD31_BITER_ELINKNO_ELINK(v)   (BITBAND_ACCESS16(HW_DMA_TCD31_BITER_ELINKNO_ADDR, BP_DMA_TCD31_BITER_ELINKNO_ELINK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_dma_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All DMA module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_dma
{
    __IO hw_dma_cr_t CR; //!< [0x0] Control Register
    __I hw_dma_es_t ES; //!< [0x4] Error Status Register
    uint32_t _reserved0;
    __IO hw_dma_erq_t ERQ; //!< [0xc] Enable Request Register
    uint32_t _reserved1;
    __IO hw_dma_eei_t EEI; //!< [0x14] Enable Error Interrupt Register
    __O hw_dma_ceei_t CEEI; //!< [0x18] Clear Enable Error Interrupt Register
    __O hw_dma_seei_t SEEI; //!< [0x19] Set Enable Error Interrupt Register
    __O hw_dma_cerq_t CERQ; //!< [0x1a] Clear Enable Request Register
    __O hw_dma_serq_t SERQ; //!< [0x1b] Set Enable Request Register
    __O hw_dma_cdne_t CDNE; //!< [0x1c] Clear DONE Status Bit Register
    __O hw_dma_ssrt_t SSRT; //!< [0x1d] Set START Bit Register
    __O hw_dma_cerr_t CERR; //!< [0x1e] Clear Error Register
    __O hw_dma_cint_t CINT; //!< [0x1f] Clear Interrupt Request Register
    uint32_t _reserved2;
    __IO hw_dma_int_t INT; //!< [0x24] Interrupt Request Register
    uint32_t _reserved3;
    __IO hw_dma_err_t ERR; //!< [0x2c] Error Register
    uint32_t _reserved4;
    __IO hw_dma_hrs_t HRS; //!< [0x34] Hardware Request Status Register
    uint32_t _reserved5[50];
    __IO hw_dma_dchpri3_t DCHPRI3; //!< [0x100] Channel n Priority Register
    __IO hw_dma_dchpri2_t DCHPRI2; //!< [0x101] Channel n Priority Register
    __IO hw_dma_dchpri1_t DCHPRI1; //!< [0x102] Channel n Priority Register
    __IO hw_dma_dchpri0_t DCHPRI0; //!< [0x103] Channel n Priority Register
    __IO hw_dma_dchpri7_t DCHPRI7; //!< [0x104] Channel n Priority Register
    __IO hw_dma_dchpri6_t DCHPRI6; //!< [0x105] Channel n Priority Register
    __IO hw_dma_dchpri5_t DCHPRI5; //!< [0x106] Channel n Priority Register
    __IO hw_dma_dchpri4_t DCHPRI4; //!< [0x107] Channel n Priority Register
    __IO hw_dma_dchpri11_t DCHPRI11; //!< [0x108] Channel n Priority Register
    __IO hw_dma_dchpri10_t DCHPRI10; //!< [0x109] Channel n Priority Register
    __IO hw_dma_dchpri9_t DCHPRI9; //!< [0x10a] Channel n Priority Register
    __IO hw_dma_dchpri8_t DCHPRI8; //!< [0x10b] Channel n Priority Register
    __IO hw_dma_dchpri15_t DCHPRI15; //!< [0x10c] Channel n Priority Register
    __IO hw_dma_dchpri14_t DCHPRI14; //!< [0x10d] Channel n Priority Register
    __IO hw_dma_dchpri13_t DCHPRI13; //!< [0x10e] Channel n Priority Register
    __IO hw_dma_dchpri12_t DCHPRI12; //!< [0x10f] Channel n Priority Register
    __IO hw_dma_dchpri19_t DCHPRI19; //!< [0x110] Channel n Priority Register
    __IO hw_dma_dchpri18_t DCHPRI18; //!< [0x111] Channel n Priority Register
    __IO hw_dma_dchpri17_t DCHPRI17; //!< [0x112] Channel n Priority Register
    __IO hw_dma_dchpri16_t DCHPRI16; //!< [0x113] Channel n Priority Register
    __IO hw_dma_dchpri23_t DCHPRI23; //!< [0x114] Channel n Priority Register
    __IO hw_dma_dchpri22_t DCHPRI22; //!< [0x115] Channel n Priority Register
    __IO hw_dma_dchpri21_t DCHPRI21; //!< [0x116] Channel n Priority Register
    __IO hw_dma_dchpri20_t DCHPRI20; //!< [0x117] Channel n Priority Register
    __IO hw_dma_dchpri27_t DCHPRI27; //!< [0x118] Channel n Priority Register
    __IO hw_dma_dchpri26_t DCHPRI26; //!< [0x119] Channel n Priority Register
    __IO hw_dma_dchpri25_t DCHPRI25; //!< [0x11a] Channel n Priority Register
    __IO hw_dma_dchpri24_t DCHPRI24; //!< [0x11b] Channel n Priority Register
    __IO hw_dma_dchpri31_t DCHPRI31; //!< [0x11c] Channel n Priority Register
    __IO hw_dma_dchpri30_t DCHPRI30; //!< [0x11d] Channel n Priority Register
    __IO hw_dma_dchpri29_t DCHPRI29; //!< [0x11e] Channel n Priority Register
    __IO hw_dma_dchpri28_t DCHPRI28; //!< [0x11f] Channel n Priority Register
    uint32_t _reserved6[952];
    __IO hw_dma_tcd0_saddr_t TCD0_SADDR; //!< [0x1000] TCD Source Address
    __IO hw_dma_tcd0_soff_t TCD0_SOFF; //!< [0x1004] TCD Signed Source Address Offset
    __IO hw_dma_tcd0_attr_t TCD0_ATTR; //!< [0x1006] TCD Transfer Attributes
    __IO hw_dma_tcd0_nbytes_mlno_t TCD0_NBYTES_MLNO; //!< [0x1008] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd0_nbytes_mloffno_t TCD0_NBYTES_MLOFFNO; //!< [0x100c] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd0_nbytes_mloffyes_t TCD0_NBYTES_MLOFFYES; //!< [0x1010] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd0_slast_t TCD0_SLAST; //!< [0x1014] TCD Last Source Address Adjustment
    __IO hw_dma_tcd0_daddr_t TCD0_DADDR; //!< [0x1018] TCD Destination Address
    __IO hw_dma_tcd0_doff_t TCD0_DOFF; //!< [0x101c] TCD Signed Destination Address Offset
    __IO hw_dma_tcd0_citer_elinkyes_t TCD0_CITER_ELINKYES; //!< [0x101e] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd0_citer_elinkno_t TCD0_CITER_ELINKNO; //!< [0x1020] 
    __IO hw_dma_tcd0_dlastsga_t TCD0_DLASTSGA; //!< [0x1022] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd0_csr_t TCD0_CSR; //!< [0x1026] TCD Control and Status
    __IO hw_dma_tcd0_biter_elinkyes_t TCD0_BITER_ELINKYES; //!< [0x1028] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd0_biter_elinkno_t TCD0_BITER_ELINKNO; //!< [0x102a] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd1_saddr_t TCD1_SADDR; //!< [0x102c] TCD Source Address
    __IO hw_dma_tcd1_soff_t TCD1_SOFF; //!< [0x1030] TCD Signed Source Address Offset
    __IO hw_dma_tcd1_attr_t TCD1_ATTR; //!< [0x1032] TCD Transfer Attributes
    __IO hw_dma_tcd1_nbytes_mlno_t TCD1_NBYTES_MLNO; //!< [0x1034] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd1_nbytes_mloffno_t TCD1_NBYTES_MLOFFNO; //!< [0x1038] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd1_nbytes_mloffyes_t TCD1_NBYTES_MLOFFYES; //!< [0x103c] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd1_slast_t TCD1_SLAST; //!< [0x1040] TCD Last Source Address Adjustment
    __IO hw_dma_tcd1_daddr_t TCD1_DADDR; //!< [0x1044] TCD Destination Address
    __IO hw_dma_tcd1_doff_t TCD1_DOFF; //!< [0x1048] TCD Signed Destination Address Offset
    __IO hw_dma_tcd1_citer_elinkyes_t TCD1_CITER_ELINKYES; //!< [0x104a] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd1_citer_elinkno_t TCD1_CITER_ELINKNO; //!< [0x104c] 
    __IO hw_dma_tcd1_dlastsga_t TCD1_DLASTSGA; //!< [0x104e] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd1_csr_t TCD1_CSR; //!< [0x1052] TCD Control and Status
    __IO hw_dma_tcd1_biter_elinkyes_t TCD1_BITER_ELINKYES; //!< [0x1054] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd1_biter_elinkno_t TCD1_BITER_ELINKNO; //!< [0x1056] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd2_saddr_t TCD2_SADDR; //!< [0x1058] TCD Source Address
    __IO hw_dma_tcd2_soff_t TCD2_SOFF; //!< [0x105c] TCD Signed Source Address Offset
    __IO hw_dma_tcd2_attr_t TCD2_ATTR; //!< [0x105e] TCD Transfer Attributes
    __IO hw_dma_tcd2_nbytes_mlno_t TCD2_NBYTES_MLNO; //!< [0x1060] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd2_nbytes_mloffno_t TCD2_NBYTES_MLOFFNO; //!< [0x1064] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd2_nbytes_mloffyes_t TCD2_NBYTES_MLOFFYES; //!< [0x1068] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd2_slast_t TCD2_SLAST; //!< [0x106c] TCD Last Source Address Adjustment
    __IO hw_dma_tcd2_daddr_t TCD2_DADDR; //!< [0x1070] TCD Destination Address
    __IO hw_dma_tcd2_doff_t TCD2_DOFF; //!< [0x1074] TCD Signed Destination Address Offset
    __IO hw_dma_tcd2_citer_elinkyes_t TCD2_CITER_ELINKYES; //!< [0x1076] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd2_citer_elinkno_t TCD2_CITER_ELINKNO; //!< [0x1078] 
    __IO hw_dma_tcd2_dlastsga_t TCD2_DLASTSGA; //!< [0x107a] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd2_csr_t TCD2_CSR; //!< [0x107e] TCD Control and Status
    __IO hw_dma_tcd2_biter_elinkyes_t TCD2_BITER_ELINKYES; //!< [0x1080] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd2_biter_elinkno_t TCD2_BITER_ELINKNO; //!< [0x1082] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd3_saddr_t TCD3_SADDR; //!< [0x1084] TCD Source Address
    __IO hw_dma_tcd3_soff_t TCD3_SOFF; //!< [0x1088] TCD Signed Source Address Offset
    __IO hw_dma_tcd3_attr_t TCD3_ATTR; //!< [0x108a] TCD Transfer Attributes
    __IO hw_dma_tcd3_nbytes_mlno_t TCD3_NBYTES_MLNO; //!< [0x108c] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd3_nbytes_mloffno_t TCD3_NBYTES_MLOFFNO; //!< [0x1090] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd3_nbytes_mloffyes_t TCD3_NBYTES_MLOFFYES; //!< [0x1094] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd3_slast_t TCD3_SLAST; //!< [0x1098] TCD Last Source Address Adjustment
    __IO hw_dma_tcd3_daddr_t TCD3_DADDR; //!< [0x109c] TCD Destination Address
    __IO hw_dma_tcd3_doff_t TCD3_DOFF; //!< [0x10a0] TCD Signed Destination Address Offset
    __IO hw_dma_tcd3_citer_elinkyes_t TCD3_CITER_ELINKYES; //!< [0x10a2] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd3_citer_elinkno_t TCD3_CITER_ELINKNO; //!< [0x10a4] 
    __IO hw_dma_tcd3_dlastsga_t TCD3_DLASTSGA; //!< [0x10a6] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd3_csr_t TCD3_CSR; //!< [0x10aa] TCD Control and Status
    __IO hw_dma_tcd3_biter_elinkyes_t TCD3_BITER_ELINKYES; //!< [0x10ac] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd3_biter_elinkno_t TCD3_BITER_ELINKNO; //!< [0x10ae] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd4_saddr_t TCD4_SADDR; //!< [0x10b0] TCD Source Address
    __IO hw_dma_tcd4_soff_t TCD4_SOFF; //!< [0x10b4] TCD Signed Source Address Offset
    __IO hw_dma_tcd4_attr_t TCD4_ATTR; //!< [0x10b6] TCD Transfer Attributes
    __IO hw_dma_tcd4_nbytes_mlno_t TCD4_NBYTES_MLNO; //!< [0x10b8] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd4_nbytes_mloffno_t TCD4_NBYTES_MLOFFNO; //!< [0x10bc] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd4_nbytes_mloffyes_t TCD4_NBYTES_MLOFFYES; //!< [0x10c0] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd4_slast_t TCD4_SLAST; //!< [0x10c4] TCD Last Source Address Adjustment
    __IO hw_dma_tcd4_daddr_t TCD4_DADDR; //!< [0x10c8] TCD Destination Address
    __IO hw_dma_tcd4_doff_t TCD4_DOFF; //!< [0x10cc] TCD Signed Destination Address Offset
    __IO hw_dma_tcd4_citer_elinkyes_t TCD4_CITER_ELINKYES; //!< [0x10ce] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd4_citer_elinkno_t TCD4_CITER_ELINKNO; //!< [0x10d0] 
    __IO hw_dma_tcd4_dlastsga_t TCD4_DLASTSGA; //!< [0x10d2] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd4_csr_t TCD4_CSR; //!< [0x10d6] TCD Control and Status
    __IO hw_dma_tcd4_biter_elinkyes_t TCD4_BITER_ELINKYES; //!< [0x10d8] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd4_biter_elinkno_t TCD4_BITER_ELINKNO; //!< [0x10da] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd5_saddr_t TCD5_SADDR; //!< [0x10dc] TCD Source Address
    __IO hw_dma_tcd5_soff_t TCD5_SOFF; //!< [0x10e0] TCD Signed Source Address Offset
    __IO hw_dma_tcd5_attr_t TCD5_ATTR; //!< [0x10e2] TCD Transfer Attributes
    __IO hw_dma_tcd5_nbytes_mlno_t TCD5_NBYTES_MLNO; //!< [0x10e4] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd5_nbytes_mloffno_t TCD5_NBYTES_MLOFFNO; //!< [0x10e8] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd5_nbytes_mloffyes_t TCD5_NBYTES_MLOFFYES; //!< [0x10ec] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd5_slast_t TCD5_SLAST; //!< [0x10f0] TCD Last Source Address Adjustment
    __IO hw_dma_tcd5_daddr_t TCD5_DADDR; //!< [0x10f4] TCD Destination Address
    __IO hw_dma_tcd5_doff_t TCD5_DOFF; //!< [0x10f8] TCD Signed Destination Address Offset
    __IO hw_dma_tcd5_citer_elinkyes_t TCD5_CITER_ELINKYES; //!< [0x10fa] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd5_citer_elinkno_t TCD5_CITER_ELINKNO; //!< [0x10fc] 
    __IO hw_dma_tcd5_dlastsga_t TCD5_DLASTSGA; //!< [0x10fe] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd5_csr_t TCD5_CSR; //!< [0x1102] TCD Control and Status
    __IO hw_dma_tcd5_biter_elinkyes_t TCD5_BITER_ELINKYES; //!< [0x1104] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd5_biter_elinkno_t TCD5_BITER_ELINKNO; //!< [0x1106] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd6_saddr_t TCD6_SADDR; //!< [0x1108] TCD Source Address
    __IO hw_dma_tcd6_soff_t TCD6_SOFF; //!< [0x110c] TCD Signed Source Address Offset
    __IO hw_dma_tcd6_attr_t TCD6_ATTR; //!< [0x110e] TCD Transfer Attributes
    __IO hw_dma_tcd6_nbytes_mlno_t TCD6_NBYTES_MLNO; //!< [0x1110] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd6_nbytes_mloffno_t TCD6_NBYTES_MLOFFNO; //!< [0x1114] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd6_nbytes_mloffyes_t TCD6_NBYTES_MLOFFYES; //!< [0x1118] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd6_slast_t TCD6_SLAST; //!< [0x111c] TCD Last Source Address Adjustment
    __IO hw_dma_tcd6_daddr_t TCD6_DADDR; //!< [0x1120] TCD Destination Address
    __IO hw_dma_tcd6_doff_t TCD6_DOFF; //!< [0x1124] TCD Signed Destination Address Offset
    __IO hw_dma_tcd6_citer_elinkyes_t TCD6_CITER_ELINKYES; //!< [0x1126] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd6_citer_elinkno_t TCD6_CITER_ELINKNO; //!< [0x1128] 
    __IO hw_dma_tcd6_dlastsga_t TCD6_DLASTSGA; //!< [0x112a] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd6_csr_t TCD6_CSR; //!< [0x112e] TCD Control and Status
    __IO hw_dma_tcd6_biter_elinkyes_t TCD6_BITER_ELINKYES; //!< [0x1130] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd6_biter_elinkno_t TCD6_BITER_ELINKNO; //!< [0x1132] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd7_saddr_t TCD7_SADDR; //!< [0x1134] TCD Source Address
    __IO hw_dma_tcd7_soff_t TCD7_SOFF; //!< [0x1138] TCD Signed Source Address Offset
    __IO hw_dma_tcd7_attr_t TCD7_ATTR; //!< [0x113a] TCD Transfer Attributes
    __IO hw_dma_tcd7_nbytes_mlno_t TCD7_NBYTES_MLNO; //!< [0x113c] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd7_nbytes_mloffno_t TCD7_NBYTES_MLOFFNO; //!< [0x1140] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd7_nbytes_mloffyes_t TCD7_NBYTES_MLOFFYES; //!< [0x1144] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd7_slast_t TCD7_SLAST; //!< [0x1148] TCD Last Source Address Adjustment
    __IO hw_dma_tcd7_daddr_t TCD7_DADDR; //!< [0x114c] TCD Destination Address
    __IO hw_dma_tcd7_doff_t TCD7_DOFF; //!< [0x1150] TCD Signed Destination Address Offset
    __IO hw_dma_tcd7_citer_elinkyes_t TCD7_CITER_ELINKYES; //!< [0x1152] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd7_citer_elinkno_t TCD7_CITER_ELINKNO; //!< [0x1154] 
    __IO hw_dma_tcd7_dlastsga_t TCD7_DLASTSGA; //!< [0x1156] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd7_csr_t TCD7_CSR; //!< [0x115a] TCD Control and Status
    __IO hw_dma_tcd7_biter_elinkyes_t TCD7_BITER_ELINKYES; //!< [0x115c] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd7_biter_elinkno_t TCD7_BITER_ELINKNO; //!< [0x115e] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd8_saddr_t TCD8_SADDR; //!< [0x1160] TCD Source Address
    __IO hw_dma_tcd8_soff_t TCD8_SOFF; //!< [0x1164] TCD Signed Source Address Offset
    __IO hw_dma_tcd8_attr_t TCD8_ATTR; //!< [0x1166] TCD Transfer Attributes
    __IO hw_dma_tcd8_nbytes_mlno_t TCD8_NBYTES_MLNO; //!< [0x1168] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd8_nbytes_mloffno_t TCD8_NBYTES_MLOFFNO; //!< [0x116c] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd8_nbytes_mloffyes_t TCD8_NBYTES_MLOFFYES; //!< [0x1170] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd8_slast_t TCD8_SLAST; //!< [0x1174] TCD Last Source Address Adjustment
    __IO hw_dma_tcd8_daddr_t TCD8_DADDR; //!< [0x1178] TCD Destination Address
    __IO hw_dma_tcd8_doff_t TCD8_DOFF; //!< [0x117c] TCD Signed Destination Address Offset
    __IO hw_dma_tcd8_citer_elinkyes_t TCD8_CITER_ELINKYES; //!< [0x117e] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd8_citer_elinkno_t TCD8_CITER_ELINKNO; //!< [0x1180] 
    __IO hw_dma_tcd8_dlastsga_t TCD8_DLASTSGA; //!< [0x1182] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd8_csr_t TCD8_CSR; //!< [0x1186] TCD Control and Status
    __IO hw_dma_tcd8_biter_elinkyes_t TCD8_BITER_ELINKYES; //!< [0x1188] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd8_biter_elinkno_t TCD8_BITER_ELINKNO; //!< [0x118a] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd9_saddr_t TCD9_SADDR; //!< [0x118c] TCD Source Address
    __IO hw_dma_tcd9_soff_t TCD9_SOFF; //!< [0x1190] TCD Signed Source Address Offset
    __IO hw_dma_tcd9_attr_t TCD9_ATTR; //!< [0x1192] TCD Transfer Attributes
    __IO hw_dma_tcd9_nbytes_mlno_t TCD9_NBYTES_MLNO; //!< [0x1194] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd9_nbytes_mloffno_t TCD9_NBYTES_MLOFFNO; //!< [0x1198] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd9_nbytes_mloffyes_t TCD9_NBYTES_MLOFFYES; //!< [0x119c] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd9_slast_t TCD9_SLAST; //!< [0x11a0] TCD Last Source Address Adjustment
    __IO hw_dma_tcd9_daddr_t TCD9_DADDR; //!< [0x11a4] TCD Destination Address
    __IO hw_dma_tcd9_doff_t TCD9_DOFF; //!< [0x11a8] TCD Signed Destination Address Offset
    __IO hw_dma_tcd9_citer_elinkyes_t TCD9_CITER_ELINKYES; //!< [0x11aa] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd9_citer_elinkno_t TCD9_CITER_ELINKNO; //!< [0x11ac] 
    __IO hw_dma_tcd9_dlastsga_t TCD9_DLASTSGA; //!< [0x11ae] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd9_csr_t TCD9_CSR; //!< [0x11b2] TCD Control and Status
    __IO hw_dma_tcd9_biter_elinkyes_t TCD9_BITER_ELINKYES; //!< [0x11b4] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd9_biter_elinkno_t TCD9_BITER_ELINKNO; //!< [0x11b6] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd10_saddr_t TCD10_SADDR; //!< [0x11b8] TCD Source Address
    __IO hw_dma_tcd10_soff_t TCD10_SOFF; //!< [0x11bc] TCD Signed Source Address Offset
    __IO hw_dma_tcd10_attr_t TCD10_ATTR; //!< [0x11be] TCD Transfer Attributes
    __IO hw_dma_tcd10_nbytes_mlno_t TCD10_NBYTES_MLNO; //!< [0x11c0] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd10_nbytes_mloffno_t TCD10_NBYTES_MLOFFNO; //!< [0x11c4] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd10_nbytes_mloffyes_t TCD10_NBYTES_MLOFFYES; //!< [0x11c8] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd10_slast_t TCD10_SLAST; //!< [0x11cc] TCD Last Source Address Adjustment
    __IO hw_dma_tcd10_daddr_t TCD10_DADDR; //!< [0x11d0] TCD Destination Address
    __IO hw_dma_tcd10_doff_t TCD10_DOFF; //!< [0x11d4] TCD Signed Destination Address Offset
    __IO hw_dma_tcd10_citer_elinkyes_t TCD10_CITER_ELINKYES; //!< [0x11d6] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd10_citer_elinkno_t TCD10_CITER_ELINKNO; //!< [0x11d8] 
    __IO hw_dma_tcd10_dlastsga_t TCD10_DLASTSGA; //!< [0x11da] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd10_csr_t TCD10_CSR; //!< [0x11de] TCD Control and Status
    __IO hw_dma_tcd10_biter_elinkyes_t TCD10_BITER_ELINKYES; //!< [0x11e0] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd10_biter_elinkno_t TCD10_BITER_ELINKNO; //!< [0x11e2] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd11_saddr_t TCD11_SADDR; //!< [0x11e4] TCD Source Address
    __IO hw_dma_tcd11_soff_t TCD11_SOFF; //!< [0x11e8] TCD Signed Source Address Offset
    __IO hw_dma_tcd11_attr_t TCD11_ATTR; //!< [0x11ea] TCD Transfer Attributes
    __IO hw_dma_tcd11_nbytes_mlno_t TCD11_NBYTES_MLNO; //!< [0x11ec] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd11_nbytes_mloffno_t TCD11_NBYTES_MLOFFNO; //!< [0x11f0] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd11_nbytes_mloffyes_t TCD11_NBYTES_MLOFFYES; //!< [0x11f4] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd11_slast_t TCD11_SLAST; //!< [0x11f8] TCD Last Source Address Adjustment
    __IO hw_dma_tcd11_daddr_t TCD11_DADDR; //!< [0x11fc] TCD Destination Address
    __IO hw_dma_tcd11_doff_t TCD11_DOFF; //!< [0x1200] TCD Signed Destination Address Offset
    __IO hw_dma_tcd11_citer_elinkyes_t TCD11_CITER_ELINKYES; //!< [0x1202] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd11_citer_elinkno_t TCD11_CITER_ELINKNO; //!< [0x1204] 
    __IO hw_dma_tcd11_dlastsga_t TCD11_DLASTSGA; //!< [0x1206] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd11_csr_t TCD11_CSR; //!< [0x120a] TCD Control and Status
    __IO hw_dma_tcd11_biter_elinkyes_t TCD11_BITER_ELINKYES; //!< [0x120c] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd11_biter_elinkno_t TCD11_BITER_ELINKNO; //!< [0x120e] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd12_saddr_t TCD12_SADDR; //!< [0x1210] TCD Source Address
    __IO hw_dma_tcd12_soff_t TCD12_SOFF; //!< [0x1214] TCD Signed Source Address Offset
    __IO hw_dma_tcd12_attr_t TCD12_ATTR; //!< [0x1216] TCD Transfer Attributes
    __IO hw_dma_tcd12_nbytes_mlno_t TCD12_NBYTES_MLNO; //!< [0x1218] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd12_nbytes_mloffno_t TCD12_NBYTES_MLOFFNO; //!< [0x121c] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd12_nbytes_mloffyes_t TCD12_NBYTES_MLOFFYES; //!< [0x1220] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd12_slast_t TCD12_SLAST; //!< [0x1224] TCD Last Source Address Adjustment
    __IO hw_dma_tcd12_daddr_t TCD12_DADDR; //!< [0x1228] TCD Destination Address
    __IO hw_dma_tcd12_doff_t TCD12_DOFF; //!< [0x122c] TCD Signed Destination Address Offset
    __IO hw_dma_tcd12_citer_elinkyes_t TCD12_CITER_ELINKYES; //!< [0x122e] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd12_citer_elinkno_t TCD12_CITER_ELINKNO; //!< [0x1230] 
    __IO hw_dma_tcd12_dlastsga_t TCD12_DLASTSGA; //!< [0x1232] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd12_csr_t TCD12_CSR; //!< [0x1236] TCD Control and Status
    __IO hw_dma_tcd12_biter_elinkyes_t TCD12_BITER_ELINKYES; //!< [0x1238] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd12_biter_elinkno_t TCD12_BITER_ELINKNO; //!< [0x123a] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd13_saddr_t TCD13_SADDR; //!< [0x123c] TCD Source Address
    __IO hw_dma_tcd13_soff_t TCD13_SOFF; //!< [0x1240] TCD Signed Source Address Offset
    __IO hw_dma_tcd13_attr_t TCD13_ATTR; //!< [0x1242] TCD Transfer Attributes
    __IO hw_dma_tcd13_nbytes_mlno_t TCD13_NBYTES_MLNO; //!< [0x1244] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd13_nbytes_mloffno_t TCD13_NBYTES_MLOFFNO; //!< [0x1248] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd13_nbytes_mloffyes_t TCD13_NBYTES_MLOFFYES; //!< [0x124c] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd13_slast_t TCD13_SLAST; //!< [0x1250] TCD Last Source Address Adjustment
    __IO hw_dma_tcd13_daddr_t TCD13_DADDR; //!< [0x1254] TCD Destination Address
    __IO hw_dma_tcd13_doff_t TCD13_DOFF; //!< [0x1258] TCD Signed Destination Address Offset
    __IO hw_dma_tcd13_citer_elinkyes_t TCD13_CITER_ELINKYES; //!< [0x125a] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd13_citer_elinkno_t TCD13_CITER_ELINKNO; //!< [0x125c] 
    __IO hw_dma_tcd13_dlastsga_t TCD13_DLASTSGA; //!< [0x125e] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd13_csr_t TCD13_CSR; //!< [0x1262] TCD Control and Status
    __IO hw_dma_tcd13_biter_elinkyes_t TCD13_BITER_ELINKYES; //!< [0x1264] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd13_biter_elinkno_t TCD13_BITER_ELINKNO; //!< [0x1266] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd14_saddr_t TCD14_SADDR; //!< [0x1268] TCD Source Address
    __IO hw_dma_tcd14_soff_t TCD14_SOFF; //!< [0x126c] TCD Signed Source Address Offset
    __IO hw_dma_tcd14_attr_t TCD14_ATTR; //!< [0x126e] TCD Transfer Attributes
    __IO hw_dma_tcd14_nbytes_mlno_t TCD14_NBYTES_MLNO; //!< [0x1270] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd14_nbytes_mloffno_t TCD14_NBYTES_MLOFFNO; //!< [0x1274] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd14_nbytes_mloffyes_t TCD14_NBYTES_MLOFFYES; //!< [0x1278] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd14_slast_t TCD14_SLAST; //!< [0x127c] TCD Last Source Address Adjustment
    __IO hw_dma_tcd14_daddr_t TCD14_DADDR; //!< [0x1280] TCD Destination Address
    __IO hw_dma_tcd14_doff_t TCD14_DOFF; //!< [0x1284] TCD Signed Destination Address Offset
    __IO hw_dma_tcd14_citer_elinkyes_t TCD14_CITER_ELINKYES; //!< [0x1286] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd14_citer_elinkno_t TCD14_CITER_ELINKNO; //!< [0x1288] 
    __IO hw_dma_tcd14_dlastsga_t TCD14_DLASTSGA; //!< [0x128a] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd14_csr_t TCD14_CSR; //!< [0x128e] TCD Control and Status
    __IO hw_dma_tcd14_biter_elinkyes_t TCD14_BITER_ELINKYES; //!< [0x1290] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd14_biter_elinkno_t TCD14_BITER_ELINKNO; //!< [0x1292] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd15_saddr_t TCD15_SADDR; //!< [0x1294] TCD Source Address
    __IO hw_dma_tcd15_soff_t TCD15_SOFF; //!< [0x1298] TCD Signed Source Address Offset
    __IO hw_dma_tcd15_attr_t TCD15_ATTR; //!< [0x129a] TCD Transfer Attributes
    __IO hw_dma_tcd15_nbytes_mlno_t TCD15_NBYTES_MLNO; //!< [0x129c] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd15_nbytes_mloffno_t TCD15_NBYTES_MLOFFNO; //!< [0x12a0] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd15_nbytes_mloffyes_t TCD15_NBYTES_MLOFFYES; //!< [0x12a4] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd15_slast_t TCD15_SLAST; //!< [0x12a8] TCD Last Source Address Adjustment
    __IO hw_dma_tcd15_daddr_t TCD15_DADDR; //!< [0x12ac] TCD Destination Address
    __IO hw_dma_tcd15_doff_t TCD15_DOFF; //!< [0x12b0] TCD Signed Destination Address Offset
    __IO hw_dma_tcd15_citer_elinkyes_t TCD15_CITER_ELINKYES; //!< [0x12b2] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd15_citer_elinkno_t TCD15_CITER_ELINKNO; //!< [0x12b4] 
    __IO hw_dma_tcd15_dlastsga_t TCD15_DLASTSGA; //!< [0x12b6] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd15_csr_t TCD15_CSR; //!< [0x12ba] TCD Control and Status
    __IO hw_dma_tcd15_biter_elinkyes_t TCD15_BITER_ELINKYES; //!< [0x12bc] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd15_biter_elinkno_t TCD15_BITER_ELINKNO; //!< [0x12be] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd16_saddr_t TCD16_SADDR; //!< [0x12c0] TCD Source Address
    __IO hw_dma_tcd16_soff_t TCD16_SOFF; //!< [0x12c4] TCD Signed Source Address Offset
    __IO hw_dma_tcd16_attr_t TCD16_ATTR; //!< [0x12c6] TCD Transfer Attributes
    __IO hw_dma_tcd16_nbytes_mlno_t TCD16_NBYTES_MLNO; //!< [0x12c8] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd16_nbytes_mloffno_t TCD16_NBYTES_MLOFFNO; //!< [0x12cc] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd16_nbytes_mloffyes_t TCD16_NBYTES_MLOFFYES; //!< [0x12d0] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd16_slast_t TCD16_SLAST; //!< [0x12d4] TCD Last Source Address Adjustment
    __IO hw_dma_tcd16_daddr_t TCD16_DADDR; //!< [0x12d8] TCD Destination Address
    __IO hw_dma_tcd16_doff_t TCD16_DOFF; //!< [0x12dc] TCD Signed Destination Address Offset
    __IO hw_dma_tcd16_citer_elinkyes_t TCD16_CITER_ELINKYES; //!< [0x12de] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd16_citer_elinkno_t TCD16_CITER_ELINKNO; //!< [0x12e0] 
    __IO hw_dma_tcd16_dlastsga_t TCD16_DLASTSGA; //!< [0x12e2] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd16_csr_t TCD16_CSR; //!< [0x12e6] TCD Control and Status
    __IO hw_dma_tcd16_biter_elinkyes_t TCD16_BITER_ELINKYES; //!< [0x12e8] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd16_biter_elinkno_t TCD16_BITER_ELINKNO; //!< [0x12ea] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd17_saddr_t TCD17_SADDR; //!< [0x12ec] TCD Source Address
    __IO hw_dma_tcd17_soff_t TCD17_SOFF; //!< [0x12f0] TCD Signed Source Address Offset
    __IO hw_dma_tcd17_attr_t TCD17_ATTR; //!< [0x12f2] TCD Transfer Attributes
    __IO hw_dma_tcd17_nbytes_mlno_t TCD17_NBYTES_MLNO; //!< [0x12f4] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd17_nbytes_mloffno_t TCD17_NBYTES_MLOFFNO; //!< [0x12f8] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd17_nbytes_mloffyes_t TCD17_NBYTES_MLOFFYES; //!< [0x12fc] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd17_slast_t TCD17_SLAST; //!< [0x1300] TCD Last Source Address Adjustment
    __IO hw_dma_tcd17_daddr_t TCD17_DADDR; //!< [0x1304] TCD Destination Address
    __IO hw_dma_tcd17_doff_t TCD17_DOFF; //!< [0x1308] TCD Signed Destination Address Offset
    __IO hw_dma_tcd17_citer_elinkyes_t TCD17_CITER_ELINKYES; //!< [0x130a] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd17_citer_elinkno_t TCD17_CITER_ELINKNO; //!< [0x130c] 
    __IO hw_dma_tcd17_dlastsga_t TCD17_DLASTSGA; //!< [0x130e] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd17_csr_t TCD17_CSR; //!< [0x1312] TCD Control and Status
    __IO hw_dma_tcd17_biter_elinkyes_t TCD17_BITER_ELINKYES; //!< [0x1314] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd17_biter_elinkno_t TCD17_BITER_ELINKNO; //!< [0x1316] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd18_saddr_t TCD18_SADDR; //!< [0x1318] TCD Source Address
    __IO hw_dma_tcd18_soff_t TCD18_SOFF; //!< [0x131c] TCD Signed Source Address Offset
    __IO hw_dma_tcd18_attr_t TCD18_ATTR; //!< [0x131e] TCD Transfer Attributes
    __IO hw_dma_tcd18_nbytes_mlno_t TCD18_NBYTES_MLNO; //!< [0x1320] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd18_nbytes_mloffno_t TCD18_NBYTES_MLOFFNO; //!< [0x1324] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd18_nbytes_mloffyes_t TCD18_NBYTES_MLOFFYES; //!< [0x1328] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd18_slast_t TCD18_SLAST; //!< [0x132c] TCD Last Source Address Adjustment
    __IO hw_dma_tcd18_daddr_t TCD18_DADDR; //!< [0x1330] TCD Destination Address
    __IO hw_dma_tcd18_doff_t TCD18_DOFF; //!< [0x1334] TCD Signed Destination Address Offset
    __IO hw_dma_tcd18_citer_elinkyes_t TCD18_CITER_ELINKYES; //!< [0x1336] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd18_citer_elinkno_t TCD18_CITER_ELINKNO; //!< [0x1338] 
    __IO hw_dma_tcd18_dlastsga_t TCD18_DLASTSGA; //!< [0x133a] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd18_csr_t TCD18_CSR; //!< [0x133e] TCD Control and Status
    __IO hw_dma_tcd18_biter_elinkyes_t TCD18_BITER_ELINKYES; //!< [0x1340] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd18_biter_elinkno_t TCD18_BITER_ELINKNO; //!< [0x1342] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd19_saddr_t TCD19_SADDR; //!< [0x1344] TCD Source Address
    __IO hw_dma_tcd19_soff_t TCD19_SOFF; //!< [0x1348] TCD Signed Source Address Offset
    __IO hw_dma_tcd19_attr_t TCD19_ATTR; //!< [0x134a] TCD Transfer Attributes
    __IO hw_dma_tcd19_nbytes_mlno_t TCD19_NBYTES_MLNO; //!< [0x134c] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd19_nbytes_mloffno_t TCD19_NBYTES_MLOFFNO; //!< [0x1350] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd19_nbytes_mloffyes_t TCD19_NBYTES_MLOFFYES; //!< [0x1354] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd19_slast_t TCD19_SLAST; //!< [0x1358] TCD Last Source Address Adjustment
    __IO hw_dma_tcd19_daddr_t TCD19_DADDR; //!< [0x135c] TCD Destination Address
    __IO hw_dma_tcd19_doff_t TCD19_DOFF; //!< [0x1360] TCD Signed Destination Address Offset
    __IO hw_dma_tcd19_citer_elinkyes_t TCD19_CITER_ELINKYES; //!< [0x1362] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd19_citer_elinkno_t TCD19_CITER_ELINKNO; //!< [0x1364] 
    __IO hw_dma_tcd19_dlastsga_t TCD19_DLASTSGA; //!< [0x1366] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd19_csr_t TCD19_CSR; //!< [0x136a] TCD Control and Status
    __IO hw_dma_tcd19_biter_elinkyes_t TCD19_BITER_ELINKYES; //!< [0x136c] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd19_biter_elinkno_t TCD19_BITER_ELINKNO; //!< [0x136e] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd20_saddr_t TCD20_SADDR; //!< [0x1370] TCD Source Address
    __IO hw_dma_tcd20_soff_t TCD20_SOFF; //!< [0x1374] TCD Signed Source Address Offset
    __IO hw_dma_tcd20_attr_t TCD20_ATTR; //!< [0x1376] TCD Transfer Attributes
    __IO hw_dma_tcd20_nbytes_mlno_t TCD20_NBYTES_MLNO; //!< [0x1378] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd20_nbytes_mloffno_t TCD20_NBYTES_MLOFFNO; //!< [0x137c] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd20_nbytes_mloffyes_t TCD20_NBYTES_MLOFFYES; //!< [0x1380] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd20_slast_t TCD20_SLAST; //!< [0x1384] TCD Last Source Address Adjustment
    __IO hw_dma_tcd20_daddr_t TCD20_DADDR; //!< [0x1388] TCD Destination Address
    __IO hw_dma_tcd20_doff_t TCD20_DOFF; //!< [0x138c] TCD Signed Destination Address Offset
    __IO hw_dma_tcd20_citer_elinkyes_t TCD20_CITER_ELINKYES; //!< [0x138e] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd20_citer_elinkno_t TCD20_CITER_ELINKNO; //!< [0x1390] 
    __IO hw_dma_tcd20_dlastsga_t TCD20_DLASTSGA; //!< [0x1392] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd20_csr_t TCD20_CSR; //!< [0x1396] TCD Control and Status
    __IO hw_dma_tcd20_biter_elinkyes_t TCD20_BITER_ELINKYES; //!< [0x1398] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd20_biter_elinkno_t TCD20_BITER_ELINKNO; //!< [0x139a] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd21_saddr_t TCD21_SADDR; //!< [0x139c] TCD Source Address
    __IO hw_dma_tcd21_soff_t TCD21_SOFF; //!< [0x13a0] TCD Signed Source Address Offset
    __IO hw_dma_tcd21_attr_t TCD21_ATTR; //!< [0x13a2] TCD Transfer Attributes
    __IO hw_dma_tcd21_nbytes_mlno_t TCD21_NBYTES_MLNO; //!< [0x13a4] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd21_nbytes_mloffno_t TCD21_NBYTES_MLOFFNO; //!< [0x13a8] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd21_nbytes_mloffyes_t TCD21_NBYTES_MLOFFYES; //!< [0x13ac] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd21_slast_t TCD21_SLAST; //!< [0x13b0] TCD Last Source Address Adjustment
    __IO hw_dma_tcd21_daddr_t TCD21_DADDR; //!< [0x13b4] TCD Destination Address
    __IO hw_dma_tcd21_doff_t TCD21_DOFF; //!< [0x13b8] TCD Signed Destination Address Offset
    __IO hw_dma_tcd21_citer_elinkyes_t TCD21_CITER_ELINKYES; //!< [0x13ba] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd21_citer_elinkno_t TCD21_CITER_ELINKNO; //!< [0x13bc] 
    __IO hw_dma_tcd21_dlastsga_t TCD21_DLASTSGA; //!< [0x13be] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd21_csr_t TCD21_CSR; //!< [0x13c2] TCD Control and Status
    __IO hw_dma_tcd21_biter_elinkyes_t TCD21_BITER_ELINKYES; //!< [0x13c4] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd21_biter_elinkno_t TCD21_BITER_ELINKNO; //!< [0x13c6] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd22_saddr_t TCD22_SADDR; //!< [0x13c8] TCD Source Address
    __IO hw_dma_tcd22_soff_t TCD22_SOFF; //!< [0x13cc] TCD Signed Source Address Offset
    __IO hw_dma_tcd22_attr_t TCD22_ATTR; //!< [0x13ce] TCD Transfer Attributes
    __IO hw_dma_tcd22_nbytes_mlno_t TCD22_NBYTES_MLNO; //!< [0x13d0] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd22_nbytes_mloffno_t TCD22_NBYTES_MLOFFNO; //!< [0x13d4] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd22_nbytes_mloffyes_t TCD22_NBYTES_MLOFFYES; //!< [0x13d8] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd22_slast_t TCD22_SLAST; //!< [0x13dc] TCD Last Source Address Adjustment
    __IO hw_dma_tcd22_daddr_t TCD22_DADDR; //!< [0x13e0] TCD Destination Address
    __IO hw_dma_tcd22_doff_t TCD22_DOFF; //!< [0x13e4] TCD Signed Destination Address Offset
    __IO hw_dma_tcd22_citer_elinkyes_t TCD22_CITER_ELINKYES; //!< [0x13e6] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd22_citer_elinkno_t TCD22_CITER_ELINKNO; //!< [0x13e8] 
    __IO hw_dma_tcd22_dlastsga_t TCD22_DLASTSGA; //!< [0x13ea] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd22_csr_t TCD22_CSR; //!< [0x13ee] TCD Control and Status
    __IO hw_dma_tcd22_biter_elinkyes_t TCD22_BITER_ELINKYES; //!< [0x13f0] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd22_biter_elinkno_t TCD22_BITER_ELINKNO; //!< [0x13f2] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd23_saddr_t TCD23_SADDR; //!< [0x13f4] TCD Source Address
    __IO hw_dma_tcd23_soff_t TCD23_SOFF; //!< [0x13f8] TCD Signed Source Address Offset
    __IO hw_dma_tcd23_attr_t TCD23_ATTR; //!< [0x13fa] TCD Transfer Attributes
    __IO hw_dma_tcd23_nbytes_mlno_t TCD23_NBYTES_MLNO; //!< [0x13fc] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd23_nbytes_mloffno_t TCD23_NBYTES_MLOFFNO; //!< [0x1400] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd23_nbytes_mloffyes_t TCD23_NBYTES_MLOFFYES; //!< [0x1404] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd23_slast_t TCD23_SLAST; //!< [0x1408] TCD Last Source Address Adjustment
    __IO hw_dma_tcd23_daddr_t TCD23_DADDR; //!< [0x140c] TCD Destination Address
    __IO hw_dma_tcd23_doff_t TCD23_DOFF; //!< [0x1410] TCD Signed Destination Address Offset
    __IO hw_dma_tcd23_citer_elinkyes_t TCD23_CITER_ELINKYES; //!< [0x1412] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd23_citer_elinkno_t TCD23_CITER_ELINKNO; //!< [0x1414] 
    __IO hw_dma_tcd23_dlastsga_t TCD23_DLASTSGA; //!< [0x1416] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd23_csr_t TCD23_CSR; //!< [0x141a] TCD Control and Status
    __IO hw_dma_tcd23_biter_elinkyes_t TCD23_BITER_ELINKYES; //!< [0x141c] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd23_biter_elinkno_t TCD23_BITER_ELINKNO; //!< [0x141e] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd24_saddr_t TCD24_SADDR; //!< [0x1420] TCD Source Address
    __IO hw_dma_tcd24_soff_t TCD24_SOFF; //!< [0x1424] TCD Signed Source Address Offset
    __IO hw_dma_tcd24_attr_t TCD24_ATTR; //!< [0x1426] TCD Transfer Attributes
    __IO hw_dma_tcd24_nbytes_mlno_t TCD24_NBYTES_MLNO; //!< [0x1428] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd24_nbytes_mloffno_t TCD24_NBYTES_MLOFFNO; //!< [0x142c] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd24_nbytes_mloffyes_t TCD24_NBYTES_MLOFFYES; //!< [0x1430] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd24_slast_t TCD24_SLAST; //!< [0x1434] TCD Last Source Address Adjustment
    __IO hw_dma_tcd24_daddr_t TCD24_DADDR; //!< [0x1438] TCD Destination Address
    __IO hw_dma_tcd24_doff_t TCD24_DOFF; //!< [0x143c] TCD Signed Destination Address Offset
    __IO hw_dma_tcd24_citer_elinkyes_t TCD24_CITER_ELINKYES; //!< [0x143e] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd24_citer_elinkno_t TCD24_CITER_ELINKNO; //!< [0x1440] 
    __IO hw_dma_tcd24_dlastsga_t TCD24_DLASTSGA; //!< [0x1442] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd24_csr_t TCD24_CSR; //!< [0x1446] TCD Control and Status
    __IO hw_dma_tcd24_biter_elinkyes_t TCD24_BITER_ELINKYES; //!< [0x1448] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd24_biter_elinkno_t TCD24_BITER_ELINKNO; //!< [0x144a] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd25_saddr_t TCD25_SADDR; //!< [0x144c] TCD Source Address
    __IO hw_dma_tcd25_soff_t TCD25_SOFF; //!< [0x1450] TCD Signed Source Address Offset
    __IO hw_dma_tcd25_attr_t TCD25_ATTR; //!< [0x1452] TCD Transfer Attributes
    __IO hw_dma_tcd25_nbytes_mlno_t TCD25_NBYTES_MLNO; //!< [0x1454] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd25_nbytes_mloffno_t TCD25_NBYTES_MLOFFNO; //!< [0x1458] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd25_nbytes_mloffyes_t TCD25_NBYTES_MLOFFYES; //!< [0x145c] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd25_slast_t TCD25_SLAST; //!< [0x1460] TCD Last Source Address Adjustment
    __IO hw_dma_tcd25_daddr_t TCD25_DADDR; //!< [0x1464] TCD Destination Address
    __IO hw_dma_tcd25_doff_t TCD25_DOFF; //!< [0x1468] TCD Signed Destination Address Offset
    __IO hw_dma_tcd25_citer_elinkyes_t TCD25_CITER_ELINKYES; //!< [0x146a] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd25_citer_elinkno_t TCD25_CITER_ELINKNO; //!< [0x146c] 
    __IO hw_dma_tcd25_dlastsga_t TCD25_DLASTSGA; //!< [0x146e] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd25_csr_t TCD25_CSR; //!< [0x1472] TCD Control and Status
    __IO hw_dma_tcd25_biter_elinkyes_t TCD25_BITER_ELINKYES; //!< [0x1474] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd25_biter_elinkno_t TCD25_BITER_ELINKNO; //!< [0x1476] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd26_saddr_t TCD26_SADDR; //!< [0x1478] TCD Source Address
    __IO hw_dma_tcd26_soff_t TCD26_SOFF; //!< [0x147c] TCD Signed Source Address Offset
    __IO hw_dma_tcd26_attr_t TCD26_ATTR; //!< [0x147e] TCD Transfer Attributes
    __IO hw_dma_tcd26_nbytes_mlno_t TCD26_NBYTES_MLNO; //!< [0x1480] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd26_nbytes_mloffno_t TCD26_NBYTES_MLOFFNO; //!< [0x1484] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd26_nbytes_mloffyes_t TCD26_NBYTES_MLOFFYES; //!< [0x1488] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd26_slast_t TCD26_SLAST; //!< [0x148c] TCD Last Source Address Adjustment
    __IO hw_dma_tcd26_daddr_t TCD26_DADDR; //!< [0x1490] TCD Destination Address
    __IO hw_dma_tcd26_doff_t TCD26_DOFF; //!< [0x1494] TCD Signed Destination Address Offset
    __IO hw_dma_tcd26_citer_elinkyes_t TCD26_CITER_ELINKYES; //!< [0x1496] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd26_citer_elinkno_t TCD26_CITER_ELINKNO; //!< [0x1498] 
    __IO hw_dma_tcd26_dlastsga_t TCD26_DLASTSGA; //!< [0x149a] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd26_csr_t TCD26_CSR; //!< [0x149e] TCD Control and Status
    __IO hw_dma_tcd26_biter_elinkyes_t TCD26_BITER_ELINKYES; //!< [0x14a0] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd26_biter_elinkno_t TCD26_BITER_ELINKNO; //!< [0x14a2] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd27_saddr_t TCD27_SADDR; //!< [0x14a4] TCD Source Address
    __IO hw_dma_tcd27_soff_t TCD27_SOFF; //!< [0x14a8] TCD Signed Source Address Offset
    __IO hw_dma_tcd27_attr_t TCD27_ATTR; //!< [0x14aa] TCD Transfer Attributes
    __IO hw_dma_tcd27_nbytes_mlno_t TCD27_NBYTES_MLNO; //!< [0x14ac] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd27_nbytes_mloffno_t TCD27_NBYTES_MLOFFNO; //!< [0x14b0] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd27_nbytes_mloffyes_t TCD27_NBYTES_MLOFFYES; //!< [0x14b4] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd27_slast_t TCD27_SLAST; //!< [0x14b8] TCD Last Source Address Adjustment
    __IO hw_dma_tcd27_daddr_t TCD27_DADDR; //!< [0x14bc] TCD Destination Address
    __IO hw_dma_tcd27_doff_t TCD27_DOFF; //!< [0x14c0] TCD Signed Destination Address Offset
    __IO hw_dma_tcd27_citer_elinkyes_t TCD27_CITER_ELINKYES; //!< [0x14c2] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd27_citer_elinkno_t TCD27_CITER_ELINKNO; //!< [0x14c4] 
    __IO hw_dma_tcd27_dlastsga_t TCD27_DLASTSGA; //!< [0x14c6] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd27_csr_t TCD27_CSR; //!< [0x14ca] TCD Control and Status
    __IO hw_dma_tcd27_biter_elinkyes_t TCD27_BITER_ELINKYES; //!< [0x14cc] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd27_biter_elinkno_t TCD27_BITER_ELINKNO; //!< [0x14ce] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd28_saddr_t TCD28_SADDR; //!< [0x14d0] TCD Source Address
    __IO hw_dma_tcd28_soff_t TCD28_SOFF; //!< [0x14d4] TCD Signed Source Address Offset
    __IO hw_dma_tcd28_attr_t TCD28_ATTR; //!< [0x14d6] TCD Transfer Attributes
    __IO hw_dma_tcd28_nbytes_mlno_t TCD28_NBYTES_MLNO; //!< [0x14d8] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd28_nbytes_mloffno_t TCD28_NBYTES_MLOFFNO; //!< [0x14dc] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd28_nbytes_mloffyes_t TCD28_NBYTES_MLOFFYES; //!< [0x14e0] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd28_slast_t TCD28_SLAST; //!< [0x14e4] TCD Last Source Address Adjustment
    __IO hw_dma_tcd28_daddr_t TCD28_DADDR; //!< [0x14e8] TCD Destination Address
    __IO hw_dma_tcd28_doff_t TCD28_DOFF; //!< [0x14ec] TCD Signed Destination Address Offset
    __IO hw_dma_tcd28_citer_elinkyes_t TCD28_CITER_ELINKYES; //!< [0x14ee] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd28_citer_elinkno_t TCD28_CITER_ELINKNO; //!< [0x14f0] 
    __IO hw_dma_tcd28_dlastsga_t TCD28_DLASTSGA; //!< [0x14f2] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd28_csr_t TCD28_CSR; //!< [0x14f6] TCD Control and Status
    __IO hw_dma_tcd28_biter_elinkyes_t TCD28_BITER_ELINKYES; //!< [0x14f8] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd28_biter_elinkno_t TCD28_BITER_ELINKNO; //!< [0x14fa] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd29_saddr_t TCD29_SADDR; //!< [0x14fc] TCD Source Address
    __IO hw_dma_tcd29_soff_t TCD29_SOFF; //!< [0x1500] TCD Signed Source Address Offset
    __IO hw_dma_tcd29_attr_t TCD29_ATTR; //!< [0x1502] TCD Transfer Attributes
    __IO hw_dma_tcd29_nbytes_mlno_t TCD29_NBYTES_MLNO; //!< [0x1504] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd29_nbytes_mloffno_t TCD29_NBYTES_MLOFFNO; //!< [0x1508] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd29_nbytes_mloffyes_t TCD29_NBYTES_MLOFFYES; //!< [0x150c] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd29_slast_t TCD29_SLAST; //!< [0x1510] TCD Last Source Address Adjustment
    __IO hw_dma_tcd29_daddr_t TCD29_DADDR; //!< [0x1514] TCD Destination Address
    __IO hw_dma_tcd29_doff_t TCD29_DOFF; //!< [0x1518] TCD Signed Destination Address Offset
    __IO hw_dma_tcd29_citer_elinkyes_t TCD29_CITER_ELINKYES; //!< [0x151a] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd29_citer_elinkno_t TCD29_CITER_ELINKNO; //!< [0x151c] 
    __IO hw_dma_tcd29_dlastsga_t TCD29_DLASTSGA; //!< [0x151e] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd29_csr_t TCD29_CSR; //!< [0x1522] TCD Control and Status
    __IO hw_dma_tcd29_biter_elinkyes_t TCD29_BITER_ELINKYES; //!< [0x1524] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd29_biter_elinkno_t TCD29_BITER_ELINKNO; //!< [0x1526] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd30_saddr_t TCD30_SADDR; //!< [0x1528] TCD Source Address
    __IO hw_dma_tcd30_soff_t TCD30_SOFF; //!< [0x152c] TCD Signed Source Address Offset
    __IO hw_dma_tcd30_attr_t TCD30_ATTR; //!< [0x152e] TCD Transfer Attributes
    __IO hw_dma_tcd30_nbytes_mlno_t TCD30_NBYTES_MLNO; //!< [0x1530] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd30_nbytes_mloffno_t TCD30_NBYTES_MLOFFNO; //!< [0x1534] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd30_nbytes_mloffyes_t TCD30_NBYTES_MLOFFYES; //!< [0x1538] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd30_slast_t TCD30_SLAST; //!< [0x153c] TCD Last Source Address Adjustment
    __IO hw_dma_tcd30_daddr_t TCD30_DADDR; //!< [0x1540] TCD Destination Address
    __IO hw_dma_tcd30_doff_t TCD30_DOFF; //!< [0x1544] TCD Signed Destination Address Offset
    __IO hw_dma_tcd30_citer_elinkyes_t TCD30_CITER_ELINKYES; //!< [0x1546] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd30_citer_elinkno_t TCD30_CITER_ELINKNO; //!< [0x1548] 
    __IO hw_dma_tcd30_dlastsga_t TCD30_DLASTSGA; //!< [0x154a] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd30_csr_t TCD30_CSR; //!< [0x154e] TCD Control and Status
    __IO hw_dma_tcd30_biter_elinkyes_t TCD30_BITER_ELINKYES; //!< [0x1550] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd30_biter_elinkno_t TCD30_BITER_ELINKNO; //!< [0x1552] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    __IO hw_dma_tcd31_saddr_t TCD31_SADDR; //!< [0x1554] TCD Source Address
    __IO hw_dma_tcd31_soff_t TCD31_SOFF; //!< [0x1558] TCD Signed Source Address Offset
    __IO hw_dma_tcd31_attr_t TCD31_ATTR; //!< [0x155a] TCD Transfer Attributes
    __IO hw_dma_tcd31_nbytes_mlno_t TCD31_NBYTES_MLNO; //!< [0x155c] TCD Minor Byte Count (Minor Loop Disabled)
    __IO hw_dma_tcd31_nbytes_mloffno_t TCD31_NBYTES_MLOFFNO; //!< [0x1560] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
    __IO hw_dma_tcd31_nbytes_mloffyes_t TCD31_NBYTES_MLOFFYES; //!< [0x1564] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
    __IO hw_dma_tcd31_slast_t TCD31_SLAST; //!< [0x1568] TCD Last Source Address Adjustment
    __IO hw_dma_tcd31_daddr_t TCD31_DADDR; //!< [0x156c] TCD Destination Address
    __IO hw_dma_tcd31_doff_t TCD31_DOFF; //!< [0x1570] TCD Signed Destination Address Offset
    __IO hw_dma_tcd31_citer_elinkyes_t TCD31_CITER_ELINKYES; //!< [0x1572] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd31_citer_elinkno_t TCD31_CITER_ELINKNO; //!< [0x1574] 
    __IO hw_dma_tcd31_dlastsga_t TCD31_DLASTSGA; //!< [0x1576] TCD Last Destination Address Adjustment/Scatter Gather Address
    __IO hw_dma_tcd31_csr_t TCD31_CSR; //!< [0x157a] TCD Control and Status
    __IO hw_dma_tcd31_biter_elinkyes_t TCD31_BITER_ELINKYES; //!< [0x157c] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    __IO hw_dma_tcd31_biter_elinkno_t TCD31_BITER_ELINKNO; //!< [0x157e] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
} hw_dma_t;
#pragma pack()

//! @brief Macro to access all DMA registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_DMA</code>.
#define HW_DMA     (*(hw_dma_t *) REGS_DMA_BASE)
#endif

#endif // __HW_DMA_REGISTERS_H__
// v22/130417/1.2.6
// EOF

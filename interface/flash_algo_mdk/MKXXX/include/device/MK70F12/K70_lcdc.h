/*
 * Copyright (c) 2013, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_LCDC_REGISTERS_H__
#define __HW_LCDC_REGISTERS_H__

#include "regs.h"

/*
 * K70 LCDC
 *
 * Liquid Crystal Display Controller
 *
 * Registers defined in this header file:
 * - HW_LCDC_LSSAR - LCDC screen start address register
 * - HW_LCDC_LSR - LCDC size register
 * - HW_LCDC_LVPWR - LCDC virtual page width register
 * - HW_LCDC_LCPR - LCDC cursor position register
 * - HW_LCDC_LCWHB - LCDC cursor width, height, and blink register
 * - HW_LCDC_LCCMR - LCDC color cursor mapping register
 * - HW_LCDC_LPCR - LCDC panel configuration register
 * - HW_LCDC_LHCR - LCDC horizontal configuration register
 * - HW_LCDC_LVCR - LCDC vertical configuration register
 * - HW_LCDC_LPOR - LCDC panning offset register
 * - HW_LCDC_LPCCR - LCDC PWM contrast control register
 * - HW_LCDC_LDCR - LCDC DMA control register
 * - HW_LCDC_LRMCR - LCDC refresh mode control register
 * - HW_LCDC_LICR - LCDC interrupt configuration register
 * - HW_LCDC_LIER - LCDC interrupt enable register
 * - HW_LCDC_LISR - LCDC interrupt status register
 * - HW_LCDC_LGWSAR - LCDC graphic window start address register
 * - HW_LCDC_LGWSR - LCDC graphic window size register
 * - HW_LCDC_LGWVPWR - LCDC graphic window virtual page width register
 * - HW_LCDC_LGWPOR - LCDC graphic window panning offset register
 * - HW_LCDC_LGWPR - LCDC graphic window position register
 * - HW_LCDC_LGWCR - LCDC graphic window control register
 * - HW_LCDC_LGWDCR - LCDC graphic window DMA control register
 * - HW_LCDC_LAUSCR - LCDC AUS mode control register
 * - HW_LCDC_LAUSCCR - LCDC AUS mode cursor control register
 *
 * - hw_lcdc_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_LCDC_BASE
#define HW_LCDC_INSTANCE_COUNT (1U) //!< Number of instances of the LCDC module.
#define REGS_LCDC_BASE (0x400b6000U) //!< Base address for LCDC.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LSSAR - LCDC screen start address register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LSSAR - LCDC screen start address register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register specifies the LCD screen start address. Refer to LCD screen format for more
 * details.
 */
typedef union _hw_lcdc_lssar
{
    uint32_t U;
    struct _hw_lcdc_lssar_bitfields
    {
        uint32_t RESERVED0 : 2; //!< [1:0] 
        uint32_t SSA : 30; //!< [31:2] Screen start address of LCD panel
    } B;
} hw_lcdc_lssar_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LSSAR register
 */
//@{
#define HW_LCDC_LSSAR_ADDR      (REGS_LCDC_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LSSAR           (*(__IO hw_lcdc_lssar_t *) HW_LCDC_LSSAR_ADDR)
#define HW_LCDC_LSSAR_RD()      (HW_LCDC_LSSAR.U)
#define HW_LCDC_LSSAR_WR(v)     (HW_LCDC_LSSAR.U = (v))
#define HW_LCDC_LSSAR_SET(v)    (HW_LCDC_LSSAR_WR(HW_LCDC_LSSAR_RD() |  (v)))
#define HW_LCDC_LSSAR_CLR(v)    (HW_LCDC_LSSAR_WR(HW_LCDC_LSSAR_RD() & ~(v)))
#define HW_LCDC_LSSAR_TOG(v)    (HW_LCDC_LSSAR_WR(HW_LCDC_LSSAR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LSSAR bitfields
 */

/*! @name Register LCDC_LSSAR, field SSA[31:2] (RW)
 *
 * Holds pixel data for a new frame from SSA address. This field must start at a location that
 * enables a complete picture to be stored in a 4 MB memory boundary (A [21:0]). A [31:22] has a
 * fixed value for a picture’s image.
 */
//@{
#define BP_LCDC_LSSAR_SSA      (2U)      //!< Bit position for LCDC_LSSAR_SSA.
#define BM_LCDC_LSSAR_SSA      (0xfffffffcU)  //!< Bit mask for LCDC_LSSAR_SSA.
#define BS_LCDC_LSSAR_SSA      (30U)  //!< Bitfield size in bits for LCDC_LSSAR_SSA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LSSAR_SSA field.
#define BR_LCDC_LSSAR_SSA()   (HW_LCDC_LSSAR.B.SSA)
#endif

//! @brief Format value for bitfield LCDC_LSSAR_SSA.
#define BF_LCDC_LSSAR_SSA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LSSAR_SSA), uint32_t) & BM_LCDC_LSSAR_SSA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSA field to a new value.
#define BW_LCDC_LSSAR_SSA(v)   (HW_LCDC_LSSAR_WR((HW_LCDC_LSSAR_RD() & ~BM_LCDC_LSSAR_SSA) | BF_LCDC_LSSAR_SSA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LSR - LCDC size register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LSR - LCDC size register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the height and width of the LCD screen.
 */
typedef union _hw_lcdc_lsr
{
    uint32_t U;
    struct _hw_lcdc_lsr_bitfields
    {
        uint32_t YMAX : 10; //!< [9:0] Screen height
        uint32_t RESERVED0 : 10; //!< [19:10] 
        uint32_t XMAX : 7; //!< [26:20] Screen width divided by 16
        uint32_t RESERVED2 : 5; //!< [31:27] Reserved.
    } B;
} hw_lcdc_lsr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LSR register
 */
//@{
#define HW_LCDC_LSR_ADDR      (REGS_LCDC_BASE + 0x4U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LSR           (*(__IO hw_lcdc_lsr_t *) HW_LCDC_LSR_ADDR)
#define HW_LCDC_LSR_RD()      (HW_LCDC_LSR.U)
#define HW_LCDC_LSR_WR(v)     (HW_LCDC_LSR.U = (v))
#define HW_LCDC_LSR_SET(v)    (HW_LCDC_LSR_WR(HW_LCDC_LSR_RD() |  (v)))
#define HW_LCDC_LSR_CLR(v)    (HW_LCDC_LSR_WR(HW_LCDC_LSR_RD() & ~(v)))
#define HW_LCDC_LSR_TOG(v)    (HW_LCDC_LSR_WR(HW_LCDC_LSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LSR bitfields
 */

/*! @name Register LCDC_LSR, field YMAX[9:0] (RW)
 *
 * Specifies the height of LCD panel in terms of pixels or lines. Lines are numbered from 1 to YMAX
 * for a total of YMAX lines.
 */
//@{
#define BP_LCDC_LSR_YMAX      (0U)      //!< Bit position for LCDC_LSR_YMAX.
#define BM_LCDC_LSR_YMAX      (0x000003ffU)  //!< Bit mask for LCDC_LSR_YMAX.
#define BS_LCDC_LSR_YMAX      (10U)  //!< Bitfield size in bits for LCDC_LSR_YMAX.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LSR_YMAX field.
#define BR_LCDC_LSR_YMAX()   (HW_LCDC_LSR.B.YMAX)
#endif

//! @brief Format value for bitfield LCDC_LSR_YMAX.
#define BF_LCDC_LSR_YMAX(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LSR_YMAX), uint32_t) & BM_LCDC_LSR_YMAX)

#ifndef __LANGUAGE_ASM__
//! @brief Set the YMAX field to a new value.
#define BW_LCDC_LSR_YMAX(v)   (HW_LCDC_LSR_WR((HW_LCDC_LSR_RD() & ~BM_LCDC_LSR_YMAX) | BF_LCDC_LSR_YMAX(v)))
#endif
//@}

/*! @name Register LCDC_LSR, field XMAX[26:20] (RW)
 *
 * Holds screen x-axis size, divided by 16. For black-and-white panels (1 bpp), XMAX[20] is ignored,
 * forcing the x-axis of the screen size to be a multiple of 32 pixels/line.
 */
//@{
#define BP_LCDC_LSR_XMAX      (20U)      //!< Bit position for LCDC_LSR_XMAX.
#define BM_LCDC_LSR_XMAX      (0x07f00000U)  //!< Bit mask for LCDC_LSR_XMAX.
#define BS_LCDC_LSR_XMAX      (7U)  //!< Bitfield size in bits for LCDC_LSR_XMAX.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LSR_XMAX field.
#define BR_LCDC_LSR_XMAX()   (HW_LCDC_LSR.B.XMAX)
#endif

//! @brief Format value for bitfield LCDC_LSR_XMAX.
#define BF_LCDC_LSR_XMAX(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LSR_XMAX), uint32_t) & BM_LCDC_LSR_XMAX)

#ifndef __LANGUAGE_ASM__
//! @brief Set the XMAX field to a new value.
#define BW_LCDC_LSR_XMAX(v)   (HW_LCDC_LSR_WR((HW_LCDC_LSR_RD() & ~BM_LCDC_LSR_XMAX) | BF_LCDC_LSR_XMAX(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LVPWR - LCDC virtual page width register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LVPWR - LCDC virtual page width register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines virtual page width for LCD panel. Refer to LCD screen format for more
 * details.
 */
typedef union _hw_lcdc_lvpwr
{
    uint32_t U;
    struct _hw_lcdc_lvpwr_bitfields
    {
        uint32_t VPW : 11; //!< [10:0] Virtual page width
        uint32_t RESERVED0 : 21; //!< [31:11] 
    } B;
} hw_lcdc_lvpwr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LVPWR register
 */
//@{
#define HW_LCDC_LVPWR_ADDR      (REGS_LCDC_BASE + 0x8U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LVPWR           (*(__IO hw_lcdc_lvpwr_t *) HW_LCDC_LVPWR_ADDR)
#define HW_LCDC_LVPWR_RD()      (HW_LCDC_LVPWR.U)
#define HW_LCDC_LVPWR_WR(v)     (HW_LCDC_LVPWR.U = (v))
#define HW_LCDC_LVPWR_SET(v)    (HW_LCDC_LVPWR_WR(HW_LCDC_LVPWR_RD() |  (v)))
#define HW_LCDC_LVPWR_CLR(v)    (HW_LCDC_LVPWR_WR(HW_LCDC_LVPWR_RD() & ~(v)))
#define HW_LCDC_LVPWR_TOG(v)    (HW_LCDC_LVPWR_WR(HW_LCDC_LVPWR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LVPWR bitfields
 */

/*! @name Register LCDC_LVPWR, field VPW[10:0] (RW)
 *
 * Defines virtual page width of LCD panel. VPW bits represent the number of 32-bit words required
 * to hold the data for one virtual line. VPW is used in calculating the starting address
 * representing the beginning of each displayed line.
 */
//@{
#define BP_LCDC_LVPWR_VPW      (0U)      //!< Bit position for LCDC_LVPWR_VPW.
#define BM_LCDC_LVPWR_VPW      (0x000007ffU)  //!< Bit mask for LCDC_LVPWR_VPW.
#define BS_LCDC_LVPWR_VPW      (11U)  //!< Bitfield size in bits for LCDC_LVPWR_VPW.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LVPWR_VPW field.
#define BR_LCDC_LVPWR_VPW()   (HW_LCDC_LVPWR.B.VPW)
#endif

//! @brief Format value for bitfield LCDC_LVPWR_VPW.
#define BF_LCDC_LVPWR_VPW(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LVPWR_VPW), uint32_t) & BM_LCDC_LVPWR_VPW)

#ifndef __LANGUAGE_ASM__
//! @brief Set the VPW field to a new value.
#define BW_LCDC_LVPWR_VPW(v)   (HW_LCDC_LVPWR_WR((HW_LCDC_LVPWR_RD() & ~BM_LCDC_LVPWR_VPW) | BF_LCDC_LVPWR_VPW(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LCPR - LCDC cursor position register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LCPR - LCDC cursor position register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register determines the starting position of the cursor on the LCD panel.
 */
typedef union _hw_lcdc_lcpr
{
    uint32_t U;
    struct _hw_lcdc_lcpr_bitfields
    {
        uint32_t CYP : 10; //!< [9:0] Cursor Y position
        uint32_t RESERVED0 : 6; //!< [15:10] 
        uint32_t CXP : 10; //!< [25:16] Cursor X position
        uint32_t RESERVED1 : 2; //!< [27:26] 
        uint32_t OP : 1; //!< [28] Arithmetic operation control
        uint32_t RESERVED2 : 1; //!< [29] 
        uint32_t CC : 2; //!< [31:30] Cursor control
    } B;
} hw_lcdc_lcpr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LCPR register
 */
//@{
#define HW_LCDC_LCPR_ADDR      (REGS_LCDC_BASE + 0xcU)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LCPR           (*(__IO hw_lcdc_lcpr_t *) HW_LCDC_LCPR_ADDR)
#define HW_LCDC_LCPR_RD()      (HW_LCDC_LCPR.U)
#define HW_LCDC_LCPR_WR(v)     (HW_LCDC_LCPR.U = (v))
#define HW_LCDC_LCPR_SET(v)    (HW_LCDC_LCPR_WR(HW_LCDC_LCPR_RD() |  (v)))
#define HW_LCDC_LCPR_CLR(v)    (HW_LCDC_LCPR_WR(HW_LCDC_LCPR_RD() & ~(v)))
#define HW_LCDC_LCPR_TOG(v)    (HW_LCDC_LCPR_WR(HW_LCDC_LCPR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LCPR bitfields
 */

/*! @name Register LCDC_LCPR, field CYP[9:0] (RW)
 *
 * Represents the cursor’s vertical starting position Y in pixel count (from 0 to YMAX).
 */
//@{
#define BP_LCDC_LCPR_CYP      (0U)      //!< Bit position for LCDC_LCPR_CYP.
#define BM_LCDC_LCPR_CYP      (0x000003ffU)  //!< Bit mask for LCDC_LCPR_CYP.
#define BS_LCDC_LCPR_CYP      (10U)  //!< Bitfield size in bits for LCDC_LCPR_CYP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCPR_CYP field.
#define BR_LCDC_LCPR_CYP()   (HW_LCDC_LCPR.B.CYP)
#endif

//! @brief Format value for bitfield LCDC_LCPR_CYP.
#define BF_LCDC_LCPR_CYP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCPR_CYP), uint32_t) & BM_LCDC_LCPR_CYP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CYP field to a new value.
#define BW_LCDC_LCPR_CYP(v)   (HW_LCDC_LCPR_WR((HW_LCDC_LCPR_RD() & ~BM_LCDC_LCPR_CYP) | BF_LCDC_LCPR_CYP(v)))
#endif
//@}

/*! @name Register LCDC_LCPR, field CXP[25:16] (RW)
 *
 * Represents the cursor’s horizontal starting position X in pixel count (from 0 to XMAX).
 */
//@{
#define BP_LCDC_LCPR_CXP      (16U)      //!< Bit position for LCDC_LCPR_CXP.
#define BM_LCDC_LCPR_CXP      (0x03ff0000U)  //!< Bit mask for LCDC_LCPR_CXP.
#define BS_LCDC_LCPR_CXP      (10U)  //!< Bitfield size in bits for LCDC_LCPR_CXP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCPR_CXP field.
#define BR_LCDC_LCPR_CXP()   (HW_LCDC_LCPR.B.CXP)
#endif

//! @brief Format value for bitfield LCDC_LCPR_CXP.
#define BF_LCDC_LCPR_CXP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCPR_CXP), uint32_t) & BM_LCDC_LCPR_CXP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CXP field to a new value.
#define BW_LCDC_LCPR_CXP(v)   (HW_LCDC_LCPR_WR((HW_LCDC_LCPR_RD() & ~BM_LCDC_LCPR_CXP) | BF_LCDC_LCPR_CXP(v)))
#endif
//@}

/*! @name Register LCDC_LCPR, field OP[28] (RW)
 *
 * Enables/disables arithmetic operations between the background and cursor.
 *
 * Values:
 * - 0 - Disable arithmetic operation
 * - 1 - Enable arithmetic operation
 */
//@{
#define BP_LCDC_LCPR_OP      (28U)      //!< Bit position for LCDC_LCPR_OP.
#define BM_LCDC_LCPR_OP      (0x10000000U)  //!< Bit mask for LCDC_LCPR_OP.
#define BS_LCDC_LCPR_OP      (1U)  //!< Bitfield size in bits for LCDC_LCPR_OP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCPR_OP field.
#define BR_LCDC_LCPR_OP()   (BITBAND_ACCESS32(HW_LCDC_LCPR_ADDR, BP_LCDC_LCPR_OP))
#endif

//! @brief Format value for bitfield LCDC_LCPR_OP.
#define BF_LCDC_LCPR_OP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCPR_OP), uint32_t) & BM_LCDC_LCPR_OP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the OP field to a new value.
#define BW_LCDC_LCPR_OP(v)   (BITBAND_ACCESS32(HW_LCDC_LCPR_ADDR, BP_LCDC_LCPR_OP) = (v))
#endif
//@}

/*! @name Register LCDC_LCPR, field CC[31:30] (RW)
 *
 * Controls the arithmetic operations used to generate the cursor color. OP = 0 OP = 1, for color
 * mode only 00 Transparent, cursor is disabled. Transparent, cursor is disabled. 01 1 for non-color
 * displays; color defined in LCDC color cursor mapping register (LCCMR) for color displays. Logic
 * OR between LCD display data and the cursor color in LCCMR. 10 Reversed, INV background for non-
 * color displays; INV color defined in LCDC color cursor mapping register (LCCMR) for color
 * displays. Logic XOR between LCD display data and the cursor color in LCCMR. 11 0 for non-color
 * displays; Logic AND between LCD display data and the cursor color in LCCMR. Logic AND between LCD
 * display data and the cursor color in LCCMR.
 */
//@{
#define BP_LCDC_LCPR_CC      (30U)      //!< Bit position for LCDC_LCPR_CC.
#define BM_LCDC_LCPR_CC      (0xc0000000U)  //!< Bit mask for LCDC_LCPR_CC.
#define BS_LCDC_LCPR_CC      (2U)  //!< Bitfield size in bits for LCDC_LCPR_CC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCPR_CC field.
#define BR_LCDC_LCPR_CC()   (HW_LCDC_LCPR.B.CC)
#endif

//! @brief Format value for bitfield LCDC_LCPR_CC.
#define BF_LCDC_LCPR_CC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCPR_CC), uint32_t) & BM_LCDC_LCPR_CC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CC field to a new value.
#define BW_LCDC_LCPR_CC(v)   (HW_LCDC_LCPR_WR((HW_LCDC_LCPR_RD() & ~BM_LCDC_LCPR_CC) | BF_LCDC_LCPR_CC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LCWHB - LCDC cursor width, height, and blink register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LCWHB - LCDC cursor width, height, and blink register (RW)
 *
 * Reset value: 0x010100ffU
 *
 * This register determines the cursor’s width and height, and how it blinks.
 */
typedef union _hw_lcdc_lcwhb
{
    uint32_t U;
    struct _hw_lcdc_lcwhb_bitfields
    {
        uint32_t BD : 8; //!< [7:0] Blink divisor
        uint32_t RESERVED0 : 8; //!< [15:8] 
        uint32_t CH : 5; //!< [20:16] Cursor height
        uint32_t RESERVED1 : 3; //!< [23:21] 
        uint32_t CW : 5; //!< [28:24] Cursor width
        uint32_t RESERVED2 : 2; //!< [30:29] 
        uint32_t BK_EN : 1; //!< [31] Blink enable
    } B;
} hw_lcdc_lcwhb_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LCWHB register
 */
//@{
#define HW_LCDC_LCWHB_ADDR      (REGS_LCDC_BASE + 0x10U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LCWHB           (*(__IO hw_lcdc_lcwhb_t *) HW_LCDC_LCWHB_ADDR)
#define HW_LCDC_LCWHB_RD()      (HW_LCDC_LCWHB.U)
#define HW_LCDC_LCWHB_WR(v)     (HW_LCDC_LCWHB.U = (v))
#define HW_LCDC_LCWHB_SET(v)    (HW_LCDC_LCWHB_WR(HW_LCDC_LCWHB_RD() |  (v)))
#define HW_LCDC_LCWHB_CLR(v)    (HW_LCDC_LCWHB_WR(HW_LCDC_LCWHB_RD() & ~(v)))
#define HW_LCDC_LCWHB_TOG(v)    (HW_LCDC_LCWHB_WR(HW_LCDC_LCWHB_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LCWHB bitfields
 */

/*! @name Register LCDC_LCWHB, field BD[7:0] (RW)
 *
 * Sets the cursor blink rate. The ERCLK32K clock from the RTC is divided down to provide a 32 Hz
 * clock that is used to clock the 8-bit up counter. When the counter value equals BD, the cursor
 * toggles on/off. Hence larger the BD, slower the cursor will blink.Blinking is disabled when BD is
 * 0.
 */
//@{
#define BP_LCDC_LCWHB_BD      (0U)      //!< Bit position for LCDC_LCWHB_BD.
#define BM_LCDC_LCWHB_BD      (0x000000ffU)  //!< Bit mask for LCDC_LCWHB_BD.
#define BS_LCDC_LCWHB_BD      (8U)  //!< Bitfield size in bits for LCDC_LCWHB_BD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCWHB_BD field.
#define BR_LCDC_LCWHB_BD()   (HW_LCDC_LCWHB.B.BD)
#endif

//! @brief Format value for bitfield LCDC_LCWHB_BD.
#define BF_LCDC_LCWHB_BD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCWHB_BD), uint32_t) & BM_LCDC_LCWHB_BD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BD field to a new value.
#define BW_LCDC_LCWHB_BD(v)   (HW_LCDC_LCWHB_WR((HW_LCDC_LCWHB_RD() & ~BM_LCDC_LCWHB_BD) | BF_LCDC_LCWHB_BD(v)))
#endif
//@}

/*! @name Register LCDC_LCWHB, field CH[20:16] (RW)
 *
 * Specifies the height of hardware cursor in pixels. This field can be any value between 1 and 31
 * (setting this field to zero disables the cursor).
 */
//@{
#define BP_LCDC_LCWHB_CH      (16U)      //!< Bit position for LCDC_LCWHB_CH.
#define BM_LCDC_LCWHB_CH      (0x001f0000U)  //!< Bit mask for LCDC_LCWHB_CH.
#define BS_LCDC_LCWHB_CH      (5U)  //!< Bitfield size in bits for LCDC_LCWHB_CH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCWHB_CH field.
#define BR_LCDC_LCWHB_CH()   (HW_LCDC_LCWHB.B.CH)
#endif

//! @brief Format value for bitfield LCDC_LCWHB_CH.
#define BF_LCDC_LCWHB_CH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCWHB_CH), uint32_t) & BM_LCDC_LCWHB_CH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CH field to a new value.
#define BW_LCDC_LCWHB_CH(v)   (HW_LCDC_LCWHB_WR((HW_LCDC_LCWHB_RD() & ~BM_LCDC_LCWHB_CH) | BF_LCDC_LCWHB_CH(v)))
#endif
//@}

/*! @name Register LCDC_LCWHB, field CW[28:24] (RW)
 *
 * Specifies the width of hardware cursor in pixels. This field can be any value between 1 and 31
 * (setting this field to zero disables the cursor).
 */
//@{
#define BP_LCDC_LCWHB_CW      (24U)      //!< Bit position for LCDC_LCWHB_CW.
#define BM_LCDC_LCWHB_CW      (0x1f000000U)  //!< Bit mask for LCDC_LCWHB_CW.
#define BS_LCDC_LCWHB_CW      (5U)  //!< Bitfield size in bits for LCDC_LCWHB_CW.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCWHB_CW field.
#define BR_LCDC_LCWHB_CW()   (HW_LCDC_LCWHB.B.CW)
#endif

//! @brief Format value for bitfield LCDC_LCWHB_CW.
#define BF_LCDC_LCWHB_CW(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCWHB_CW), uint32_t) & BM_LCDC_LCWHB_CW)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CW field to a new value.
#define BW_LCDC_LCWHB_CW(v)   (HW_LCDC_LCWHB_WR((HW_LCDC_LCWHB_RD() & ~BM_LCDC_LCWHB_CW) | BF_LCDC_LCWHB_CW(v)))
#endif
//@}

/*! @name Register LCDC_LCWHB, field BK_EN[31] (RW)
 *
 * Determines whether the blink enable cursor will blink or remain steady.
 *
 * Values:
 * - 0 - Blink is disabled.
 * - 1 - Blink is enabled.
 */
//@{
#define BP_LCDC_LCWHB_BK_EN      (31U)      //!< Bit position for LCDC_LCWHB_BK_EN.
#define BM_LCDC_LCWHB_BK_EN      (0x80000000U)  //!< Bit mask for LCDC_LCWHB_BK_EN.
#define BS_LCDC_LCWHB_BK_EN      (1U)  //!< Bitfield size in bits for LCDC_LCWHB_BK_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCWHB_BK_EN field.
#define BR_LCDC_LCWHB_BK_EN()   (BITBAND_ACCESS32(HW_LCDC_LCWHB_ADDR, BP_LCDC_LCWHB_BK_EN))
#endif

//! @brief Format value for bitfield LCDC_LCWHB_BK_EN.
#define BF_LCDC_LCWHB_BK_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCWHB_BK_EN), uint32_t) & BM_LCDC_LCWHB_BK_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BK_EN field to a new value.
#define BW_LCDC_LCWHB_BK_EN(v)   (BITBAND_ACCESS32(HW_LCDC_LCWHB_ADDR, BP_LCDC_LCWHB_BK_EN) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LCCMR - LCDC color cursor mapping register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LCCMR - LCDC color cursor mapping register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the cursor color in passive or TFT color modes. If bpp mode setting is
 * smaller than 18bpp, cursor color component bits should be put in the MSBs. For example, if color
 * cursor of RGB=(0x1a, 0x26, 0x05) is wanted when using 16bpp, CUR_COL_R, CUR_COL_G and CUR_COL_B
 * should be set to 0x34, 0x26 and 0x0a.
 */
typedef union _hw_lcdc_lccmr
{
    uint32_t U;
    struct _hw_lcdc_lccmr_bitfields
    {
        uint32_t CUR_COL_B : 6; //!< [5:0] Cursor blue field
        uint32_t CUR_COL_G : 6; //!< [11:6] Cursor green field
        uint32_t CUR_COL_R : 6; //!< [17:12] Cursor red field
        uint32_t RESERVED0 : 14; //!< [31:18] 
    } B;
} hw_lcdc_lccmr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LCCMR register
 */
//@{
#define HW_LCDC_LCCMR_ADDR      (REGS_LCDC_BASE + 0x14U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LCCMR           (*(__IO hw_lcdc_lccmr_t *) HW_LCDC_LCCMR_ADDR)
#define HW_LCDC_LCCMR_RD()      (HW_LCDC_LCCMR.U)
#define HW_LCDC_LCCMR_WR(v)     (HW_LCDC_LCCMR.U = (v))
#define HW_LCDC_LCCMR_SET(v)    (HW_LCDC_LCCMR_WR(HW_LCDC_LCCMR_RD() |  (v)))
#define HW_LCDC_LCCMR_CLR(v)    (HW_LCDC_LCCMR_WR(HW_LCDC_LCCMR_RD() & ~(v)))
#define HW_LCDC_LCCMR_TOG(v)    (HW_LCDC_LCCMR_WR(HW_LCDC_LCCMR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LCCMR bitfields
 */

/*! @name Register LCDC_LCCMR, field CUR_COL_B[5:0] (RW)
 *
 * Defines the blue component of the cursor color in color mode.
 *
 * Values:
 * - 000000 - No blue
 * - ....... - 
 * - 111111 - Full blue
 */
//@{
#define BP_LCDC_LCCMR_CUR_COL_B      (0U)      //!< Bit position for LCDC_LCCMR_CUR_COL_B.
#define BM_LCDC_LCCMR_CUR_COL_B      (0x0000003fU)  //!< Bit mask for LCDC_LCCMR_CUR_COL_B.
#define BS_LCDC_LCCMR_CUR_COL_B      (6U)  //!< Bitfield size in bits for LCDC_LCCMR_CUR_COL_B.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCCMR_CUR_COL_B field.
#define BR_LCDC_LCCMR_CUR_COL_B()   (HW_LCDC_LCCMR.B.CUR_COL_B)
#endif

//! @brief Format value for bitfield LCDC_LCCMR_CUR_COL_B.
#define BF_LCDC_LCCMR_CUR_COL_B(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCCMR_CUR_COL_B), uint32_t) & BM_LCDC_LCCMR_CUR_COL_B)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CUR_COL_B field to a new value.
#define BW_LCDC_LCCMR_CUR_COL_B(v)   (HW_LCDC_LCCMR_WR((HW_LCDC_LCCMR_RD() & ~BM_LCDC_LCCMR_CUR_COL_B) | BF_LCDC_LCCMR_CUR_COL_B(v)))
#endif
//@}

/*! @name Register LCDC_LCCMR, field CUR_COL_G[11:6] (RW)
 *
 * Defines the green component of the cursor color in color mode.
 *
 * Values:
 * - 000000 - No green
 * - ....... - 
 * - 111111 - Full green
 */
//@{
#define BP_LCDC_LCCMR_CUR_COL_G      (6U)      //!< Bit position for LCDC_LCCMR_CUR_COL_G.
#define BM_LCDC_LCCMR_CUR_COL_G      (0x00000fc0U)  //!< Bit mask for LCDC_LCCMR_CUR_COL_G.
#define BS_LCDC_LCCMR_CUR_COL_G      (6U)  //!< Bitfield size in bits for LCDC_LCCMR_CUR_COL_G.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCCMR_CUR_COL_G field.
#define BR_LCDC_LCCMR_CUR_COL_G()   (HW_LCDC_LCCMR.B.CUR_COL_G)
#endif

//! @brief Format value for bitfield LCDC_LCCMR_CUR_COL_G.
#define BF_LCDC_LCCMR_CUR_COL_G(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCCMR_CUR_COL_G), uint32_t) & BM_LCDC_LCCMR_CUR_COL_G)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CUR_COL_G field to a new value.
#define BW_LCDC_LCCMR_CUR_COL_G(v)   (HW_LCDC_LCCMR_WR((HW_LCDC_LCCMR_RD() & ~BM_LCDC_LCCMR_CUR_COL_G) | BF_LCDC_LCCMR_CUR_COL_G(v)))
#endif
//@}

/*! @name Register LCDC_LCCMR, field CUR_COL_R[17:12] (RW)
 *
 * Defines the red component of the cursor color in color mode.
 *
 * Values:
 * - 000000 - No red
 * - ....... - 
 * - 111111 - Full red
 */
//@{
#define BP_LCDC_LCCMR_CUR_COL_R      (12U)      //!< Bit position for LCDC_LCCMR_CUR_COL_R.
#define BM_LCDC_LCCMR_CUR_COL_R      (0x0003f000U)  //!< Bit mask for LCDC_LCCMR_CUR_COL_R.
#define BS_LCDC_LCCMR_CUR_COL_R      (6U)  //!< Bitfield size in bits for LCDC_LCCMR_CUR_COL_R.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LCCMR_CUR_COL_R field.
#define BR_LCDC_LCCMR_CUR_COL_R()   (HW_LCDC_LCCMR.B.CUR_COL_R)
#endif

//! @brief Format value for bitfield LCDC_LCCMR_CUR_COL_R.
#define BF_LCDC_LCCMR_CUR_COL_R(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LCCMR_CUR_COL_R), uint32_t) & BM_LCDC_LCCMR_CUR_COL_R)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CUR_COL_R field to a new value.
#define BW_LCDC_LCCMR_CUR_COL_R(v)   (HW_LCDC_LCCMR_WR((HW_LCDC_LCCMR_RD() & ~BM_LCDC_LCCMR_CUR_COL_R) | BF_LCDC_LCCMR_CUR_COL_R(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LPCR - LCDC panel configuration register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LPCR - LCDC panel configuration register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines all properties of the LCD screen.
 */
typedef union _hw_lcdc_lpcr
{
    uint32_t U;
    struct _hw_lcdc_lpcr_bitfields
    {
        uint32_t PCD : 6; //!< [5:0] Pixel clock divider
        uint32_t RESERVED0 : 1; //!< [6] 
        uint32_t SCLKSEL : 1; //!< [7] LSCLK select
        uint32_t ACD : 7; //!< [14:8] Alternate crystal direction
        uint32_t ACDSEL : 1; //!< [15] ACD clock source select
        uint32_t REV_VS : 1; //!< [16] Reverse vertical scan
        uint32_t SWAP_SEL : 1; //!< [17] Swap select
        uint32_t END_SEL : 1; //!< [18] Endian select
        uint32_t SCLKIDLE : 1; //!< [19] LSCLK idle enable
        uint32_t OEPOL : 1; //!< [20] Output enable polarity
        uint32_t CLKPOL : 1; //!< [21] LCD shift clock polarity
        uint32_t LPPOL : 1; //!< [22] Line pulse polarity
        uint32_t FLMPOL : 1; //!< [23] First line marker polarity
        uint32_t PIXPOL : 1; //!< [24] Pixel polarity
        uint32_t BPIX : 3; //!< [27:25] Bits per pixel
        uint32_t PBSIZ : 2; //!< [29:28] Panel bus width
        uint32_t COLOR : 1; //!< [30] Interfaces to color display
        uint32_t TFT : 1; //!< [31] Interfaces to TFT display
    } B;
} hw_lcdc_lpcr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LPCR register
 */
//@{
#define HW_LCDC_LPCR_ADDR      (REGS_LCDC_BASE + 0x18U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LPCR           (*(__IO hw_lcdc_lpcr_t *) HW_LCDC_LPCR_ADDR)
#define HW_LCDC_LPCR_RD()      (HW_LCDC_LPCR.U)
#define HW_LCDC_LPCR_WR(v)     (HW_LCDC_LPCR.U = (v))
#define HW_LCDC_LPCR_SET(v)    (HW_LCDC_LPCR_WR(HW_LCDC_LPCR_RD() |  (v)))
#define HW_LCDC_LPCR_CLR(v)    (HW_LCDC_LPCR_WR(HW_LCDC_LPCR_RD() & ~(v)))
#define HW_LCDC_LPCR_TOG(v)    (HW_LCDC_LPCR_WR(HW_LCDC_LPCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LPCR bitfields
 */

/*! @name Register LCDC_LPCR, field PCD[5:0] (RW)
 *
 * Holds clock divider value. The bus clock is divided by N (PCD plus one) to yield the pixel clock
 * rate. Values of 1 to 63 yield N=2 to 64. Pixel clock rate is faster than LSCLK by a factor equal
 * to the data bus width for monochrome display. For all other displays, pixel clock rate is the
 * same as LSCLK. PCD value must be set such that LSCLK frequency is no more than one third or one
 * fourth of system clock frequency in TFT and CSTN modes respectively, otherwise LD will be
 * incorrect.
 */
//@{
#define BP_LCDC_LPCR_PCD      (0U)      //!< Bit position for LCDC_LPCR_PCD.
#define BM_LCDC_LPCR_PCD      (0x0000003fU)  //!< Bit mask for LCDC_LPCR_PCD.
#define BS_LCDC_LPCR_PCD      (6U)  //!< Bitfield size in bits for LCDC_LPCR_PCD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_PCD field.
#define BR_LCDC_LPCR_PCD()   (HW_LCDC_LPCR.B.PCD)
#endif

//! @brief Format value for bitfield LCDC_LPCR_PCD.
#define BF_LCDC_LPCR_PCD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_PCD), uint32_t) & BM_LCDC_LPCR_PCD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PCD field to a new value.
#define BW_LCDC_LPCR_PCD(v)   (HW_LCDC_LPCR_WR((HW_LCDC_LPCR_RD() & ~BM_LCDC_LPCR_PCD) | BF_LCDC_LPCR_PCD(v)))
#endif
//@}

/*! @name Register LCDC_LPCR, field SCLKSEL[7] (RW)
 *
 * Selects whether to enable or disable LSCLK in TFT mode when there is no data output.
 *
 * Values:
 * - 0 - Disable OE and LSCLK in TFT mode when no data output.
 * - 1 - Always enable LSCLK in TFT mode even if there is no data output.
 */
//@{
#define BP_LCDC_LPCR_SCLKSEL      (7U)      //!< Bit position for LCDC_LPCR_SCLKSEL.
#define BM_LCDC_LPCR_SCLKSEL      (0x00000080U)  //!< Bit mask for LCDC_LPCR_SCLKSEL.
#define BS_LCDC_LPCR_SCLKSEL      (1U)  //!< Bitfield size in bits for LCDC_LPCR_SCLKSEL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_SCLKSEL field.
#define BR_LCDC_LPCR_SCLKSEL()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_SCLKSEL))
#endif

//! @brief Format value for bitfield LCDC_LPCR_SCLKSEL.
#define BF_LCDC_LPCR_SCLKSEL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_SCLKSEL), uint32_t) & BM_LCDC_LPCR_SCLKSEL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SCLKSEL field to a new value.
#define BW_LCDC_LPCR_SCLKSEL(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_SCLKSEL) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field ACD[14:8] (RW)
 *
 * Toggles ACD signal once every 1–16 ACD clock source cycles based on the value specified in this
 * field. The actual number of ACD clock source cycles between toggles is the programmed value plus
 * one. For active mode (TFT=1), this parameter is not used.
 */
//@{
#define BP_LCDC_LPCR_ACD      (8U)      //!< Bit position for LCDC_LPCR_ACD.
#define BM_LCDC_LPCR_ACD      (0x00007f00U)  //!< Bit mask for LCDC_LPCR_ACD.
#define BS_LCDC_LPCR_ACD      (7U)  //!< Bitfield size in bits for LCDC_LPCR_ACD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_ACD field.
#define BR_LCDC_LPCR_ACD()   (HW_LCDC_LPCR.B.ACD)
#endif

//! @brief Format value for bitfield LCDC_LPCR_ACD.
#define BF_LCDC_LPCR_ACD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_ACD), uint32_t) & BM_LCDC_LPCR_ACD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACD field to a new value.
#define BW_LCDC_LPCR_ACD(v)   (HW_LCDC_LPCR_WR((HW_LCDC_LPCR_RD() & ~BM_LCDC_LPCR_ACD) | BF_LCDC_LPCR_ACD(v)))
#endif
//@}

/*! @name Register LCDC_LPCR, field ACDSEL[15] (RW)
 *
 * Selects the clock source used by alternative crystal direction counter.
 *
 * Values:
 * - 0 - Use FLM as a clock source for ACD count.
 * - 1 - Use LP/HSYNC as a clock source for ACD count.
 */
//@{
#define BP_LCDC_LPCR_ACDSEL      (15U)      //!< Bit position for LCDC_LPCR_ACDSEL.
#define BM_LCDC_LPCR_ACDSEL      (0x00008000U)  //!< Bit mask for LCDC_LPCR_ACDSEL.
#define BS_LCDC_LPCR_ACDSEL      (1U)  //!< Bitfield size in bits for LCDC_LPCR_ACDSEL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_ACDSEL field.
#define BR_LCDC_LPCR_ACDSEL()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_ACDSEL))
#endif

//! @brief Format value for bitfield LCDC_LPCR_ACDSEL.
#define BF_LCDC_LPCR_ACDSEL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_ACDSEL), uint32_t) & BM_LCDC_LPCR_ACDSEL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACDSEL field to a new value.
#define BW_LCDC_LPCR_ACDSEL(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_ACDSEL) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field REV_VS[16] (RW)
 *
 * Selects the vertical scan direction as normal or reverse image flips along the x-axis. The LSSAR
 * register should be changed accordingly if this bit is set so that it points to the beginning of
 * last horizontal line of the image.
 *
 * Values:
 * - 0 - Vertical scan in normal direction.
 * - 1 - Vertical scan in reverse direction.
 */
//@{
#define BP_LCDC_LPCR_REV_VS      (16U)      //!< Bit position for LCDC_LPCR_REV_VS.
#define BM_LCDC_LPCR_REV_VS      (0x00010000U)  //!< Bit mask for LCDC_LPCR_REV_VS.
#define BS_LCDC_LPCR_REV_VS      (1U)  //!< Bitfield size in bits for LCDC_LPCR_REV_VS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_REV_VS field.
#define BR_LCDC_LPCR_REV_VS()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_REV_VS))
#endif

//! @brief Format value for bitfield LCDC_LPCR_REV_VS.
#define BF_LCDC_LPCR_REV_VS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_REV_VS), uint32_t) & BM_LCDC_LPCR_REV_VS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the REV_VS field to a new value.
#define BW_LCDC_LPCR_REV_VS(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_REV_VS) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field SWAP_SEL[17] (RW)
 *
 * LCDC operates in big endian mode internally. This bit controls the swap of data before operation
 * in little endian mode when END_SEL=0. When END_SEL=1, this bit has no affect. When SWAP_SEL = 0,
 * byte 3 (bits 31–24), byte 2 (bits 23–16), byte 1 (bits 15–8), and byte 0 (bits 7–0) data swapped
 * to byte 1, byte 0, byte 3, and byte 2 respectively. When SWAP_SEL = 1 and in 24, 18, 16, or 12
 * bpp mode, byte 2 and byte 0 are swapped so that the output is BGR instead of RGB. When SWAP_SEL =
 * 1 and in 8, 4, 2, or 1bpp mode, byte 3, byte 2, byte 1, and byte 0 data swapped to byte 0, byte
 * 1, byte 2, and byte 3 respectively.
 *
 * Values:
 * - 0 - 24 bpp, 18 bpp, 16 bpp, 12 bpp mode.
 * - 1 - 8 bpp, 4 bpp, 2 bpp, and 1 bpp mode.
 */
//@{
#define BP_LCDC_LPCR_SWAP_SEL      (17U)      //!< Bit position for LCDC_LPCR_SWAP_SEL.
#define BM_LCDC_LPCR_SWAP_SEL      (0x00020000U)  //!< Bit mask for LCDC_LPCR_SWAP_SEL.
#define BS_LCDC_LPCR_SWAP_SEL      (1U)  //!< Bitfield size in bits for LCDC_LPCR_SWAP_SEL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_SWAP_SEL field.
#define BR_LCDC_LPCR_SWAP_SEL()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_SWAP_SEL))
#endif

//! @brief Format value for bitfield LCDC_LPCR_SWAP_SEL.
#define BF_LCDC_LPCR_SWAP_SEL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_SWAP_SEL), uint32_t) & BM_LCDC_LPCR_SWAP_SEL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SWAP_SEL field to a new value.
#define BW_LCDC_LPCR_SWAP_SEL(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_SWAP_SEL) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field END_SEL[18] (RW)
 *
 * Selects the image download into memory as big or little endian format.
 *
 * Values:
 * - 0 - Little Endian
 * - 1 - Big Endian
 */
//@{
#define BP_LCDC_LPCR_END_SEL      (18U)      //!< Bit position for LCDC_LPCR_END_SEL.
#define BM_LCDC_LPCR_END_SEL      (0x00040000U)  //!< Bit mask for LCDC_LPCR_END_SEL.
#define BS_LCDC_LPCR_END_SEL      (1U)  //!< Bitfield size in bits for LCDC_LPCR_END_SEL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_END_SEL field.
#define BR_LCDC_LPCR_END_SEL()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_END_SEL))
#endif

//! @brief Format value for bitfield LCDC_LPCR_END_SEL.
#define BF_LCDC_LPCR_END_SEL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_END_SEL), uint32_t) & BM_LCDC_LPCR_END_SEL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the END_SEL field to a new value.
#define BW_LCDC_LPCR_END_SEL(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_END_SEL) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field SCLKIDLE[19] (RW)
 *
 * Enables/disables LSCLK when VSYNC is idle in TFT mode.
 *
 * Values:
 * - 0 - Disable LSCLK
 * - 1 - Enable LSCLK
 */
//@{
#define BP_LCDC_LPCR_SCLKIDLE      (19U)      //!< Bit position for LCDC_LPCR_SCLKIDLE.
#define BM_LCDC_LPCR_SCLKIDLE      (0x00080000U)  //!< Bit mask for LCDC_LPCR_SCLKIDLE.
#define BS_LCDC_LPCR_SCLKIDLE      (1U)  //!< Bitfield size in bits for LCDC_LPCR_SCLKIDLE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_SCLKIDLE field.
#define BR_LCDC_LPCR_SCLKIDLE()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_SCLKIDLE))
#endif

//! @brief Format value for bitfield LCDC_LPCR_SCLKIDLE.
#define BF_LCDC_LPCR_SCLKIDLE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_SCLKIDLE), uint32_t) & BM_LCDC_LPCR_SCLKIDLE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SCLKIDLE field to a new value.
#define BW_LCDC_LPCR_SCLKIDLE(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_SCLKIDLE) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field OEPOL[20] (RW)
 *
 * Sets the output enable signal polarity.
 *
 * Values:
 * - 0 - Active high
 * - 1 - Active low
 */
//@{
#define BP_LCDC_LPCR_OEPOL      (20U)      //!< Bit position for LCDC_LPCR_OEPOL.
#define BM_LCDC_LPCR_OEPOL      (0x00100000U)  //!< Bit mask for LCDC_LPCR_OEPOL.
#define BS_LCDC_LPCR_OEPOL      (1U)  //!< Bitfield size in bits for LCDC_LPCR_OEPOL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_OEPOL field.
#define BR_LCDC_LPCR_OEPOL()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_OEPOL))
#endif

//! @brief Format value for bitfield LCDC_LPCR_OEPOL.
#define BF_LCDC_LPCR_OEPOL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_OEPOL), uint32_t) & BM_LCDC_LPCR_OEPOL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the OEPOL field to a new value.
#define BW_LCDC_LPCR_OEPOL(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_OEPOL) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field CLKPOL[21] (RW)
 *
 * Sets the polarity of active edge of LCD shift clock.
 *
 * Values:
 * - 0 - Active on negative edge of LSCLK. In TFT mode, active on positive edge of LSCLK.
 * - 1 - Active on positive edge of LSCLK. In TFT mode, active on negative edge of LSCLK.
 */
//@{
#define BP_LCDC_LPCR_CLKPOL      (21U)      //!< Bit position for LCDC_LPCR_CLKPOL.
#define BM_LCDC_LPCR_CLKPOL      (0x00200000U)  //!< Bit mask for LCDC_LPCR_CLKPOL.
#define BS_LCDC_LPCR_CLKPOL      (1U)  //!< Bitfield size in bits for LCDC_LPCR_CLKPOL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_CLKPOL field.
#define BR_LCDC_LPCR_CLKPOL()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_CLKPOL))
#endif

//! @brief Format value for bitfield LCDC_LPCR_CLKPOL.
#define BF_LCDC_LPCR_CLKPOL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_CLKPOL), uint32_t) & BM_LCDC_LPCR_CLKPOL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CLKPOL field to a new value.
#define BW_LCDC_LPCR_CLKPOL(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_CLKPOL) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field LPPOL[22] (RW)
 *
 * Sets the polarity of line pulse signal (LP/HSYNC).
 *
 * Values:
 * - 0 - Active high
 * - 1 - Active low
 */
//@{
#define BP_LCDC_LPCR_LPPOL      (22U)      //!< Bit position for LCDC_LPCR_LPPOL.
#define BM_LCDC_LPCR_LPPOL      (0x00400000U)  //!< Bit mask for LCDC_LPCR_LPPOL.
#define BS_LCDC_LPCR_LPPOL      (1U)  //!< Bitfield size in bits for LCDC_LPCR_LPPOL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_LPPOL field.
#define BR_LCDC_LPCR_LPPOL()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_LPPOL))
#endif

//! @brief Format value for bitfield LCDC_LPCR_LPPOL.
#define BF_LCDC_LPCR_LPPOL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_LPPOL), uint32_t) & BM_LCDC_LPCR_LPPOL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LPPOL field to a new value.
#define BW_LCDC_LPCR_LPPOL(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_LPPOL) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field FLMPOL[23] (RW)
 *
 * Sets the polarity of first line marker signal (FLM/VSYNC).
 *
 * Values:
 * - 0 - Active high
 * - 1 - Active low
 */
//@{
#define BP_LCDC_LPCR_FLMPOL      (23U)      //!< Bit position for LCDC_LPCR_FLMPOL.
#define BM_LCDC_LPCR_FLMPOL      (0x00800000U)  //!< Bit mask for LCDC_LPCR_FLMPOL.
#define BS_LCDC_LPCR_FLMPOL      (1U)  //!< Bitfield size in bits for LCDC_LPCR_FLMPOL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_FLMPOL field.
#define BR_LCDC_LPCR_FLMPOL()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_FLMPOL))
#endif

//! @brief Format value for bitfield LCDC_LPCR_FLMPOL.
#define BF_LCDC_LPCR_FLMPOL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_FLMPOL), uint32_t) & BM_LCDC_LPCR_FLMPOL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FLMPOL field to a new value.
#define BW_LCDC_LPCR_FLMPOL(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_FLMPOL) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field PIXPOL[24] (RW)
 *
 * Sets the pixels polarity.
 *
 * Values:
 * - 0 - Active high
 * - 1 - Active low
 */
//@{
#define BP_LCDC_LPCR_PIXPOL      (24U)      //!< Bit position for LCDC_LPCR_PIXPOL.
#define BM_LCDC_LPCR_PIXPOL      (0x01000000U)  //!< Bit mask for LCDC_LPCR_PIXPOL.
#define BS_LCDC_LPCR_PIXPOL      (1U)  //!< Bitfield size in bits for LCDC_LPCR_PIXPOL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_PIXPOL field.
#define BR_LCDC_LPCR_PIXPOL()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_PIXPOL))
#endif

//! @brief Format value for bitfield LCDC_LPCR_PIXPOL.
#define BF_LCDC_LPCR_PIXPOL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_PIXPOL), uint32_t) & BM_LCDC_LPCR_PIXPOL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PIXPOL field to a new value.
#define BW_LCDC_LPCR_PIXPOL(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_PIXPOL) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field BPIX[27:25] (RW)
 *
 * Indicates the number of bits per pixel in memory. To set normal 18 bpp mode: BPIX = 110, END_SEL
 * = 1, and SWAP_SEL = X (don’t care). To set Microsoft PAL_BGR 18 bpp mode: BPIX = 110, END_SEL =
 * 0, and SWAP_SEL = 1. See for more information.
 *
 * Values:
 * - 000 - 1 bpp, FRC bypassed
 * - 001 - 2 bpp
 * - 010 - 4 bpp
 * - 011 - 8 bpp
 * - 100 - 12 bpp (16-bits of memory used)
 * - 101 - 16 bpp
 * - 110 - 18 bpp (32-bits of memory used)
 * - 111 - 24 bpp (32-bits of memory used)
 */
//@{
#define BP_LCDC_LPCR_BPIX      (25U)      //!< Bit position for LCDC_LPCR_BPIX.
#define BM_LCDC_LPCR_BPIX      (0x0e000000U)  //!< Bit mask for LCDC_LPCR_BPIX.
#define BS_LCDC_LPCR_BPIX      (3U)  //!< Bitfield size in bits for LCDC_LPCR_BPIX.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_BPIX field.
#define BR_LCDC_LPCR_BPIX()   (HW_LCDC_LPCR.B.BPIX)
#endif

//! @brief Format value for bitfield LCDC_LPCR_BPIX.
#define BF_LCDC_LPCR_BPIX(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_BPIX), uint32_t) & BM_LCDC_LPCR_BPIX)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BPIX field to a new value.
#define BW_LCDC_LPCR_BPIX(v)   (HW_LCDC_LPCR_WR((HW_LCDC_LPCR_RD() & ~BM_LCDC_LPCR_BPIX) | BF_LCDC_LPCR_BPIX(v)))
#endif
//@}

/*! @name Register LCDC_LPCR, field PBSIZ[29:28] (RW)
 *
 * Specifies the panel bus width. Applicable for monochrome monitors. For passive color panels, only
 * 8-bit panel bus width is supported. For active mode, these bits are not applicable. See for TFT
 * data line assignments.
 *
 * Values:
 * - 000 - 1-bit
 * - 001 - 2-bit
 * - 010 - 4-bit
 * - 011 - 8-bit
 */
//@{
#define BP_LCDC_LPCR_PBSIZ      (28U)      //!< Bit position for LCDC_LPCR_PBSIZ.
#define BM_LCDC_LPCR_PBSIZ      (0x30000000U)  //!< Bit mask for LCDC_LPCR_PBSIZ.
#define BS_LCDC_LPCR_PBSIZ      (2U)  //!< Bitfield size in bits for LCDC_LPCR_PBSIZ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_PBSIZ field.
#define BR_LCDC_LPCR_PBSIZ()   (HW_LCDC_LPCR.B.PBSIZ)
#endif

//! @brief Format value for bitfield LCDC_LPCR_PBSIZ.
#define BF_LCDC_LPCR_PBSIZ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_PBSIZ), uint32_t) & BM_LCDC_LPCR_PBSIZ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PBSIZ field to a new value.
#define BW_LCDC_LPCR_PBSIZ(v)   (HW_LCDC_LPCR_WR((HW_LCDC_LPCR_RD() & ~BM_LCDC_LPCR_PBSIZ) | BF_LCDC_LPCR_PBSIZ(v)))
#endif
//@}

/*! @name Register LCDC_LPCR, field COLOR[30] (RW)
 *
 * In passive mode, this bit activates 3 channels of FRC to allow the use of special 2 2/3 pixels
 * per output vector format. Please refer to for TFT/COLOR setting usage.
 *
 * Values:
 * - 0 - LCD panel is a Monochrome display.
 * - 1 - LCD panel is a Color display.
 */
//@{
#define BP_LCDC_LPCR_COLOR      (30U)      //!< Bit position for LCDC_LPCR_COLOR.
#define BM_LCDC_LPCR_COLOR      (0x40000000U)  //!< Bit mask for LCDC_LPCR_COLOR.
#define BS_LCDC_LPCR_COLOR      (1U)  //!< Bitfield size in bits for LCDC_LPCR_COLOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_COLOR field.
#define BR_LCDC_LPCR_COLOR()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_COLOR))
#endif

//! @brief Format value for bitfield LCDC_LPCR_COLOR.
#define BF_LCDC_LPCR_COLOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_COLOR), uint32_t) & BM_LCDC_LPCR_COLOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the COLOR field to a new value.
#define BW_LCDC_LPCR_COLOR(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_COLOR) = (v))
#endif
//@}

/*! @name Register LCDC_LPCR, field TFT[31] (RW)
 *
 * Controls the format and timing of output control signals. Active and passive displays use
 * different signal timing formats as described in Panel Interface Signals and Timing . TFT also
 * controls the use of FRC in color mode. The following table shows the TFT/COLOR setting usage.
 * TFT/COLOR settings TFT Color LCD display 0 0 Monochrome 0 1 CSTN 1 0 ̶ 1 1 TFT
 *
 * Values:
 * - 0 - LCD panel is a passive display.
 * - 1 - LCD panel is an active display: “digital CRT” signal format, FRC is bypassed.
 */
//@{
#define BP_LCDC_LPCR_TFT      (31U)      //!< Bit position for LCDC_LPCR_TFT.
#define BM_LCDC_LPCR_TFT      (0x80000000U)  //!< Bit mask for LCDC_LPCR_TFT.
#define BS_LCDC_LPCR_TFT      (1U)  //!< Bitfield size in bits for LCDC_LPCR_TFT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCR_TFT field.
#define BR_LCDC_LPCR_TFT()   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_TFT))
#endif

//! @brief Format value for bitfield LCDC_LPCR_TFT.
#define BF_LCDC_LPCR_TFT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCR_TFT), uint32_t) & BM_LCDC_LPCR_TFT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TFT field to a new value.
#define BW_LCDC_LPCR_TFT(v)   (BITBAND_ACCESS32(HW_LCDC_LPCR_ADDR, BP_LCDC_LPCR_TFT) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LHCR - LCDC horizontal configuration register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LHCR - LCDC horizontal configuration register (RW)
 *
 * Reset value: 0x04000000U
 *
 * This register defines the horizontal sync pulse timing. To determine the proper settings, please
 * refer to the panel's data sheet.
 */
typedef union _hw_lcdc_lhcr
{
    uint32_t U;
    struct _hw_lcdc_lhcr_bitfields
    {
        uint32_t H_WAIT_2 : 8; //!< [7:0] Wait between HSYNC and start of next line
        uint32_t H_WAIT_1 : 8; //!< [15:8] Wait between OE and HSYNC
        uint32_t RESERVED0 : 10; //!< [25:16] 
        uint32_t H_WIDTH : 6; //!< [31:26] Horizontal sync pulse width
    } B;
} hw_lcdc_lhcr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LHCR register
 */
//@{
#define HW_LCDC_LHCR_ADDR      (REGS_LCDC_BASE + 0x1cU)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LHCR           (*(__IO hw_lcdc_lhcr_t *) HW_LCDC_LHCR_ADDR)
#define HW_LCDC_LHCR_RD()      (HW_LCDC_LHCR.U)
#define HW_LCDC_LHCR_WR(v)     (HW_LCDC_LHCR.U = (v))
#define HW_LCDC_LHCR_SET(v)    (HW_LCDC_LHCR_WR(HW_LCDC_LHCR_RD() |  (v)))
#define HW_LCDC_LHCR_CLR(v)    (HW_LCDC_LHCR_WR(HW_LCDC_LHCR_RD() & ~(v)))
#define HW_LCDC_LHCR_TOG(v)    (HW_LCDC_LHCR_WR(HW_LCDC_LHCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LHCR bitfields
 */

/*! @name Register LCDC_LHCR, field H_WAIT_2[7:0] (RW)
 *
 * In TFT mode, it specifies the number of SCLK periods between the end of HSYNC and the beginning
 * of OE signal. Total delay time equals (H_WAIT_2 + 3). In CSTN mode, it specifies the number of
 * SCLK periods between the end of the LP signal and the first display data in each line. Total
 * delay time equals (H_WAIT_2 + 2) of SCLK periods.
 */
//@{
#define BP_LCDC_LHCR_H_WAIT_2      (0U)      //!< Bit position for LCDC_LHCR_H_WAIT_2.
#define BM_LCDC_LHCR_H_WAIT_2      (0x000000ffU)  //!< Bit mask for LCDC_LHCR_H_WAIT_2.
#define BS_LCDC_LHCR_H_WAIT_2      (8U)  //!< Bitfield size in bits for LCDC_LHCR_H_WAIT_2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LHCR_H_WAIT_2 field.
#define BR_LCDC_LHCR_H_WAIT_2()   (HW_LCDC_LHCR.B.H_WAIT_2)
#endif

//! @brief Format value for bitfield LCDC_LHCR_H_WAIT_2.
#define BF_LCDC_LHCR_H_WAIT_2(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LHCR_H_WAIT_2), uint32_t) & BM_LCDC_LHCR_H_WAIT_2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the H_WAIT_2 field to a new value.
#define BW_LCDC_LHCR_H_WAIT_2(v)   (HW_LCDC_LHCR_WR((HW_LCDC_LHCR_RD() & ~BM_LCDC_LHCR_H_WAIT_2) | BF_LCDC_LHCR_H_WAIT_2(v)))
#endif
//@}

/*! @name Register LCDC_LHCR, field H_WAIT_1[15:8] (RW)
 *
 * In TFT mode, it specifies the number of SCLK periods between the end of OE signal and the
 * beginning of HSYNC. Total delay time equals (H_WAIT_1 + 1) of SCLK periods. In CSTN mode, it
 * specifies the number of SCLK periods between the last display data and the beginning of the LP
 * signal. Total delay time equals (H_WAIT_1 + 1) of SCLK periods.
 */
//@{
#define BP_LCDC_LHCR_H_WAIT_1      (8U)      //!< Bit position for LCDC_LHCR_H_WAIT_1.
#define BM_LCDC_LHCR_H_WAIT_1      (0x0000ff00U)  //!< Bit mask for LCDC_LHCR_H_WAIT_1.
#define BS_LCDC_LHCR_H_WAIT_1      (8U)  //!< Bitfield size in bits for LCDC_LHCR_H_WAIT_1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LHCR_H_WAIT_1 field.
#define BR_LCDC_LHCR_H_WAIT_1()   (HW_LCDC_LHCR.B.H_WAIT_1)
#endif

//! @brief Format value for bitfield LCDC_LHCR_H_WAIT_1.
#define BF_LCDC_LHCR_H_WAIT_1(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LHCR_H_WAIT_1), uint32_t) & BM_LCDC_LHCR_H_WAIT_1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the H_WAIT_1 field to a new value.
#define BW_LCDC_LHCR_H_WAIT_1(v)   (HW_LCDC_LHCR_WR((HW_LCDC_LHCR_RD() & ~BM_LCDC_LHCR_H_WAIT_1) | BF_LCDC_LHCR_H_WAIT_1(v)))
#endif
//@}

/*! @name Register LCDC_LHCR, field H_WIDTH[31:26] (RW)
 *
 * Specifies the number of SCLK periods for which HSYNC is activated. The active time is equal to
 * (H_WIDTH + 1) of the SCLK periods.
 */
//@{
#define BP_LCDC_LHCR_H_WIDTH      (26U)      //!< Bit position for LCDC_LHCR_H_WIDTH.
#define BM_LCDC_LHCR_H_WIDTH      (0xfc000000U)  //!< Bit mask for LCDC_LHCR_H_WIDTH.
#define BS_LCDC_LHCR_H_WIDTH      (6U)  //!< Bitfield size in bits for LCDC_LHCR_H_WIDTH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LHCR_H_WIDTH field.
#define BR_LCDC_LHCR_H_WIDTH()   (HW_LCDC_LHCR.B.H_WIDTH)
#endif

//! @brief Format value for bitfield LCDC_LHCR_H_WIDTH.
#define BF_LCDC_LHCR_H_WIDTH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LHCR_H_WIDTH), uint32_t) & BM_LCDC_LHCR_H_WIDTH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the H_WIDTH field to a new value.
#define BW_LCDC_LHCR_H_WIDTH(v)   (HW_LCDC_LHCR_WR((HW_LCDC_LHCR_RD() & ~BM_LCDC_LHCR_H_WIDTH) | BF_LCDC_LHCR_H_WIDTH(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LVCR - LCDC vertical configuration register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LVCR - LCDC vertical configuration register (RW)
 *
 * Reset value: 0x04000000U
 *
 * This register defines the vertical sync pulse timing. To determine the proper settings, please
 * refer to the panel's data sheet.
 */
typedef union _hw_lcdc_lvcr
{
    uint32_t U;
    struct _hw_lcdc_lvcr_bitfields
    {
        uint32_t V_WAIT_2 : 8; //!< [7:0] Wait between frames 2
        uint32_t V_WAIT_1 : 8; //!< [15:8] Wait between frames 1
        uint32_t RESERVED0 : 10; //!< [25:16] 
        uint32_t V_WIDTH : 6; //!< [31:26] Vertical sync pulse width
    } B;
} hw_lcdc_lvcr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LVCR register
 */
//@{
#define HW_LCDC_LVCR_ADDR      (REGS_LCDC_BASE + 0x20U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LVCR           (*(__IO hw_lcdc_lvcr_t *) HW_LCDC_LVCR_ADDR)
#define HW_LCDC_LVCR_RD()      (HW_LCDC_LVCR.U)
#define HW_LCDC_LVCR_WR(v)     (HW_LCDC_LVCR.U = (v))
#define HW_LCDC_LVCR_SET(v)    (HW_LCDC_LVCR_WR(HW_LCDC_LVCR_RD() |  (v)))
#define HW_LCDC_LVCR_CLR(v)    (HW_LCDC_LVCR_WR(HW_LCDC_LVCR_RD() & ~(v)))
#define HW_LCDC_LVCR_TOG(v)    (HW_LCDC_LVCR_WR(HW_LCDC_LVCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LVCR bitfields
 */

/*! @name Register LCDC_LVCR, field V_WAIT_2[7:0] (RW)
 *
 * Defines the delay, in lines, between the end of VSYNC pulse and the beginning of OE pulse of the
 * first line in active mode (TFT=1). The actual delay is (V_WAIT_2 ) lines. Set this field to zero
 * for passive non-color mode. The minimum value of this field is 0x01.
 */
//@{
#define BP_LCDC_LVCR_V_WAIT_2      (0U)      //!< Bit position for LCDC_LVCR_V_WAIT_2.
#define BM_LCDC_LVCR_V_WAIT_2      (0x000000ffU)  //!< Bit mask for LCDC_LVCR_V_WAIT_2.
#define BS_LCDC_LVCR_V_WAIT_2      (8U)  //!< Bitfield size in bits for LCDC_LVCR_V_WAIT_2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LVCR_V_WAIT_2 field.
#define BR_LCDC_LVCR_V_WAIT_2()   (HW_LCDC_LVCR.B.V_WAIT_2)
#endif

//! @brief Format value for bitfield LCDC_LVCR_V_WAIT_2.
#define BF_LCDC_LVCR_V_WAIT_2(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LVCR_V_WAIT_2), uint32_t) & BM_LCDC_LVCR_V_WAIT_2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the V_WAIT_2 field to a new value.
#define BW_LCDC_LVCR_V_WAIT_2(v)   (HW_LCDC_LVCR_WR((HW_LCDC_LVCR_RD() & ~BM_LCDC_LVCR_V_WAIT_2) | BF_LCDC_LVCR_V_WAIT_2(v)))
#endif
//@}

/*! @name Register LCDC_LVCR, field V_WAIT_1[15:8] (RW)
 *
 * Defines the delay, in lines, between the end of OE pulse and the beginning of VSYNC pulse for
 * active mode (TFT=1). The actual delay is (V_WAIT_1) lines. In passive color mode, this field is
 * the delay, measured in virtual clock periods, between the last line of the frame to the beginning
 * of next frame. This field has no meaning in passive non-color mode.
 */
//@{
#define BP_LCDC_LVCR_V_WAIT_1      (8U)      //!< Bit position for LCDC_LVCR_V_WAIT_1.
#define BM_LCDC_LVCR_V_WAIT_1      (0x0000ff00U)  //!< Bit mask for LCDC_LVCR_V_WAIT_1.
#define BS_LCDC_LVCR_V_WAIT_1      (8U)  //!< Bitfield size in bits for LCDC_LVCR_V_WAIT_1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LVCR_V_WAIT_1 field.
#define BR_LCDC_LVCR_V_WAIT_1()   (HW_LCDC_LVCR.B.V_WAIT_1)
#endif

//! @brief Format value for bitfield LCDC_LVCR_V_WAIT_1.
#define BF_LCDC_LVCR_V_WAIT_1(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LVCR_V_WAIT_1), uint32_t) & BM_LCDC_LVCR_V_WAIT_1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the V_WAIT_1 field to a new value.
#define BW_LCDC_LVCR_V_WAIT_1(v)   (HW_LCDC_LVCR_WR((HW_LCDC_LVCR_RD() & ~BM_LCDC_LVCR_V_WAIT_1) | BF_LCDC_LVCR_V_WAIT_1(v)))
#endif
//@}

/*! @name Register LCDC_LVCR, field V_WIDTH[31:26] (RW)
 *
 * Specifies the width, in lines, of VSYNC pulse for active mode (TFT=1). For a value of “000001”, a
 * vertical sync pulse encompasses one HSYNC pulse. For a value of “000002”, a vertical sync pulse
 * encompasses two HSYNC pulses, and so on. For passive mode (TFT=0) and non-color mode, see
 * Horizontal Sync Pulse Timing in Passive Mode diagram .
 */
//@{
#define BP_LCDC_LVCR_V_WIDTH      (26U)      //!< Bit position for LCDC_LVCR_V_WIDTH.
#define BM_LCDC_LVCR_V_WIDTH      (0xfc000000U)  //!< Bit mask for LCDC_LVCR_V_WIDTH.
#define BS_LCDC_LVCR_V_WIDTH      (6U)  //!< Bitfield size in bits for LCDC_LVCR_V_WIDTH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LVCR_V_WIDTH field.
#define BR_LCDC_LVCR_V_WIDTH()   (HW_LCDC_LVCR.B.V_WIDTH)
#endif

//! @brief Format value for bitfield LCDC_LVCR_V_WIDTH.
#define BF_LCDC_LVCR_V_WIDTH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LVCR_V_WIDTH), uint32_t) & BM_LCDC_LVCR_V_WIDTH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the V_WIDTH field to a new value.
#define BW_LCDC_LVCR_V_WIDTH(v)   (HW_LCDC_LVCR_WR((HW_LCDC_LVCR_RD() & ~BM_LCDC_LVCR_V_WIDTH) | BF_LCDC_LVCR_V_WIDTH(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LPOR - LCDC panning offset register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LPOR - LCDC panning offset register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register sets up panning for the image.
 */
typedef union _hw_lcdc_lpor
{
    uint32_t U;
    struct _hw_lcdc_lpor_bitfields
    {
        uint32_t POS : 5; //!< [4:0] Panning offset
        uint32_t RESERVED0 : 27; //!< [31:5] 
    } B;
} hw_lcdc_lpor_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LPOR register
 */
//@{
#define HW_LCDC_LPOR_ADDR      (REGS_LCDC_BASE + 0x24U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LPOR           (*(__IO hw_lcdc_lpor_t *) HW_LCDC_LPOR_ADDR)
#define HW_LCDC_LPOR_RD()      (HW_LCDC_LPOR.U)
#define HW_LCDC_LPOR_WR(v)     (HW_LCDC_LPOR.U = (v))
#define HW_LCDC_LPOR_SET(v)    (HW_LCDC_LPOR_WR(HW_LCDC_LPOR_RD() |  (v)))
#define HW_LCDC_LPOR_CLR(v)    (HW_LCDC_LPOR_WR(HW_LCDC_LPOR_RD() & ~(v)))
#define HW_LCDC_LPOR_TOG(v)    (HW_LCDC_LPOR_WR(HW_LCDC_LPOR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LPOR bitfields
 */

/*! @name Register LCDC_LPOR, field POS[4:0] (RW)
 *
 * Defines the number of bits that the data from memory is panned to the left before processing. POS
 * is read by the LCDC once at the beginning of each frame. For example, in 4 bpp mode, setting POS
 * = 4 shifts 16-bits, which means panning the image by 4 pixels left. Shifting data more than 32
 * bits should use LSSAR register setting. 18 and 24 bpp panning should use LSSAR register setting.
 * To achieve panning of the final image by N bits: Bits per pixel POS Effective # of pixels panned
 * on image 1 N N 2 2N N 4 4N N 8 8N N 12/16 16N N
 */
//@{
#define BP_LCDC_LPOR_POS      (0U)      //!< Bit position for LCDC_LPOR_POS.
#define BM_LCDC_LPOR_POS      (0x0000001fU)  //!< Bit mask for LCDC_LPOR_POS.
#define BS_LCDC_LPOR_POS      (5U)  //!< Bitfield size in bits for LCDC_LPOR_POS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPOR_POS field.
#define BR_LCDC_LPOR_POS()   (HW_LCDC_LPOR.B.POS)
#endif

//! @brief Format value for bitfield LCDC_LPOR_POS.
#define BF_LCDC_LPOR_POS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPOR_POS), uint32_t) & BM_LCDC_LPOR_POS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the POS field to a new value.
#define BW_LCDC_LPOR_POS(v)   (HW_LCDC_LPOR_WR((HW_LCDC_LPOR_RD() & ~BM_LCDC_LPOR_POS) | BF_LCDC_LPOR_POS(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LPCCR - LCDC PWM contrast control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LPCCR - LCDC PWM contrast control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the signal output at the contrast pin that controls contrast of the LCD
 * panel.
 */
typedef union _hw_lcdc_lpccr
{
    uint32_t U;
    struct _hw_lcdc_lpccr_bitfields
    {
        uint32_t PW : 8; //!< [7:0] Pulse-width
        uint32_t CC_EN : 1; //!< [8] Contrast control enable
        uint32_t SCR : 2; //!< [10:9] Source select
        uint32_t RESERVED0 : 4; //!< [14:11] 
        uint32_t LDMSK : 1; //!< [15] LD mask
        uint32_t RESERVED1 : 16; //!< [31:16] Reserved.
    } B;
} hw_lcdc_lpccr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LPCCR register
 */
//@{
#define HW_LCDC_LPCCR_ADDR      (REGS_LCDC_BASE + 0x2cU)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LPCCR           (*(__IO hw_lcdc_lpccr_t *) HW_LCDC_LPCCR_ADDR)
#define HW_LCDC_LPCCR_RD()      (HW_LCDC_LPCCR.U)
#define HW_LCDC_LPCCR_WR(v)     (HW_LCDC_LPCCR.U = (v))
#define HW_LCDC_LPCCR_SET(v)    (HW_LCDC_LPCCR_WR(HW_LCDC_LPCCR_RD() |  (v)))
#define HW_LCDC_LPCCR_CLR(v)    (HW_LCDC_LPCCR_WR(HW_LCDC_LPCCR_RD() & ~(v)))
#define HW_LCDC_LPCCR_TOG(v)    (HW_LCDC_LPCCR_WR(HW_LCDC_LPCCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LPCCR bitfields
 */

/*! @name Register LCDC_LPCCR, field PW[7:0] (RW)
 *
 * Controls the pulse-width of the built-in PWM that controls the contrast of LCD screen.
 */
//@{
#define BP_LCDC_LPCCR_PW      (0U)      //!< Bit position for LCDC_LPCCR_PW.
#define BM_LCDC_LPCCR_PW      (0x000000ffU)  //!< Bit mask for LCDC_LPCCR_PW.
#define BS_LCDC_LPCCR_PW      (8U)  //!< Bitfield size in bits for LCDC_LPCCR_PW.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCCR_PW field.
#define BR_LCDC_LPCCR_PW()   (HW_LCDC_LPCCR.B.PW)
#endif

//! @brief Format value for bitfield LCDC_LPCCR_PW.
#define BF_LCDC_LPCCR_PW(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCCR_PW), uint32_t) & BM_LCDC_LPCCR_PW)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PW field to a new value.
#define BW_LCDC_LPCCR_PW(v)   (HW_LCDC_LPCCR_WR((HW_LCDC_LPCCR_RD() & ~BM_LCDC_LPCCR_PW) | BF_LCDC_LPCCR_PW(v)))
#endif
//@}

/*! @name Register LCDC_LPCCR, field CC_EN[8] (RW)
 *
 * Enables/disables the contrast control function.
 *
 * Values:
 * - 0 - Contrast control is off.
 * - 1 - Contrast control is on.
 */
//@{
#define BP_LCDC_LPCCR_CC_EN      (8U)      //!< Bit position for LCDC_LPCCR_CC_EN.
#define BM_LCDC_LPCCR_CC_EN      (0x00000100U)  //!< Bit mask for LCDC_LPCCR_CC_EN.
#define BS_LCDC_LPCCR_CC_EN      (1U)  //!< Bitfield size in bits for LCDC_LPCCR_CC_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCCR_CC_EN field.
#define BR_LCDC_LPCCR_CC_EN()   (BITBAND_ACCESS32(HW_LCDC_LPCCR_ADDR, BP_LCDC_LPCCR_CC_EN))
#endif

//! @brief Format value for bitfield LCDC_LPCCR_CC_EN.
#define BF_LCDC_LPCCR_CC_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCCR_CC_EN), uint32_t) & BM_LCDC_LPCCR_CC_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CC_EN field to a new value.
#define BW_LCDC_LPCCR_CC_EN(v)   (BITBAND_ACCESS32(HW_LCDC_LPCCR_ADDR, BP_LCDC_LPCCR_CC_EN) = (v))
#endif
//@}

/*! @name Register LCDC_LPCCR, field SCR[10:9] (RW)
 *
 * Selects the input clock source for PWM counter. PWM output frequency is equal to the frequency of
 * input clock divided by 256.
 *
 * Values:
 * - 00 - Line pulse
 * - 01 - Pixel clock
 * - 10 - LCD clock
 * - 11 - Reserved
 */
//@{
#define BP_LCDC_LPCCR_SCR      (9U)      //!< Bit position for LCDC_LPCCR_SCR.
#define BM_LCDC_LPCCR_SCR      (0x00000600U)  //!< Bit mask for LCDC_LPCCR_SCR.
#define BS_LCDC_LPCCR_SCR      (2U)  //!< Bitfield size in bits for LCDC_LPCCR_SCR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCCR_SCR field.
#define BR_LCDC_LPCCR_SCR()   (HW_LCDC_LPCCR.B.SCR)
#endif

//! @brief Format value for bitfield LCDC_LPCCR_SCR.
#define BF_LCDC_LPCCR_SCR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCCR_SCR), uint32_t) & BM_LCDC_LPCCR_SCR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SCR field to a new value.
#define BW_LCDC_LPCCR_SCR(v)   (HW_LCDC_LPCCR_WR((HW_LCDC_LPCCR_RD() & ~BM_LCDC_LPCCR_SCR) | BF_LCDC_LPCCR_SCR(v)))
#endif
//@}

/*! @name Register LCDC_LPCCR, field LDMSK[15] (RW)
 *
 * Enables/disables the LD output to zero .
 *
 * Values:
 * - 0 - LD [23:0] is normal.
 * - 1 - LD [23:0] always equals 0.
 */
//@{
#define BP_LCDC_LPCCR_LDMSK      (15U)      //!< Bit position for LCDC_LPCCR_LDMSK.
#define BM_LCDC_LPCCR_LDMSK      (0x00008000U)  //!< Bit mask for LCDC_LPCCR_LDMSK.
#define BS_LCDC_LPCCR_LDMSK      (1U)  //!< Bitfield size in bits for LCDC_LPCCR_LDMSK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LPCCR_LDMSK field.
#define BR_LCDC_LPCCR_LDMSK()   (BITBAND_ACCESS32(HW_LCDC_LPCCR_ADDR, BP_LCDC_LPCCR_LDMSK))
#endif

//! @brief Format value for bitfield LCDC_LPCCR_LDMSK.
#define BF_LCDC_LPCCR_LDMSK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LPCCR_LDMSK), uint32_t) & BM_LCDC_LPCCR_LDMSK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LDMSK field to a new value.
#define BW_LCDC_LPCCR_LDMSK(v)   (BITBAND_ACCESS32(HW_LCDC_LPCCR_ADDR, BP_LCDC_LPCCR_LDMSK) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LDCR - LCDC DMA control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LDCR - LCDC DMA control register (RW)
 *
 * Reset value: 0x80040060U
 *
 * There is a 128 x 32 bit line buffer in the LCDC that stores DMA data from system memory. LDCR
 * controls DMA burst length and when to trigger a DMA burst in terms of number of data bytes left
 * in the pixel buffer.
 */
typedef union _hw_lcdc_ldcr
{
    uint32_t U;
    struct _hw_lcdc_ldcr_bitfields
    {
        uint32_t TM : 7; //!< [6:0] DMA trigger mark
        uint32_t RESERVED0 : 9; //!< [15:7] 
        uint32_t HM : 7; //!< [22:16] DMA high mark
        uint32_t RESERVED1 : 8; //!< [30:23] 
        uint32_t BURST : 1; //!< [31] Burst length
    } B;
} hw_lcdc_ldcr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LDCR register
 */
//@{
#define HW_LCDC_LDCR_ADDR      (REGS_LCDC_BASE + 0x30U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LDCR           (*(__IO hw_lcdc_ldcr_t *) HW_LCDC_LDCR_ADDR)
#define HW_LCDC_LDCR_RD()      (HW_LCDC_LDCR.U)
#define HW_LCDC_LDCR_WR(v)     (HW_LCDC_LDCR.U = (v))
#define HW_LCDC_LDCR_SET(v)    (HW_LCDC_LDCR_WR(HW_LCDC_LDCR_RD() |  (v)))
#define HW_LCDC_LDCR_CLR(v)    (HW_LCDC_LDCR_WR(HW_LCDC_LDCR_RD() & ~(v)))
#define HW_LCDC_LDCR_TOG(v)    (HW_LCDC_LDCR_WR(HW_LCDC_LDCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LDCR bitfields
 */

/*! @name Register LCDC_LDCR, field TM[6:0] (RW)
 *
 * Sets the low-level mark in the pixel buffer to trigger a DMA request. The low-level mark equals
 * the number of words left in the pixel buffer.
 */
//@{
#define BP_LCDC_LDCR_TM      (0U)      //!< Bit position for LCDC_LDCR_TM.
#define BM_LCDC_LDCR_TM      (0x0000007fU)  //!< Bit mask for LCDC_LDCR_TM.
#define BS_LCDC_LDCR_TM      (7U)  //!< Bitfield size in bits for LCDC_LDCR_TM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LDCR_TM field.
#define BR_LCDC_LDCR_TM()   (HW_LCDC_LDCR.B.TM)
#endif

//! @brief Format value for bitfield LCDC_LDCR_TM.
#define BF_LCDC_LDCR_TM(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LDCR_TM), uint32_t) & BM_LCDC_LDCR_TM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TM field to a new value.
#define BW_LCDC_LDCR_TM(v)   (HW_LCDC_LDCR_WR((HW_LCDC_LDCR_RD() & ~BM_LCDC_LDCR_TM) | BF_LCDC_LDCR_TM(v)))
#endif
//@}

/*! @name Register LCDC_LDCR, field HM[22:16] (RW)
 *
 * Establishes the high mark for DMA requests. For dynamic burst length, after DMA request is made,
 * data is loaded and pixel buffer continues to be filled until the number of empty words left in
 * DMA FIFO is equal to the high mark minus 2. Minimum HM setting in dynamic burst is 3. For fixed
 * burst length, burst length (in words) of each request is equal to the DMA high mark setting and
 * its value must be larger than TM.
 */
//@{
#define BP_LCDC_LDCR_HM      (16U)      //!< Bit position for LCDC_LDCR_HM.
#define BM_LCDC_LDCR_HM      (0x007f0000U)  //!< Bit mask for LCDC_LDCR_HM.
#define BS_LCDC_LDCR_HM      (7U)  //!< Bitfield size in bits for LCDC_LDCR_HM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LDCR_HM field.
#define BR_LCDC_LDCR_HM()   (HW_LCDC_LDCR.B.HM)
#endif

//! @brief Format value for bitfield LCDC_LDCR_HM.
#define BF_LCDC_LDCR_HM(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LDCR_HM), uint32_t) & BM_LCDC_LDCR_HM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HM field to a new value.
#define BW_LCDC_LDCR_HM(v)   (HW_LCDC_LDCR_WR((HW_LCDC_LDCR_RD() & ~BM_LCDC_LDCR_HM) | BF_LCDC_LDCR_HM(v)))
#endif
//@}

/*! @name Register LCDC_LDCR, field BURST[31] (RW)
 *
 * Determines whether the burst length is fixed or dynamic.
 *
 * Values:
 * - 0 - Burst length is dynamic.
 * - 1 - Burst length is fixed.
 */
//@{
#define BP_LCDC_LDCR_BURST      (31U)      //!< Bit position for LCDC_LDCR_BURST.
#define BM_LCDC_LDCR_BURST      (0x80000000U)  //!< Bit mask for LCDC_LDCR_BURST.
#define BS_LCDC_LDCR_BURST      (1U)  //!< Bitfield size in bits for LCDC_LDCR_BURST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LDCR_BURST field.
#define BR_LCDC_LDCR_BURST()   (BITBAND_ACCESS32(HW_LCDC_LDCR_ADDR, BP_LCDC_LDCR_BURST))
#endif

//! @brief Format value for bitfield LCDC_LDCR_BURST.
#define BF_LCDC_LDCR_BURST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LDCR_BURST), uint32_t) & BM_LCDC_LDCR_BURST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BURST field to a new value.
#define BW_LCDC_LDCR_BURST(v)   (BITBAND_ACCESS32(HW_LCDC_LDCR_ADDR, BP_LCDC_LDCR_BURST) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LRMCR - LCDC refresh mode control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LRMCR - LCDC refresh mode control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the refresh characteristics. SELF_REF must be set while the LCDC is
 * already enabled with SIM_MCR[LCDSTART]=1. On entering self-refresh mode, LSCLK and LD[23:0]
 * signals stay low. HYSN and VSYN operate normally. Except for SSA, LRMCR, BGLUT and GWLUT
 * registers, all configurations must be performed before enabling the LCDC to avoid a malfunction.
 * SSA must always match the address range of the RAM selected. If the user wants to switch between
 * various types of RAM, LCDC must be disabled before switching.
 */
typedef union _hw_lcdc_lrmcr
{
    uint32_t U;
    struct _hw_lcdc_lrmcr_bitfields
    {
        uint32_t SELF_REF : 1; //!< [0] Self-refresh
        uint32_t RESERVED0 : 31; //!< [31:1] 
    } B;
} hw_lcdc_lrmcr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LRMCR register
 */
//@{
#define HW_LCDC_LRMCR_ADDR      (REGS_LCDC_BASE + 0x34U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LRMCR           (*(__IO hw_lcdc_lrmcr_t *) HW_LCDC_LRMCR_ADDR)
#define HW_LCDC_LRMCR_RD()      (HW_LCDC_LRMCR.U)
#define HW_LCDC_LRMCR_WR(v)     (HW_LCDC_LRMCR.U = (v))
#define HW_LCDC_LRMCR_SET(v)    (HW_LCDC_LRMCR_WR(HW_LCDC_LRMCR_RD() |  (v)))
#define HW_LCDC_LRMCR_CLR(v)    (HW_LCDC_LRMCR_WR(HW_LCDC_LRMCR_RD() & ~(v)))
#define HW_LCDC_LRMCR_TOG(v)    (HW_LCDC_LRMCR_WR(HW_LCDC_LRMCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LRMCR bitfields
 */

/*! @name Register LCDC_LRMCR, field SELF_REF[0] (RW)
 *
 * Enables/disables self-refresh mode.
 *
 * Values:
 * - 0 - Disable self-refresh
 * - 1 - Enable self-refresh
 */
//@{
#define BP_LCDC_LRMCR_SELF_REF      (0U)      //!< Bit position for LCDC_LRMCR_SELF_REF.
#define BM_LCDC_LRMCR_SELF_REF      (0x00000001U)  //!< Bit mask for LCDC_LRMCR_SELF_REF.
#define BS_LCDC_LRMCR_SELF_REF      (1U)  //!< Bitfield size in bits for LCDC_LRMCR_SELF_REF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LRMCR_SELF_REF field.
#define BR_LCDC_LRMCR_SELF_REF()   (BITBAND_ACCESS32(HW_LCDC_LRMCR_ADDR, BP_LCDC_LRMCR_SELF_REF))
#endif

//! @brief Format value for bitfield LCDC_LRMCR_SELF_REF.
#define BF_LCDC_LRMCR_SELF_REF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LRMCR_SELF_REF), uint32_t) & BM_LCDC_LRMCR_SELF_REF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SELF_REF field to a new value.
#define BW_LCDC_LRMCR_SELF_REF(v)   (BITBAND_ACCESS32(HW_LCDC_LRMCR_ADDR, BP_LCDC_LRMCR_SELF_REF) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LICR - LCDC interrupt configuration register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LICR - LCDC interrupt configuration register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the interrupt conditions. The LCDC selects between triggering an
 * interrupt at either the End of Frame or at the Beginning of Frame. This register works in
 * conjunction with the LIER to enable LCDC interrupts. If an EOF interrupt is desired, then set
 * INTCON=0 and LIER[EOF_EN]=1. If a BOF interrupt is desired, then set INTCON=1 and LIER[BOF_EN]=1.
 * The graphic window interrupt are enabled in the same manner by modifying the GW_INT_CON bit and
 * LIEF register.
 */
typedef union _hw_lcdc_licr
{
    uint32_t U;
    struct _hw_lcdc_licr_bitfields
    {
        uint32_t INTCON : 1; //!< [0] Interrupt condition
        uint32_t RESERVED0 : 1; //!< [1] 
        uint32_t INTSYN : 1; //!< [2] Interrupt source
        uint32_t RESERVED1 : 1; //!< [3] 
        uint32_t GW_INT_CON : 1; //!< [4] Graphic window interrupt condition
        uint32_t RESERVED2 : 27; //!< [31:5] 
    } B;
} hw_lcdc_licr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LICR register
 */
//@{
#define HW_LCDC_LICR_ADDR      (REGS_LCDC_BASE + 0x38U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LICR           (*(__IO hw_lcdc_licr_t *) HW_LCDC_LICR_ADDR)
#define HW_LCDC_LICR_RD()      (HW_LCDC_LICR.U)
#define HW_LCDC_LICR_WR(v)     (HW_LCDC_LICR.U = (v))
#define HW_LCDC_LICR_SET(v)    (HW_LCDC_LICR_WR(HW_LCDC_LICR_RD() |  (v)))
#define HW_LCDC_LICR_CLR(v)    (HW_LCDC_LICR_WR(HW_LCDC_LICR_RD() & ~(v)))
#define HW_LCDC_LICR_TOG(v)    (HW_LCDC_LICR_WR(HW_LCDC_LICR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LICR bitfields
 */

/*! @name Register LCDC_LICR, field INTCON[0] (RW)
 *
 * Determines if an interrupt condition is set at the beginning or end of frame condition. Refer to
 * for INTSYN/INTCON setting usage.
 *
 * Values:
 * - 0 - Interrupt flag is set when the end of frame (EOF) is reached.
 * - 1 - Interrupt flag is set when the beginning of frame (BOF) is reached.
 */
//@{
#define BP_LCDC_LICR_INTCON      (0U)      //!< Bit position for LCDC_LICR_INTCON.
#define BM_LCDC_LICR_INTCON      (0x00000001U)  //!< Bit mask for LCDC_LICR_INTCON.
#define BS_LCDC_LICR_INTCON      (1U)  //!< Bitfield size in bits for LCDC_LICR_INTCON.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LICR_INTCON field.
#define BR_LCDC_LICR_INTCON()   (BITBAND_ACCESS32(HW_LCDC_LICR_ADDR, BP_LCDC_LICR_INTCON))
#endif

//! @brief Format value for bitfield LCDC_LICR_INTCON.
#define BF_LCDC_LICR_INTCON(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LICR_INTCON), uint32_t) & BM_LCDC_LICR_INTCON)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTCON field to a new value.
#define BW_LCDC_LICR_INTCON(v)   (BITBAND_ACCESS32(HW_LCDC_LICR_ADDR, BP_LCDC_LICR_INTCON) = (v))
#endif
//@}

/*! @name Register LCDC_LICR, field INTSYN[2] (RW)
 *
 * Determines if an interrupt flag is set during last/first data of frame loading or on last/first
 * data of frame output to the LCD panel. Please refer to the following table for INTSYN/INTCON
 * setting usage. There is a latency between loading last/first data of the frame to output to the
 * LCD panel. INTSYN/INTCON settings INTSYN INTCON Description 0 0 Interrupt flag is set on loading
 * last data of frame from memory. 0 1 Interrupt flag is set on loading first data of frame from
 * memory. 1 0 Interrupt flag is set on output of last data of frame to LCD panel. 1 1 Interrupt
 * flag is set on output of first data of frame to LCD panel.
 *
 * Values:
 * - 0 - Interrupt flag is set on loading the last/first data of frame from memory.
 * - 1 - Interrupt flag is set on output of the last/first data of frame to LCD panel.
 */
//@{
#define BP_LCDC_LICR_INTSYN      (2U)      //!< Bit position for LCDC_LICR_INTSYN.
#define BM_LCDC_LICR_INTSYN      (0x00000004U)  //!< Bit mask for LCDC_LICR_INTSYN.
#define BS_LCDC_LICR_INTSYN      (1U)  //!< Bitfield size in bits for LCDC_LICR_INTSYN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LICR_INTSYN field.
#define BR_LCDC_LICR_INTSYN()   (BITBAND_ACCESS32(HW_LCDC_LICR_ADDR, BP_LCDC_LICR_INTSYN))
#endif

//! @brief Format value for bitfield LCDC_LICR_INTSYN.
#define BF_LCDC_LICR_INTSYN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LICR_INTSYN), uint32_t) & BM_LCDC_LICR_INTSYN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INTSYN field to a new value.
#define BW_LCDC_LICR_INTSYN(v)   (BITBAND_ACCESS32(HW_LCDC_LICR_ADDR, BP_LCDC_LICR_INTSYN) = (v))
#endif
//@}

/*! @name Register LCDC_LICR, field GW_INT_CON[4] (RW)
 *
 * Determines if an interrupt condition is set at the beginning or end of graphic window condition.
 *
 * Values:
 * - 0 - Interrupt flag is set when end of graphic window is reached.
 * - 1 - Interrupt flag is set when beginning of graphic window is reached.
 */
//@{
#define BP_LCDC_LICR_GW_INT_CON      (4U)      //!< Bit position for LCDC_LICR_GW_INT_CON.
#define BM_LCDC_LICR_GW_INT_CON      (0x00000010U)  //!< Bit mask for LCDC_LICR_GW_INT_CON.
#define BS_LCDC_LICR_GW_INT_CON      (1U)  //!< Bitfield size in bits for LCDC_LICR_GW_INT_CON.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LICR_GW_INT_CON field.
#define BR_LCDC_LICR_GW_INT_CON()   (BITBAND_ACCESS32(HW_LCDC_LICR_ADDR, BP_LCDC_LICR_GW_INT_CON))
#endif

//! @brief Format value for bitfield LCDC_LICR_GW_INT_CON.
#define BF_LCDC_LICR_GW_INT_CON(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LICR_GW_INT_CON), uint32_t) & BM_LCDC_LICR_GW_INT_CON)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GW_INT_CON field to a new value.
#define BW_LCDC_LICR_GW_INT_CON(v)   (BITBAND_ACCESS32(HW_LCDC_LICR_ADDR, BP_LCDC_LICR_GW_INT_CON) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LIER - LCDC interrupt enable register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LIER - LCDC interrupt enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register enables the LCDC to generate an interrupt. When the interrupt is disabled, its
 * status can still be observed in the Interrupt Status Register.
 */
typedef union _hw_lcdc_lier
{
    uint32_t U;
    struct _hw_lcdc_lier_bitfields
    {
        uint32_t BOF_EN : 1; //!< [0] Beginning of frame interrupt enable
        uint32_t EOF_EN : 1; //!< [1] End of frame interrupt enable
        uint32_t RESERVED0 : 1; //!< [2] 
        uint32_t UDR_ERR_EN : 1; //!< [3] Under run error interrupt enable
        uint32_t GW_BOF_EN : 1; //!< [4] Graphic window beginning of frame interrupt enable
        uint32_t GW_EOF_EN : 1; //!< [5] Graphic window end of frame interrupt enable
        uint32_t RESERVED1 : 1; //!< [6] 
        uint32_t GW_UDR_ERR_EN : 1; //!< [7] Graphic window under run error interrupt enable
        uint32_t RESERVED2 : 24; //!< [31:8] 
    } B;
} hw_lcdc_lier_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LIER register
 */
//@{
#define HW_LCDC_LIER_ADDR      (REGS_LCDC_BASE + 0x3cU)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LIER           (*(__IO hw_lcdc_lier_t *) HW_LCDC_LIER_ADDR)
#define HW_LCDC_LIER_RD()      (HW_LCDC_LIER.U)
#define HW_LCDC_LIER_WR(v)     (HW_LCDC_LIER.U = (v))
#define HW_LCDC_LIER_SET(v)    (HW_LCDC_LIER_WR(HW_LCDC_LIER_RD() |  (v)))
#define HW_LCDC_LIER_CLR(v)    (HW_LCDC_LIER_WR(HW_LCDC_LIER_RD() & ~(v)))
#define HW_LCDC_LIER_TOG(v)    (HW_LCDC_LIER_WR(HW_LCDC_LIER_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LIER bitfields
 */

/*! @name Register LCDC_LIER, field BOF_EN[0] (RW)
 *
 * Enables or masks the background plane beginning of frame interrupt. LICR[INTCON] must be 1 to use
 * the BOF interrupt.
 *
 * Values:
 * - 0 - Mask interrupt.
 * - 1 - Enable interrupt.
 */
//@{
#define BP_LCDC_LIER_BOF_EN      (0U)      //!< Bit position for LCDC_LIER_BOF_EN.
#define BM_LCDC_LIER_BOF_EN      (0x00000001U)  //!< Bit mask for LCDC_LIER_BOF_EN.
#define BS_LCDC_LIER_BOF_EN      (1U)  //!< Bitfield size in bits for LCDC_LIER_BOF_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LIER_BOF_EN field.
#define BR_LCDC_LIER_BOF_EN()   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_BOF_EN))
#endif

//! @brief Format value for bitfield LCDC_LIER_BOF_EN.
#define BF_LCDC_LIER_BOF_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LIER_BOF_EN), uint32_t) & BM_LCDC_LIER_BOF_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BOF_EN field to a new value.
#define BW_LCDC_LIER_BOF_EN(v)   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_BOF_EN) = (v))
#endif
//@}

/*! @name Register LCDC_LIER, field EOF_EN[1] (RW)
 *
 * Enables or masks the background plane end of frame interrupt. LICR[INTCON] must be 0 to use the
 * EOF interrupt.
 *
 * Values:
 * - 0 - Mask interrupt.
 * - 1 - Enable interrupt.
 */
//@{
#define BP_LCDC_LIER_EOF_EN      (1U)      //!< Bit position for LCDC_LIER_EOF_EN.
#define BM_LCDC_LIER_EOF_EN      (0x00000002U)  //!< Bit mask for LCDC_LIER_EOF_EN.
#define BS_LCDC_LIER_EOF_EN      (1U)  //!< Bitfield size in bits for LCDC_LIER_EOF_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LIER_EOF_EN field.
#define BR_LCDC_LIER_EOF_EN()   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_EOF_EN))
#endif

//! @brief Format value for bitfield LCDC_LIER_EOF_EN.
#define BF_LCDC_LIER_EOF_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LIER_EOF_EN), uint32_t) & BM_LCDC_LIER_EOF_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EOF_EN field to a new value.
#define BW_LCDC_LIER_EOF_EN(v)   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_EOF_EN) = (v))
#endif
//@}

/*! @name Register LCDC_LIER, field UDR_ERR_EN[3] (RW)
 *
 * Enables or masks the background plane under-run error interrupt.
 *
 * Values:
 * - 0 - Mask interrupt.
 * - 1 - Enable interrupt.
 */
//@{
#define BP_LCDC_LIER_UDR_ERR_EN      (3U)      //!< Bit position for LCDC_LIER_UDR_ERR_EN.
#define BM_LCDC_LIER_UDR_ERR_EN      (0x00000008U)  //!< Bit mask for LCDC_LIER_UDR_ERR_EN.
#define BS_LCDC_LIER_UDR_ERR_EN      (1U)  //!< Bitfield size in bits for LCDC_LIER_UDR_ERR_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LIER_UDR_ERR_EN field.
#define BR_LCDC_LIER_UDR_ERR_EN()   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_UDR_ERR_EN))
#endif

//! @brief Format value for bitfield LCDC_LIER_UDR_ERR_EN.
#define BF_LCDC_LIER_UDR_ERR_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LIER_UDR_ERR_EN), uint32_t) & BM_LCDC_LIER_UDR_ERR_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UDR_ERR_EN field to a new value.
#define BW_LCDC_LIER_UDR_ERR_EN(v)   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_UDR_ERR_EN) = (v))
#endif
//@}

/*! @name Register LCDC_LIER, field GW_BOF_EN[4] (RW)
 *
 * Enables or masks the graphic window beginning of frame interrupt. LICR[GW_INT_CON] must be 1 to
 * use the Graphic Window BOF interrupt.
 *
 * Values:
 * - 0 - Mask interrupt.
 * - 1 - Enable interrupt.
 */
//@{
#define BP_LCDC_LIER_GW_BOF_EN      (4U)      //!< Bit position for LCDC_LIER_GW_BOF_EN.
#define BM_LCDC_LIER_GW_BOF_EN      (0x00000010U)  //!< Bit mask for LCDC_LIER_GW_BOF_EN.
#define BS_LCDC_LIER_GW_BOF_EN      (1U)  //!< Bitfield size in bits for LCDC_LIER_GW_BOF_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LIER_GW_BOF_EN field.
#define BR_LCDC_LIER_GW_BOF_EN()   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_GW_BOF_EN))
#endif

//! @brief Format value for bitfield LCDC_LIER_GW_BOF_EN.
#define BF_LCDC_LIER_GW_BOF_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LIER_GW_BOF_EN), uint32_t) & BM_LCDC_LIER_GW_BOF_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GW_BOF_EN field to a new value.
#define BW_LCDC_LIER_GW_BOF_EN(v)   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_GW_BOF_EN) = (v))
#endif
//@}

/*! @name Register LCDC_LIER, field GW_EOF_EN[5] (RW)
 *
 * Enables or masks the graphic window end of frame interrupt. LICR[GW_INT_CON] must be 0 to use the
 * Graphic Window EOF interrupt.
 *
 * Values:
 * - 0 - Mask interrupt.
 * - 1 - Enable interrupt.
 */
//@{
#define BP_LCDC_LIER_GW_EOF_EN      (5U)      //!< Bit position for LCDC_LIER_GW_EOF_EN.
#define BM_LCDC_LIER_GW_EOF_EN      (0x00000020U)  //!< Bit mask for LCDC_LIER_GW_EOF_EN.
#define BS_LCDC_LIER_GW_EOF_EN      (1U)  //!< Bitfield size in bits for LCDC_LIER_GW_EOF_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LIER_GW_EOF_EN field.
#define BR_LCDC_LIER_GW_EOF_EN()   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_GW_EOF_EN))
#endif

//! @brief Format value for bitfield LCDC_LIER_GW_EOF_EN.
#define BF_LCDC_LIER_GW_EOF_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LIER_GW_EOF_EN), uint32_t) & BM_LCDC_LIER_GW_EOF_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GW_EOF_EN field to a new value.
#define BW_LCDC_LIER_GW_EOF_EN(v)   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_GW_EOF_EN) = (v))
#endif
//@}

/*! @name Register LCDC_LIER, field GW_UDR_ERR_EN[7] (RW)
 *
 * Enables or masks the graphic window under-run error interrupt.
 *
 * Values:
 * - 0 - Mask interrupt.
 * - 1 - Enable interrupt.
 */
//@{
#define BP_LCDC_LIER_GW_UDR_ERR_EN      (7U)      //!< Bit position for LCDC_LIER_GW_UDR_ERR_EN.
#define BM_LCDC_LIER_GW_UDR_ERR_EN      (0x00000080U)  //!< Bit mask for LCDC_LIER_GW_UDR_ERR_EN.
#define BS_LCDC_LIER_GW_UDR_ERR_EN      (1U)  //!< Bitfield size in bits for LCDC_LIER_GW_UDR_ERR_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LIER_GW_UDR_ERR_EN field.
#define BR_LCDC_LIER_GW_UDR_ERR_EN()   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_GW_UDR_ERR_EN))
#endif

//! @brief Format value for bitfield LCDC_LIER_GW_UDR_ERR_EN.
#define BF_LCDC_LIER_GW_UDR_ERR_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LIER_GW_UDR_ERR_EN), uint32_t) & BM_LCDC_LIER_GW_UDR_ERR_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GW_UDR_ERR_EN field to a new value.
#define BW_LCDC_LIER_GW_UDR_ERR_EN(v)   (BITBAND_ACCESS32(HW_LCDC_LIER_ADDR, BP_LCDC_LIER_GW_UDR_ERR_EN) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LISR - LCDC interrupt status register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LISR - LCDC interrupt status register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates whether an interrupt condition has occurred or not. The status bit is set
 * whenever the interrupt condition is met. If any bit in this register is set and the corresponding
 * bit in LIER is set, LCDC interrupt pin is asserted to the interrupt controller. The status bit is
 * cleared by reading the register.
 */
typedef union _hw_lcdc_lisr
{
    uint32_t U;
    struct _hw_lcdc_lisr_bitfields
    {
        uint32_t BOF : 1; //!< [0] Beginning of frame
        uint32_t EOF_ : 1; //!< [1] End of frame
        uint32_t RESERVED0 : 1; //!< [2] 
        uint32_t UDR_ERR : 1; //!< [3] Under run error
        uint32_t GW_BOF : 1; //!< [4] Graphic window beginning of frame
        uint32_t GW_EOF : 1; //!< [5] Graphic window end of frame
        uint32_t RESERVED1 : 1; //!< [6] 
        uint32_t GW_UDR_ERR : 1; //!< [7] Graphic window under run error
        uint32_t RESERVED2 : 24; //!< [31:8] 
    } B;
} hw_lcdc_lisr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LISR register
 */
//@{
#define HW_LCDC_LISR_ADDR      (REGS_LCDC_BASE + 0x40U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LISR           (*(__I hw_lcdc_lisr_t *) HW_LCDC_LISR_ADDR)
#define HW_LCDC_LISR_RD()      (HW_LCDC_LISR.U)
#endif
//@}

/*
 * constants & macros for individual LCDC_LISR bitfields
 */

/*! @name Register LCDC_LISR, field BOF[0] (RO)
 *
 * Indicates whether the beginning of frame has reached. It is cleared by reading the status
 * register, at power on reset, or when the LCDC is disabled.
 *
 * Values:
 * - 0 - Interrupt has not occurred.
 * - 1 - Interrupt has occurred.
 */
//@{
#define BP_LCDC_LISR_BOF      (0U)      //!< Bit position for LCDC_LISR_BOF.
#define BM_LCDC_LISR_BOF      (0x00000001U)  //!< Bit mask for LCDC_LISR_BOF.
#define BS_LCDC_LISR_BOF      (1U)  //!< Bitfield size in bits for LCDC_LISR_BOF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LISR_BOF field.
#define BR_LCDC_LISR_BOF()   (BITBAND_ACCESS32(HW_LCDC_LISR_ADDR, BP_LCDC_LISR_BOF))
#endif
//@}

/*! @name Register LCDC_LISR, field EOF_[1] (RO)
 *
 * Indicates whether the end of frame has reached. It is cleared by reading the status register, at
 * power on reset, or when the LCDC is disabled.
 *
 * Values:
 * - 0 - Interrupt has not occurred.
 * - 1 - Interrupt has occurred.
 */
//@{
#define BP_LCDC_LISR_EOF_      (1U)      //!< Bit position for LCDC_LISR_EOF_.
#define BM_LCDC_LISR_EOF_      (0x00000002U)  //!< Bit mask for LCDC_LISR_EOF_.
#define BS_LCDC_LISR_EOF_      (1U)  //!< Bitfield size in bits for LCDC_LISR_EOF_.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LISR_EOF_ field.
#define BR_LCDC_LISR_EOF_()   (BITBAND_ACCESS32(HW_LCDC_LISR_ADDR, BP_LCDC_LISR_EOF_))
#endif
//@}

/*! @name Register LCDC_LISR, field UDR_ERR[3] (RO)
 *
 * Indicates whether the LCDC FIFO has hit an under-run condition. This is when the data output rate
 * is faster than the data input rate to the FIFO. Under-run can cause erroneous data output to LD.
 * LD data output rate must be adjusted to prevent this error.
 *
 * Values:
 * - 0 - Interrupt has not occurred.
 * - 1 - Interrupt has occurred.
 */
//@{
#define BP_LCDC_LISR_UDR_ERR      (3U)      //!< Bit position for LCDC_LISR_UDR_ERR.
#define BM_LCDC_LISR_UDR_ERR      (0x00000008U)  //!< Bit mask for LCDC_LISR_UDR_ERR.
#define BS_LCDC_LISR_UDR_ERR      (1U)  //!< Bitfield size in bits for LCDC_LISR_UDR_ERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LISR_UDR_ERR field.
#define BR_LCDC_LISR_UDR_ERR()   (BITBAND_ACCESS32(HW_LCDC_LISR_ADDR, BP_LCDC_LISR_UDR_ERR))
#endif
//@}

/*! @name Register LCDC_LISR, field GW_BOF[4] (RO)
 *
 * Indicates whether the beginning of graphic window has reached. It is cleared by reading the
 * status register, at power on reset, or when the LCDC is disabled.
 *
 * Values:
 * - 0 - Interrupt has not occurred.
 * - 1 - Interrupt has occurred.
 */
//@{
#define BP_LCDC_LISR_GW_BOF      (4U)      //!< Bit position for LCDC_LISR_GW_BOF.
#define BM_LCDC_LISR_GW_BOF      (0x00000010U)  //!< Bit mask for LCDC_LISR_GW_BOF.
#define BS_LCDC_LISR_GW_BOF      (1U)  //!< Bitfield size in bits for LCDC_LISR_GW_BOF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LISR_GW_BOF field.
#define BR_LCDC_LISR_GW_BOF()   (BITBAND_ACCESS32(HW_LCDC_LISR_ADDR, BP_LCDC_LISR_GW_BOF))
#endif
//@}

/*! @name Register LCDC_LISR, field GW_EOF[5] (RO)
 *
 * Indicates whether the end of graphic window has reached. It is cleared by reading the status
 * register, at power on reset, or when the LCDC is disabled.
 *
 * Values:
 * - 0 - Interrupt has not occurred.
 * - 1 - Interrupt has occurred.
 */
//@{
#define BP_LCDC_LISR_GW_EOF      (5U)      //!< Bit position for LCDC_LISR_GW_EOF.
#define BM_LCDC_LISR_GW_EOF      (0x00000020U)  //!< Bit mask for LCDC_LISR_GW_EOF.
#define BS_LCDC_LISR_GW_EOF      (1U)  //!< Bitfield size in bits for LCDC_LISR_GW_EOF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LISR_GW_EOF field.
#define BR_LCDC_LISR_GW_EOF()   (BITBAND_ACCESS32(HW_LCDC_LISR_ADDR, BP_LCDC_LISR_GW_EOF))
#endif
//@}

/*! @name Register LCDC_LISR, field GW_UDR_ERR[7] (RO)
 *
 * Indicates whether the LCDC FIFO in graphic window plan has hit an under-run condition. This is
 * when the data output rate is faster than the data input rate to the FIFO of the graphic window
 * plan. Under-run can cause erroneous data output to LD. LD data output rate must be adjusted to
 * prevent this error.
 *
 * Values:
 * - 0 - Graphic window under run has not occurred.
 * - 1 - Graphic window under run has occurred.
 */
//@{
#define BP_LCDC_LISR_GW_UDR_ERR      (7U)      //!< Bit position for LCDC_LISR_GW_UDR_ERR.
#define BM_LCDC_LISR_GW_UDR_ERR      (0x00000080U)  //!< Bit mask for LCDC_LISR_GW_UDR_ERR.
#define BS_LCDC_LISR_GW_UDR_ERR      (1U)  //!< Bitfield size in bits for LCDC_LISR_GW_UDR_ERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LISR_GW_UDR_ERR field.
#define BR_LCDC_LISR_GW_UDR_ERR()   (BITBAND_ACCESS32(HW_LCDC_LISR_ADDR, BP_LCDC_LISR_GW_UDR_ERR))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LGWSAR - LCDC graphic window start address register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LGWSAR - LCDC graphic window start address register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the starting address of the graphic window image. Refer to Graphic Window
 * on Screen for more details.
 */
typedef union _hw_lcdc_lgwsar
{
    uint32_t U;
    struct _hw_lcdc_lgwsar_bitfields
    {
        uint32_t RESERVED0 : 2; //!< [1:0] 
        uint32_t GWSA : 30; //!< [31:2] Graphic window start address on LCD screen
    } B;
} hw_lcdc_lgwsar_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LGWSAR register
 */
//@{
#define HW_LCDC_LGWSAR_ADDR      (REGS_LCDC_BASE + 0x50U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LGWSAR           (*(__IO hw_lcdc_lgwsar_t *) HW_LCDC_LGWSAR_ADDR)
#define HW_LCDC_LGWSAR_RD()      (HW_LCDC_LGWSAR.U)
#define HW_LCDC_LGWSAR_WR(v)     (HW_LCDC_LGWSAR.U = (v))
#define HW_LCDC_LGWSAR_SET(v)    (HW_LCDC_LGWSAR_WR(HW_LCDC_LGWSAR_RD() |  (v)))
#define HW_LCDC_LGWSAR_CLR(v)    (HW_LCDC_LGWSAR_WR(HW_LCDC_LGWSAR_RD() & ~(v)))
#define HW_LCDC_LGWSAR_TOG(v)    (HW_LCDC_LGWSAR_WR(HW_LCDC_LGWSAR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LGWSAR bitfields
 */

/*! @name Register LCDC_LGWSAR, field GWSA[31:2] (RW)
 *
 * Holds the starting address of the graphic window picture. This field must start at a location
 * that enables a complete graphic window picture to be stored in a 4Mbyte memory boundary
 * (A[21:0]). A[31:22] has a fixed value for the graphic window picture’s image.
 */
//@{
#define BP_LCDC_LGWSAR_GWSA      (2U)      //!< Bit position for LCDC_LGWSAR_GWSA.
#define BM_LCDC_LGWSAR_GWSA      (0xfffffffcU)  //!< Bit mask for LCDC_LGWSAR_GWSA.
#define BS_LCDC_LGWSAR_GWSA      (30U)  //!< Bitfield size in bits for LCDC_LGWSAR_GWSA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWSAR_GWSA field.
#define BR_LCDC_LGWSAR_GWSA()   (HW_LCDC_LGWSAR.B.GWSA)
#endif

//! @brief Format value for bitfield LCDC_LGWSAR_GWSA.
#define BF_LCDC_LGWSAR_GWSA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWSAR_GWSA), uint32_t) & BM_LCDC_LGWSAR_GWSA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWSA field to a new value.
#define BW_LCDC_LGWSAR_GWSA(v)   (HW_LCDC_LGWSAR_WR((HW_LCDC_LGWSAR_RD() & ~BM_LCDC_LGWSAR_GWSA) | BF_LCDC_LGWSAR_GWSA(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LGWSR - LCDC graphic window size register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LGWSR - LCDC graphic window size register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the height and width of the graphic window on the LCD screen.
 */
typedef union _hw_lcdc_lgwsr
{
    uint32_t U;
    struct _hw_lcdc_lgwsr_bitfields
    {
        uint32_t GWH : 10; //!< [9:0] Graphic window height
        uint32_t RESERVED0 : 10; //!< [19:10] 
        uint32_t GWW : 7; //!< [26:20] Graphic window width divided by 16
        uint32_t RESERVED1 : 5; //!< [31:27] 
    } B;
} hw_lcdc_lgwsr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LGWSR register
 */
//@{
#define HW_LCDC_LGWSR_ADDR      (REGS_LCDC_BASE + 0x54U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LGWSR           (*(__IO hw_lcdc_lgwsr_t *) HW_LCDC_LGWSR_ADDR)
#define HW_LCDC_LGWSR_RD()      (HW_LCDC_LGWSR.U)
#define HW_LCDC_LGWSR_WR(v)     (HW_LCDC_LGWSR.U = (v))
#define HW_LCDC_LGWSR_SET(v)    (HW_LCDC_LGWSR_WR(HW_LCDC_LGWSR_RD() |  (v)))
#define HW_LCDC_LGWSR_CLR(v)    (HW_LCDC_LGWSR_WR(HW_LCDC_LGWSR_RD() & ~(v)))
#define HW_LCDC_LGWSR_TOG(v)    (HW_LCDC_LGWSR_WR(HW_LCDC_LGWSR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LGWSR bitfields
 */

/*! @name Register LCDC_LGWSR, field GWH[9:0] (RW)
 *
 * Specifies height of the graphic window in terms of pixels or lines. The lines are numbered from 1
 * to GW_YMAX for a total of GW_YMAX lines. Graphic window size cannot be set to 0.
 */
//@{
#define BP_LCDC_LGWSR_GWH      (0U)      //!< Bit position for LCDC_LGWSR_GWH.
#define BM_LCDC_LGWSR_GWH      (0x000003ffU)  //!< Bit mask for LCDC_LGWSR_GWH.
#define BS_LCDC_LGWSR_GWH      (10U)  //!< Bitfield size in bits for LCDC_LGWSR_GWH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWSR_GWH field.
#define BR_LCDC_LGWSR_GWH()   (HW_LCDC_LGWSR.B.GWH)
#endif

//! @brief Format value for bitfield LCDC_LGWSR_GWH.
#define BF_LCDC_LGWSR_GWH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWSR_GWH), uint32_t) & BM_LCDC_LGWSR_GWH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWH field to a new value.
#define BW_LCDC_LGWSR_GWH(v)   (HW_LCDC_LGWSR_WR((HW_LCDC_LGWSR_RD() & ~BM_LCDC_LGWSR_GWH) | BF_LCDC_LGWSR_GWH(v)))
#endif
//@}

/*! @name Register LCDC_LGWSR, field GWW[26:20] (RW)
 *
 * Holds graphic window x-axis size divided by 16. For black-and-white panels (1 bpp), GW_XMAX [20]
 * is ignored, forcing the x-axis of the screen size to be a multiple of 32 pixels/line. Graphic
 * window size cannot be set to 0.
 */
//@{
#define BP_LCDC_LGWSR_GWW      (20U)      //!< Bit position for LCDC_LGWSR_GWW.
#define BM_LCDC_LGWSR_GWW      (0x07f00000U)  //!< Bit mask for LCDC_LGWSR_GWW.
#define BS_LCDC_LGWSR_GWW      (7U)  //!< Bitfield size in bits for LCDC_LGWSR_GWW.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWSR_GWW field.
#define BR_LCDC_LGWSR_GWW()   (HW_LCDC_LGWSR.B.GWW)
#endif

//! @brief Format value for bitfield LCDC_LGWSR_GWW.
#define BF_LCDC_LGWSR_GWW(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWSR_GWW), uint32_t) & BM_LCDC_LGWSR_GWW)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWW field to a new value.
#define BW_LCDC_LGWSR_GWW(v)   (HW_LCDC_LGWSR_WR((HW_LCDC_LGWSR_RD() & ~BM_LCDC_LGWSR_GWW) | BF_LCDC_LGWSR_GWW(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LGWVPWR - LCDC graphic window virtual page width register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LGWVPWR - LCDC graphic window virtual page width register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the virtual page width for the graphic window picture on the LCD screen.
 * Refer to Graphic Window on Screen for more details.
 */
typedef union _hw_lcdc_lgwvpwr
{
    uint32_t U;
    struct _hw_lcdc_lgwvpwr_bitfields
    {
        uint32_t GWVPW : 11; //!< [10:0] Graphic window virtual page width
        uint32_t RESERVED0 : 21; //!< [31:11] 
    } B;
} hw_lcdc_lgwvpwr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LGWVPWR register
 */
//@{
#define HW_LCDC_LGWVPWR_ADDR      (REGS_LCDC_BASE + 0x58U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LGWVPWR           (*(__IO hw_lcdc_lgwvpwr_t *) HW_LCDC_LGWVPWR_ADDR)
#define HW_LCDC_LGWVPWR_RD()      (HW_LCDC_LGWVPWR.U)
#define HW_LCDC_LGWVPWR_WR(v)     (HW_LCDC_LGWVPWR.U = (v))
#define HW_LCDC_LGWVPWR_SET(v)    (HW_LCDC_LGWVPWR_WR(HW_LCDC_LGWVPWR_RD() |  (v)))
#define HW_LCDC_LGWVPWR_CLR(v)    (HW_LCDC_LGWVPWR_WR(HW_LCDC_LGWVPWR_RD() & ~(v)))
#define HW_LCDC_LGWVPWR_TOG(v)    (HW_LCDC_LGWVPWR_WR(HW_LCDC_LGWVPWR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LGWVPWR bitfields
 */

/*! @name Register LCDC_LGWVPWR, field GWVPW[10:0] (RW)
 *
 * Defines the virtual page width of the graphic window picture. VPW bits represent the number of
 * 32-bit words required to hold the data for one virtual line. GWVPW is used in calculating the
 * starting address representing the beginning of each line of the graphic window picture.
 */
//@{
#define BP_LCDC_LGWVPWR_GWVPW      (0U)      //!< Bit position for LCDC_LGWVPWR_GWVPW.
#define BM_LCDC_LGWVPWR_GWVPW      (0x000007ffU)  //!< Bit mask for LCDC_LGWVPWR_GWVPW.
#define BS_LCDC_LGWVPWR_GWVPW      (11U)  //!< Bitfield size in bits for LCDC_LGWVPWR_GWVPW.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWVPWR_GWVPW field.
#define BR_LCDC_LGWVPWR_GWVPW()   (HW_LCDC_LGWVPWR.B.GWVPW)
#endif

//! @brief Format value for bitfield LCDC_LGWVPWR_GWVPW.
#define BF_LCDC_LGWVPWR_GWVPW(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWVPWR_GWVPW), uint32_t) & BM_LCDC_LGWVPWR_GWVPW)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWVPW field to a new value.
#define BW_LCDC_LGWVPWR_GWVPW(v)   (HW_LCDC_LGWVPWR_WR((HW_LCDC_LGWVPWR_RD() & ~BM_LCDC_LGWVPWR_GWVPW) | BF_LCDC_LGWVPWR_GWVPW(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LGWPOR - LCDC graphic window panning offset register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LGWPOR - LCDC graphic window panning offset register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register sets up panning for the graphic window.
 */
typedef union _hw_lcdc_lgwpor
{
    uint32_t U;
    struct _hw_lcdc_lgwpor_bitfields
    {
        uint32_t GWPO : 5; //!< [4:0] Graphic window panning offset
        uint32_t RESERVED0 : 27; //!< [31:5] 
    } B;
} hw_lcdc_lgwpor_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LGWPOR register
 */
//@{
#define HW_LCDC_LGWPOR_ADDR      (REGS_LCDC_BASE + 0x5cU)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LGWPOR           (*(__IO hw_lcdc_lgwpor_t *) HW_LCDC_LGWPOR_ADDR)
#define HW_LCDC_LGWPOR_RD()      (HW_LCDC_LGWPOR.U)
#define HW_LCDC_LGWPOR_WR(v)     (HW_LCDC_LGWPOR.U = (v))
#define HW_LCDC_LGWPOR_SET(v)    (HW_LCDC_LGWPOR_WR(HW_LCDC_LGWPOR_RD() |  (v)))
#define HW_LCDC_LGWPOR_CLR(v)    (HW_LCDC_LGWPOR_WR(HW_LCDC_LGWPOR_RD() & ~(v)))
#define HW_LCDC_LGWPOR_TOG(v)    (HW_LCDC_LGWPOR_WR(HW_LCDC_LGWPOR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LGWPOR bitfields
 */

/*! @name Register LCDC_LGWPOR, field GWPO[4:0] (RW)
 *
 * Defines the number of bits that the graphic window data from memory is panned to the left before
 * processing. GWPO is read by the LCDC once at the beginning of each frame. For example, in 4 bpp
 * mode, setting GWPO = 4 shifts 16 bits which means panning the image by 4 pixels left. Shifting
 * data more than 32 bits in graphic window should use LGWSAR register setting. 18 and 24 bpp
 * graphic window panning should use LGWSAR register setting. To achieve panning of the final image
 * by N bits: Bits per pixel GWPO Effective number of pixels panned 1 N N 2 2N N 4 4N N 8 8N N 12/16
 * 16N N
 */
//@{
#define BP_LCDC_LGWPOR_GWPO      (0U)      //!< Bit position for LCDC_LGWPOR_GWPO.
#define BM_LCDC_LGWPOR_GWPO      (0x0000001fU)  //!< Bit mask for LCDC_LGWPOR_GWPO.
#define BS_LCDC_LGWPOR_GWPO      (5U)  //!< Bitfield size in bits for LCDC_LGWPOR_GWPO.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWPOR_GWPO field.
#define BR_LCDC_LGWPOR_GWPO()   (HW_LCDC_LGWPOR.B.GWPO)
#endif

//! @brief Format value for bitfield LCDC_LGWPOR_GWPO.
#define BF_LCDC_LGWPOR_GWPO(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWPOR_GWPO), uint32_t) & BM_LCDC_LGWPOR_GWPO)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWPO field to a new value.
#define BW_LCDC_LGWPOR_GWPO(v)   (HW_LCDC_LGWPOR_WR((HW_LCDC_LGWPOR_RD() & ~BM_LCDC_LGWPOR_GWPO) | BF_LCDC_LGWPOR_GWPO(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LGWPR - LCDC graphic window position register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LGWPR - LCDC graphic window position register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register determines the starting position of the graphic window on the LCD panel. If any
 * part of the graphic window is not displayed on the screen, then the entire graphic window will
 * disappear. Take caution when changing the LGWPR and LGWSR registers.
 */
typedef union _hw_lcdc_lgwpr
{
    uint32_t U;
    struct _hw_lcdc_lgwpr_bitfields
    {
        uint32_t GWYP : 10; //!< [9:0] Graphic window Y position
        uint32_t RESERVED0 : 6; //!< [15:10] 
        uint32_t GWXP : 10; //!< [25:16] Graphic window X position
        uint32_t RESERVED1 : 6; //!< [31:26] 
    } B;
} hw_lcdc_lgwpr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LGWPR register
 */
//@{
#define HW_LCDC_LGWPR_ADDR      (REGS_LCDC_BASE + 0x60U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LGWPR           (*(__IO hw_lcdc_lgwpr_t *) HW_LCDC_LGWPR_ADDR)
#define HW_LCDC_LGWPR_RD()      (HW_LCDC_LGWPR.U)
#define HW_LCDC_LGWPR_WR(v)     (HW_LCDC_LGWPR.U = (v))
#define HW_LCDC_LGWPR_SET(v)    (HW_LCDC_LGWPR_WR(HW_LCDC_LGWPR_RD() |  (v)))
#define HW_LCDC_LGWPR_CLR(v)    (HW_LCDC_LGWPR_WR(HW_LCDC_LGWPR_RD() & ~(v)))
#define HW_LCDC_LGWPR_TOG(v)    (HW_LCDC_LGWPR_WR(HW_LCDC_LGWPR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LGWPR bitfields
 */

/*! @name Register LCDC_LGWPR, field GWYP[9:0] (RW)
 *
 * Represents the graphic window’s vertical starting position in line (from 0 to YMAX).
 */
//@{
#define BP_LCDC_LGWPR_GWYP      (0U)      //!< Bit position for LCDC_LGWPR_GWYP.
#define BM_LCDC_LGWPR_GWYP      (0x000003ffU)  //!< Bit mask for LCDC_LGWPR_GWYP.
#define BS_LCDC_LGWPR_GWYP      (10U)  //!< Bitfield size in bits for LCDC_LGWPR_GWYP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWPR_GWYP field.
#define BR_LCDC_LGWPR_GWYP()   (HW_LCDC_LGWPR.B.GWYP)
#endif

//! @brief Format value for bitfield LCDC_LGWPR_GWYP.
#define BF_LCDC_LGWPR_GWYP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWPR_GWYP), uint32_t) & BM_LCDC_LGWPR_GWYP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWYP field to a new value.
#define BW_LCDC_LGWPR_GWYP(v)   (HW_LCDC_LGWPR_WR((HW_LCDC_LGWPR_RD() & ~BM_LCDC_LGWPR_GWYP) | BF_LCDC_LGWPR_GWYP(v)))
#endif
//@}

/*! @name Register LCDC_LGWPR, field GWXP[25:16] (RW)
 *
 * Represents the graphic window’s horizontal starting position in pixel count (from 0 to XMAX).
 */
//@{
#define BP_LCDC_LGWPR_GWXP      (16U)      //!< Bit position for LCDC_LGWPR_GWXP.
#define BM_LCDC_LGWPR_GWXP      (0x03ff0000U)  //!< Bit mask for LCDC_LGWPR_GWXP.
#define BS_LCDC_LGWPR_GWXP      (10U)  //!< Bitfield size in bits for LCDC_LGWPR_GWXP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWPR_GWXP field.
#define BR_LCDC_LGWPR_GWXP()   (HW_LCDC_LGWPR.B.GWXP)
#endif

//! @brief Format value for bitfield LCDC_LGWPR_GWXP.
#define BF_LCDC_LGWPR_GWXP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWPR_GWXP), uint32_t) & BM_LCDC_LGWPR_GWXP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWXP field to a new value.
#define BW_LCDC_LGWPR_GWXP(v)   (HW_LCDC_LGWPR_WR((HW_LCDC_LGWPR_RD() & ~BM_LCDC_LGWPR_GWXP) | BF_LCDC_LGWPR_GWXP(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LGWCR - LCDC graphic window control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LGWCR - LCDC graphic window control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the behaviors of graphic window. In AUS mode, use LAUSCR for color keying
 * values. If using 16 or 12 bpp, it will use the least significant bits for comparison. If using 8
 * or 4 bpp, it uses the 18 bpp data from the GWLUT.
 */
typedef union _hw_lcdc_lgwcr
{
    uint32_t U;
    struct _hw_lcdc_lgwcr_bitfields
    {
        uint32_t GWCKB : 6; //!< [5:0] Graphic window color keying blue component
        uint32_t GWCKG : 6; //!< [11:6] Graphic window color keying green component
        uint32_t GWCKR : 6; //!< [17:12] Graphic window color keying red component
        uint32_t RESERVED0 : 3; //!< [20:18] 
        uint32_t GW_RVS : 1; //!< [21] Graphic window reverse vertical scan
        uint32_t GWE : 1; //!< [22] Graphic window enable
        uint32_t GWCKE : 1; //!< [23] Graphic window color keying enable
        uint32_t GWAV : 8; //!< [31:24] Graphic window alpha value
    } B;
} hw_lcdc_lgwcr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LGWCR register
 */
//@{
#define HW_LCDC_LGWCR_ADDR      (REGS_LCDC_BASE + 0x64U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LGWCR           (*(__IO hw_lcdc_lgwcr_t *) HW_LCDC_LGWCR_ADDR)
#define HW_LCDC_LGWCR_RD()      (HW_LCDC_LGWCR.U)
#define HW_LCDC_LGWCR_WR(v)     (HW_LCDC_LGWCR.U = (v))
#define HW_LCDC_LGWCR_SET(v)    (HW_LCDC_LGWCR_WR(HW_LCDC_LGWCR_RD() |  (v)))
#define HW_LCDC_LGWCR_CLR(v)    (HW_LCDC_LGWCR_WR(HW_LCDC_LGWCR_RD() & ~(v)))
#define HW_LCDC_LGWCR_TOG(v)    (HW_LCDC_LGWCR_WR(HW_LCDC_LGWCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LGWCR bitfields
 */

/*! @name Register LCDC_LGWCR, field GWCKB[5:0] (RW)
 *
 * Values:
 * - 000000 - No blue
 * - ..... - 
 * - 111111 - Full blue
 */
//@{
#define BP_LCDC_LGWCR_GWCKB      (0U)      //!< Bit position for LCDC_LGWCR_GWCKB.
#define BM_LCDC_LGWCR_GWCKB      (0x0000003fU)  //!< Bit mask for LCDC_LGWCR_GWCKB.
#define BS_LCDC_LGWCR_GWCKB      (6U)  //!< Bitfield size in bits for LCDC_LGWCR_GWCKB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWCR_GWCKB field.
#define BR_LCDC_LGWCR_GWCKB()   (HW_LCDC_LGWCR.B.GWCKB)
#endif

//! @brief Format value for bitfield LCDC_LGWCR_GWCKB.
#define BF_LCDC_LGWCR_GWCKB(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWCR_GWCKB), uint32_t) & BM_LCDC_LGWCR_GWCKB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWCKB field to a new value.
#define BW_LCDC_LGWCR_GWCKB(v)   (HW_LCDC_LGWCR_WR((HW_LCDC_LGWCR_RD() & ~BM_LCDC_LGWCR_GWCKB) | BF_LCDC_LGWCR_GWCKB(v)))
#endif
//@}

/*! @name Register LCDC_LGWCR, field GWCKG[11:6] (RW)
 *
 * Values:
 * - 000000 - No green
 * - ..... - 
 * - 111111 - Full green
 */
//@{
#define BP_LCDC_LGWCR_GWCKG      (6U)      //!< Bit position for LCDC_LGWCR_GWCKG.
#define BM_LCDC_LGWCR_GWCKG      (0x00000fc0U)  //!< Bit mask for LCDC_LGWCR_GWCKG.
#define BS_LCDC_LGWCR_GWCKG      (6U)  //!< Bitfield size in bits for LCDC_LGWCR_GWCKG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWCR_GWCKG field.
#define BR_LCDC_LGWCR_GWCKG()   (HW_LCDC_LGWCR.B.GWCKG)
#endif

//! @brief Format value for bitfield LCDC_LGWCR_GWCKG.
#define BF_LCDC_LGWCR_GWCKG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWCR_GWCKG), uint32_t) & BM_LCDC_LGWCR_GWCKG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWCKG field to a new value.
#define BW_LCDC_LGWCR_GWCKG(v)   (HW_LCDC_LGWCR_WR((HW_LCDC_LGWCR_RD() & ~BM_LCDC_LGWCR_GWCKG) | BF_LCDC_LGWCR_GWCKG(v)))
#endif
//@}

/*! @name Register LCDC_LGWCR, field GWCKR[17:12] (RW)
 *
 * Values:
 * - 000000 - No red
 * - ..... - 
 * - 111111 - Full red
 */
//@{
#define BP_LCDC_LGWCR_GWCKR      (12U)      //!< Bit position for LCDC_LGWCR_GWCKR.
#define BM_LCDC_LGWCR_GWCKR      (0x0003f000U)  //!< Bit mask for LCDC_LGWCR_GWCKR.
#define BS_LCDC_LGWCR_GWCKR      (6U)  //!< Bitfield size in bits for LCDC_LGWCR_GWCKR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWCR_GWCKR field.
#define BR_LCDC_LGWCR_GWCKR()   (HW_LCDC_LGWCR.B.GWCKR)
#endif

//! @brief Format value for bitfield LCDC_LGWCR_GWCKR.
#define BF_LCDC_LGWCR_GWCKR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWCR_GWCKR), uint32_t) & BM_LCDC_LGWCR_GWCKR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWCKR field to a new value.
#define BW_LCDC_LGWCR_GWCKR(v)   (HW_LCDC_LGWCR_WR((HW_LCDC_LGWCR_RD() & ~BM_LCDC_LGWCR_GWCKR) | BF_LCDC_LGWCR_GWCKR(v)))
#endif
//@}

/*! @name Register LCDC_LGWCR, field GW_RVS[21] (RW)
 *
 * Selects the graphic window vertical scan direction as normal or reverse (graphic window image
 * flips along the x-axis). The LGWSAR register should be changed accordingly to point to the
 * beginning of the last line of horizontal graphic window data.
 *
 * Values:
 * - 0 - Vertical scan in normal direction.
 * - 1 - Vertical scan in reverse direction.
 */
//@{
#define BP_LCDC_LGWCR_GW_RVS      (21U)      //!< Bit position for LCDC_LGWCR_GW_RVS.
#define BM_LCDC_LGWCR_GW_RVS      (0x00200000U)  //!< Bit mask for LCDC_LGWCR_GW_RVS.
#define BS_LCDC_LGWCR_GW_RVS      (1U)  //!< Bitfield size in bits for LCDC_LGWCR_GW_RVS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWCR_GW_RVS field.
#define BR_LCDC_LGWCR_GW_RVS()   (BITBAND_ACCESS32(HW_LCDC_LGWCR_ADDR, BP_LCDC_LGWCR_GW_RVS))
#endif

//! @brief Format value for bitfield LCDC_LGWCR_GW_RVS.
#define BF_LCDC_LGWCR_GW_RVS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWCR_GW_RVS), uint32_t) & BM_LCDC_LGWCR_GW_RVS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GW_RVS field to a new value.
#define BW_LCDC_LGWCR_GW_RVS(v)   (BITBAND_ACCESS32(HW_LCDC_LGWCR_ADDR, BP_LCDC_LGWCR_GW_RVS) = (v))
#endif
//@}

/*! @name Register LCDC_LGWCR, field GWE[22] (RW)
 *
 * Enables/disables graphic window displayed on screen.
 *
 * Values:
 * - 0 - Disable graphic window on screen.
 * - 1 - Enable graphic window on screen.
 */
//@{
#define BP_LCDC_LGWCR_GWE      (22U)      //!< Bit position for LCDC_LGWCR_GWE.
#define BM_LCDC_LGWCR_GWE      (0x00400000U)  //!< Bit mask for LCDC_LGWCR_GWE.
#define BS_LCDC_LGWCR_GWE      (1U)  //!< Bitfield size in bits for LCDC_LGWCR_GWE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWCR_GWE field.
#define BR_LCDC_LGWCR_GWE()   (BITBAND_ACCESS32(HW_LCDC_LGWCR_ADDR, BP_LCDC_LGWCR_GWE))
#endif

//! @brief Format value for bitfield LCDC_LGWCR_GWE.
#define BF_LCDC_LGWCR_GWE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWCR_GWE), uint32_t) & BM_LCDC_LGWCR_GWE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWE field to a new value.
#define BW_LCDC_LGWCR_GWE(v)   (BITBAND_ACCESS32(HW_LCDC_LGWCR_ADDR, BP_LCDC_LGWCR_GWE) = (v))
#endif
//@}

/*! @name Register LCDC_LGWCR, field GWCKE[23] (RW)
 *
 * Enables/disables graphic window color keying.
 *
 * Values:
 * - 0 - Disable color keying of graphic window.
 * - 1 - Enable color keying of graphic window.
 */
//@{
#define BP_LCDC_LGWCR_GWCKE      (23U)      //!< Bit position for LCDC_LGWCR_GWCKE.
#define BM_LCDC_LGWCR_GWCKE      (0x00800000U)  //!< Bit mask for LCDC_LGWCR_GWCKE.
#define BS_LCDC_LGWCR_GWCKE      (1U)  //!< Bitfield size in bits for LCDC_LGWCR_GWCKE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWCR_GWCKE field.
#define BR_LCDC_LGWCR_GWCKE()   (BITBAND_ACCESS32(HW_LCDC_LGWCR_ADDR, BP_LCDC_LGWCR_GWCKE))
#endif

//! @brief Format value for bitfield LCDC_LGWCR_GWCKE.
#define BF_LCDC_LGWCR_GWCKE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWCR_GWCKE), uint32_t) & BM_LCDC_LGWCR_GWCKE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWCKE field to a new value.
#define BW_LCDC_LGWCR_GWCKE(v)   (BITBAND_ACCESS32(HW_LCDC_LGWCR_ADDR, BP_LCDC_LGWCR_GWCKE) = (v))
#endif
//@}

/*! @name Register LCDC_LGWCR, field GWAV[31:24] (RW)
 *
 * Defines the graphic window alpha value used for alpha blending between graphic window and
 * background plane.
 *
 * Values:
 * - 0 - Graphic window totally transparent (not displayed on LCD screen).
 * - 1 - Graphic window totally opaque (completely visible on LCD screen).
 */
//@{
#define BP_LCDC_LGWCR_GWAV      (24U)      //!< Bit position for LCDC_LGWCR_GWAV.
#define BM_LCDC_LGWCR_GWAV      (0xff000000U)  //!< Bit mask for LCDC_LGWCR_GWAV.
#define BS_LCDC_LGWCR_GWAV      (8U)  //!< Bitfield size in bits for LCDC_LGWCR_GWAV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWCR_GWAV field.
#define BR_LCDC_LGWCR_GWAV()   (HW_LCDC_LGWCR.B.GWAV)
#endif

//! @brief Format value for bitfield LCDC_LGWCR_GWAV.
#define BF_LCDC_LGWCR_GWAV(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWCR_GWAV), uint32_t) & BM_LCDC_LGWCR_GWAV)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWAV field to a new value.
#define BW_LCDC_LGWCR_GWAV(v)   (HW_LCDC_LGWCR_WR((HW_LCDC_LGWCR_RD() & ~BM_LCDC_LGWCR_GWAV) | BF_LCDC_LGWCR_GWAV(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LGWDCR - LCDC graphic window DMA control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LGWDCR - LCDC graphic window DMA control register (RW)
 *
 * Reset value: 0x80040060U
 *
 * There is a 128 x 32 bit line buffer in the LCDC that stores graphic window data from system
 * memory. LGWDCE controls the DMA burst length and when to trigger a DMA burst in terms of the
 * number of data bytes left in the pixel buffer.
 */
typedef union _hw_lcdc_lgwdcr
{
    uint32_t U;
    struct _hw_lcdc_lgwdcr_bitfields
    {
        uint32_t GWTM : 7; //!< [6:0] Graphic window DMA low mark
        uint32_t RESERVED0 : 9; //!< [15:7] 
        uint32_t GWHM : 7; //!< [22:16] Graphic window DMA high mark
        uint32_t RESERVED1 : 8; //!< [30:23] 
        uint32_t GWBT : 1; //!< [31] Graphic window DMA burst type
    } B;
} hw_lcdc_lgwdcr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LGWDCR register
 */
//@{
#define HW_LCDC_LGWDCR_ADDR      (REGS_LCDC_BASE + 0x68U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LGWDCR           (*(__IO hw_lcdc_lgwdcr_t *) HW_LCDC_LGWDCR_ADDR)
#define HW_LCDC_LGWDCR_RD()      (HW_LCDC_LGWDCR.U)
#define HW_LCDC_LGWDCR_WR(v)     (HW_LCDC_LGWDCR.U = (v))
#define HW_LCDC_LGWDCR_SET(v)    (HW_LCDC_LGWDCR_WR(HW_LCDC_LGWDCR_RD() |  (v)))
#define HW_LCDC_LGWDCR_CLR(v)    (HW_LCDC_LGWDCR_WR(HW_LCDC_LGWDCR_RD() & ~(v)))
#define HW_LCDC_LGWDCR_TOG(v)    (HW_LCDC_LGWDCR_WR(HW_LCDC_LGWDCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LGWDCR bitfields
 */

/*! @name Register LCDC_LGWDCR, field GWTM[6:0] (RW)
 *
 * Sets low level mark in the graphic window FIFO to trigger a DMA request. Low level mark equals
 * the number of words left in the pixel buffer.
 */
//@{
#define BP_LCDC_LGWDCR_GWTM      (0U)      //!< Bit position for LCDC_LGWDCR_GWTM.
#define BM_LCDC_LGWDCR_GWTM      (0x0000007fU)  //!< Bit mask for LCDC_LGWDCR_GWTM.
#define BS_LCDC_LGWDCR_GWTM      (7U)  //!< Bitfield size in bits for LCDC_LGWDCR_GWTM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWDCR_GWTM field.
#define BR_LCDC_LGWDCR_GWTM()   (HW_LCDC_LGWDCR.B.GWTM)
#endif

//! @brief Format value for bitfield LCDC_LGWDCR_GWTM.
#define BF_LCDC_LGWDCR_GWTM(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWDCR_GWTM), uint32_t) & BM_LCDC_LGWDCR_GWTM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWTM field to a new value.
#define BW_LCDC_LGWDCR_GWTM(v)   (HW_LCDC_LGWDCR_WR((HW_LCDC_LGWDCR_RD() & ~BM_LCDC_LGWDCR_GWTM) | BF_LCDC_LGWDCR_GWTM(v)))
#endif
//@}

/*! @name Register LCDC_LGWDCR, field GWHM[22:16] (RW)
 *
 * Establishes high mark for DMA requests. For dynamic burst length, once DMA request is made, data
 * is loaded and the graphic window FIFO continues to be filled until the number of empty words left
 * in the graphic window FIFO is equal to the high mark minus 2. Minimum GWHM setting in dynamic
 * burst is 3. For fixed burst length, burst length (in words) of each request is equal to the DMA
 * high mark setting and its value must be larger than GWTM.
 */
//@{
#define BP_LCDC_LGWDCR_GWHM      (16U)      //!< Bit position for LCDC_LGWDCR_GWHM.
#define BM_LCDC_LGWDCR_GWHM      (0x007f0000U)  //!< Bit mask for LCDC_LGWDCR_GWHM.
#define BS_LCDC_LGWDCR_GWHM      (7U)  //!< Bitfield size in bits for LCDC_LGWDCR_GWHM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWDCR_GWHM field.
#define BR_LCDC_LGWDCR_GWHM()   (HW_LCDC_LGWDCR.B.GWHM)
#endif

//! @brief Format value for bitfield LCDC_LGWDCR_GWHM.
#define BF_LCDC_LGWDCR_GWHM(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWDCR_GWHM), uint32_t) & BM_LCDC_LGWDCR_GWHM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWHM field to a new value.
#define BW_LCDC_LGWDCR_GWHM(v)   (HW_LCDC_LGWDCR_WR((HW_LCDC_LGWDCR_RD() & ~BM_LCDC_LGWDCR_GWHM) | BF_LCDC_LGWDCR_GWHM(v)))
#endif
//@}

/*! @name Register LCDC_LGWDCR, field GWBT[31] (RW)
 *
 * Determines whether burst length is fixed or dynamic in graphic window plane.
 *
 * Values:
 * - 0 - Burst length is dynamic.
 * - 1 - Burst length is fixed.
 */
//@{
#define BP_LCDC_LGWDCR_GWBT      (31U)      //!< Bit position for LCDC_LGWDCR_GWBT.
#define BM_LCDC_LGWDCR_GWBT      (0x80000000U)  //!< Bit mask for LCDC_LGWDCR_GWBT.
#define BS_LCDC_LGWDCR_GWBT      (1U)  //!< Bitfield size in bits for LCDC_LGWDCR_GWBT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LGWDCR_GWBT field.
#define BR_LCDC_LGWDCR_GWBT()   (BITBAND_ACCESS32(HW_LCDC_LGWDCR_ADDR, BP_LCDC_LGWDCR_GWBT))
#endif

//! @brief Format value for bitfield LCDC_LGWDCR_GWBT.
#define BF_LCDC_LGWDCR_GWBT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LGWDCR_GWBT), uint32_t) & BM_LCDC_LGWDCR_GWBT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GWBT field to a new value.
#define BW_LCDC_LGWDCR_GWBT(v)   (BITBAND_ACCESS32(HW_LCDC_LGWDCR_ADDR, BP_LCDC_LGWDCR_GWBT) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LAUSCR - LCDC AUS mode control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LAUSCR - LCDC AUS mode control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register determines the behavior of LCDC in AUS mode.
 */
typedef union _hw_lcdc_lauscr
{
    uint32_t U;
    struct _hw_lcdc_lauscr_bitfields
    {
        uint32_t AGWCKB : 8; //!< [7:0] AUS graphic window color keying blue component
        uint32_t AGWCKG : 8; //!< [15:8] AUS graphic window color keying green component
        uint32_t AGWCKR : 8; //!< [23:16] AUS graphic window color keying red component
        uint32_t RESERVED0 : 7; //!< [30:24] 
        uint32_t AUS_MODE : 1; //!< [31] AUS mode control
    } B;
} hw_lcdc_lauscr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LAUSCR register
 */
//@{
#define HW_LCDC_LAUSCR_ADDR      (REGS_LCDC_BASE + 0x80U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LAUSCR           (*(__IO hw_lcdc_lauscr_t *) HW_LCDC_LAUSCR_ADDR)
#define HW_LCDC_LAUSCR_RD()      (HW_LCDC_LAUSCR.U)
#define HW_LCDC_LAUSCR_WR(v)     (HW_LCDC_LAUSCR.U = (v))
#define HW_LCDC_LAUSCR_SET(v)    (HW_LCDC_LAUSCR_WR(HW_LCDC_LAUSCR_RD() |  (v)))
#define HW_LCDC_LAUSCR_CLR(v)    (HW_LCDC_LAUSCR_WR(HW_LCDC_LAUSCR_RD() & ~(v)))
#define HW_LCDC_LAUSCR_TOG(v)    (HW_LCDC_LAUSCR_WR(HW_LCDC_LAUSCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LAUSCR bitfields
 */

/*! @name Register LCDC_LAUSCR, field AGWCKB[7:0] (RW)
 *
 * Defines the blue component of graphic window color keying (AUS mode only).
 */
//@{
#define BP_LCDC_LAUSCR_AGWCKB      (0U)      //!< Bit position for LCDC_LAUSCR_AGWCKB.
#define BM_LCDC_LAUSCR_AGWCKB      (0x000000ffU)  //!< Bit mask for LCDC_LAUSCR_AGWCKB.
#define BS_LCDC_LAUSCR_AGWCKB      (8U)  //!< Bitfield size in bits for LCDC_LAUSCR_AGWCKB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LAUSCR_AGWCKB field.
#define BR_LCDC_LAUSCR_AGWCKB()   (HW_LCDC_LAUSCR.B.AGWCKB)
#endif

//! @brief Format value for bitfield LCDC_LAUSCR_AGWCKB.
#define BF_LCDC_LAUSCR_AGWCKB(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LAUSCR_AGWCKB), uint32_t) & BM_LCDC_LAUSCR_AGWCKB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AGWCKB field to a new value.
#define BW_LCDC_LAUSCR_AGWCKB(v)   (HW_LCDC_LAUSCR_WR((HW_LCDC_LAUSCR_RD() & ~BM_LCDC_LAUSCR_AGWCKB) | BF_LCDC_LAUSCR_AGWCKB(v)))
#endif
//@}

/*! @name Register LCDC_LAUSCR, field AGWCKG[15:8] (RW)
 *
 * Defines the green component of graphic window color keying (AUS mode only).
 */
//@{
#define BP_LCDC_LAUSCR_AGWCKG      (8U)      //!< Bit position for LCDC_LAUSCR_AGWCKG.
#define BM_LCDC_LAUSCR_AGWCKG      (0x0000ff00U)  //!< Bit mask for LCDC_LAUSCR_AGWCKG.
#define BS_LCDC_LAUSCR_AGWCKG      (8U)  //!< Bitfield size in bits for LCDC_LAUSCR_AGWCKG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LAUSCR_AGWCKG field.
#define BR_LCDC_LAUSCR_AGWCKG()   (HW_LCDC_LAUSCR.B.AGWCKG)
#endif

//! @brief Format value for bitfield LCDC_LAUSCR_AGWCKG.
#define BF_LCDC_LAUSCR_AGWCKG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LAUSCR_AGWCKG), uint32_t) & BM_LCDC_LAUSCR_AGWCKG)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AGWCKG field to a new value.
#define BW_LCDC_LAUSCR_AGWCKG(v)   (HW_LCDC_LAUSCR_WR((HW_LCDC_LAUSCR_RD() & ~BM_LCDC_LAUSCR_AGWCKG) | BF_LCDC_LAUSCR_AGWCKG(v)))
#endif
//@}

/*! @name Register LCDC_LAUSCR, field AGWCKR[23:16] (RW)
 *
 * Defines the red component of graphic window color keying (AUS mode only).
 */
//@{
#define BP_LCDC_LAUSCR_AGWCKR      (16U)      //!< Bit position for LCDC_LAUSCR_AGWCKR.
#define BM_LCDC_LAUSCR_AGWCKR      (0x00ff0000U)  //!< Bit mask for LCDC_LAUSCR_AGWCKR.
#define BS_LCDC_LAUSCR_AGWCKR      (8U)  //!< Bitfield size in bits for LCDC_LAUSCR_AGWCKR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LAUSCR_AGWCKR field.
#define BR_LCDC_LAUSCR_AGWCKR()   (HW_LCDC_LAUSCR.B.AGWCKR)
#endif

//! @brief Format value for bitfield LCDC_LAUSCR_AGWCKR.
#define BF_LCDC_LAUSCR_AGWCKR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LAUSCR_AGWCKR), uint32_t) & BM_LCDC_LAUSCR_AGWCKR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AGWCKR field to a new value.
#define BW_LCDC_LAUSCR_AGWCKR(v)   (HW_LCDC_LAUSCR_WR((HW_LCDC_LAUSCR_RD() & ~BM_LCDC_LAUSCR_AGWCKR) | BF_LCDC_LAUSCR_AGWCKR(v)))
#endif
//@}

/*! @name Register LCDC_LAUSCR, field AUS_MODE[31] (RW)
 *
 * Determines whether LCDC enters AUS mode or not. When BPIX = 101, supports 16 bpp AUO panel. When
 * BPIX = 110, supports 24 bpp AUO panel.
 *
 * Values:
 * - 0 - Normal mode
 * - 1 - AUS mode
 */
//@{
#define BP_LCDC_LAUSCR_AUS_MODE      (31U)      //!< Bit position for LCDC_LAUSCR_AUS_MODE.
#define BM_LCDC_LAUSCR_AUS_MODE      (0x80000000U)  //!< Bit mask for LCDC_LAUSCR_AUS_MODE.
#define BS_LCDC_LAUSCR_AUS_MODE      (1U)  //!< Bitfield size in bits for LCDC_LAUSCR_AUS_MODE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LAUSCR_AUS_MODE field.
#define BR_LCDC_LAUSCR_AUS_MODE()   (BITBAND_ACCESS32(HW_LCDC_LAUSCR_ADDR, BP_LCDC_LAUSCR_AUS_MODE))
#endif

//! @brief Format value for bitfield LCDC_LAUSCR_AUS_MODE.
#define BF_LCDC_LAUSCR_AUS_MODE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LAUSCR_AUS_MODE), uint32_t) & BM_LCDC_LAUSCR_AUS_MODE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AUS_MODE field to a new value.
#define BW_LCDC_LAUSCR_AUS_MODE(v)   (BITBAND_ACCESS32(HW_LCDC_LAUSCR_ADDR, BP_LCDC_LAUSCR_AUS_MODE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_LCDC_LAUSCCR - LCDC AUS mode cursor control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_LCDC_LAUSCCR - LCDC AUS mode cursor control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register determines the color map of cursor in AUS mode. In 16 bpp mode, this register uses
 * bits [21:17] for Red, [13:8] for Green, and [5:1] for Blue.
 */
typedef union _hw_lcdc_lausccr
{
    uint32_t U;
    struct _hw_lcdc_lausccr_bitfields
    {
        uint32_t ACUR_COL_B : 8; //!< [7:0] AUS cursor red field
        uint32_t ACUR_COL_G : 8; //!< [15:8] AUS cursor green field
        uint32_t ACUR_COL_R : 8; //!< [23:16] AUS cursor red field
        uint32_t RESERVED0 : 8; //!< [31:24] 
    } B;
} hw_lcdc_lausccr_t;
#endif

/*!
 * @name Constants and macros for entire LCDC_LAUSCCR register
 */
//@{
#define HW_LCDC_LAUSCCR_ADDR      (REGS_LCDC_BASE + 0x84U)

#ifndef __LANGUAGE_ASM__
#define HW_LCDC_LAUSCCR           (*(__IO hw_lcdc_lausccr_t *) HW_LCDC_LAUSCCR_ADDR)
#define HW_LCDC_LAUSCCR_RD()      (HW_LCDC_LAUSCCR.U)
#define HW_LCDC_LAUSCCR_WR(v)     (HW_LCDC_LAUSCCR.U = (v))
#define HW_LCDC_LAUSCCR_SET(v)    (HW_LCDC_LAUSCCR_WR(HW_LCDC_LAUSCCR_RD() |  (v)))
#define HW_LCDC_LAUSCCR_CLR(v)    (HW_LCDC_LAUSCCR_WR(HW_LCDC_LAUSCCR_RD() & ~(v)))
#define HW_LCDC_LAUSCCR_TOG(v)    (HW_LCDC_LAUSCCR_WR(HW_LCDC_LAUSCCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual LCDC_LAUSCCR bitfields
 */

/*! @name Register LCDC_LAUSCCR, field ACUR_COL_B[7:0] (RW)
 *
 * Defines the blue component of cursor color in color mode (AUS mode only).
 */
//@{
#define BP_LCDC_LAUSCCR_ACUR_COL_B      (0U)      //!< Bit position for LCDC_LAUSCCR_ACUR_COL_B.
#define BM_LCDC_LAUSCCR_ACUR_COL_B      (0x000000ffU)  //!< Bit mask for LCDC_LAUSCCR_ACUR_COL_B.
#define BS_LCDC_LAUSCCR_ACUR_COL_B      (8U)  //!< Bitfield size in bits for LCDC_LAUSCCR_ACUR_COL_B.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LAUSCCR_ACUR_COL_B field.
#define BR_LCDC_LAUSCCR_ACUR_COL_B()   (HW_LCDC_LAUSCCR.B.ACUR_COL_B)
#endif

//! @brief Format value for bitfield LCDC_LAUSCCR_ACUR_COL_B.
#define BF_LCDC_LAUSCCR_ACUR_COL_B(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LAUSCCR_ACUR_COL_B), uint32_t) & BM_LCDC_LAUSCCR_ACUR_COL_B)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACUR_COL_B field to a new value.
#define BW_LCDC_LAUSCCR_ACUR_COL_B(v)   (HW_LCDC_LAUSCCR_WR((HW_LCDC_LAUSCCR_RD() & ~BM_LCDC_LAUSCCR_ACUR_COL_B) | BF_LCDC_LAUSCCR_ACUR_COL_B(v)))
#endif
//@}

/*! @name Register LCDC_LAUSCCR, field ACUR_COL_G[15:8] (RW)
 *
 * Defines the green component of cursor color in color mode (AUS mode only).
 */
//@{
#define BP_LCDC_LAUSCCR_ACUR_COL_G      (8U)      //!< Bit position for LCDC_LAUSCCR_ACUR_COL_G.
#define BM_LCDC_LAUSCCR_ACUR_COL_G      (0x0000ff00U)  //!< Bit mask for LCDC_LAUSCCR_ACUR_COL_G.
#define BS_LCDC_LAUSCCR_ACUR_COL_G      (8U)  //!< Bitfield size in bits for LCDC_LAUSCCR_ACUR_COL_G.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LAUSCCR_ACUR_COL_G field.
#define BR_LCDC_LAUSCCR_ACUR_COL_G()   (HW_LCDC_LAUSCCR.B.ACUR_COL_G)
#endif

//! @brief Format value for bitfield LCDC_LAUSCCR_ACUR_COL_G.
#define BF_LCDC_LAUSCCR_ACUR_COL_G(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LAUSCCR_ACUR_COL_G), uint32_t) & BM_LCDC_LAUSCCR_ACUR_COL_G)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACUR_COL_G field to a new value.
#define BW_LCDC_LAUSCCR_ACUR_COL_G(v)   (HW_LCDC_LAUSCCR_WR((HW_LCDC_LAUSCCR_RD() & ~BM_LCDC_LAUSCCR_ACUR_COL_G) | BF_LCDC_LAUSCCR_ACUR_COL_G(v)))
#endif
//@}

/*! @name Register LCDC_LAUSCCR, field ACUR_COL_R[23:16] (RW)
 *
 * Defines the red component of cursor color in color mode (AUS mode only).
 */
//@{
#define BP_LCDC_LAUSCCR_ACUR_COL_R      (16U)      //!< Bit position for LCDC_LAUSCCR_ACUR_COL_R.
#define BM_LCDC_LAUSCCR_ACUR_COL_R      (0x00ff0000U)  //!< Bit mask for LCDC_LAUSCCR_ACUR_COL_R.
#define BS_LCDC_LAUSCCR_ACUR_COL_R      (8U)  //!< Bitfield size in bits for LCDC_LAUSCCR_ACUR_COL_R.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the LCDC_LAUSCCR_ACUR_COL_R field.
#define BR_LCDC_LAUSCCR_ACUR_COL_R()   (HW_LCDC_LAUSCCR.B.ACUR_COL_R)
#endif

//! @brief Format value for bitfield LCDC_LAUSCCR_ACUR_COL_R.
#define BF_LCDC_LAUSCCR_ACUR_COL_R(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_LCDC_LAUSCCR_ACUR_COL_R), uint32_t) & BM_LCDC_LAUSCCR_ACUR_COL_R)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACUR_COL_R field to a new value.
#define BW_LCDC_LAUSCCR_ACUR_COL_R(v)   (HW_LCDC_LAUSCCR_WR((HW_LCDC_LAUSCCR_RD() & ~BM_LCDC_LAUSCCR_ACUR_COL_R) | BF_LCDC_LAUSCCR_ACUR_COL_R(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_lcdc_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All LCDC module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_lcdc
{
    __IO hw_lcdc_lssar_t LSSAR; //!< [0x0] LCDC screen start address register
    __IO hw_lcdc_lsr_t LSR; //!< [0x4] LCDC size register
    __IO hw_lcdc_lvpwr_t LVPWR; //!< [0x8] LCDC virtual page width register
    __IO hw_lcdc_lcpr_t LCPR; //!< [0xc] LCDC cursor position register
    __IO hw_lcdc_lcwhb_t LCWHB; //!< [0x10] LCDC cursor width, height, and blink register
    __IO hw_lcdc_lccmr_t LCCMR; //!< [0x14] LCDC color cursor mapping register
    __IO hw_lcdc_lpcr_t LPCR; //!< [0x18] LCDC panel configuration register
    __IO hw_lcdc_lhcr_t LHCR; //!< [0x1c] LCDC horizontal configuration register
    __IO hw_lcdc_lvcr_t LVCR; //!< [0x20] LCDC vertical configuration register
    __IO hw_lcdc_lpor_t LPOR; //!< [0x24] LCDC panning offset register
    uint32_t _reserved0;
    __IO hw_lcdc_lpccr_t LPCCR; //!< [0x2c] LCDC PWM contrast control register
    __IO hw_lcdc_ldcr_t LDCR; //!< [0x30] LCDC DMA control register
    __IO hw_lcdc_lrmcr_t LRMCR; //!< [0x34] LCDC refresh mode control register
    __IO hw_lcdc_licr_t LICR; //!< [0x38] LCDC interrupt configuration register
    __IO hw_lcdc_lier_t LIER; //!< [0x3c] LCDC interrupt enable register
    __I hw_lcdc_lisr_t LISR; //!< [0x40] LCDC interrupt status register
    uint32_t _reserved1[3];
    __IO hw_lcdc_lgwsar_t LGWSAR; //!< [0x50] LCDC graphic window start address register
    __IO hw_lcdc_lgwsr_t LGWSR; //!< [0x54] LCDC graphic window size register
    __IO hw_lcdc_lgwvpwr_t LGWVPWR; //!< [0x58] LCDC graphic window virtual page width register
    __IO hw_lcdc_lgwpor_t LGWPOR; //!< [0x5c] LCDC graphic window panning offset register
    __IO hw_lcdc_lgwpr_t LGWPR; //!< [0x60] LCDC graphic window position register
    __IO hw_lcdc_lgwcr_t LGWCR; //!< [0x64] LCDC graphic window control register
    __IO hw_lcdc_lgwdcr_t LGWDCR; //!< [0x68] LCDC graphic window DMA control register
    uint32_t _reserved2[5];
    __IO hw_lcdc_lauscr_t LAUSCR; //!< [0x80] LCDC AUS mode control register
    __IO hw_lcdc_lausccr_t LAUSCCR; //!< [0x84] LCDC AUS mode cursor control register
} hw_lcdc_t;
#pragma pack()

//! @brief Macro to access all LCDC registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_LCDC</code>.
#define HW_LCDC     (*(hw_lcdc_t *) REGS_LCDC_BASE)
#endif

#endif // __HW_LCDC_REGISTERS_H__
// v22/130417/1.2.6
// EOF

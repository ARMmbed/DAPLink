/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_USBHS_REGISTERS_H__
#define __HW_USBHS_REGISTERS_H__

#include "regs.h"

/*
 * MK70F12 USBHS
 *
 * USB HS/FS/LS OTG Controller
 *
 * Registers defined in this header file:
 * - HW_USBHS_ID - Identification Register
 * - HW_USBHS_HWGENERAL - General Hardware Parameters Register
 * - HW_USBHS_HWHOST - Host Hardware Parameters Register
 * - HW_USBHS_HWDEVICE - Device Hardware Parameters Register
 * - HW_USBHS_HWTXBUF - Transmit Buffer Hardware Parameters Register
 * - HW_USBHS_HWRXBUF - Receive Buffer Hardware Parameters Register
 * - HW_USBHS_GPTIMER0LD - General Purpose Timer n Load Register
 * - HW_USBHS_GPTIMER0CTL - General Purpose Timer n Control Register
 * - HW_USBHS_GPTIMER1LD - General Purpose Timer n Load Register
 * - HW_USBHS_GPTIMER1CTL - General Purpose Timer n Control Register
 * - HW_USBHS_USB_SBUSCFG - System Bus Interface Configuration Register
 * - HW_USBHS_HCIVERSION - Host Controller Interface Version and Capability Registers Length Register
 * - HW_USBHS_HCSPARAMS - Host Controller Structural Parameters Register
 * - HW_USBHS_HCCPARAMS - Host Controller Capability Parameters Register
 * - HW_USBHS_DCIVERSION - Device Controller Interface Version
 * - HW_USBHS_DCCPARAMS - Device Controller Capability Parameters
 * - HW_USBHS_USBCMD - USB Command Register
 * - HW_USBHS_USBSTS - USB Status Register
 * - HW_USBHS_USBINTR - USB Interrupt Enable Register
 * - HW_USBHS_FRINDEX - Frame Index Register
 * - HW_USBHS_DEVICEADDR - Device Address Register
 * - HW_USBHS_PERIODICLISTBASE - Periodic Frame List Base Address Register
 * - HW_USBHS_ASYNCLISTADDR - Current Asynchronous List Address Register
 * - HW_USBHS_EPLISTADDR - Endpoint List Address Register
 * - HW_USBHS_TTCTRL - Host TT Asynchronous Buffer Control
 * - HW_USBHS_BURSTSIZE - Master Interface Data Burst Size Register
 * - HW_USBHS_TXFILLTUNING - Transmit FIFO Tuning Control Register
 * - HW_USBHS_ULPI_VIEWPORT - ULPI Register Access
 * - HW_USBHS_ENDPTNAK - Endpoint NAK Register
 * - HW_USBHS_ENDPTNAKEN - Endpoint NAK Enable Register
 * - HW_USBHS_CONFIGFLAG - Configure Flag Register
 * - HW_USBHS_PORTSC1 - Port Status and Control Registers
 * - HW_USBHS_OTGSC - On-the-Go Status and Control Register
 * - HW_USBHS_USBMODE - USB Mode Register
 * - HW_USBHS_EPSETUPSR - Endpoint Setup Status Register
 * - HW_USBHS_EPPRIME - Endpoint Initialization Register
 * - HW_USBHS_EPFLUSH - Endpoint Flush Register
 * - HW_USBHS_EPSR - Endpoint Status Register
 * - HW_USBHS_EPCOMPLETE - Endpoint Complete Register
 * - HW_USBHS_EPCR0 - Endpoint Control Register 0
 * - HW_USBHS_EPCRn - Endpoint Control Register n
 * - HW_USBHS_EPCRn - Endpoint Control Register n
 * - HW_USBHS_EPCRn - Endpoint Control Register n
 * - HW_USBHS_USBGENCTRL - USB General Control Register
 *
 * - hw_usbhs_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_USBHS_BASE
#define HW_USBHS_INSTANCE_COUNT (1U) //!< Number of instances of the USBHS module.
#define REGS_USBHS_BASE (0x40034000U) //!< Base address for USBHS.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_ID - Identification Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_ID - Identification Register (RO)
 *
 * Reset value: 0xE461FA05U
 *
 * The ID register provides a simple way to determine if the module is provided
 * in the system. The ID register identifies the module and its revision.
 */
typedef union _hw_usbhs_id
{
    uint32_t U;
    struct _hw_usbhs_id_bitfields
    {
        uint32_t ID : 6;               //!< [5:0] Configuration number
        uint32_t RESERVED0 : 2;        //!< [7:6] Reserved
        uint32_t NID : 6;              //!< [13:8]
        uint32_t RESERVED1 : 2;        //!< [15:14] Reserved
        uint32_t TAG : 5;              //!< [20:16] Tag
        uint32_t REVISION : 4;         //!< [24:21] Revision
        uint32_t VERSION : 4;          //!< [28:25] Version
        uint32_t VERSIONID : 3;        //!< [31:29] Version ID
    } B;
} hw_usbhs_id_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_ID register
 */
//@{
#define HW_USBHS_ID_ADDR         (REGS_USBHS_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_ID              (*(__I hw_usbhs_id_t *) HW_USBHS_ID_ADDR)
#define HW_USBHS_ID_RD()         (HW_USBHS_ID.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_ID bitfields
 */

/*!
 * @name Register USBHS_ID, field ID[5:0] (RO)
 *
 * This number is set to 0x05.
 */
//@{
#define BP_USBHS_ID_ID       (0U)          //!< Bit position for USBHS_ID_ID.
#define BM_USBHS_ID_ID       (0x0000003FU) //!< Bit mask for USBHS_ID_ID.
#define BS_USBHS_ID_ID       (6U)          //!< Bit field size in bits for USBHS_ID_ID.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ID_ID field.
#define BR_USBHS_ID_ID       (HW_USBHS_ID.B.ID)
#endif
//@}

/*!
 * @name Register USBHS_ID, field NID[13:8] (RO)
 *
 * Ones complement version of ID.
 */
//@{
#define BP_USBHS_ID_NID      (8U)          //!< Bit position for USBHS_ID_NID.
#define BM_USBHS_ID_NID      (0x00003F00U) //!< Bit mask for USBHS_ID_NID.
#define BS_USBHS_ID_NID      (6U)          //!< Bit field size in bits for USBHS_ID_NID.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ID_NID field.
#define BR_USBHS_ID_NID      (HW_USBHS_ID.B.NID)
#endif
//@}

/*!
 * @name Register USBHS_ID, field TAG[20:16] (RO)
 *
 * Tag of the module.
 */
//@{
#define BP_USBHS_ID_TAG      (16U)         //!< Bit position for USBHS_ID_TAG.
#define BM_USBHS_ID_TAG      (0x001F0000U) //!< Bit mask for USBHS_ID_TAG.
#define BS_USBHS_ID_TAG      (5U)          //!< Bit field size in bits for USBHS_ID_TAG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ID_TAG field.
#define BR_USBHS_ID_TAG      (HW_USBHS_ID.B.TAG)
#endif
//@}

/*!
 * @name Register USBHS_ID, field REVISION[24:21] (RO)
 *
 * Revision number of the module.
 */
//@{
#define BP_USBHS_ID_REVISION (21U)         //!< Bit position for USBHS_ID_REVISION.
#define BM_USBHS_ID_REVISION (0x01E00000U) //!< Bit mask for USBHS_ID_REVISION.
#define BS_USBHS_ID_REVISION (4U)          //!< Bit field size in bits for USBHS_ID_REVISION.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ID_REVISION field.
#define BR_USBHS_ID_REVISION (HW_USBHS_ID.B.REVISION)
#endif
//@}

/*!
 * @name Register USBHS_ID, field VERSION[28:25] (RO)
 *
 * Version of the module.
 */
//@{
#define BP_USBHS_ID_VERSION  (25U)         //!< Bit position for USBHS_ID_VERSION.
#define BM_USBHS_ID_VERSION  (0x1E000000U) //!< Bit mask for USBHS_ID_VERSION.
#define BS_USBHS_ID_VERSION  (4U)          //!< Bit field size in bits for USBHS_ID_VERSION.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ID_VERSION field.
#define BR_USBHS_ID_VERSION  (HW_USBHS_ID.B.VERSION)
#endif
//@}

/*!
 * @name Register USBHS_ID, field VERSIONID[31:29] (RO)
 *
 * Internal version counter.
 */
//@{
#define BP_USBHS_ID_VERSIONID (29U)        //!< Bit position for USBHS_ID_VERSIONID.
#define BM_USBHS_ID_VERSIONID (0xE0000000U) //!< Bit mask for USBHS_ID_VERSIONID.
#define BS_USBHS_ID_VERSIONID (3U)         //!< Bit field size in bits for USBHS_ID_VERSIONID.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ID_VERSIONID field.
#define BR_USBHS_ID_VERSIONID (HW_USBHS_ID.B.VERSIONID)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_HWGENERAL - General Hardware Parameters Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_HWGENERAL - General Hardware Parameters Register (RO)
 *
 * Reset value: 0x00000085U
 *
 * The HWGENERAL register contains parameters defining the particular
 * implementation of the module.
 */
typedef union _hw_usbhs_hwgeneral
{
    uint32_t U;
    struct _hw_usbhs_hwgeneral_bitfields
    {
        uint32_t RESERVED0 : 6;        //!< [5:0] Reserved
        uint32_t PHYM : 3;             //!< [8:6] PHY Mode
        uint32_t SM : 2;               //!< [10:9] Serial mode
        uint32_t RESERVED1 : 21;       //!< [31:11] Reserved
    } B;
} hw_usbhs_hwgeneral_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_HWGENERAL register
 */
//@{
#define HW_USBHS_HWGENERAL_ADDR  (REGS_USBHS_BASE + 0x4U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_HWGENERAL       (*(__I hw_usbhs_hwgeneral_t *) HW_USBHS_HWGENERAL_ADDR)
#define HW_USBHS_HWGENERAL_RD()  (HW_USBHS_HWGENERAL.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_HWGENERAL bitfields
 */

/*!
 * @name Register USBHS_HWGENERAL, field PHYM[8:6] (RO)
 *
 * Indicates USB transceiver interface used. Always reads 010. 010 ULPI only
 */
//@{
#define BP_USBHS_HWGENERAL_PHYM (6U)       //!< Bit position for USBHS_HWGENERAL_PHYM.
#define BM_USBHS_HWGENERAL_PHYM (0x000001C0U) //!< Bit mask for USBHS_HWGENERAL_PHYM.
#define BS_USBHS_HWGENERAL_PHYM (3U)       //!< Bit field size in bits for USBHS_HWGENERAL_PHYM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWGENERAL_PHYM field.
#define BR_USBHS_HWGENERAL_PHYM (HW_USBHS_HWGENERAL.B.PHYM)
#endif
//@}

/*!
 * @name Register USBHS_HWGENERAL, field SM[10:9] (RO)
 *
 * Indicates presence of serial interface. Always 00. 00 Serial engine not
 * present
 */
//@{
#define BP_USBHS_HWGENERAL_SM (9U)         //!< Bit position for USBHS_HWGENERAL_SM.
#define BM_USBHS_HWGENERAL_SM (0x00000600U) //!< Bit mask for USBHS_HWGENERAL_SM.
#define BS_USBHS_HWGENERAL_SM (2U)         //!< Bit field size in bits for USBHS_HWGENERAL_SM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWGENERAL_SM field.
#define BR_USBHS_HWGENERAL_SM (HW_USBHS_HWGENERAL.B.SM)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_HWHOST - Host Hardware Parameters Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_HWHOST - Host Hardware Parameters Register (RO)
 *
 * Reset value: 0x10020001U
 *
 * The HWHOST register provides host hardware parameters for this implementation
 * of the module.
 */
typedef union _hw_usbhs_hwhost
{
    uint32_t U;
    struct _hw_usbhs_hwhost_bitfields
    {
        uint32_t HC : 1;               //!< [0] Host Capable
        uint32_t NPORT : 3;            //!< [3:1] Number of Ports
        uint32_t RESERVED0 : 12;       //!< [15:4] Reserved
        uint32_t TTASY : 8;            //!< [23:16] Transaction translator contexts.
        uint32_t TTPER : 8;            //!< [31:24] Transaction translator periodic
                                       //! contexts.
    } B;
} hw_usbhs_hwhost_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_HWHOST register
 */
//@{
#define HW_USBHS_HWHOST_ADDR     (REGS_USBHS_BASE + 0x8U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_HWHOST          (*(__I hw_usbhs_hwhost_t *) HW_USBHS_HWHOST_ADDR)
#define HW_USBHS_HWHOST_RD()     (HW_USBHS_HWHOST.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_HWHOST bitfields
 */

/*!
 * @name Register USBHS_HWHOST, field HC[0] (RO)
 *
 * Always reads as 0b1, indicating the module is host capable.
 */
//@{
#define BP_USBHS_HWHOST_HC   (0U)          //!< Bit position for USBHS_HWHOST_HC.
#define BM_USBHS_HWHOST_HC   (0x00000001U) //!< Bit mask for USBHS_HWHOST_HC.
#define BS_USBHS_HWHOST_HC   (1U)          //!< Bit field size in bits for USBHS_HWHOST_HC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWHOST_HC field.
#define BR_USBHS_HWHOST_HC   (BITBAND_ACCESS32(HW_USBHS_HWHOST_ADDR, BP_USBHS_HWHOST_HC))
#endif
//@}

/*!
 * @name Register USBHS_HWHOST, field NPORT[3:1] (RO)
 *
 * Always 0, indicating the number of ports available (NPORT + 1) for this host
 * implementation.
 */
//@{
#define BP_USBHS_HWHOST_NPORT (1U)         //!< Bit position for USBHS_HWHOST_NPORT.
#define BM_USBHS_HWHOST_NPORT (0x0000000EU) //!< Bit mask for USBHS_HWHOST_NPORT.
#define BS_USBHS_HWHOST_NPORT (3U)         //!< Bit field size in bits for USBHS_HWHOST_NPORT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWHOST_NPORT field.
#define BR_USBHS_HWHOST_NPORT (HW_USBHS_HWHOST.B.NPORT)
#endif
//@}

/*!
 * @name Register USBHS_HWHOST, field TTASY[23:16] (RO)
 *
 * The number of transaction translator contexts. Always reads as 0x02.
 */
//@{
#define BP_USBHS_HWHOST_TTASY (16U)        //!< Bit position for USBHS_HWHOST_TTASY.
#define BM_USBHS_HWHOST_TTASY (0x00FF0000U) //!< Bit mask for USBHS_HWHOST_TTASY.
#define BS_USBHS_HWHOST_TTASY (8U)         //!< Bit field size in bits for USBHS_HWHOST_TTASY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWHOST_TTASY field.
#define BR_USBHS_HWHOST_TTASY (HW_USBHS_HWHOST.B.TTASY)
#endif
//@}

/*!
 * @name Register USBHS_HWHOST, field TTPER[31:24] (RO)
 *
 * The number of supported transaction translator periodic contexts. Always
 * reads as 0x10 (16 contexts supported).
 */
//@{
#define BP_USBHS_HWHOST_TTPER (24U)        //!< Bit position for USBHS_HWHOST_TTPER.
#define BM_USBHS_HWHOST_TTPER (0xFF000000U) //!< Bit mask for USBHS_HWHOST_TTPER.
#define BS_USBHS_HWHOST_TTPER (8U)         //!< Bit field size in bits for USBHS_HWHOST_TTPER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWHOST_TTPER field.
#define BR_USBHS_HWHOST_TTPER (HW_USBHS_HWHOST.B.TTPER)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_HWDEVICE - Device Hardware Parameters Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_HWDEVICE - Device Hardware Parameters Register (RO)
 *
 * Reset value: 0x00000009U
 *
 * Provides device hardware parameters for this implementation of the USBHS
 * module.
 */
typedef union _hw_usbhs_hwdevice
{
    uint32_t U;
    struct _hw_usbhs_hwdevice_bitfields
    {
        uint32_t DC : 1;               //!< [0] Device Capable
        uint32_t DEVEP : 5;            //!< [5:1] Device endpoints.
        uint32_t RESERVED0 : 26;       //!< [31:6] Reserved
    } B;
} hw_usbhs_hwdevice_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_HWDEVICE register
 */
//@{
#define HW_USBHS_HWDEVICE_ADDR   (REGS_USBHS_BASE + 0xCU)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_HWDEVICE        (*(__I hw_usbhs_hwdevice_t *) HW_USBHS_HWDEVICE_ADDR)
#define HW_USBHS_HWDEVICE_RD()   (HW_USBHS_HWDEVICE.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_HWDEVICE bitfields
 */

/*!
 * @name Register USBHS_HWDEVICE, field DC[0] (RO)
 *
 * Always reads as 0b1, indicating the USBHS module is device capable.
 */
//@{
#define BP_USBHS_HWDEVICE_DC (0U)          //!< Bit position for USBHS_HWDEVICE_DC.
#define BM_USBHS_HWDEVICE_DC (0x00000001U) //!< Bit mask for USBHS_HWDEVICE_DC.
#define BS_USBHS_HWDEVICE_DC (1U)          //!< Bit field size in bits for USBHS_HWDEVICE_DC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWDEVICE_DC field.
#define BR_USBHS_HWDEVICE_DC (BITBAND_ACCESS32(HW_USBHS_HWDEVICE_ADDR, BP_USBHS_HWDEVICE_DC))
#endif
//@}

/*!
 * @name Register USBHS_HWDEVICE, field DEVEP[5:1] (RO)
 *
 * The number of supported endpoints. Always reads as 0b00100.
 */
//@{
#define BP_USBHS_HWDEVICE_DEVEP (1U)       //!< Bit position for USBHS_HWDEVICE_DEVEP.
#define BM_USBHS_HWDEVICE_DEVEP (0x0000003EU) //!< Bit mask for USBHS_HWDEVICE_DEVEP.
#define BS_USBHS_HWDEVICE_DEVEP (5U)       //!< Bit field size in bits for USBHS_HWDEVICE_DEVEP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWDEVICE_DEVEP field.
#define BR_USBHS_HWDEVICE_DEVEP (HW_USBHS_HWDEVICE.B.DEVEP)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_HWTXBUF - Transmit Buffer Hardware Parameters Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_HWTXBUF - Transmit Buffer Hardware Parameters Register (RO)
 *
 * Reset value: 0x80070908U
 *
 * The HWTXBUF register provides the transmit buffer parameters for this
 * implementation of the module.
 */
typedef union _hw_usbhs_hwtxbuf
{
    uint32_t U;
    struct _hw_usbhs_hwtxbuf_bitfields
    {
        uint32_t TXBURST : 8;          //!< [7:0] Transmit Burst.
        uint32_t TXADD : 8;            //!< [15:8] Transmit Address.
        uint32_t TXCHANADD : 8;        //!< [23:16] Transmit Channel Address
        uint32_t RESERVED0 : 7;        //!< [30:24] Reserved
        uint32_t TXLC : 1;             //!< [31] Transmit local Context Registers
    } B;
} hw_usbhs_hwtxbuf_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_HWTXBUF register
 */
//@{
#define HW_USBHS_HWTXBUF_ADDR    (REGS_USBHS_BASE + 0x10U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_HWTXBUF         (*(__I hw_usbhs_hwtxbuf_t *) HW_USBHS_HWTXBUF_ADDR)
#define HW_USBHS_HWTXBUF_RD()    (HW_USBHS_HWTXBUF.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_HWTXBUF bitfields
 */

/*!
 * @name Register USBHS_HWTXBUF, field TXBURST[7:0] (RO)
 *
 * Indicates the number of data beats in a burst for transmit DMA data
 * transfers. Always 0x8.
 */
//@{
#define BP_USBHS_HWTXBUF_TXBURST (0U)      //!< Bit position for USBHS_HWTXBUF_TXBURST.
#define BM_USBHS_HWTXBUF_TXBURST (0x000000FFU) //!< Bit mask for USBHS_HWTXBUF_TXBURST.
#define BS_USBHS_HWTXBUF_TXBURST (8U)      //!< Bit field size in bits for USBHS_HWTXBUF_TXBURST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWTXBUF_TXBURST field.
#define BR_USBHS_HWTXBUF_TXBURST (HW_USBHS_HWTXBUF.B.TXBURST)
#endif
//@}

/*!
 * @name Register USBHS_HWTXBUF, field TXADD[15:8] (RO)
 *
 * The number of address bits for the entire TX buffer. Always 0x9.
 */
//@{
#define BP_USBHS_HWTXBUF_TXADD (8U)        //!< Bit position for USBHS_HWTXBUF_TXADD.
#define BM_USBHS_HWTXBUF_TXADD (0x0000FF00U) //!< Bit mask for USBHS_HWTXBUF_TXADD.
#define BS_USBHS_HWTXBUF_TXADD (8U)        //!< Bit field size in bits for USBHS_HWTXBUF_TXADD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWTXBUF_TXADD field.
#define BR_USBHS_HWTXBUF_TXADD (HW_USBHS_HWTXBUF.B.TXADD)
#endif
//@}

/*!
 * @name Register USBHS_HWTXBUF, field TXCHANADD[23:16] (RO)
 *
 * The number of address bits required to address one channel's worth of TX
 * data. Always 0x7.
 */
//@{
#define BP_USBHS_HWTXBUF_TXCHANADD (16U)   //!< Bit position for USBHS_HWTXBUF_TXCHANADD.
#define BM_USBHS_HWTXBUF_TXCHANADD (0x00FF0000U) //!< Bit mask for USBHS_HWTXBUF_TXCHANADD.
#define BS_USBHS_HWTXBUF_TXCHANADD (8U)    //!< Bit field size in bits for USBHS_HWTXBUF_TXCHANADD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWTXBUF_TXCHANADD field.
#define BR_USBHS_HWTXBUF_TXCHANADD (HW_USBHS_HWTXBUF.B.TXCHANADD)
#endif
//@}

/*!
 * @name Register USBHS_HWTXBUF, field TXLC[31] (RO)
 *
 * Indicates how the device transmit context registers implement. Always set.
 *
 * Values:
 * - 0 - Store device transmit contexts in the TX FIFO
 * - 1 - Store device transmit contexts in a register file
 */
//@{
#define BP_USBHS_HWTXBUF_TXLC (31U)        //!< Bit position for USBHS_HWTXBUF_TXLC.
#define BM_USBHS_HWTXBUF_TXLC (0x80000000U) //!< Bit mask for USBHS_HWTXBUF_TXLC.
#define BS_USBHS_HWTXBUF_TXLC (1U)         //!< Bit field size in bits for USBHS_HWTXBUF_TXLC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWTXBUF_TXLC field.
#define BR_USBHS_HWTXBUF_TXLC (BITBAND_ACCESS32(HW_USBHS_HWTXBUF_ADDR, BP_USBHS_HWTXBUF_TXLC))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_HWRXBUF - Receive Buffer Hardware Parameters Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_HWRXBUF - Receive Buffer Hardware Parameters Register (RO)
 *
 * Reset value: 0x00000808U
 *
 * The HWRXBUF register provide the receive buffer parameters for this
 * implementation of the module.
 */
typedef union _hw_usbhs_hwrxbuf
{
    uint32_t U;
    struct _hw_usbhs_hwrxbuf_bitfields
    {
        uint32_t RXBURST : 8;          //!< [7:0] Receive Burst.
        uint32_t RXADD : 8;            //!< [15:8] Receive Address.
        uint32_t RESERVED0 : 16;       //!< [31:16] Reserved
    } B;
} hw_usbhs_hwrxbuf_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_HWRXBUF register
 */
//@{
#define HW_USBHS_HWRXBUF_ADDR    (REGS_USBHS_BASE + 0x14U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_HWRXBUF         (*(__I hw_usbhs_hwrxbuf_t *) HW_USBHS_HWRXBUF_ADDR)
#define HW_USBHS_HWRXBUF_RD()    (HW_USBHS_HWRXBUF.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_HWRXBUF bitfields
 */

/*!
 * @name Register USBHS_HWRXBUF, field RXBURST[7:0] (RO)
 *
 * Indicates the number of data beats in a burst for receive DMA data transfers.
 * Always reads as 0x08.
 */
//@{
#define BP_USBHS_HWRXBUF_RXBURST (0U)      //!< Bit position for USBHS_HWRXBUF_RXBURST.
#define BM_USBHS_HWRXBUF_RXBURST (0x000000FFU) //!< Bit mask for USBHS_HWRXBUF_RXBURST.
#define BS_USBHS_HWRXBUF_RXBURST (8U)      //!< Bit field size in bits for USBHS_HWRXBUF_RXBURST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWRXBUF_RXBURST field.
#define BR_USBHS_HWRXBUF_RXBURST (HW_USBHS_HWRXBUF.B.RXBURST)
#endif
//@}

/*!
 * @name Register USBHS_HWRXBUF, field RXADD[15:8] (RO)
 *
 * The number of address bits for the entire RX buffer. Always reads as 0x08.
 */
//@{
#define BP_USBHS_HWRXBUF_RXADD (8U)        //!< Bit position for USBHS_HWRXBUF_RXADD.
#define BM_USBHS_HWRXBUF_RXADD (0x0000FF00U) //!< Bit mask for USBHS_HWRXBUF_RXADD.
#define BS_USBHS_HWRXBUF_RXADD (8U)        //!< Bit field size in bits for USBHS_HWRXBUF_RXADD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HWRXBUF_RXADD field.
#define BR_USBHS_HWRXBUF_RXADD (HW_USBHS_HWRXBUF.B.RXADD)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_GPTIMER0LD - General Purpose Timer n Load Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_GPTIMER0LD - General Purpose Timer n Load Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The GPTIMERnLD register contains the timer duration or load value.
 */
typedef union _hw_usbhs_gptimer0ld
{
    uint32_t U;
    struct _hw_usbhs_gptimer0ld_bitfields
    {
        uint32_t GPTLD : 24;           //!< [23:0]
        uint32_t RESERVED0 : 8;        //!< [31:24] Reserved
    } B;
} hw_usbhs_gptimer0ld_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_GPTIMER0LD register
 */
//@{
#define HW_USBHS_GPTIMER0LD_ADDR (REGS_USBHS_BASE + 0x80U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_GPTIMER0LD      (*(__IO hw_usbhs_gptimer0ld_t *) HW_USBHS_GPTIMER0LD_ADDR)
#define HW_USBHS_GPTIMER0LD_RD() (HW_USBHS_GPTIMER0LD.U)
#define HW_USBHS_GPTIMER0LD_WR(v) (HW_USBHS_GPTIMER0LD.U = (v))
#define HW_USBHS_GPTIMER0LD_SET(v) (HW_USBHS_GPTIMER0LD_WR(HW_USBHS_GPTIMER0LD_RD() |  (v)))
#define HW_USBHS_GPTIMER0LD_CLR(v) (HW_USBHS_GPTIMER0LD_WR(HW_USBHS_GPTIMER0LD_RD() & ~(v)))
#define HW_USBHS_GPTIMER0LD_TOG(v) (HW_USBHS_GPTIMER0LD_WR(HW_USBHS_GPTIMER0LD_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_GPTIMER0LD bitfields
 */

/*!
 * @name Register USBHS_GPTIMER0LD, field GPTLD[23:0] (RW)
 */
//@{
#define BP_USBHS_GPTIMER0LD_GPTLD (0U)     //!< Bit position for USBHS_GPTIMER0LD_GPTLD.
#define BM_USBHS_GPTIMER0LD_GPTLD (0x00FFFFFFU) //!< Bit mask for USBHS_GPTIMER0LD_GPTLD.
#define BS_USBHS_GPTIMER0LD_GPTLD (24U)    //!< Bit field size in bits for USBHS_GPTIMER0LD_GPTLD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER0LD_GPTLD field.
#define BR_USBHS_GPTIMER0LD_GPTLD (HW_USBHS_GPTIMER0LD.B.GPTLD)
#endif

//! @brief Format value for bitfield USBHS_GPTIMER0LD_GPTLD.
#define BF_USBHS_GPTIMER0LD_GPTLD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_GPTIMER0LD_GPTLD), uint32_t) & BM_USBHS_GPTIMER0LD_GPTLD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GPTLD field to a new value.
#define BW_USBHS_GPTIMER0LD_GPTLD(v) (HW_USBHS_GPTIMER0LD_WR((HW_USBHS_GPTIMER0LD_RD() & ~BM_USBHS_GPTIMER0LD_GPTLD) | BF_USBHS_GPTIMER0LD_GPTLD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_GPTIMER0CTL - General Purpose Timer n Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_GPTIMER0CTL - General Purpose Timer n Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The GPTIMERnCTL register controls the various functions of the general
 * purpose timers.
 */
typedef union _hw_usbhs_gptimer0ctl
{
    uint32_t U;
    struct _hw_usbhs_gptimer0ctl_bitfields
    {
        uint32_t GPTCNT : 24;          //!< [23:0] Timer Count
        uint32_t MODE : 1;             //!< [24] Timer Mode
        uint32_t RESERVED0 : 5;        //!< [29:25] Reserved
        uint32_t RST : 1;              //!< [30] Timer Reset
        uint32_t RUN : 1;              //!< [31] Timer Run
    } B;
} hw_usbhs_gptimer0ctl_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_GPTIMER0CTL register
 */
//@{
#define HW_USBHS_GPTIMER0CTL_ADDR (REGS_USBHS_BASE + 0x84U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_GPTIMER0CTL     (*(__IO hw_usbhs_gptimer0ctl_t *) HW_USBHS_GPTIMER0CTL_ADDR)
#define HW_USBHS_GPTIMER0CTL_RD() (HW_USBHS_GPTIMER0CTL.U)
#define HW_USBHS_GPTIMER0CTL_WR(v) (HW_USBHS_GPTIMER0CTL.U = (v))
#define HW_USBHS_GPTIMER0CTL_SET(v) (HW_USBHS_GPTIMER0CTL_WR(HW_USBHS_GPTIMER0CTL_RD() |  (v)))
#define HW_USBHS_GPTIMER0CTL_CLR(v) (HW_USBHS_GPTIMER0CTL_WR(HW_USBHS_GPTIMER0CTL_RD() & ~(v)))
#define HW_USBHS_GPTIMER0CTL_TOG(v) (HW_USBHS_GPTIMER0CTL_WR(HW_USBHS_GPTIMER0CTL_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_GPTIMER0CTL bitfields
 */

/*!
 * @name Register USBHS_GPTIMER0CTL, field GPTCNT[23:0] (RO)
 */
//@{
#define BP_USBHS_GPTIMER0CTL_GPTCNT (0U)   //!< Bit position for USBHS_GPTIMER0CTL_GPTCNT.
#define BM_USBHS_GPTIMER0CTL_GPTCNT (0x00FFFFFFU) //!< Bit mask for USBHS_GPTIMER0CTL_GPTCNT.
#define BS_USBHS_GPTIMER0CTL_GPTCNT (24U)  //!< Bit field size in bits for USBHS_GPTIMER0CTL_GPTCNT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER0CTL_GPTCNT field.
#define BR_USBHS_GPTIMER0CTL_GPTCNT (HW_USBHS_GPTIMER0CTL.B.GPTCNT)
#endif
//@}

/*!
 * @name Register USBHS_GPTIMER0CTL, field MODE[24] (RW)
 *
 * Values:
 * - 0 - One shot
 * - 1 - Repeat
 */
//@{
#define BP_USBHS_GPTIMER0CTL_MODE (24U)    //!< Bit position for USBHS_GPTIMER0CTL_MODE.
#define BM_USBHS_GPTIMER0CTL_MODE (0x01000000U) //!< Bit mask for USBHS_GPTIMER0CTL_MODE.
#define BS_USBHS_GPTIMER0CTL_MODE (1U)     //!< Bit field size in bits for USBHS_GPTIMER0CTL_MODE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER0CTL_MODE field.
#define BR_USBHS_GPTIMER0CTL_MODE (BITBAND_ACCESS32(HW_USBHS_GPTIMER0CTL_ADDR, BP_USBHS_GPTIMER0CTL_MODE))
#endif

//! @brief Format value for bitfield USBHS_GPTIMER0CTL_MODE.
#define BF_USBHS_GPTIMER0CTL_MODE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_GPTIMER0CTL_MODE), uint32_t) & BM_USBHS_GPTIMER0CTL_MODE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MODE field to a new value.
#define BW_USBHS_GPTIMER0CTL_MODE(v) (BITBAND_ACCESS32(HW_USBHS_GPTIMER0CTL_ADDR, BP_USBHS_GPTIMER0CTL_MODE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_GPTIMER0CTL, field RST[30] (WO)
 *
 * Values:
 * - 0 - No action
 * - 1 - Load counter value
 */
//@{
#define BP_USBHS_GPTIMER0CTL_RST (30U)     //!< Bit position for USBHS_GPTIMER0CTL_RST.
#define BM_USBHS_GPTIMER0CTL_RST (0x40000000U) //!< Bit mask for USBHS_GPTIMER0CTL_RST.
#define BS_USBHS_GPTIMER0CTL_RST (1U)      //!< Bit field size in bits for USBHS_GPTIMER0CTL_RST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER0CTL_RST field.
#define BR_USBHS_GPTIMER0CTL_RST (BITBAND_ACCESS32(HW_USBHS_GPTIMER0CTL_ADDR, BP_USBHS_GPTIMER0CTL_RST))
#endif

//! @brief Format value for bitfield USBHS_GPTIMER0CTL_RST.
#define BF_USBHS_GPTIMER0CTL_RST(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_GPTIMER0CTL_RST), uint32_t) & BM_USBHS_GPTIMER0CTL_RST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RST field to a new value.
#define BW_USBHS_GPTIMER0CTL_RST(v) (BITBAND_ACCESS32(HW_USBHS_GPTIMER0CTL_ADDR, BP_USBHS_GPTIMER0CTL_RST) = (v))
#endif
//@}

/*!
 * @name Register USBHS_GPTIMER0CTL, field RUN[31] (RW)
 *
 * Values:
 * - 0 - Timer stop
 * - 1 - Timer run
 */
//@{
#define BP_USBHS_GPTIMER0CTL_RUN (31U)     //!< Bit position for USBHS_GPTIMER0CTL_RUN.
#define BM_USBHS_GPTIMER0CTL_RUN (0x80000000U) //!< Bit mask for USBHS_GPTIMER0CTL_RUN.
#define BS_USBHS_GPTIMER0CTL_RUN (1U)      //!< Bit field size in bits for USBHS_GPTIMER0CTL_RUN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER0CTL_RUN field.
#define BR_USBHS_GPTIMER0CTL_RUN (BITBAND_ACCESS32(HW_USBHS_GPTIMER0CTL_ADDR, BP_USBHS_GPTIMER0CTL_RUN))
#endif

//! @brief Format value for bitfield USBHS_GPTIMER0CTL_RUN.
#define BF_USBHS_GPTIMER0CTL_RUN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_GPTIMER0CTL_RUN), uint32_t) & BM_USBHS_GPTIMER0CTL_RUN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RUN field to a new value.
#define BW_USBHS_GPTIMER0CTL_RUN(v) (BITBAND_ACCESS32(HW_USBHS_GPTIMER0CTL_ADDR, BP_USBHS_GPTIMER0CTL_RUN) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_GPTIMER1LD - General Purpose Timer n Load Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_GPTIMER1LD - General Purpose Timer n Load Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The GPTIMERnLD register contains the timer duration or load value.
 */
typedef union _hw_usbhs_gptimer1ld
{
    uint32_t U;
    struct _hw_usbhs_gptimer1ld_bitfields
    {
        uint32_t GPTLD : 24;           //!< [23:0]
        uint32_t RESERVED0 : 8;        //!< [31:24] Reserved
    } B;
} hw_usbhs_gptimer1ld_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_GPTIMER1LD register
 */
//@{
#define HW_USBHS_GPTIMER1LD_ADDR (REGS_USBHS_BASE + 0x88U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_GPTIMER1LD      (*(__IO hw_usbhs_gptimer1ld_t *) HW_USBHS_GPTIMER1LD_ADDR)
#define HW_USBHS_GPTIMER1LD_RD() (HW_USBHS_GPTIMER1LD.U)
#define HW_USBHS_GPTIMER1LD_WR(v) (HW_USBHS_GPTIMER1LD.U = (v))
#define HW_USBHS_GPTIMER1LD_SET(v) (HW_USBHS_GPTIMER1LD_WR(HW_USBHS_GPTIMER1LD_RD() |  (v)))
#define HW_USBHS_GPTIMER1LD_CLR(v) (HW_USBHS_GPTIMER1LD_WR(HW_USBHS_GPTIMER1LD_RD() & ~(v)))
#define HW_USBHS_GPTIMER1LD_TOG(v) (HW_USBHS_GPTIMER1LD_WR(HW_USBHS_GPTIMER1LD_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_GPTIMER1LD bitfields
 */

/*!
 * @name Register USBHS_GPTIMER1LD, field GPTLD[23:0] (RW)
 */
//@{
#define BP_USBHS_GPTIMER1LD_GPTLD (0U)     //!< Bit position for USBHS_GPTIMER1LD_GPTLD.
#define BM_USBHS_GPTIMER1LD_GPTLD (0x00FFFFFFU) //!< Bit mask for USBHS_GPTIMER1LD_GPTLD.
#define BS_USBHS_GPTIMER1LD_GPTLD (24U)    //!< Bit field size in bits for USBHS_GPTIMER1LD_GPTLD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER1LD_GPTLD field.
#define BR_USBHS_GPTIMER1LD_GPTLD (HW_USBHS_GPTIMER1LD.B.GPTLD)
#endif

//! @brief Format value for bitfield USBHS_GPTIMER1LD_GPTLD.
#define BF_USBHS_GPTIMER1LD_GPTLD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_GPTIMER1LD_GPTLD), uint32_t) & BM_USBHS_GPTIMER1LD_GPTLD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GPTLD field to a new value.
#define BW_USBHS_GPTIMER1LD_GPTLD(v) (HW_USBHS_GPTIMER1LD_WR((HW_USBHS_GPTIMER1LD_RD() & ~BM_USBHS_GPTIMER1LD_GPTLD) | BF_USBHS_GPTIMER1LD_GPTLD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_GPTIMER1CTL - General Purpose Timer n Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_GPTIMER1CTL - General Purpose Timer n Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The GPTIMERnCTL register controls the various functions of the general
 * purpose timers.
 */
typedef union _hw_usbhs_gptimer1ctl
{
    uint32_t U;
    struct _hw_usbhs_gptimer1ctl_bitfields
    {
        uint32_t GPTCNT : 24;          //!< [23:0] Timer Count
        uint32_t MODE : 1;             //!< [24] Timer Mode
        uint32_t RESERVED0 : 5;        //!< [29:25] Reserved
        uint32_t RST : 1;              //!< [30] Timer Reset
        uint32_t RUN : 1;              //!< [31] Timer Run
    } B;
} hw_usbhs_gptimer1ctl_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_GPTIMER1CTL register
 */
//@{
#define HW_USBHS_GPTIMER1CTL_ADDR (REGS_USBHS_BASE + 0x8CU)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_GPTIMER1CTL     (*(__IO hw_usbhs_gptimer1ctl_t *) HW_USBHS_GPTIMER1CTL_ADDR)
#define HW_USBHS_GPTIMER1CTL_RD() (HW_USBHS_GPTIMER1CTL.U)
#define HW_USBHS_GPTIMER1CTL_WR(v) (HW_USBHS_GPTIMER1CTL.U = (v))
#define HW_USBHS_GPTIMER1CTL_SET(v) (HW_USBHS_GPTIMER1CTL_WR(HW_USBHS_GPTIMER1CTL_RD() |  (v)))
#define HW_USBHS_GPTIMER1CTL_CLR(v) (HW_USBHS_GPTIMER1CTL_WR(HW_USBHS_GPTIMER1CTL_RD() & ~(v)))
#define HW_USBHS_GPTIMER1CTL_TOG(v) (HW_USBHS_GPTIMER1CTL_WR(HW_USBHS_GPTIMER1CTL_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_GPTIMER1CTL bitfields
 */

/*!
 * @name Register USBHS_GPTIMER1CTL, field GPTCNT[23:0] (RO)
 */
//@{
#define BP_USBHS_GPTIMER1CTL_GPTCNT (0U)   //!< Bit position for USBHS_GPTIMER1CTL_GPTCNT.
#define BM_USBHS_GPTIMER1CTL_GPTCNT (0x00FFFFFFU) //!< Bit mask for USBHS_GPTIMER1CTL_GPTCNT.
#define BS_USBHS_GPTIMER1CTL_GPTCNT (24U)  //!< Bit field size in bits for USBHS_GPTIMER1CTL_GPTCNT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER1CTL_GPTCNT field.
#define BR_USBHS_GPTIMER1CTL_GPTCNT (HW_USBHS_GPTIMER1CTL.B.GPTCNT)
#endif
//@}

/*!
 * @name Register USBHS_GPTIMER1CTL, field MODE[24] (RW)
 *
 * Values:
 * - 0 - One shot
 * - 1 - Repeat
 */
//@{
#define BP_USBHS_GPTIMER1CTL_MODE (24U)    //!< Bit position for USBHS_GPTIMER1CTL_MODE.
#define BM_USBHS_GPTIMER1CTL_MODE (0x01000000U) //!< Bit mask for USBHS_GPTIMER1CTL_MODE.
#define BS_USBHS_GPTIMER1CTL_MODE (1U)     //!< Bit field size in bits for USBHS_GPTIMER1CTL_MODE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER1CTL_MODE field.
#define BR_USBHS_GPTIMER1CTL_MODE (BITBAND_ACCESS32(HW_USBHS_GPTIMER1CTL_ADDR, BP_USBHS_GPTIMER1CTL_MODE))
#endif

//! @brief Format value for bitfield USBHS_GPTIMER1CTL_MODE.
#define BF_USBHS_GPTIMER1CTL_MODE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_GPTIMER1CTL_MODE), uint32_t) & BM_USBHS_GPTIMER1CTL_MODE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MODE field to a new value.
#define BW_USBHS_GPTIMER1CTL_MODE(v) (BITBAND_ACCESS32(HW_USBHS_GPTIMER1CTL_ADDR, BP_USBHS_GPTIMER1CTL_MODE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_GPTIMER1CTL, field RST[30] (WO)
 *
 * Values:
 * - 0 - No action
 * - 1 - Load counter value
 */
//@{
#define BP_USBHS_GPTIMER1CTL_RST (30U)     //!< Bit position for USBHS_GPTIMER1CTL_RST.
#define BM_USBHS_GPTIMER1CTL_RST (0x40000000U) //!< Bit mask for USBHS_GPTIMER1CTL_RST.
#define BS_USBHS_GPTIMER1CTL_RST (1U)      //!< Bit field size in bits for USBHS_GPTIMER1CTL_RST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER1CTL_RST field.
#define BR_USBHS_GPTIMER1CTL_RST (BITBAND_ACCESS32(HW_USBHS_GPTIMER1CTL_ADDR, BP_USBHS_GPTIMER1CTL_RST))
#endif

//! @brief Format value for bitfield USBHS_GPTIMER1CTL_RST.
#define BF_USBHS_GPTIMER1CTL_RST(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_GPTIMER1CTL_RST), uint32_t) & BM_USBHS_GPTIMER1CTL_RST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RST field to a new value.
#define BW_USBHS_GPTIMER1CTL_RST(v) (BITBAND_ACCESS32(HW_USBHS_GPTIMER1CTL_ADDR, BP_USBHS_GPTIMER1CTL_RST) = (v))
#endif
//@}

/*!
 * @name Register USBHS_GPTIMER1CTL, field RUN[31] (RW)
 *
 * Values:
 * - 0 - Timer stop
 * - 1 - Timer run
 */
//@{
#define BP_USBHS_GPTIMER1CTL_RUN (31U)     //!< Bit position for USBHS_GPTIMER1CTL_RUN.
#define BM_USBHS_GPTIMER1CTL_RUN (0x80000000U) //!< Bit mask for USBHS_GPTIMER1CTL_RUN.
#define BS_USBHS_GPTIMER1CTL_RUN (1U)      //!< Bit field size in bits for USBHS_GPTIMER1CTL_RUN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_GPTIMER1CTL_RUN field.
#define BR_USBHS_GPTIMER1CTL_RUN (BITBAND_ACCESS32(HW_USBHS_GPTIMER1CTL_ADDR, BP_USBHS_GPTIMER1CTL_RUN))
#endif

//! @brief Format value for bitfield USBHS_GPTIMER1CTL_RUN.
#define BF_USBHS_GPTIMER1CTL_RUN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_GPTIMER1CTL_RUN), uint32_t) & BM_USBHS_GPTIMER1CTL_RUN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RUN field to a new value.
#define BW_USBHS_GPTIMER1CTL_RUN(v) (BITBAND_ACCESS32(HW_USBHS_GPTIMER1CTL_ADDR, BP_USBHS_GPTIMER1CTL_RUN) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_USB_SBUSCFG - System Bus Interface Configuration Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_USB_SBUSCFG - System Bus Interface Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The System Bus Interface Configuration (USB_SBUSCFG) register contains the
 * control for the system bus interface.
 */
typedef union _hw_usbhs_usb_sbuscfg
{
    uint32_t U;
    struct _hw_usbhs_usb_sbuscfg_bitfields
    {
        uint32_t BURSTMODE : 3;        //!< [2:0] Burst mode
        uint32_t RESERVED0 : 29;       //!< [31:3] Reserved
    } B;
} hw_usbhs_usb_sbuscfg_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_USB_SBUSCFG register
 */
//@{
#define HW_USBHS_USB_SBUSCFG_ADDR (REGS_USBHS_BASE + 0x90U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_USB_SBUSCFG     (*(__IO hw_usbhs_usb_sbuscfg_t *) HW_USBHS_USB_SBUSCFG_ADDR)
#define HW_USBHS_USB_SBUSCFG_RD() (HW_USBHS_USB_SBUSCFG.U)
#define HW_USBHS_USB_SBUSCFG_WR(v) (HW_USBHS_USB_SBUSCFG.U = (v))
#define HW_USBHS_USB_SBUSCFG_SET(v) (HW_USBHS_USB_SBUSCFG_WR(HW_USBHS_USB_SBUSCFG_RD() |  (v)))
#define HW_USBHS_USB_SBUSCFG_CLR(v) (HW_USBHS_USB_SBUSCFG_WR(HW_USBHS_USB_SBUSCFG_RD() & ~(v)))
#define HW_USBHS_USB_SBUSCFG_TOG(v) (HW_USBHS_USB_SBUSCFG_WR(HW_USBHS_USB_SBUSCFG_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_USB_SBUSCFG bitfields
 */

/*!
 * @name Register USBHS_USB_SBUSCFG, field BURSTMODE[2:0] (RW)
 *
 * Selects the options for the burst signal of the Master Interface. In all
 * cases where the unspecified length burst is allowed, single accesses may also
 * occur; this is mostly true when the transaction is not 32-bit aligned. Two
 * consecutive single accesses should not happen. When an INCRx burst size is selected
 * and the transfer is not multiple of the INCRx burst, the burst is decomposed in
 * the different ways. With BURSTMODE[2] = 1, the smaller bursts is unspecified
 * length. with BURSTMODE[2] = 0, the smaller bursts are smaller INCRx or
 * singles. For example, if it were required at a given time to transfer 22 words of
 * information, for the following values of BURSTMODE the master sequences are: 101
 * INCR4 + INCR4 + INCR4 + INCR4 + INCR4 + INCR unspec. length. 110 INCR8 + INCR8
 * + INCR4 + INCR unspec. length. 111 INCR16 + INCR4 + INCR unspec. length. 001
 * INCR4 + INCR4 + INCR4 + INCR4 + INCR4 + SINGLE + SINGLE. 010 INCR8 + INCR8 +
 * INCR4 + SINGLE + SINGLE. 011 INCR16 + INCR4 + SINGLE + SINGLE. When this field
 * is different from zero, the values in the TXBURST/RXBURST bitfields in the
 * USB_BURSTSIZE register are ignored by the controller. Internally the BURSTMODE is
 * set to the value of the INCRx burst. Since this has a direct relation with
 * the burst sizes you must be careful with AHB burst selected. Although the
 * TXBURST/RXBURST are bypassed, this register can be written/read with no effect while
 * the BURSTMODE field is non-zero. Setting the BURSTMODE value to 000 might
 * cause bus allocation during BULK or ISO transfers. Changing this BURSTMODE field
 * while a transaction is in progress yields undefined results. One possible way
 * to prevent undefined results is to clear the Run/Stop (RS) bit in the
 * USB_USBCMD register, after the HCHALTED is detected in USB_USBSTS.
 *
 * Values:
 * - 000 - INCR burst of unspecified length
 * - 001 - INCR4, non-multiple transfers of INCR4 is decomposed into singles.
 * - 010 - INCR8, non-multiple transfers of INCR8, is decomposed into INCR4 or
 *     singles.
 * - 011 - INCR16, non-multiple transfers of INCR16, is decomposed into INCR8,
 *     INCR4 or singles.
 * - 100 - Reserved, do not use.
 * - 101 - INCR4, non-multiple transfers of INCR4 is decomposed into smaller
 *     unspecified length bursts.
 * - 110 - INCR8, non-multiple transfers of INCR8 is decomposed into smaller
 *     unspecified length bursts.
 * - 111 - INCR16, non-multiple transfers of INCR16 is decomposed into smaller
 *     unspecified length bursts.
 */
//@{
#define BP_USBHS_USB_SBUSCFG_BURSTMODE (0U) //!< Bit position for USBHS_USB_SBUSCFG_BURSTMODE.
#define BM_USBHS_USB_SBUSCFG_BURSTMODE (0x00000007U) //!< Bit mask for USBHS_USB_SBUSCFG_BURSTMODE.
#define BS_USBHS_USB_SBUSCFG_BURSTMODE (3U) //!< Bit field size in bits for USBHS_USB_SBUSCFG_BURSTMODE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USB_SBUSCFG_BURSTMODE field.
#define BR_USBHS_USB_SBUSCFG_BURSTMODE (HW_USBHS_USB_SBUSCFG.B.BURSTMODE)
#endif

//! @brief Format value for bitfield USBHS_USB_SBUSCFG_BURSTMODE.
#define BF_USBHS_USB_SBUSCFG_BURSTMODE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USB_SBUSCFG_BURSTMODE), uint32_t) & BM_USBHS_USB_SBUSCFG_BURSTMODE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BURSTMODE field to a new value.
#define BW_USBHS_USB_SBUSCFG_BURSTMODE(v) (HW_USBHS_USB_SBUSCFG_WR((HW_USBHS_USB_SBUSCFG_RD() & ~BM_USBHS_USB_SBUSCFG_BURSTMODE) | BF_USBHS_USB_SBUSCFG_BURSTMODE(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_HCIVERSION - Host Controller Interface Version and Capability Registers Length Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_HCIVERSION - Host Controller Interface Version and Capability Registers Length Register (RO)
 *
 * Reset value: 0x01000040U
 *
 * Contains the CAPLENGTH field used as an offset to add to the register base
 * address to find the beginning of the operational register space, the location of
 * the USBCMD register. Also contains a BCD encoding of the EHCI revision number
 * supported by this OTG controller. The most-significant byte of the HCIVERSION
 * field represents a major revision; the least-significant byte is the minor
 * revision.
 */
typedef union _hw_usbhs_hciversion
{
    uint32_t U;
    struct _hw_usbhs_hciversion_bitfields
    {
        uint32_t CAPLENGTH : 8;        //!< [7:0] Capability registers length
        uint32_t RESERVED0 : 8;        //!< [15:8] Reserved
        uint32_t HCIVERSION : 16;      //!< [31:16] EHCI revision number
    } B;
} hw_usbhs_hciversion_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_HCIVERSION register
 */
//@{
#define HW_USBHS_HCIVERSION_ADDR (REGS_USBHS_BASE + 0x100U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_HCIVERSION      (*(__I hw_usbhs_hciversion_t *) HW_USBHS_HCIVERSION_ADDR)
#define HW_USBHS_HCIVERSION_RD() (HW_USBHS_HCIVERSION.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_HCIVERSION bitfields
 */

/*!
 * @name Register USBHS_HCIVERSION, field CAPLENGTH[7:0] (RO)
 *
 * Always reads as 0x40.
 */
//@{
#define BP_USBHS_HCIVERSION_CAPLENGTH (0U) //!< Bit position for USBHS_HCIVERSION_CAPLENGTH.
#define BM_USBHS_HCIVERSION_CAPLENGTH (0x000000FFU) //!< Bit mask for USBHS_HCIVERSION_CAPLENGTH.
#define BS_USBHS_HCIVERSION_CAPLENGTH (8U) //!< Bit field size in bits for USBHS_HCIVERSION_CAPLENGTH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCIVERSION_CAPLENGTH field.
#define BR_USBHS_HCIVERSION_CAPLENGTH (HW_USBHS_HCIVERSION.B.CAPLENGTH)
#endif
//@}

/*!
 * @name Register USBHS_HCIVERSION, field HCIVERSION[31:16] (RO)
 *
 * Value is reads as 0x0100, indicating version 1.0.
 */
//@{
#define BP_USBHS_HCIVERSION_HCIVERSION (16U) //!< Bit position for USBHS_HCIVERSION_HCIVERSION.
#define BM_USBHS_HCIVERSION_HCIVERSION (0xFFFF0000U) //!< Bit mask for USBHS_HCIVERSION_HCIVERSION.
#define BS_USBHS_HCIVERSION_HCIVERSION (16U) //!< Bit field size in bits for USBHS_HCIVERSION_HCIVERSION.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCIVERSION_HCIVERSION field.
#define BR_USBHS_HCIVERSION_HCIVERSION (HW_USBHS_HCIVERSION.B.HCIVERSION)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_HCSPARAMS - Host Controller Structural Parameters Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_HCSPARAMS - Host Controller Structural Parameters Register (RO)
 *
 * Reset value: 0x00010011U
 *
 * This register contains structural parameters such as the number of downstream
 * ports.
 */
typedef union _hw_usbhs_hcsparams
{
    uint32_t U;
    struct _hw_usbhs_hcsparams_bitfields
    {
        uint32_t N_PORTS : 4;          //!< [3:0] Number of Ports
        uint32_t PPC : 1;              //!< [4] Power Port Control
        uint32_t RESERVED0 : 3;        //!< [7:5] Reserved
        uint32_t N_PCC : 4;            //!< [11:8] Number Ports per CC
        uint32_t N_CC : 4;             //!< [15:12] Number of Companion Controllers
        uint32_t PI : 1;               //!< [16] Port Indicators
        uint32_t RESERVED1 : 3;        //!< [19:17] Reserved
        uint32_t N_PTT : 4;            //!< [23:20] Ports per Transaction Translator
        uint32_t N_TT : 4;             //!< [27:24] Number of Transaction Translators.
        uint32_t RESERVED2 : 4;        //!< [31:28] Reserved
    } B;
} hw_usbhs_hcsparams_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_HCSPARAMS register
 */
//@{
#define HW_USBHS_HCSPARAMS_ADDR  (REGS_USBHS_BASE + 0x104U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_HCSPARAMS       (*(__I hw_usbhs_hcsparams_t *) HW_USBHS_HCSPARAMS_ADDR)
#define HW_USBHS_HCSPARAMS_RD()  (HW_USBHS_HCSPARAMS.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_HCSPARAMS bitfields
 */

/*!
 * @name Register USBHS_HCSPARAMS, field N_PORTS[3:0] (RO)
 *
 * Indicates number of physical downstream ports implemented for host
 * applications. Field value determines how many addressable port registers in the
 * operational register. Always reads as 0x1.
 */
//@{
#define BP_USBHS_HCSPARAMS_N_PORTS (0U)    //!< Bit position for USBHS_HCSPARAMS_N_PORTS.
#define BM_USBHS_HCSPARAMS_N_PORTS (0x0000000FU) //!< Bit mask for USBHS_HCSPARAMS_N_PORTS.
#define BS_USBHS_HCSPARAMS_N_PORTS (4U)    //!< Bit field size in bits for USBHS_HCSPARAMS_N_PORTS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCSPARAMS_N_PORTS field.
#define BR_USBHS_HCSPARAMS_N_PORTS (HW_USBHS_HCSPARAMS.B.N_PORTS)
#endif
//@}

/*!
 * @name Register USBHS_HCSPARAMS, field PPC[4] (RO)
 *
 * Indicates whether host controller supports port power control. Always reads
 * as 0b1.
 *
 * Values:
 * - 1 - Ports have power port switches
 */
//@{
#define BP_USBHS_HCSPARAMS_PPC (4U)        //!< Bit position for USBHS_HCSPARAMS_PPC.
#define BM_USBHS_HCSPARAMS_PPC (0x00000010U) //!< Bit mask for USBHS_HCSPARAMS_PPC.
#define BS_USBHS_HCSPARAMS_PPC (1U)        //!< Bit field size in bits for USBHS_HCSPARAMS_PPC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCSPARAMS_PPC field.
#define BR_USBHS_HCSPARAMS_PPC (BITBAND_ACCESS32(HW_USBHS_HCSPARAMS_ADDR, BP_USBHS_HCSPARAMS_PPC))
#endif
//@}

/*!
 * @name Register USBHS_HCSPARAMS, field N_PCC[11:8] (RO)
 *
 * Indicates number of ports supported per internal companion controller. This
 * field reads as 0x0 because no companion controllers are present.
 */
//@{
#define BP_USBHS_HCSPARAMS_N_PCC (8U)      //!< Bit position for USBHS_HCSPARAMS_N_PCC.
#define BM_USBHS_HCSPARAMS_N_PCC (0x00000F00U) //!< Bit mask for USBHS_HCSPARAMS_N_PCC.
#define BS_USBHS_HCSPARAMS_N_PCC (4U)      //!< Bit field size in bits for USBHS_HCSPARAMS_N_PCC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCSPARAMS_N_PCC field.
#define BR_USBHS_HCSPARAMS_N_PCC (HW_USBHS_HCSPARAMS.B.N_PCC)
#endif
//@}

/*!
 * @name Register USBHS_HCSPARAMS, field N_CC[15:12] (RO)
 *
 * Indicates number of companion controllers associated with USBHS controller.
 * Always cleared.
 */
//@{
#define BP_USBHS_HCSPARAMS_N_CC (12U)      //!< Bit position for USBHS_HCSPARAMS_N_CC.
#define BM_USBHS_HCSPARAMS_N_CC (0x0000F000U) //!< Bit mask for USBHS_HCSPARAMS_N_CC.
#define BS_USBHS_HCSPARAMS_N_CC (4U)       //!< Bit field size in bits for USBHS_HCSPARAMS_N_CC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCSPARAMS_N_CC field.
#define BR_USBHS_HCSPARAMS_N_CC (HW_USBHS_HCSPARAMS.B.N_CC)
#endif
//@}

/*!
 * @name Register USBHS_HCSPARAMS, field PI[16] (RO)
 *
 * Indicates whether the ports support port indicator control. Always set.
 *
 * Values:
 * - 0 - No port indicator fields
 * - 1 - The port status and control registers include a R/W field for
 *     controlling the state of the port indicator
 */
//@{
#define BP_USBHS_HCSPARAMS_PI (16U)        //!< Bit position for USBHS_HCSPARAMS_PI.
#define BM_USBHS_HCSPARAMS_PI (0x00010000U) //!< Bit mask for USBHS_HCSPARAMS_PI.
#define BS_USBHS_HCSPARAMS_PI (1U)         //!< Bit field size in bits for USBHS_HCSPARAMS_PI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCSPARAMS_PI field.
#define BR_USBHS_HCSPARAMS_PI (BITBAND_ACCESS32(HW_USBHS_HCSPARAMS_ADDR, BP_USBHS_HCSPARAMS_PI))
#endif
//@}

/*!
 * @name Register USBHS_HCSPARAMS, field N_PTT[23:20] (RO)
 *
 * Non-EHCI field. Indicates number of ports assigned to each transaction
 * translator within host controller.
 */
//@{
#define BP_USBHS_HCSPARAMS_N_PTT (20U)     //!< Bit position for USBHS_HCSPARAMS_N_PTT.
#define BM_USBHS_HCSPARAMS_N_PTT (0x00F00000U) //!< Bit mask for USBHS_HCSPARAMS_N_PTT.
#define BS_USBHS_HCSPARAMS_N_PTT (4U)      //!< Bit field size in bits for USBHS_HCSPARAMS_N_PTT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCSPARAMS_N_PTT field.
#define BR_USBHS_HCSPARAMS_N_PTT (HW_USBHS_HCSPARAMS.B.N_PTT)
#endif
//@}

/*!
 * @name Register USBHS_HCSPARAMS, field N_TT[27:24] (RO)
 *
 * Non-EHCI field. Indicates number of embedded transaction translators
 * associated with host controller. This field always reads as 0x0. See section "Embedded
 * Transaction Translator Function," for more information on embedded
 * transaction translators.
 */
//@{
#define BP_USBHS_HCSPARAMS_N_TT (24U)      //!< Bit position for USBHS_HCSPARAMS_N_TT.
#define BM_USBHS_HCSPARAMS_N_TT (0x0F000000U) //!< Bit mask for USBHS_HCSPARAMS_N_TT.
#define BS_USBHS_HCSPARAMS_N_TT (4U)       //!< Bit field size in bits for USBHS_HCSPARAMS_N_TT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCSPARAMS_N_TT field.
#define BR_USBHS_HCSPARAMS_N_TT (HW_USBHS_HCSPARAMS.B.N_TT)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_HCCPARAMS - Host Controller Capability Parameters Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_HCCPARAMS - Host Controller Capability Parameters Register (RO)
 *
 * Reset value: 0x00000006U
 *
 * Identifies multiple mode control (time-base bit functionality) addressing
 * capability.
 */
typedef union _hw_usbhs_hccparams
{
    uint32_t U;
    struct _hw_usbhs_hccparams_bitfields
    {
        uint32_t ADC : 1;              //!< [0] 64-bit addressing capability.
        uint32_t PFL : 1;              //!< [1] Programmable Frame List flag
        uint32_t ASP : 1;              //!< [2] Asynchronous Schedule Park capability
        uint32_t RESERVED0 : 1;        //!< [3] Reserved
        uint32_t IST : 4;              //!< [7:4] Isochronous Scheduling Threshold
        uint32_t EECP : 8;             //!< [15:8] EHCI Extended Capabilities Pointer
        uint32_t RESERVED1 : 16;       //!< [31:16] Reserved
    } B;
} hw_usbhs_hccparams_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_HCCPARAMS register
 */
//@{
#define HW_USBHS_HCCPARAMS_ADDR  (REGS_USBHS_BASE + 0x108U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_HCCPARAMS       (*(__I hw_usbhs_hccparams_t *) HW_USBHS_HCCPARAMS_ADDR)
#define HW_USBHS_HCCPARAMS_RD()  (HW_USBHS_HCCPARAMS.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_HCCPARAMS bitfields
 */

/*!
 * @name Register USBHS_HCCPARAMS, field ADC[0] (RO)
 *
 * This bit always reads as 0b0, indicating 64-bit addressing is not supported.
 * 0 Data structures use 32-bit address memory pointers
 */
//@{
#define BP_USBHS_HCCPARAMS_ADC (0U)        //!< Bit position for USBHS_HCCPARAMS_ADC.
#define BM_USBHS_HCCPARAMS_ADC (0x00000001U) //!< Bit mask for USBHS_HCCPARAMS_ADC.
#define BS_USBHS_HCCPARAMS_ADC (1U)        //!< Bit field size in bits for USBHS_HCCPARAMS_ADC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCCPARAMS_ADC field.
#define BR_USBHS_HCCPARAMS_ADC (BITBAND_ACCESS32(HW_USBHS_HCCPARAMS_ADDR, BP_USBHS_HCCPARAMS_ADC))
#endif
//@}

/*!
 * @name Register USBHS_HCCPARAMS, field PFL[1] (RO)
 *
 * Indicates that system software can specify and use a frame list length less
 * that 1024 elements. This bit always reads as 0b1. 1 Frame list size is
 * configured via the USBCMD register frame list size field. The frame list must always
 * be aligned on a 4K-page boundary. This requirement ensures that the frame list
 * is always physically contiguous.
 */
//@{
#define BP_USBHS_HCCPARAMS_PFL (1U)        //!< Bit position for USBHS_HCCPARAMS_PFL.
#define BM_USBHS_HCCPARAMS_PFL (0x00000002U) //!< Bit mask for USBHS_HCCPARAMS_PFL.
#define BS_USBHS_HCCPARAMS_PFL (1U)        //!< Bit field size in bits for USBHS_HCCPARAMS_PFL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCCPARAMS_PFL field.
#define BR_USBHS_HCCPARAMS_PFL (BITBAND_ACCESS32(HW_USBHS_HCCPARAMS_ADDR, BP_USBHS_HCCPARAMS_PFL))
#endif
//@}

/*!
 * @name Register USBHS_HCCPARAMS, field ASP[2] (RO)
 *
 * Indicates if the host controller supports the park feature for high-speed
 * queue heads in the asynchronous schedule. The feature can be disabled or enabled
 * and set to a specific level by using the asynchronous schedule park mode
 * enable and asynchronous schedule park mode count fields in the USBCMD register.
 * This bit always reads as 0b1.
 *
 * Values:
 * - 0 - Park not supported.
 * - 1 - Park supported.
 */
//@{
#define BP_USBHS_HCCPARAMS_ASP (2U)        //!< Bit position for USBHS_HCCPARAMS_ASP.
#define BM_USBHS_HCCPARAMS_ASP (0x00000004U) //!< Bit mask for USBHS_HCCPARAMS_ASP.
#define BS_USBHS_HCCPARAMS_ASP (1U)        //!< Bit field size in bits for USBHS_HCCPARAMS_ASP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCCPARAMS_ASP field.
#define BR_USBHS_HCCPARAMS_ASP (BITBAND_ACCESS32(HW_USBHS_HCCPARAMS_ADDR, BP_USBHS_HCCPARAMS_ASP))
#endif
//@}

/*!
 * @name Register USBHS_HCCPARAMS, field IST[7:4] (RO)
 *
 * Indicates where software can reliably update the isochronous schedule,
 * relative to the current position of the executing host controller. This field always
 * reads as 0x0.
 *
 * Values:
 * - 0 - The value of the least significant 3 bits indicates the number of
 *     microframes a host controller can hold a set of isochronous data structures
 *     (one or more) before flushing the state
 */
//@{
#define BP_USBHS_HCCPARAMS_IST (4U)        //!< Bit position for USBHS_HCCPARAMS_IST.
#define BM_USBHS_HCCPARAMS_IST (0x000000F0U) //!< Bit mask for USBHS_HCCPARAMS_IST.
#define BS_USBHS_HCCPARAMS_IST (4U)        //!< Bit field size in bits for USBHS_HCCPARAMS_IST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCCPARAMS_IST field.
#define BR_USBHS_HCCPARAMS_IST (HW_USBHS_HCCPARAMS.B.IST)
#endif
//@}

/*!
 * @name Register USBHS_HCCPARAMS, field EECP[15:8] (RO)
 *
 * This optional field indicates the existence of a capabilities list. This
 * field always reads as 0x000.
 *
 * Values:
 * - 0 - No extended capabilities are implemented
 */
//@{
#define BP_USBHS_HCCPARAMS_EECP (8U)       //!< Bit position for USBHS_HCCPARAMS_EECP.
#define BM_USBHS_HCCPARAMS_EECP (0x0000FF00U) //!< Bit mask for USBHS_HCCPARAMS_EECP.
#define BS_USBHS_HCCPARAMS_EECP (8U)       //!< Bit field size in bits for USBHS_HCCPARAMS_EECP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_HCCPARAMS_EECP field.
#define BR_USBHS_HCCPARAMS_EECP (HW_USBHS_HCCPARAMS.B.EECP)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_DCIVERSION - Device Controller Interface Version
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_DCIVERSION - Device Controller Interface Version (RO)
 *
 * Reset value: 0x0001U
 *
 * Not defined in the EHCI specification. DCIVERSION is a two-byte register
 * containing a BCD encoding of the device controller interface. The most-significant
 * byte of the register represents a major revision and the least-significant
 * byte is the minor revision.
 */
typedef union _hw_usbhs_dciversion
{
    uint16_t U;
    struct _hw_usbhs_dciversion_bitfields
    {
        uint16_t DCIVERSION : 16;      //!< [15:0]
    } B;
} hw_usbhs_dciversion_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_DCIVERSION register
 */
//@{
#define HW_USBHS_DCIVERSION_ADDR (REGS_USBHS_BASE + 0x122U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_DCIVERSION      (*(__I hw_usbhs_dciversion_t *) HW_USBHS_DCIVERSION_ADDR)
#define HW_USBHS_DCIVERSION_RD() (HW_USBHS_DCIVERSION.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_DCIVERSION bitfields
 */

/*!
 * @name Register USBHS_DCIVERSION, field DCIVERSION[15:0] (RO)
 *
 * Device interface revision number.
 */
//@{
#define BP_USBHS_DCIVERSION_DCIVERSION (0U) //!< Bit position for USBHS_DCIVERSION_DCIVERSION.
#define BM_USBHS_DCIVERSION_DCIVERSION (0xFFFFU) //!< Bit mask for USBHS_DCIVERSION_DCIVERSION.
#define BS_USBHS_DCIVERSION_DCIVERSION (16U) //!< Bit field size in bits for USBHS_DCIVERSION_DCIVERSION.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_DCIVERSION_DCIVERSION field.
#define BR_USBHS_DCIVERSION_DCIVERSION (HW_USBHS_DCIVERSION.B.DCIVERSION)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_DCCPARAMS - Device Controller Capability Parameters
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_DCCPARAMS - Device Controller Capability Parameters (RO)
 *
 * Reset value: 0x00000184U
 *
 * Not defined in the EHCI specification. Register describes the overall
 * host/device capability of the USBHS module.
 */
typedef union _hw_usbhs_dccparams
{
    uint32_t U;
    struct _hw_usbhs_dccparams_bitfields
    {
        uint32_t DEN : 5;              //!< [4:0] Device Endpoint Number
        uint32_t RESERVED0 : 2;        //!< [6:5] Reserved
        uint32_t DC : 1;               //!< [7] Device Capable
        uint32_t HC : 1;               //!< [8] Host Capable
        uint32_t RESERVED1 : 23;       //!< [31:9] Reserved
    } B;
} hw_usbhs_dccparams_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_DCCPARAMS register
 */
//@{
#define HW_USBHS_DCCPARAMS_ADDR  (REGS_USBHS_BASE + 0x124U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_DCCPARAMS       (*(__I hw_usbhs_dccparams_t *) HW_USBHS_DCCPARAMS_ADDR)
#define HW_USBHS_DCCPARAMS_RD()  (HW_USBHS_DCCPARAMS.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_DCCPARAMS bitfields
 */

/*!
 * @name Register USBHS_DCCPARAMS, field DEN[4:0] (RO)
 *
 * This field indicates the number of endpoints built into the device
 * controller. Always reads as 0b0100.
 */
//@{
#define BP_USBHS_DCCPARAMS_DEN (0U)        //!< Bit position for USBHS_DCCPARAMS_DEN.
#define BM_USBHS_DCCPARAMS_DEN (0x0000001FU) //!< Bit mask for USBHS_DCCPARAMS_DEN.
#define BS_USBHS_DCCPARAMS_DEN (5U)        //!< Bit field size in bits for USBHS_DCCPARAMS_DEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_DCCPARAMS_DEN field.
#define BR_USBHS_DCCPARAMS_DEN (HW_USBHS_DCCPARAMS.B.DEN)
#endif
//@}

/*!
 * @name Register USBHS_DCCPARAMS, field DC[7] (RO)
 *
 * Indicates the USBHS controller can operate as an USB 2.0 device. Always set.
 */
//@{
#define BP_USBHS_DCCPARAMS_DC (7U)         //!< Bit position for USBHS_DCCPARAMS_DC.
#define BM_USBHS_DCCPARAMS_DC (0x00000080U) //!< Bit mask for USBHS_DCCPARAMS_DC.
#define BS_USBHS_DCCPARAMS_DC (1U)         //!< Bit field size in bits for USBHS_DCCPARAMS_DC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_DCCPARAMS_DC field.
#define BR_USBHS_DCCPARAMS_DC (BITBAND_ACCESS32(HW_USBHS_DCCPARAMS_ADDR, BP_USBHS_DCCPARAMS_DC))
#endif
//@}

/*!
 * @name Register USBHS_DCCPARAMS, field HC[8] (RO)
 *
 * Indicates the USBHS controller can operate as an EHCI compatible USB 2.0
 * host. Always reads as 0b1.
 */
//@{
#define BP_USBHS_DCCPARAMS_HC (8U)         //!< Bit position for USBHS_DCCPARAMS_HC.
#define BM_USBHS_DCCPARAMS_HC (0x00000100U) //!< Bit mask for USBHS_DCCPARAMS_HC.
#define BS_USBHS_DCCPARAMS_HC (1U)         //!< Bit field size in bits for USBHS_DCCPARAMS_HC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_DCCPARAMS_HC field.
#define BR_USBHS_DCCPARAMS_HC (BITBAND_ACCESS32(HW_USBHS_DCCPARAMS_ADDR, BP_USBHS_DCCPARAMS_HC))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_USBCMD - USB Command Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_USBCMD - USB Command Register (RW)
 *
 * Reset value: 0x00080000U
 *
 * The module executes the command indicated in this register.
 */
typedef union _hw_usbhs_usbcmd
{
    uint32_t U;
    struct _hw_usbhs_usbcmd_bitfields
    {
        uint32_t RS : 1;               //!< [0] Run/Stop
        uint32_t RST : 1;              //!< [1] Controller Reset
        uint32_t FS : 2;               //!< [3:2] Frame list Size
        uint32_t PSE : 1;              //!< [4] Periodic Schedule Enable
        uint32_t ASE : 1;              //!< [5] Asynchronous Schedule Enable
        uint32_t IAA : 1;              //!< [6] Interrupt on Async Advance doorbell
        uint32_t RESERVED0 : 1;        //!< [7] Reserved
        uint32_t ASP : 2;              //!< [9:8] Asynchronous Schedule Park mode count
        uint32_t RESERVED1 : 1;        //!< [10] Reserved
        uint32_t ASPE : 1;             //!< [11] Asynchronous Schedule Park mode Enable
        uint32_t RESERVED2 : 1;        //!< [12] Reserved
        uint32_t SUTW : 1;             //!< [13] Setup TripWire
        uint32_t ATDTW : 1;            //!< [14] Add dTD TripWire
        uint32_t FS2 : 1;              //!< [15] Frame list Size 2
        uint32_t ITC : 8;              //!< [23:16] Interrupt Threshold Control
        uint32_t RESERVED3 : 8;        //!< [31:24] Reserved
    } B;
} hw_usbhs_usbcmd_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_USBCMD register
 */
//@{
#define HW_USBHS_USBCMD_ADDR     (REGS_USBHS_BASE + 0x140U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_USBCMD          (*(__IO hw_usbhs_usbcmd_t *) HW_USBHS_USBCMD_ADDR)
#define HW_USBHS_USBCMD_RD()     (HW_USBHS_USBCMD.U)
#define HW_USBHS_USBCMD_WR(v)    (HW_USBHS_USBCMD.U = (v))
#define HW_USBHS_USBCMD_SET(v)   (HW_USBHS_USBCMD_WR(HW_USBHS_USBCMD_RD() |  (v)))
#define HW_USBHS_USBCMD_CLR(v)   (HW_USBHS_USBCMD_WR(HW_USBHS_USBCMD_RD() & ~(v)))
#define HW_USBHS_USBCMD_TOG(v)   (HW_USBHS_USBCMD_WR(HW_USBHS_USBCMD_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_USBCMD bitfields
 */

/*!
 * @name Register USBHS_USBCMD, field RS[0] (RW)
 *
 * Host mode: When set, the controller proceeds with the execution of the
 * schedule. The controller continues execution as long as this bit is set. When this
 * bit is cleared, the controller completes the current transaction on the USB and
 * then halts. The USBSTS[HCH] bit indicates when the host controller finishes
 * the transaction and enters the stopped state. Software must not set this bit
 * unless controller is in halted state (USBSTS[HCH] = 1). Device mode: Setting
 * this bit causes the controller to enable a pull-up on DP and initiate an attach
 * event. This control bit is not directly connected to the pull-up enable, as the
 * pull-up becomes disabled upon transitioning into high-speed mode. Software
 * must use this bit to prevent an attach event before the USBHS controller has
 * properly initialized. Clearing this bit causes a detach event.
 */
//@{
#define BP_USBHS_USBCMD_RS   (0U)          //!< Bit position for USBHS_USBCMD_RS.
#define BM_USBHS_USBCMD_RS   (0x00000001U) //!< Bit mask for USBHS_USBCMD_RS.
#define BS_USBHS_USBCMD_RS   (1U)          //!< Bit field size in bits for USBHS_USBCMD_RS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_RS field.
#define BR_USBHS_USBCMD_RS   (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_RS))
#endif

//! @brief Format value for bitfield USBHS_USBCMD_RS.
#define BF_USBHS_USBCMD_RS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_RS), uint32_t) & BM_USBHS_USBCMD_RS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RS field to a new value.
#define BW_USBHS_USBCMD_RS(v) (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_RS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field RST[1] (RW)
 *
 * Software uses this bit to reset controller. Controller clears this bit when
 * reset process completes. Clearing this register does not allow software to
 * terminate the reset process early. Host mode: When software sets this bit, the
 * controller resets its internal pipelines, timers, counters, state machines etc.
 * to their initial value. Any transaction in progress on the USB immediately
 * terminates. A USB reset is not driven on downstream ports. Software must not set
 * this bit when the USBSTS[HCH] bit is cleared. Attempting to reset an actively
 * running host controller results in undefined behavior. Device mode: When
 * software sets this bit, the controller resets its internal pipelines, timers,
 * counters, state machines, etc. to their initial value. Setting this bit with the
 * device in the attached state is not recommended because it has an undefined
 * effect on an attached host. To ensure the device is not in an attached state before
 * initiating a device controller reset, all primed endpoints must be flushed
 * and the USBCMD[RS] bit must be cleared.
 */
//@{
#define BP_USBHS_USBCMD_RST  (1U)          //!< Bit position for USBHS_USBCMD_RST.
#define BM_USBHS_USBCMD_RST  (0x00000002U) //!< Bit mask for USBHS_USBCMD_RST.
#define BS_USBHS_USBCMD_RST  (1U)          //!< Bit field size in bits for USBHS_USBCMD_RST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_RST field.
#define BR_USBHS_USBCMD_RST  (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_RST))
#endif

//! @brief Format value for bitfield USBHS_USBCMD_RST.
#define BF_USBHS_USBCMD_RST(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_RST), uint32_t) & BM_USBHS_USBCMD_RST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RST field to a new value.
#define BW_USBHS_USBCMD_RST(v) (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_RST) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field FS[3:2] (RW)
 *
 * With bit 15, these bits make the FS[2:0] field, which specifies the frame
 * list size controlling which bits in the frame index register must be used for the
 * frame list current index. Used only in host mode. Values below 256 elements
 * are not defined in the EHCI specification.
 *
 * Values:
 * - 00 - When FS2 = 0, the size is 1024 elements (4096 bytes). When FS2 = 1,
 *     the size is 64 elements (256 bytes).
 * - 01 - When FS2 = 0, the size is 512 elements (2048 bytes). When FS2 = 1, the
 *     size is 32 elements (128 bytes).
 * - 10 - When FS2 = 0, the size is 256 elements (1024 bytes). When FS2 = 1, the
 *     size is 16 elements (64 bytes).
 * - 11 - When FS2 = 0, the size is 128 elements (512 bytes). When FS2 = 1, the
 *     size is 8 elements (32 bytes).
 */
//@{
#define BP_USBHS_USBCMD_FS   (2U)          //!< Bit position for USBHS_USBCMD_FS.
#define BM_USBHS_USBCMD_FS   (0x0000000CU) //!< Bit mask for USBHS_USBCMD_FS.
#define BS_USBHS_USBCMD_FS   (2U)          //!< Bit field size in bits for USBHS_USBCMD_FS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_FS field.
#define BR_USBHS_USBCMD_FS   (HW_USBHS_USBCMD.B.FS)
#endif

//! @brief Format value for bitfield USBHS_USBCMD_FS.
#define BF_USBHS_USBCMD_FS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_FS), uint32_t) & BM_USBHS_USBCMD_FS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FS field to a new value.
#define BW_USBHS_USBCMD_FS(v) (HW_USBHS_USBCMD_WR((HW_USBHS_USBCMD_RD() & ~BM_USBHS_USBCMD_FS) | BF_USBHS_USBCMD_FS(v)))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field PSE[4] (RW)
 *
 * Controls whether the controller skips processing periodic schedule. Used only
 * in host mode.
 *
 * Values:
 * - 0 - Do not process periodic schedule.
 * - 1 - Use the PERIODICLISTBASE register to access the periodic schedule.
 */
//@{
#define BP_USBHS_USBCMD_PSE  (4U)          //!< Bit position for USBHS_USBCMD_PSE.
#define BM_USBHS_USBCMD_PSE  (0x00000010U) //!< Bit mask for USBHS_USBCMD_PSE.
#define BS_USBHS_USBCMD_PSE  (1U)          //!< Bit field size in bits for USBHS_USBCMD_PSE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_PSE field.
#define BR_USBHS_USBCMD_PSE  (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_PSE))
#endif

//! @brief Format value for bitfield USBHS_USBCMD_PSE.
#define BF_USBHS_USBCMD_PSE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_PSE), uint32_t) & BM_USBHS_USBCMD_PSE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PSE field to a new value.
#define BW_USBHS_USBCMD_PSE(v) (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_PSE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field ASE[5] (RW)
 *
 * Controls whether the controller skips processing the asynchronous schedule.
 * Only used in host mode.
 *
 * Values:
 * - 0 - Do not process asynchronous schedule.
 * - 1 - Use the ASYNCLISTADDR register to access asynchronous schedule.
 */
//@{
#define BP_USBHS_USBCMD_ASE  (5U)          //!< Bit position for USBHS_USBCMD_ASE.
#define BM_USBHS_USBCMD_ASE  (0x00000020U) //!< Bit mask for USBHS_USBCMD_ASE.
#define BS_USBHS_USBCMD_ASE  (1U)          //!< Bit field size in bits for USBHS_USBCMD_ASE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_ASE field.
#define BR_USBHS_USBCMD_ASE  (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_ASE))
#endif

//! @brief Format value for bitfield USBHS_USBCMD_ASE.
#define BF_USBHS_USBCMD_ASE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_ASE), uint32_t) & BM_USBHS_USBCMD_ASE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ASE field to a new value.
#define BW_USBHS_USBCMD_ASE(v) (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_ASE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field IAA[6] (RW)
 *
 * Used as a doorbell by software to tell controller to issue an interrupt the
 * next time it advances the asynchronous schedule. Software must write a 1 to
 * this bit to ring the doorbell. When controller has evicted all appropriate cached
 * schedule states, it sets USBSTS[AAI] register. If the USBINTR[AAE] bit is
 * set, the host controller asserts an interrupt at the next interrupt threshold.
 * The controller clears this bit after it has set the USBSTS[AAI] bit. Software
 * must not write a 1 to this bit when the asynchronous schedule is inactive. Doing
 * so yields undefined results. This bit used only in host mode. Writing a 1 to
 * this bit when the USBHS module is in device mode has undefined results.
 */
//@{
#define BP_USBHS_USBCMD_IAA  (6U)          //!< Bit position for USBHS_USBCMD_IAA.
#define BM_USBHS_USBCMD_IAA  (0x00000040U) //!< Bit mask for USBHS_USBCMD_IAA.
#define BS_USBHS_USBCMD_IAA  (1U)          //!< Bit field size in bits for USBHS_USBCMD_IAA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_IAA field.
#define BR_USBHS_USBCMD_IAA  (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_IAA))
#endif

//! @brief Format value for bitfield USBHS_USBCMD_IAA.
#define BF_USBHS_USBCMD_IAA(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_IAA), uint32_t) & BM_USBHS_USBCMD_IAA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IAA field to a new value.
#define BW_USBHS_USBCMD_IAA(v) (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_IAA) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field ASP[9:8] (RW)
 *
 * Contains a count of the successive transactions the host controller can
 * execute from a high-speed queue head on the asynchronous schedule before continuing
 * traversal of the asynchronous schedule. Valid values are 0b1 to 0b11.
 * Software must not write a zero to this field when ASPE is set as this results in
 * undefined behavior.
 */
//@{
#define BP_USBHS_USBCMD_ASP  (8U)          //!< Bit position for USBHS_USBCMD_ASP.
#define BM_USBHS_USBCMD_ASP  (0x00000300U) //!< Bit mask for USBHS_USBCMD_ASP.
#define BS_USBHS_USBCMD_ASP  (2U)          //!< Bit field size in bits for USBHS_USBCMD_ASP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_ASP field.
#define BR_USBHS_USBCMD_ASP  (HW_USBHS_USBCMD.B.ASP)
#endif

//! @brief Format value for bitfield USBHS_USBCMD_ASP.
#define BF_USBHS_USBCMD_ASP(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_ASP), uint32_t) & BM_USBHS_USBCMD_ASP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ASP field to a new value.
#define BW_USBHS_USBCMD_ASP(v) (HW_USBHS_USBCMD_WR((HW_USBHS_USBCMD_RD() & ~BM_USBHS_USBCMD_ASP) | BF_USBHS_USBCMD_ASP(v)))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field ASPE[11] (RW)
 *
 * Software uses this bit to enable or disable park mode.
 *
 * Values:
 * - 0 - Park mode disabled
 * - 1 - Park mode enabled
 */
//@{
#define BP_USBHS_USBCMD_ASPE (11U)         //!< Bit position for USBHS_USBCMD_ASPE.
#define BM_USBHS_USBCMD_ASPE (0x00000800U) //!< Bit mask for USBHS_USBCMD_ASPE.
#define BS_USBHS_USBCMD_ASPE (1U)          //!< Bit field size in bits for USBHS_USBCMD_ASPE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_ASPE field.
#define BR_USBHS_USBCMD_ASPE (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_ASPE))
#endif

//! @brief Format value for bitfield USBHS_USBCMD_ASPE.
#define BF_USBHS_USBCMD_ASPE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_ASPE), uint32_t) & BM_USBHS_USBCMD_ASPE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ASPE field to a new value.
#define BW_USBHS_USBCMD_ASPE(v) (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_ASPE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field SUTW[13] (RW)
 *
 * This is a non-EHCI bit. Used as a semaphore to ensure that the setup data
 * payload of 8 bytes is extracted from a QH by driver software without being
 * corrupted. If the setup lockout mode is off (USBMODE[SLOM] = 1) then a hazard exists
 * when new setup data arrives, and the software copies setup from the QH for a
 * previous setup packet. This bit is set and cleared by software and is cleared
 * by hardware when a hazard exists. More information appears in section "Control
 * Endpoint Operation."
 */
//@{
#define BP_USBHS_USBCMD_SUTW (13U)         //!< Bit position for USBHS_USBCMD_SUTW.
#define BM_USBHS_USBCMD_SUTW (0x00002000U) //!< Bit mask for USBHS_USBCMD_SUTW.
#define BS_USBHS_USBCMD_SUTW (1U)          //!< Bit field size in bits for USBHS_USBCMD_SUTW.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_SUTW field.
#define BR_USBHS_USBCMD_SUTW (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_SUTW))
#endif

//! @brief Format value for bitfield USBHS_USBCMD_SUTW.
#define BF_USBHS_USBCMD_SUTW(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_SUTW), uint32_t) & BM_USBHS_USBCMD_SUTW)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUTW field to a new value.
#define BW_USBHS_USBCMD_SUTW(v) (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_SUTW) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field ATDTW[14] (RW)
 *
 * This is a non-EHCI bit. This bit is used as a semaphore when a dTD is added
 * to an active (primed) endpoint. This bit is set and cleared by software. This
 * bit is also cleared by hardware when the state machine is in a hazard region
 * where adding a dTD to a primed endpoint may go unrecognized. More information
 * appears in section "Executing a Transfer Descriptor."
 */
//@{
#define BP_USBHS_USBCMD_ATDTW (14U)        //!< Bit position for USBHS_USBCMD_ATDTW.
#define BM_USBHS_USBCMD_ATDTW (0x00004000U) //!< Bit mask for USBHS_USBCMD_ATDTW.
#define BS_USBHS_USBCMD_ATDTW (1U)         //!< Bit field size in bits for USBHS_USBCMD_ATDTW.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_ATDTW field.
#define BR_USBHS_USBCMD_ATDTW (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_ATDTW))
#endif

//! @brief Format value for bitfield USBHS_USBCMD_ATDTW.
#define BF_USBHS_USBCMD_ATDTW(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_ATDTW), uint32_t) & BM_USBHS_USBCMD_ATDTW)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ATDTW field to a new value.
#define BW_USBHS_USBCMD_ATDTW(v) (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_ATDTW) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field FS2[15] (RW)
 *
 * See the FS bit description below. This is a non-EHCI bit.
 */
//@{
#define BP_USBHS_USBCMD_FS2  (15U)         //!< Bit position for USBHS_USBCMD_FS2.
#define BM_USBHS_USBCMD_FS2  (0x00008000U) //!< Bit mask for USBHS_USBCMD_FS2.
#define BS_USBHS_USBCMD_FS2  (1U)          //!< Bit field size in bits for USBHS_USBCMD_FS2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_FS2 field.
#define BR_USBHS_USBCMD_FS2  (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_FS2))
#endif

//! @brief Format value for bitfield USBHS_USBCMD_FS2.
#define BF_USBHS_USBCMD_FS2(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_FS2), uint32_t) & BM_USBHS_USBCMD_FS2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FS2 field to a new value.
#define BW_USBHS_USBCMD_FS2(v) (BITBAND_ACCESS32(HW_USBHS_USBCMD_ADDR, BP_USBHS_USBCMD_FS2) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBCMD, field ITC[23:16] (RW)
 *
 * System software uses this field to set the maximum rate at which the module
 * issues interrupts. ITC contains maximum interrupt interval measured in
 * microframes.
 *
 * Values:
 * - 0 - Immediate (no threshold)
 * - 1 - 1 microframe
 * - 10 - 2 microframes
 * - 100 - 4 microframes
 * - 1000 - 8 microframes
 * - 10000 - 16 microframes
 * - 100000 - 32 microframes
 * - 1000000 - 64 microframes
 */
//@{
#define BP_USBHS_USBCMD_ITC  (16U)         //!< Bit position for USBHS_USBCMD_ITC.
#define BM_USBHS_USBCMD_ITC  (0x00FF0000U) //!< Bit mask for USBHS_USBCMD_ITC.
#define BS_USBHS_USBCMD_ITC  (8U)          //!< Bit field size in bits for USBHS_USBCMD_ITC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBCMD_ITC field.
#define BR_USBHS_USBCMD_ITC  (HW_USBHS_USBCMD.B.ITC)
#endif

//! @brief Format value for bitfield USBHS_USBCMD_ITC.
#define BF_USBHS_USBCMD_ITC(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBCMD_ITC), uint32_t) & BM_USBHS_USBCMD_ITC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ITC field to a new value.
#define BW_USBHS_USBCMD_ITC(v) (HW_USBHS_USBCMD_WR((HW_USBHS_USBCMD_RD() & ~BM_USBHS_USBCMD_ITC) | BF_USBHS_USBCMD_ITC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_USBSTS - USB Status Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_USBSTS - USB Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates various states of each module and any pending
 * interrupts. This register does not indicate status resulting from a transaction on
 * the serial bus. Software clears certain bits in this register by writing a 1 to
 * them.
 */
typedef union _hw_usbhs_usbsts
{
    uint32_t U;
    struct _hw_usbhs_usbsts_bitfields
    {
        uint32_t UI : 1;               //!< [0] USB Interrupt (USBINT)
        uint32_t UEI : 1;              //!< [1] USB Error Interrupt
        uint32_t PCI : 1;              //!< [2] Port Change detect
        uint32_t FRI : 1;              //!< [3] Frame-list Rollover
        uint32_t SEI : 1;              //!< [4] System Error
        uint32_t AAI : 1;              //!< [5] Interrupt on Async Advance
        uint32_t URI : 1;              //!< [6] USB Reset received
        uint32_t SRI : 1;              //!< [7] SOF Received
        uint32_t SLI : 1;              //!< [8] Device-controller suspend
        uint32_t RESERVED0 : 1;        //!< [9] Reserved
        uint32_t ULPII : 1;            //!< [10] ULPI Interrupt
        uint32_t RESERVED1 : 1;        //!< [11] Reserved
        uint32_t HCH : 1;              //!< [12] Host Controller Halted
        uint32_t RCL : 1;              //!< [13] Reclamation
        uint32_t PS : 1;               //!< [14] Periodic schedule Status
        uint32_t AS : 1;               //!< [15] Asynchronous schedule Status
        uint32_t NAKI : 1;             //!< [16] NAK Interrupt
        uint32_t RESERVED2 : 1;        //!< [17] Reserved
        uint32_t UAI : 1;              //!< [18] USB host Asynchronous Interrupt
        uint32_t UPI : 1;              //!< [19] USB host Periodic Interrupt
        uint32_t RESERVED3 : 4;        //!< [23:20] Reserved
        uint32_t TI0 : 1;              //!< [24] General purpose Timer 0 Interrupt
        uint32_t TI1 : 1;              //!< [25] General purpose Timer 1 Interrupt
        uint32_t RESERVED4 : 6;        //!< [31:26] Reserved
    } B;
} hw_usbhs_usbsts_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_USBSTS register
 */
//@{
#define HW_USBHS_USBSTS_ADDR     (REGS_USBHS_BASE + 0x144U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_USBSTS          (*(__IO hw_usbhs_usbsts_t *) HW_USBHS_USBSTS_ADDR)
#define HW_USBHS_USBSTS_RD()     (HW_USBHS_USBSTS.U)
#define HW_USBHS_USBSTS_WR(v)    (HW_USBHS_USBSTS.U = (v))
#define HW_USBHS_USBSTS_SET(v)   (HW_USBHS_USBSTS_WR(HW_USBHS_USBSTS_RD() |  (v)))
#define HW_USBHS_USBSTS_CLR(v)   (HW_USBHS_USBSTS_WR(HW_USBHS_USBSTS_RD() & ~(v)))
#define HW_USBHS_USBSTS_TOG(v)   (HW_USBHS_USBSTS_WR(HW_USBHS_USBSTS_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_USBSTS bitfields
 */

/*!
 * @name Register USBHS_USBSTS, field UI[0] (W1C)
 *
 * This bit is set by the controller when the cause of an interrupt is a
 * completion of a USB transaction where the TD has an interrupt on complete (IOC) bit
 * set. This bit is also set by the controller when a short packet is detected. A
 * short packet is when the actual number of bytes received was less than the
 * expected number of bytes.
 */
//@{
#define BP_USBHS_USBSTS_UI   (0U)          //!< Bit position for USBHS_USBSTS_UI.
#define BM_USBHS_USBSTS_UI   (0x00000001U) //!< Bit mask for USBHS_USBSTS_UI.
#define BS_USBHS_USBSTS_UI   (1U)          //!< Bit field size in bits for USBHS_USBSTS_UI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_UI field.
#define BR_USBHS_USBSTS_UI   (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_UI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_UI.
#define BF_USBHS_USBSTS_UI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_UI), uint32_t) & BM_USBHS_USBSTS_UI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UI field to a new value.
#define BW_USBHS_USBSTS_UI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_UI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field UEI[1] (W1C)
 *
 * When completion of USB transaction results in error condition, the controller
 * sets this bit. If the TD on which the error interrupt occurred also had its
 * interrupt on complete (IOC) bit set, this bit is set along with the USBINT bit.
 * See Section 4.15.1 in the EHCI specification for a complete list of host
 * error interrupt conditions. See Table 24-62 for more information on device error
 * matrix.
 *
 * Values:
 * - 0 - No error
 * - 1 - Error detected
 */
//@{
#define BP_USBHS_USBSTS_UEI  (1U)          //!< Bit position for USBHS_USBSTS_UEI.
#define BM_USBHS_USBSTS_UEI  (0x00000002U) //!< Bit mask for USBHS_USBSTS_UEI.
#define BS_USBHS_USBSTS_UEI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_UEI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_UEI field.
#define BR_USBHS_USBSTS_UEI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_UEI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_UEI.
#define BF_USBHS_USBSTS_UEI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_UEI), uint32_t) & BM_USBHS_USBSTS_UEI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UEI field to a new value.
#define BW_USBHS_USBSTS_UEI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_UEI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field PCI[2] (W1C)
 *
 * This bit is not EHCI compatible. Host mode: Controller sets this bit when a
 * connect status occurs on any port, a port enable/disable change occurs, an
 * over-current change occurs, or the force port resume (PORTSCn[FPR]) bit is set as
 * the result of a J-K transition on the suspended port. Device mode: The
 * controller sets this bit when it enters the full- or high-speed operational state.
 * When it exits the full- or high-speed operation states due to reset or suspend
 * events, the notification mechanisms are URI and SLI bits respectively. The
 * device controller detects resume signaling only.
 */
//@{
#define BP_USBHS_USBSTS_PCI  (2U)          //!< Bit position for USBHS_USBSTS_PCI.
#define BM_USBHS_USBSTS_PCI  (0x00000004U) //!< Bit mask for USBHS_USBSTS_PCI.
#define BS_USBHS_USBSTS_PCI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_PCI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_PCI field.
#define BR_USBHS_USBSTS_PCI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_PCI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_PCI.
#define BF_USBHS_USBSTS_PCI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_PCI), uint32_t) & BM_USBHS_USBSTS_PCI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PCI field to a new value.
#define BW_USBHS_USBSTS_PCI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_PCI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field FRI[3] (W1C)
 *
 * Controller sets this bit when the frame list index (FRINDEX) rolls over from
 * its maximum value to 0. The exact value the rollover occurs depends on the
 * frame list size. For example, if the frame list size (as programmed in the
 * USBCMD[FS] field) is 1024, the frame index register rolls over every time
 * FRINDEX[13] toggles. Similarly, if the size is 512, the controller sets this bit each
 * time FRINDEX[12] toggles. Used only in the host mode.
 */
//@{
#define BP_USBHS_USBSTS_FRI  (3U)          //!< Bit position for USBHS_USBSTS_FRI.
#define BM_USBHS_USBSTS_FRI  (0x00000008U) //!< Bit mask for USBHS_USBSTS_FRI.
#define BS_USBHS_USBSTS_FRI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_FRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_FRI field.
#define BR_USBHS_USBSTS_FRI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_FRI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_FRI.
#define BF_USBHS_USBSTS_FRI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_FRI), uint32_t) & BM_USBHS_USBSTS_FRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FRI field to a new value.
#define BW_USBHS_USBSTS_FRI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_FRI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field SEI[4] (W1C)
 *
 * Set when an error is detected on the system bus. If the system error enable
 * bit (USBINTR[SEE]) is set, interrupt generates. The interrupt and status bits
 * remain set until cleared by writing a 1 to this bit. Additionally, when in host
 * mode, the USBCMD[RS] bit is cleared, effectively disabling controller. An
 * interrupt generates for the USBHS controller in device mode, but no other action
 * is taken.
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Error
 */
//@{
#define BP_USBHS_USBSTS_SEI  (4U)          //!< Bit position for USBHS_USBSTS_SEI.
#define BM_USBHS_USBSTS_SEI  (0x00000010U) //!< Bit mask for USBHS_USBSTS_SEI.
#define BS_USBHS_USBSTS_SEI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_SEI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_SEI field.
#define BR_USBHS_USBSTS_SEI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_SEI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_SEI.
#define BF_USBHS_USBSTS_SEI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_SEI), uint32_t) & BM_USBHS_USBSTS_SEI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SEI field to a new value.
#define BW_USBHS_USBSTS_SEI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_SEI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field AAI[5] (W1C)
 *
 * By setting the USBCMD[IAA] bit, system software can force the controller to
 * issue an interrupt the next time the controller advances the asynchronous
 * schedule. This status bit indicates the assertion of that interrupt source. Used
 * only by the host mode.
 *
 * Values:
 * - 0 - No async advance interrupt
 * - 1 - Async advance interrupt
 */
//@{
#define BP_USBHS_USBSTS_AAI  (5U)          //!< Bit position for USBHS_USBSTS_AAI.
#define BM_USBHS_USBSTS_AAI  (0x00000020U) //!< Bit mask for USBHS_USBSTS_AAI.
#define BS_USBHS_USBSTS_AAI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_AAI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_AAI field.
#define BR_USBHS_USBSTS_AAI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_AAI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_AAI.
#define BF_USBHS_USBSTS_AAI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_AAI), uint32_t) & BM_USBHS_USBSTS_AAI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AAI field to a new value.
#define BW_USBHS_USBSTS_AAI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_AAI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field URI[6] (W1C)
 *
 * A non-EHCI bit. When the controller detects a USB reset and enters the
 * default state, this bit is set. Software can write a 1 to this bit to clear it. Used
 * only by in device mode.
 *
 * Values:
 * - 0 - No reset received
 * - 1 - Reset received
 */
//@{
#define BP_USBHS_USBSTS_URI  (6U)          //!< Bit position for USBHS_USBSTS_URI.
#define BM_USBHS_USBSTS_URI  (0x00000040U) //!< Bit mask for USBHS_USBSTS_URI.
#define BS_USBHS_USBSTS_URI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_URI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_URI field.
#define BR_USBHS_USBSTS_URI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_URI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_URI.
#define BF_USBHS_USBSTS_URI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_URI), uint32_t) & BM_USBHS_USBSTS_URI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the URI field to a new value.
#define BW_USBHS_USBSTS_URI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_URI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field SRI[7] (W1C)
 *
 * This is a non-EHCI status bit. Software writes a 1 to this bit to clear it.
 * Host mode: In host mode, this bit is set every 125 ms, provided PHY clock is
 * present and running (for example, the port is NOT suspended) and can be used by
 * the host-controller driver as a time base. Device mode: When controller
 * detects a start of (micro) frame, bit is set. When a SOF is extremely late,
 * controller automatically sets this bit to indicate an SOF was expected. Therefore,
 * this bit is set roughly every 1 ms in device FS mode and every 125 us in HS mode,
 * and it is synchronized to the actual SOF received. Because the controller is
 * initialized to FS before connect, this bit is set at an interval of 1 ms
 * during the prelude to the connect and chirp.
 */
//@{
#define BP_USBHS_USBSTS_SRI  (7U)          //!< Bit position for USBHS_USBSTS_SRI.
#define BM_USBHS_USBSTS_SRI  (0x00000080U) //!< Bit mask for USBHS_USBSTS_SRI.
#define BS_USBHS_USBSTS_SRI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_SRI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_SRI field.
#define BR_USBHS_USBSTS_SRI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_SRI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_SRI.
#define BF_USBHS_USBSTS_SRI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_SRI), uint32_t) & BM_USBHS_USBSTS_SRI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SRI field to a new value.
#define BW_USBHS_USBSTS_SRI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_SRI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field SLI[8] (W1C)
 *
 * Non-EHCI bit. When a device controller enters a suspend state from an active
 * state, this bit is set. The device controller clears the bit upon exiting from
 * a suspend state. Used only by the device controller.
 *
 * Values:
 * - 0 - Active
 * - 1 - Suspended
 */
//@{
#define BP_USBHS_USBSTS_SLI  (8U)          //!< Bit position for USBHS_USBSTS_SLI.
#define BM_USBHS_USBSTS_SLI  (0x00000100U) //!< Bit mask for USBHS_USBSTS_SLI.
#define BS_USBHS_USBSTS_SLI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_SLI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_SLI field.
#define BR_USBHS_USBSTS_SLI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_SLI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_SLI.
#define BF_USBHS_USBSTS_SLI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_SLI), uint32_t) & BM_USBHS_USBSTS_SLI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLI field to a new value.
#define BW_USBHS_USBSTS_SLI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_SLI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field ULPII[10] (RO)
 *
 * Set by event completion.
 */
//@{
#define BP_USBHS_USBSTS_ULPII (10U)        //!< Bit position for USBHS_USBSTS_ULPII.
#define BM_USBHS_USBSTS_ULPII (0x00000400U) //!< Bit mask for USBHS_USBSTS_ULPII.
#define BS_USBHS_USBSTS_ULPII (1U)         //!< Bit field size in bits for USBHS_USBSTS_ULPII.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_ULPII field.
#define BR_USBHS_USBSTS_ULPII (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_ULPII))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field HCH[12] (RO)
 *
 * This bit is cleared when the USBCMD[RS] bit is set. The controller sets this
 * bit after it stops executing because of the USBCMD[RS] bit being cleared, by
 * software or the host controller hardware (for example, internal error). Used
 * only in host mode.
 *
 * Values:
 * - 0 - Running
 * - 1 - Halted
 */
//@{
#define BP_USBHS_USBSTS_HCH  (12U)         //!< Bit position for USBHS_USBSTS_HCH.
#define BM_USBHS_USBSTS_HCH  (0x00001000U) //!< Bit mask for USBHS_USBSTS_HCH.
#define BS_USBHS_USBSTS_HCH  (1U)          //!< Bit field size in bits for USBHS_USBSTS_HCH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_HCH field.
#define BR_USBHS_USBSTS_HCH  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_HCH))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field RCL[13] (RO)
 *
 * Detects an empty asynchronous schedule. Used only by the host mode.
 *
 * Values:
 * - 0 - Non-empty asynchronous schedule
 * - 1 - Empty asynchronous schedule
 */
//@{
#define BP_USBHS_USBSTS_RCL  (13U)         //!< Bit position for USBHS_USBSTS_RCL.
#define BM_USBHS_USBSTS_RCL  (0x00002000U) //!< Bit mask for USBHS_USBSTS_RCL.
#define BS_USBHS_USBSTS_RCL  (1U)          //!< Bit field size in bits for USBHS_USBSTS_RCL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_RCL field.
#define BR_USBHS_USBSTS_RCL  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_RCL))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field PS[14] (RO)
 *
 * Reports current real status of periodic schedule. Controller is not
 * immediately required to disable or enable the periodic schedule when software
 * transitions the USBCMD[PSE] bit. When this bit and the USBCMD[PSE] bit have the same
 * value, the periodic schedule is enabled or disabled. Used only in host mode.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBSTS_PS   (14U)         //!< Bit position for USBHS_USBSTS_PS.
#define BM_USBHS_USBSTS_PS   (0x00004000U) //!< Bit mask for USBHS_USBSTS_PS.
#define BS_USBHS_USBSTS_PS   (1U)          //!< Bit field size in bits for USBHS_USBSTS_PS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_PS field.
#define BR_USBHS_USBSTS_PS   (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_PS))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field AS[15] (RO)
 *
 * Reports the current real status of asynchronous schedule. Controller is not
 * immediately required to disable or enable the asynchronous schedule when
 * software transitions the USBCMD[ASE] bit. When this bit and the USBCMD[ASE] bit have
 * the same value, the asynchronous schedule is enabled (1) or disabled (0).
 * Used only in host mode.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBSTS_AS   (15U)         //!< Bit position for USBHS_USBSTS_AS.
#define BM_USBHS_USBSTS_AS   (0x00008000U) //!< Bit mask for USBHS_USBSTS_AS.
#define BS_USBHS_USBSTS_AS   (1U)          //!< Bit field size in bits for USBHS_USBSTS_AS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_AS field.
#define BR_USBHS_USBSTS_AS   (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_AS))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field NAKI[16] (RO)
 *
 * Set by hardware for a particular endpoint when the TX/RX endpoint's NAK bit
 * and the corresponding TX/RX endpoint's NAK enable bit are set. The hardware
 * automatically clears this bit when all the enabled TX/RX endpoint NAK bits are
 * cleared.
 */
//@{
#define BP_USBHS_USBSTS_NAKI (16U)         //!< Bit position for USBHS_USBSTS_NAKI.
#define BM_USBHS_USBSTS_NAKI (0x00010000U) //!< Bit mask for USBHS_USBSTS_NAKI.
#define BS_USBHS_USBSTS_NAKI (1U)          //!< Bit field size in bits for USBHS_USBSTS_NAKI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_NAKI field.
#define BR_USBHS_USBSTS_NAKI (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_NAKI))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field UAI[18] (RW)
 *
 * Set by the host controller when the cause of an interrupt is a completion of
 * a USB transaction where the transfer descriptor (TD) has an interrupt on
 * complete (IOC) bit set and the TD was from the asynchronous schedule. This bit is
 * also set by the host controller when a short packet is detected and the packet
 * is on the asynchronous schedule. A short packet is when the actual number of
 * bytes received was less than the expected number of bytes. This bit is not used
 * by the device controller and is always zero.
 */
//@{
#define BP_USBHS_USBSTS_UAI  (18U)         //!< Bit position for USBHS_USBSTS_UAI.
#define BM_USBHS_USBSTS_UAI  (0x00040000U) //!< Bit mask for USBHS_USBSTS_UAI.
#define BS_USBHS_USBSTS_UAI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_UAI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_UAI field.
#define BR_USBHS_USBSTS_UAI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_UAI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_UAI.
#define BF_USBHS_USBSTS_UAI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_UAI), uint32_t) & BM_USBHS_USBSTS_UAI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UAI field to a new value.
#define BW_USBHS_USBSTS_UAI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_UAI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field UPI[19] (RW)
 *
 * Set by the host controller when the cause of an interrupt is a completion of
 * a USB transaction where the transfer descriptor (TD) has an interrupt on
 * complete (IOC) bit set and the TD was from the periodic schedule. This bit is also
 * set by the host controller when a short packet is detected and the packet is
 * on the periodic schedule. A short packet is when the actual number of bytes
 * received was less than the expected number of bytes. This bit is not used by the
 * device controller and is always zero.
 */
//@{
#define BP_USBHS_USBSTS_UPI  (19U)         //!< Bit position for USBHS_USBSTS_UPI.
#define BM_USBHS_USBSTS_UPI  (0x00080000U) //!< Bit mask for USBHS_USBSTS_UPI.
#define BS_USBHS_USBSTS_UPI  (1U)          //!< Bit field size in bits for USBHS_USBSTS_UPI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_UPI field.
#define BR_USBHS_USBSTS_UPI  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_UPI))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_UPI.
#define BF_USBHS_USBSTS_UPI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_UPI), uint32_t) & BM_USBHS_USBSTS_UPI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UPI field to a new value.
#define BW_USBHS_USBSTS_UPI(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_UPI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field TI0[24] (W1C)
 *
 * Set when the counter in the GPTIMER0CTRL register transitions to zero.
 * Writing a one to this bit clears it.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
//@{
#define BP_USBHS_USBSTS_TI0  (24U)         //!< Bit position for USBHS_USBSTS_TI0.
#define BM_USBHS_USBSTS_TI0  (0x01000000U) //!< Bit mask for USBHS_USBSTS_TI0.
#define BS_USBHS_USBSTS_TI0  (1U)          //!< Bit field size in bits for USBHS_USBSTS_TI0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_TI0 field.
#define BR_USBHS_USBSTS_TI0  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_TI0))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_TI0.
#define BF_USBHS_USBSTS_TI0(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_TI0), uint32_t) & BM_USBHS_USBSTS_TI0)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TI0 field to a new value.
#define BW_USBHS_USBSTS_TI0(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_TI0) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBSTS, field TI1[25] (W1C)
 *
 * Set when the counter in the GPTIMER1CTRL register transitions to zero.
 * Writing a one to this bit clears it.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
//@{
#define BP_USBHS_USBSTS_TI1  (25U)         //!< Bit position for USBHS_USBSTS_TI1.
#define BM_USBHS_USBSTS_TI1  (0x02000000U) //!< Bit mask for USBHS_USBSTS_TI1.
#define BS_USBHS_USBSTS_TI1  (1U)          //!< Bit field size in bits for USBHS_USBSTS_TI1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBSTS_TI1 field.
#define BR_USBHS_USBSTS_TI1  (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_TI1))
#endif

//! @brief Format value for bitfield USBHS_USBSTS_TI1.
#define BF_USBHS_USBSTS_TI1(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBSTS_TI1), uint32_t) & BM_USBHS_USBSTS_TI1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TI1 field to a new value.
#define BW_USBHS_USBSTS_TI1(v) (BITBAND_ACCESS32(HW_USBHS_USBSTS_ADDR, BP_USBHS_USBSTS_TI1) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_USBINTR - USB Interrupt Enable Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_USBINTR - USB Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The interrupts to software are enabled with this register. An interrupt
 * generates when a bit is set and the corresponding interrupt is active. The USB
 * status register (USBSTS) continues to show interrupt sources (even if the USBINTR
 * register disables them), allowing polling of interrupt events by the software.
 */
typedef union _hw_usbhs_usbintr
{
    uint32_t U;
    struct _hw_usbhs_usbintr_bitfields
    {
        uint32_t UE : 1;               //!< [0] USB interrupt Enable
        uint32_t UEE : 1;              //!< [1] USB Error interrupt Enable
        uint32_t PCE : 1;              //!< [2] Port Change detect Enable
        uint32_t FRE : 1;              //!< [3] Frame list Rollover Enable
        uint32_t SEE : 1;              //!< [4] System Error Enable
        uint32_t AAE : 1;              //!< [5] Interrupt on Async advance Enable
        uint32_t URE : 1;              //!< [6] USB-Reset Enable
        uint32_t SRE : 1;              //!< [7] SOF-Received Enable
        uint32_t SLE : 1;              //!< [8] Sleep (DC suspend) Enable
        uint32_t RESERVED0 : 1;        //!< [9] Reserved
        uint32_t ULPIE : 1;            //!< [10] ULPI Enable
        uint32_t RESERVED1 : 5;        //!< [15:11] Reserved
        uint32_t NAKE : 1;             //!< [16] NAK Interrupt Enable
        uint32_t RESERVED2 : 1;        //!< [17] Reserved
        uint32_t UAIE : 1;             //!< [18] USB host Asynchronous Interrupt Enable
        uint32_t UPIE : 1;             //!< [19] USB host Periodic Interrupt Enable
        uint32_t RESERVED3 : 4;        //!< [23:20] Reserved
        uint32_t TIE0 : 1;             //!< [24] General purpose Timer 0 Interrupt Enable
        uint32_t TIE1 : 1;             //!< [25] General purpose Timer 1 Interrupt Enable
        uint32_t RESERVED4 : 6;        //!< [31:26] Reserved
    } B;
} hw_usbhs_usbintr_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_USBINTR register
 */
//@{
#define HW_USBHS_USBINTR_ADDR    (REGS_USBHS_BASE + 0x148U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_USBINTR         (*(__IO hw_usbhs_usbintr_t *) HW_USBHS_USBINTR_ADDR)
#define HW_USBHS_USBINTR_RD()    (HW_USBHS_USBINTR.U)
#define HW_USBHS_USBINTR_WR(v)   (HW_USBHS_USBINTR.U = (v))
#define HW_USBHS_USBINTR_SET(v)  (HW_USBHS_USBINTR_WR(HW_USBHS_USBINTR_RD() |  (v)))
#define HW_USBHS_USBINTR_CLR(v)  (HW_USBHS_USBINTR_WR(HW_USBHS_USBINTR_RD() & ~(v)))
#define HW_USBHS_USBINTR_TOG(v)  (HW_USBHS_USBINTR_WR(HW_USBHS_USBINTR_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_USBINTR bitfields
 */

/*!
 * @name Register USBHS_USBINTR, field UE[0] (RW)
 *
 * When this bit is 1 and the USBSTS[UI] bit is set, the USBHS controller issues
 * an interrupt at the next interrupt threshold. Software clearing the
 * USBSTS[UI] bit acknowledges the interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_UE  (0U)          //!< Bit position for USBHS_USBINTR_UE.
#define BM_USBHS_USBINTR_UE  (0x00000001U) //!< Bit mask for USBHS_USBINTR_UE.
#define BS_USBHS_USBINTR_UE  (1U)          //!< Bit field size in bits for USBHS_USBINTR_UE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_UE field.
#define BR_USBHS_USBINTR_UE  (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_UE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_UE.
#define BF_USBHS_USBINTR_UE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_UE), uint32_t) & BM_USBHS_USBINTR_UE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UE field to a new value.
#define BW_USBHS_USBINTR_UE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_UE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field UEE[1] (RW)
 *
 * When this bit and the USBSTS[UEI ] bit are set, controller issues an
 * interrupt at the next interrupt threshold. Software clearing the USBSTS[UEI ] bit
 * acknowledges the interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_UEE (1U)          //!< Bit position for USBHS_USBINTR_UEE.
#define BM_USBHS_USBINTR_UEE (0x00000002U) //!< Bit mask for USBHS_USBINTR_UEE.
#define BS_USBHS_USBINTR_UEE (1U)          //!< Bit field size in bits for USBHS_USBINTR_UEE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_UEE field.
#define BR_USBHS_USBINTR_UEE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_UEE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_UEE.
#define BF_USBHS_USBINTR_UEE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_UEE), uint32_t) & BM_USBHS_USBINTR_UEE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UEE field to a new value.
#define BW_USBHS_USBINTR_UEE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_UEE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field PCE[2] (RW)
 *
 * When this bit and the USBSTS[PCI] bit are set, controller issues an
 * interrupt. Software clearing the USBSTS[PCI] bit acknowledges the interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_PCE (2U)          //!< Bit position for USBHS_USBINTR_PCE.
#define BM_USBHS_USBINTR_PCE (0x00000004U) //!< Bit mask for USBHS_USBINTR_PCE.
#define BS_USBHS_USBINTR_PCE (1U)          //!< Bit field size in bits for USBHS_USBINTR_PCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_PCE field.
#define BR_USBHS_USBINTR_PCE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_PCE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_PCE.
#define BF_USBHS_USBINTR_PCE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_PCE), uint32_t) & BM_USBHS_USBINTR_PCE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PCE field to a new value.
#define BW_USBHS_USBINTR_PCE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_PCE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field FRE[3] (RW)
 *
 * When this bit and the USBSTS[FRI] bit are set, controller issues an
 * interrupt. Software clearing the USBSTS[FRI] bit acknowledges the interrupt. Used only
 * in host mode.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_FRE (3U)          //!< Bit position for USBHS_USBINTR_FRE.
#define BM_USBHS_USBINTR_FRE (0x00000008U) //!< Bit mask for USBHS_USBINTR_FRE.
#define BS_USBHS_USBINTR_FRE (1U)          //!< Bit field size in bits for USBHS_USBINTR_FRE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_FRE field.
#define BR_USBHS_USBINTR_FRE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_FRE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_FRE.
#define BF_USBHS_USBINTR_FRE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_FRE), uint32_t) & BM_USBHS_USBINTR_FRE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FRE field to a new value.
#define BW_USBHS_USBINTR_FRE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_FRE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field SEE[4] (RW)
 *
 * When this bit and the USBSTS[SEI] bit are set, controller issues an
 * interrupt. Software clearing the USBSTS[SEI] bit acknowledges the interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_SEE (4U)          //!< Bit position for USBHS_USBINTR_SEE.
#define BM_USBHS_USBINTR_SEE (0x00000010U) //!< Bit mask for USBHS_USBINTR_SEE.
#define BS_USBHS_USBINTR_SEE (1U)          //!< Bit field size in bits for USBHS_USBINTR_SEE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_SEE field.
#define BR_USBHS_USBINTR_SEE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_SEE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_SEE.
#define BF_USBHS_USBINTR_SEE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_SEE), uint32_t) & BM_USBHS_USBINTR_SEE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SEE field to a new value.
#define BW_USBHS_USBINTR_SEE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_SEE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field AAE[5] (RW)
 *
 * When this bit and the USBSTS[AAI] bit are set, controller issues an interrupt
 * at the next interrupt threshold. Software clearing the USBSTS[AAI] bit
 * acknowledges the interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_AAE (5U)          //!< Bit position for USBHS_USBINTR_AAE.
#define BM_USBHS_USBINTR_AAE (0x00000020U) //!< Bit mask for USBHS_USBINTR_AAE.
#define BS_USBHS_USBINTR_AAE (1U)          //!< Bit field size in bits for USBHS_USBINTR_AAE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_AAE field.
#define BR_USBHS_USBINTR_AAE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_AAE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_AAE.
#define BF_USBHS_USBINTR_AAE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_AAE), uint32_t) & BM_USBHS_USBINTR_AAE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AAE field to a new value.
#define BW_USBHS_USBINTR_AAE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_AAE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field URE[6] (RW)
 *
 * A non-EHCI bit. When this bit and the USBSTS[URI] bit are set, device
 * controller issues an interrupt. Software clearing the USBSTS[URI] bit acknowledges
 * the interrupt. Used only in device mode.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_URE (6U)          //!< Bit position for USBHS_USBINTR_URE.
#define BM_USBHS_USBINTR_URE (0x00000040U) //!< Bit mask for USBHS_USBINTR_URE.
#define BS_USBHS_USBINTR_URE (1U)          //!< Bit field size in bits for USBHS_USBINTR_URE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_URE field.
#define BR_USBHS_USBINTR_URE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_URE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_URE.
#define BF_USBHS_USBINTR_URE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_URE), uint32_t) & BM_USBHS_USBINTR_URE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the URE field to a new value.
#define BW_USBHS_USBINTR_URE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_URE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field SRE[7] (RW)
 *
 * This is a non-EHCI bit. When this bit and the USBSTS[SRI] bit are set,
 * controller issues an interrupt. Software clearing the USBSTS[SRI] bit acknowledges
 * the interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_SRE (7U)          //!< Bit position for USBHS_USBINTR_SRE.
#define BM_USBHS_USBINTR_SRE (0x00000080U) //!< Bit mask for USBHS_USBINTR_SRE.
#define BS_USBHS_USBINTR_SRE (1U)          //!< Bit field size in bits for USBHS_USBINTR_SRE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_SRE field.
#define BR_USBHS_USBINTR_SRE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_SRE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_SRE.
#define BF_USBHS_USBINTR_SRE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_SRE), uint32_t) & BM_USBHS_USBINTR_SRE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_USBHS_USBINTR_SRE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_SRE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field SLE[8] (RW)
 *
 * A non-EHCI bit. When this bit is set and the USBSTS[SLI] bit transitions,
 * USBHS controller issues an interrupt. Software writing a 1 to the USBSTS[SLI] bit
 * acknowledges the interrupt. Used only in device mode.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_SLE (8U)          //!< Bit position for USBHS_USBINTR_SLE.
#define BM_USBHS_USBINTR_SLE (0x00000100U) //!< Bit mask for USBHS_USBINTR_SLE.
#define BS_USBHS_USBINTR_SLE (1U)          //!< Bit field size in bits for USBHS_USBINTR_SLE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_SLE field.
#define BR_USBHS_USBINTR_SLE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_SLE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_SLE.
#define BF_USBHS_USBINTR_SLE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_SLE), uint32_t) & BM_USBHS_USBINTR_SLE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLE field to a new value.
#define BW_USBHS_USBINTR_SLE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_SLE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field ULPIE[10] (RW)
 *
 * When this bit and USBSTS[ULPII] are set, controller issues an interrupt. The
 * interrupt is acknowledged by writing a 1 to USBSTS[ULPII].
 */
//@{
#define BP_USBHS_USBINTR_ULPIE (10U)       //!< Bit position for USBHS_USBINTR_ULPIE.
#define BM_USBHS_USBINTR_ULPIE (0x00000400U) //!< Bit mask for USBHS_USBINTR_ULPIE.
#define BS_USBHS_USBINTR_ULPIE (1U)        //!< Bit field size in bits for USBHS_USBINTR_ULPIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_ULPIE field.
#define BR_USBHS_USBINTR_ULPIE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_ULPIE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_ULPIE.
#define BF_USBHS_USBINTR_ULPIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_ULPIE), uint32_t) & BM_USBHS_USBINTR_ULPIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ULPIE field to a new value.
#define BW_USBHS_USBINTR_ULPIE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_ULPIE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field NAKE[16] (RW)
 *
 * When this bit and the USBSTS[NAKI] bit are set, an interrupt generates.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_NAKE (16U)        //!< Bit position for USBHS_USBINTR_NAKE.
#define BM_USBHS_USBINTR_NAKE (0x00010000U) //!< Bit mask for USBHS_USBINTR_NAKE.
#define BS_USBHS_USBINTR_NAKE (1U)         //!< Bit field size in bits for USBHS_USBINTR_NAKE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_NAKE field.
#define BR_USBHS_USBINTR_NAKE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_NAKE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_NAKE.
#define BF_USBHS_USBINTR_NAKE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_NAKE), uint32_t) & BM_USBHS_USBINTR_NAKE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NAKE field to a new value.
#define BW_USBHS_USBINTR_NAKE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_NAKE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field UAIE[18] (RW)
 *
 * When this bit and USBSTS[USBHSTASYNCINT] are set, the host controller issues
 * an interrupt at the next interrupt threshold. The interrupt is acknowledged by
 * clearing USBHSTASYNCINT.
 */
//@{
#define BP_USBHS_USBINTR_UAIE (18U)        //!< Bit position for USBHS_USBINTR_UAIE.
#define BM_USBHS_USBINTR_UAIE (0x00040000U) //!< Bit mask for USBHS_USBINTR_UAIE.
#define BS_USBHS_USBINTR_UAIE (1U)         //!< Bit field size in bits for USBHS_USBINTR_UAIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_UAIE field.
#define BR_USBHS_USBINTR_UAIE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_UAIE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_UAIE.
#define BF_USBHS_USBINTR_UAIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_UAIE), uint32_t) & BM_USBHS_USBINTR_UAIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UAIE field to a new value.
#define BW_USBHS_USBINTR_UAIE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_UAIE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field UPIE[19] (RW)
 *
 * When this bit and USBSTS[USBHSTPERINT] are set, the host controller issues an
 * interrupt at the next interrupt threshold. The interrupt is acknowledged by
 * clearing USBHSTPERINT.
 */
//@{
#define BP_USBHS_USBINTR_UPIE (19U)        //!< Bit position for USBHS_USBINTR_UPIE.
#define BM_USBHS_USBINTR_UPIE (0x00080000U) //!< Bit mask for USBHS_USBINTR_UPIE.
#define BS_USBHS_USBINTR_UPIE (1U)         //!< Bit field size in bits for USBHS_USBINTR_UPIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_UPIE field.
#define BR_USBHS_USBINTR_UPIE (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_UPIE))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_UPIE.
#define BF_USBHS_USBINTR_UPIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_UPIE), uint32_t) & BM_USBHS_USBINTR_UPIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UPIE field to a new value.
#define BW_USBHS_USBINTR_UPIE(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_UPIE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field TIE0[24] (RW)
 *
 * When this bit and USBSTS[GPTINT0] are set, the USB controller issues an
 * interrupt to the processor. The interrupt is acknowledged by clearing GPTINT0.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_TIE0 (24U)        //!< Bit position for USBHS_USBINTR_TIE0.
#define BM_USBHS_USBINTR_TIE0 (0x01000000U) //!< Bit mask for USBHS_USBINTR_TIE0.
#define BS_USBHS_USBINTR_TIE0 (1U)         //!< Bit field size in bits for USBHS_USBINTR_TIE0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_TIE0 field.
#define BR_USBHS_USBINTR_TIE0 (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_TIE0))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_TIE0.
#define BF_USBHS_USBINTR_TIE0(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_TIE0), uint32_t) & BM_USBHS_USBINTR_TIE0)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIE0 field to a new value.
#define BW_USBHS_USBINTR_TIE0(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_TIE0) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBINTR, field TIE1[25] (RW)
 *
 * When this bit and USBSTS[GPTINT1] are set, the USB controller issues an
 * interrupt to the processor. The interrupt is acknowledged by clearing GPTINT1.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBINTR_TIE1 (25U)        //!< Bit position for USBHS_USBINTR_TIE1.
#define BM_USBHS_USBINTR_TIE1 (0x02000000U) //!< Bit mask for USBHS_USBINTR_TIE1.
#define BS_USBHS_USBINTR_TIE1 (1U)         //!< Bit field size in bits for USBHS_USBINTR_TIE1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBINTR_TIE1 field.
#define BR_USBHS_USBINTR_TIE1 (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_TIE1))
#endif

//! @brief Format value for bitfield USBHS_USBINTR_TIE1.
#define BF_USBHS_USBINTR_TIE1(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBINTR_TIE1), uint32_t) & BM_USBHS_USBINTR_TIE1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIE1 field to a new value.
#define BW_USBHS_USBINTR_TIE1(v) (BITBAND_ACCESS32(HW_USBHS_USBINTR_ADDR, BP_USBHS_USBINTR_TIE1) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_FRINDEX - Frame Index Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_FRINDEX - Frame Index Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * In host mode, the controller uses this register to index the periodic frame
 * list. The register updates every 125 microseconds (once each microframe). Bits
 * [N-3] select a particular entry in the periodic frame list during periodic
 * schedule execution. The number of bits used for the index depends on the size of
 * the frame list as set by system software in the USBCMD[FS] field. Only perform
 * 32-bit accesses to this register. Byte writes produce undefined results. This
 * register cannot be written unless the USBHS controller is in halted state as
 * the USBSTS[HCH] bit indicates. A write to this register while the USBSTS[RS]
 * bit is set produces undefined results. Writes to this register also affect the
 * SOF value. In device mode, this register is read-only, and the USBHS
 * controller updates the FRINDEX[13-3] bits from the frame number the SOF marker
 * indicates. When the USB bus receives a SOF, FRINDEX[13-3] checks against the SOF
 * marker. If FRINDEX[13-3] is different from the SOF marker, FRINDEX[13-3] is set to
 * the SOF value and FRINDEX[2-0] is cleared (SOF for 1 ms frame). If
 * FRINDEX[13-3] equals the SOF value, FRINDEX[2-0] is incremented (SOF for 125 microsec
 * microframe.)
 */
typedef union _hw_usbhs_frindex
{
    uint32_t U;
    struct _hw_usbhs_frindex_bitfields
    {
        uint32_t FRINDEX : 14;         //!< [13:0] Frame Index
        uint32_t Reerved : 18;         //!< [31:14] Reserved
    } B;
} hw_usbhs_frindex_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_FRINDEX register
 */
//@{
#define HW_USBHS_FRINDEX_ADDR    (REGS_USBHS_BASE + 0x14CU)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_FRINDEX         (*(__IO hw_usbhs_frindex_t *) HW_USBHS_FRINDEX_ADDR)
#define HW_USBHS_FRINDEX_RD()    (HW_USBHS_FRINDEX.U)
#define HW_USBHS_FRINDEX_WR(v)   (HW_USBHS_FRINDEX.U = (v))
#define HW_USBHS_FRINDEX_SET(v)  (HW_USBHS_FRINDEX_WR(HW_USBHS_FRINDEX_RD() |  (v)))
#define HW_USBHS_FRINDEX_CLR(v)  (HW_USBHS_FRINDEX_WR(HW_USBHS_FRINDEX_RD() & ~(v)))
#define HW_USBHS_FRINDEX_TOG(v)  (HW_USBHS_FRINDEX_WR(HW_USBHS_FRINDEX_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_FRINDEX bitfields
 */

/*!
 * @name Register USBHS_FRINDEX, field FRINDEX[13:0] (RW)
 *
 * The value in this register increments at the end of each time frame
 * (microframe). Bits [N- 3] are for the frame list current index. This means each
 * location of the frame list is accessed 8 times per frame (once each microframe)
 * before moving to the next index. In device mode, the value is the current frame
 * number of the last frame transmitted and not used as an index. In either mode,
 * bits 2-0 indicate current microframe. The table illustrates values of N based on
 * the value of the USBCMD[FS] field when used in host mode. FRINDEX N Values
 * USBCMD[FS] Frame List Size FRINDEX N value 000 1024 elements (4096 bytes) 12 001
 * 512 elements (2048 bytes) 11 010 256 elements (1024 bytes) 10 011 128
 * elements (512 bytes) 9 100 64 elements (256 bytes) 8 101 32 elements (128 bytes) 7
 * 110 16 elements (64 bytes) 6 111 8 elements (32 bytes) 5
 */
//@{
#define BP_USBHS_FRINDEX_FRINDEX (0U)      //!< Bit position for USBHS_FRINDEX_FRINDEX.
#define BM_USBHS_FRINDEX_FRINDEX (0x00003FFFU) //!< Bit mask for USBHS_FRINDEX_FRINDEX.
#define BS_USBHS_FRINDEX_FRINDEX (14U)     //!< Bit field size in bits for USBHS_FRINDEX_FRINDEX.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_FRINDEX_FRINDEX field.
#define BR_USBHS_FRINDEX_FRINDEX (HW_USBHS_FRINDEX.B.FRINDEX)
#endif

//! @brief Format value for bitfield USBHS_FRINDEX_FRINDEX.
#define BF_USBHS_FRINDEX_FRINDEX(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_FRINDEX_FRINDEX), uint32_t) & BM_USBHS_FRINDEX_FRINDEX)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FRINDEX field to a new value.
#define BW_USBHS_FRINDEX_FRINDEX(v) (HW_USBHS_FRINDEX_WR((HW_USBHS_FRINDEX_RD() & ~BM_USBHS_FRINDEX_FRINDEX) | BF_USBHS_FRINDEX_FRINDEX(v)))
#endif
//@}

/*!
 * @name Register USBHS_FRINDEX, field Reerved[31:14] (ROZ)
 *
 * Must be cleared.
 */
//@{
#define BP_USBHS_FRINDEX_Reerved (14U)     //!< Bit position for USBHS_FRINDEX_Reerved.
#define BM_USBHS_FRINDEX_Reerved (0xFFFFC000U) //!< Bit mask for USBHS_FRINDEX_Reerved.
#define BS_USBHS_FRINDEX_Reerved (18U)     //!< Bit field size in bits for USBHS_FRINDEX_Reerved.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_FRINDEX_Reerved field.
#define BR_USBHS_FRINDEX_Reerved (HW_USBHS_FRINDEX.B.Reerved)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_DEVICEADDR - Device Address Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_DEVICEADDR - Device Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is not defined in the EHCI specification. For device mode, the
 * upper seven bits of this register represent the device address. After any
 * controller or USB reset, the device address is set to the default address (0). The
 * default address matches all incoming addresses. Software reprograms the
 * address after receiving a SET_ADDRESS descriptor. The host and device mode
 * functions share this register. In device mode, it is the DEVICEADDR register; in host
 * mode, it is the PERIODICLISTBASE register. See section "Periodic Frame List
 * Base Address Register (PERIODICLISTBASE)," for more information.
 */
typedef union _hw_usbhs_deviceaddr
{
    uint32_t U;
    struct _hw_usbhs_deviceaddr_bitfields
    {
        uint32_t RESERVED0 : 24;       //!< [23:0] Reserved
        uint32_t USBADRA : 1;          //!< [24] Device Address Advance
        uint32_t USBADR : 7;           //!< [31:25] Device Address
    } B;
} hw_usbhs_deviceaddr_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_DEVICEADDR register
 */
//@{
#define HW_USBHS_DEVICEADDR_ADDR (REGS_USBHS_BASE + 0x154U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_DEVICEADDR      (*(__IO hw_usbhs_deviceaddr_t *) HW_USBHS_DEVICEADDR_ADDR)
#define HW_USBHS_DEVICEADDR_RD() (HW_USBHS_DEVICEADDR.U)
#define HW_USBHS_DEVICEADDR_WR(v) (HW_USBHS_DEVICEADDR.U = (v))
#define HW_USBHS_DEVICEADDR_SET(v) (HW_USBHS_DEVICEADDR_WR(HW_USBHS_DEVICEADDR_RD() |  (v)))
#define HW_USBHS_DEVICEADDR_CLR(v) (HW_USBHS_DEVICEADDR_WR(HW_USBHS_DEVICEADDR_RD() & ~(v)))
#define HW_USBHS_DEVICEADDR_TOG(v) (HW_USBHS_DEVICEADDR_WR(HW_USBHS_DEVICEADDR_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_DEVICEADDR bitfields
 */

/*!
 * @name Register USBHS_DEVICEADDR, field USBADRA[24] (RW)
 *
 * This field provides a mechanism for staging the device address in advance.
 * After the status phase of the SET_ADDRESS descriptor, the DCD has 2 ms to
 * program the USBADR field. This mechanism ensures this specification is met when the
 * DCD cannot write to the device address within 2 ms from the SET_ADDRESS status
 * phase. If the DCD writes the USBADR with USBADRA equaling 1 after the
 * SET_ADDRESS data phase (before the prime of the status phase), the USBADR is
 * programmed instantly at the correct time and meets the 2 ms USB requirement. Hardware
 * automatically clears this bit on the following conditions: IN is ACKed to
 * endpoint 0. (USBADR is updated from staging register.) OUT/SETUP occur to endpoint
 * 0. (USBADR is not updated.) Device Reset occurs. (USBADR is reset to 0.)
 *
 * Values:
 * - 0 - Writes to USBADR are instantaneous.
 * - 1 - When this bit is written to a 1 at the same time or before USBADR is
 *     written, the write to the USBADR field is staged and held in a hidden
 *     register. After an IN occurs on endpoint 0 and is ACKed, USBADR is loaded from
 *     the holding register.
 */
//@{
#define BP_USBHS_DEVICEADDR_USBADRA (24U)  //!< Bit position for USBHS_DEVICEADDR_USBADRA.
#define BM_USBHS_DEVICEADDR_USBADRA (0x01000000U) //!< Bit mask for USBHS_DEVICEADDR_USBADRA.
#define BS_USBHS_DEVICEADDR_USBADRA (1U)   //!< Bit field size in bits for USBHS_DEVICEADDR_USBADRA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_DEVICEADDR_USBADRA field.
#define BR_USBHS_DEVICEADDR_USBADRA (BITBAND_ACCESS32(HW_USBHS_DEVICEADDR_ADDR, BP_USBHS_DEVICEADDR_USBADRA))
#endif

//! @brief Format value for bitfield USBHS_DEVICEADDR_USBADRA.
#define BF_USBHS_DEVICEADDR_USBADRA(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_DEVICEADDR_USBADRA), uint32_t) & BM_USBHS_DEVICEADDR_USBADRA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the USBADRA field to a new value.
#define BW_USBHS_DEVICEADDR_USBADRA(v) (BITBAND_ACCESS32(HW_USBHS_DEVICEADDR_ADDR, BP_USBHS_DEVICEADDR_USBADRA) = (v))
#endif
//@}

/*!
 * @name Register USBHS_DEVICEADDR, field USBADR[31:25] (RW)
 *
 * This field corresponds to the USB device address.
 */
//@{
#define BP_USBHS_DEVICEADDR_USBADR (25U)   //!< Bit position for USBHS_DEVICEADDR_USBADR.
#define BM_USBHS_DEVICEADDR_USBADR (0xFE000000U) //!< Bit mask for USBHS_DEVICEADDR_USBADR.
#define BS_USBHS_DEVICEADDR_USBADR (7U)    //!< Bit field size in bits for USBHS_DEVICEADDR_USBADR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_DEVICEADDR_USBADR field.
#define BR_USBHS_DEVICEADDR_USBADR (HW_USBHS_DEVICEADDR.B.USBADR)
#endif

//! @brief Format value for bitfield USBHS_DEVICEADDR_USBADR.
#define BF_USBHS_DEVICEADDR_USBADR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_DEVICEADDR_USBADR), uint32_t) & BM_USBHS_DEVICEADDR_USBADR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the USBADR field to a new value.
#define BW_USBHS_DEVICEADDR_USBADR(v) (HW_USBHS_DEVICEADDR_WR((HW_USBHS_DEVICEADDR_RD() & ~BM_USBHS_DEVICEADDR_USBADR) | BF_USBHS_DEVICEADDR_USBADR(v)))
#endif
//@}
//-------------------------------------------------------------------------------------------
// HW_USBHS_PERIODICLISTBASE - Periodic Frame List Base Address Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_PERIODICLISTBASE - Periodic Frame List Base Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the beginning address of the periodic frame list in
 * the system memory. The host controller driver loads this register prior to
 * starting the schedule execution by the controller. The memory structure referenced
 * by this physical memory pointer assumes to be 4-Kbyte aligned. The contents
 * combine with the FRINDEX register to enable the controller to step through the
 * periodic frame list in sequence. The host and device mode functions share this
 * register. In host mode, it is the PERIODICLISTBASE register; in device mode,
 * it is the DEVICEADDR register. See section "Device Address Register
 * (DEVICEADDR)," for more information.
 */
typedef union _hw_usbhs_periodiclistbase
{
    uint32_t U;
    struct _hw_usbhs_periodiclistbase_bitfields
    {
        uint32_t RESERVED0 : 12;       //!< [11:0] Reserved
        uint32_t PERBASE : 20;         //!< [31:12] Base address
    } B;
} hw_usbhs_periodiclistbase_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_PERIODICLISTBASE register
 */
//@{
#define HW_USBHS_PERIODICLISTBASE_ADDR (REGS_USBHS_BASE + 0x154U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_PERIODICLISTBASE (*(__IO hw_usbhs_periodiclistbase_t *) HW_USBHS_PERIODICLISTBASE_ADDR)
#define HW_USBHS_PERIODICLISTBASE_RD() (HW_USBHS_PERIODICLISTBASE.U)
#define HW_USBHS_PERIODICLISTBASE_WR(v) (HW_USBHS_PERIODICLISTBASE.U = (v))
#define HW_USBHS_PERIODICLISTBASE_SET(v) (HW_USBHS_PERIODICLISTBASE_WR(HW_USBHS_PERIODICLISTBASE_RD() |  (v)))
#define HW_USBHS_PERIODICLISTBASE_CLR(v) (HW_USBHS_PERIODICLISTBASE_WR(HW_USBHS_PERIODICLISTBASE_RD() & ~(v)))
#define HW_USBHS_PERIODICLISTBASE_TOG(v) (HW_USBHS_PERIODICLISTBASE_WR(HW_USBHS_PERIODICLISTBASE_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_PERIODICLISTBASE bitfields
 */

/*!
 * @name Register USBHS_PERIODICLISTBASE, field PERBASE[31:12] (RW)
 *
 * These bits correspond to memory address signal [31:12]. Used only in the host
 * mode.
 */
//@{
#define BP_USBHS_PERIODICLISTBASE_PERBASE (12U) //!< Bit position for USBHS_PERIODICLISTBASE_PERBASE.
#define BM_USBHS_PERIODICLISTBASE_PERBASE (0xFFFFF000U) //!< Bit mask for USBHS_PERIODICLISTBASE_PERBASE.
#define BS_USBHS_PERIODICLISTBASE_PERBASE (20U) //!< Bit field size in bits for USBHS_PERIODICLISTBASE_PERBASE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PERIODICLISTBASE_PERBASE field.
#define BR_USBHS_PERIODICLISTBASE_PERBASE (HW_USBHS_PERIODICLISTBASE.B.PERBASE)
#endif

//! @brief Format value for bitfield USBHS_PERIODICLISTBASE_PERBASE.
#define BF_USBHS_PERIODICLISTBASE_PERBASE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PERIODICLISTBASE_PERBASE), uint32_t) & BM_USBHS_PERIODICLISTBASE_PERBASE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PERBASE field to a new value.
#define BW_USBHS_PERIODICLISTBASE_PERBASE(v) (HW_USBHS_PERIODICLISTBASE_WR((HW_USBHS_PERIODICLISTBASE_RD() & ~BM_USBHS_PERIODICLISTBASE_PERBASE) | BF_USBHS_PERIODICLISTBASE_PERBASE(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_ASYNCLISTADDR - Current Asynchronous List Address Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_ASYNCLISTADDR - Current Asynchronous List Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ASYNCLISTADDR register contains the address of the next asynchronous
 * queue head to executed by the host. The host and device mode functions share this
 * register. In host mode, it is the ASYNCLISTADDR register; in device mode, it
 * is the EPLISTADDR register. See section "Endpoint List Address Register
 * (EPLISTADDR)," for more information.
 */
typedef union _hw_usbhs_asynclistaddr
{
    uint32_t U;
    struct _hw_usbhs_asynclistaddr_bitfields
    {
        uint32_t RESERVED0 : 5;        //!< [4:0] Reserved
        uint32_t ASYBASE : 27;         //!< [31:5] Link pointer low (LPL)
    } B;
} hw_usbhs_asynclistaddr_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_ASYNCLISTADDR register
 */
//@{
#define HW_USBHS_ASYNCLISTADDR_ADDR (REGS_USBHS_BASE + 0x158U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_ASYNCLISTADDR   (*(__IO hw_usbhs_asynclistaddr_t *) HW_USBHS_ASYNCLISTADDR_ADDR)
#define HW_USBHS_ASYNCLISTADDR_RD() (HW_USBHS_ASYNCLISTADDR.U)
#define HW_USBHS_ASYNCLISTADDR_WR(v) (HW_USBHS_ASYNCLISTADDR.U = (v))
#define HW_USBHS_ASYNCLISTADDR_SET(v) (HW_USBHS_ASYNCLISTADDR_WR(HW_USBHS_ASYNCLISTADDR_RD() |  (v)))
#define HW_USBHS_ASYNCLISTADDR_CLR(v) (HW_USBHS_ASYNCLISTADDR_WR(HW_USBHS_ASYNCLISTADDR_RD() & ~(v)))
#define HW_USBHS_ASYNCLISTADDR_TOG(v) (HW_USBHS_ASYNCLISTADDR_WR(HW_USBHS_ASYNCLISTADDR_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_ASYNCLISTADDR bitfields
 */

/*!
 * @name Register USBHS_ASYNCLISTADDR, field ASYBASE[31:5] (RW)
 *
 * These bits correspond to memory address signal [31:5]. This field may only
 * reference a queue head (QH). Used only in host mode.
 */
//@{
#define BP_USBHS_ASYNCLISTADDR_ASYBASE (5U) //!< Bit position for USBHS_ASYNCLISTADDR_ASYBASE.
#define BM_USBHS_ASYNCLISTADDR_ASYBASE (0xFFFFFFE0U) //!< Bit mask for USBHS_ASYNCLISTADDR_ASYBASE.
#define BS_USBHS_ASYNCLISTADDR_ASYBASE (27U) //!< Bit field size in bits for USBHS_ASYNCLISTADDR_ASYBASE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ASYNCLISTADDR_ASYBASE field.
#define BR_USBHS_ASYNCLISTADDR_ASYBASE (HW_USBHS_ASYNCLISTADDR.B.ASYBASE)
#endif

//! @brief Format value for bitfield USBHS_ASYNCLISTADDR_ASYBASE.
#define BF_USBHS_ASYNCLISTADDR_ASYBASE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ASYNCLISTADDR_ASYBASE), uint32_t) & BM_USBHS_ASYNCLISTADDR_ASYBASE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ASYBASE field to a new value.
#define BW_USBHS_ASYNCLISTADDR_ASYBASE(v) (HW_USBHS_ASYNCLISTADDR_WR((HW_USBHS_ASYNCLISTADDR_RD() & ~BM_USBHS_ASYNCLISTADDR_ASYBASE) | BF_USBHS_ASYNCLISTADDR_ASYBASE(v)))
#endif
//@}
//-------------------------------------------------------------------------------------------
// HW_USBHS_EPLISTADDR - Endpoint List Address Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPLISTADDR - Endpoint List Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is not defined in the EHCI specification. For device mode, this
 * register contains the address of the endpoint list top in system memory. The
 * memory structure referenced by this physical memory pointer assumes to be
 * 64-bytes. The queue head is actually a 48-byte structure, but must be aligned on
 * 64-byte boundary. However, the EPBASE field has a granularity of 2 Kbytes; in
 * practice, the queue head should be 2-Kbyte aligned. The host and device mode
 * functions share this register. In device mode, it is the EPLISTADDR register; in
 * host mode, it is the ASYNCLISTADDR register. See section "Current
 * Asynchronous List Address Register (ASYNCLISTADDR)," for more information.
 */
typedef union _hw_usbhs_eplistaddr
{
    uint32_t U;
    struct _hw_usbhs_eplistaddr_bitfields
    {
        uint32_t RESERVED0 : 11;       //!< [10:0] Reserved
        uint32_t EPBASE : 21;          //!< [31:11] Endpoint list address
    } B;
} hw_usbhs_eplistaddr_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPLISTADDR register
 */
//@{
#define HW_USBHS_EPLISTADDR_ADDR (REGS_USBHS_BASE + 0x158U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPLISTADDR      (*(__IO hw_usbhs_eplistaddr_t *) HW_USBHS_EPLISTADDR_ADDR)
#define HW_USBHS_EPLISTADDR_RD() (HW_USBHS_EPLISTADDR.U)
#define HW_USBHS_EPLISTADDR_WR(v) (HW_USBHS_EPLISTADDR.U = (v))
#define HW_USBHS_EPLISTADDR_SET(v) (HW_USBHS_EPLISTADDR_WR(HW_USBHS_EPLISTADDR_RD() |  (v)))
#define HW_USBHS_EPLISTADDR_CLR(v) (HW_USBHS_EPLISTADDR_WR(HW_USBHS_EPLISTADDR_RD() & ~(v)))
#define HW_USBHS_EPLISTADDR_TOG(v) (HW_USBHS_EPLISTADDR_WR(HW_USBHS_EPLISTADDR_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPLISTADDR bitfields
 */

/*!
 * @name Register USBHS_EPLISTADDR, field EPBASE[31:11] (RW)
 *
 * Correspond to memory address signals [31:11] References a list of up to 32
 * queue heads (i.e. one queue head per endpoint and direction). Address of the top
 * of the endpoint list.
 */
//@{
#define BP_USBHS_EPLISTADDR_EPBASE (11U)   //!< Bit position for USBHS_EPLISTADDR_EPBASE.
#define BM_USBHS_EPLISTADDR_EPBASE (0xFFFFF800U) //!< Bit mask for USBHS_EPLISTADDR_EPBASE.
#define BS_USBHS_EPLISTADDR_EPBASE (21U)   //!< Bit field size in bits for USBHS_EPLISTADDR_EPBASE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPLISTADDR_EPBASE field.
#define BR_USBHS_EPLISTADDR_EPBASE (HW_USBHS_EPLISTADDR.B.EPBASE)
#endif

//! @brief Format value for bitfield USBHS_EPLISTADDR_EPBASE.
#define BF_USBHS_EPLISTADDR_EPBASE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPLISTADDR_EPBASE), uint32_t) & BM_USBHS_EPLISTADDR_EPBASE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EPBASE field to a new value.
#define BW_USBHS_EPLISTADDR_EPBASE(v) (HW_USBHS_EPLISTADDR_WR((HW_USBHS_EPLISTADDR_RD() & ~BM_USBHS_EPLISTADDR_EPBASE) | BF_USBHS_EPLISTADDR_EPBASE(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_TTCTRL - Host TT Asynchronous Buffer Control
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_TTCTRL - Host TT Asynchronous Buffer Control (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_usbhs_ttctrl
{
    uint32_t U;
    struct _hw_usbhs_ttctrl_bitfields
    {
        uint32_t RESERVED0 : 24;       //!< [23:0] Reserved
        uint32_t TTHA : 7;             //!< [30:24] TT Hub Address
        uint32_t Reerved : 1;          //!< [31] Reserved
    } B;
} hw_usbhs_ttctrl_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_TTCTRL register
 */
//@{
#define HW_USBHS_TTCTRL_ADDR     (REGS_USBHS_BASE + 0x15CU)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_TTCTRL          (*(__I hw_usbhs_ttctrl_t *) HW_USBHS_TTCTRL_ADDR)
#define HW_USBHS_TTCTRL_RD()     (HW_USBHS_TTCTRL.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_TTCTRL bitfields
 */

/*!
 * @name Register USBHS_TTCTRL, field TTHA[30:24] (RO)
 *
 * This field is used to match against the Hub Address field in a QH or siTD to
 * determine if the packet is routed to the internal TT for directly attached
 * FS/LS devices. If the hub address in the QH or siTD does not match this address
 * then the packet is broadcast on the high speed ports destined for a downstream
 * HS hub with the address in the QH or siTD.
 */
//@{
#define BP_USBHS_TTCTRL_TTHA (24U)         //!< Bit position for USBHS_TTCTRL_TTHA.
#define BM_USBHS_TTCTRL_TTHA (0x7F000000U) //!< Bit mask for USBHS_TTCTRL_TTHA.
#define BS_USBHS_TTCTRL_TTHA (7U)          //!< Bit field size in bits for USBHS_TTCTRL_TTHA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_TTCTRL_TTHA field.
#define BR_USBHS_TTCTRL_TTHA (HW_USBHS_TTCTRL.B.TTHA)
#endif
//@}

/*!
 * @name Register USBHS_TTCTRL, field Reerved[31] (ROZ)
 *
 * Must ne cleared.
 */
//@{
#define BP_USBHS_TTCTRL_Reerved (31U)      //!< Bit position for USBHS_TTCTRL_Reerved.
#define BM_USBHS_TTCTRL_Reerved (0x80000000U) //!< Bit mask for USBHS_TTCTRL_Reerved.
#define BS_USBHS_TTCTRL_Reerved (1U)       //!< Bit field size in bits for USBHS_TTCTRL_Reerved.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_TTCTRL_Reerved field.
#define BR_USBHS_TTCTRL_Reerved (BITBAND_ACCESS32(HW_USBHS_TTCTRL_ADDR, BP_USBHS_TTCTRL_Reerved))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_BURSTSIZE - Master Interface Data Burst Size Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_BURSTSIZE - Master Interface Data Burst Size Register (RW)
 *
 * Reset value: 0x00008080U
 *
 * This register is not defined in the EHCI specification. BURSTSIZE dynamically
 * controls the burst size during data movement on the initiator (master)
 * interface.
 */
typedef union _hw_usbhs_burstsize
{
    uint32_t U;
    struct _hw_usbhs_burstsize_bitfields
    {
        uint32_t RXPBURST : 8;         //!< [7:0] Programable RX Burst length
        uint32_t TXPBURST : 8;         //!< [15:8] Programable TX Burst length
        uint32_t RESERVED0 : 16;       //!< [31:16] Reserved
    } B;
} hw_usbhs_burstsize_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_BURSTSIZE register
 */
//@{
#define HW_USBHS_BURSTSIZE_ADDR  (REGS_USBHS_BASE + 0x160U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_BURSTSIZE       (*(__IO hw_usbhs_burstsize_t *) HW_USBHS_BURSTSIZE_ADDR)
#define HW_USBHS_BURSTSIZE_RD()  (HW_USBHS_BURSTSIZE.U)
#define HW_USBHS_BURSTSIZE_WR(v) (HW_USBHS_BURSTSIZE.U = (v))
#define HW_USBHS_BURSTSIZE_SET(v) (HW_USBHS_BURSTSIZE_WR(HW_USBHS_BURSTSIZE_RD() |  (v)))
#define HW_USBHS_BURSTSIZE_CLR(v) (HW_USBHS_BURSTSIZE_WR(HW_USBHS_BURSTSIZE_RD() & ~(v)))
#define HW_USBHS_BURSTSIZE_TOG(v) (HW_USBHS_BURSTSIZE_WR(HW_USBHS_BURSTSIZE_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_BURSTSIZE bitfields
 */

/*!
 * @name Register USBHS_BURSTSIZE, field RXPBURST[7:0] (RW)
 *
 * This register represents the maximum length of a burst in 32-bit words while
 * moving data from the USB bus to system memory. Must not be set to greater than
 * 16. If the BURSTSIZE field of register SBUSCFG is non-zero, the RXPBURST
 * field returns the value of the INCRx length.
 */
//@{
#define BP_USBHS_BURSTSIZE_RXPBURST (0U)   //!< Bit position for USBHS_BURSTSIZE_RXPBURST.
#define BM_USBHS_BURSTSIZE_RXPBURST (0x000000FFU) //!< Bit mask for USBHS_BURSTSIZE_RXPBURST.
#define BS_USBHS_BURSTSIZE_RXPBURST (8U)   //!< Bit field size in bits for USBHS_BURSTSIZE_RXPBURST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_BURSTSIZE_RXPBURST field.
#define BR_USBHS_BURSTSIZE_RXPBURST (HW_USBHS_BURSTSIZE.B.RXPBURST)
#endif

//! @brief Format value for bitfield USBHS_BURSTSIZE_RXPBURST.
#define BF_USBHS_BURSTSIZE_RXPBURST(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_BURSTSIZE_RXPBURST), uint32_t) & BM_USBHS_BURSTSIZE_RXPBURST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXPBURST field to a new value.
#define BW_USBHS_BURSTSIZE_RXPBURST(v) (HW_USBHS_BURSTSIZE_WR((HW_USBHS_BURSTSIZE_RD() & ~BM_USBHS_BURSTSIZE_RXPBURST) | BF_USBHS_BURSTSIZE_RXPBURST(v)))
#endif
//@}

/*!
 * @name Register USBHS_BURSTSIZE, field TXPBURST[15:8] (RW)
 *
 * Represents the maximum length of a burst in 32-bit words while moving data
 * from system memory to the USB bus. Must not be set to greater than 16. If the
 * BURSTSIZE field of register SBUSCFG is non-zero, the TXPBURST field returns the
 * value of the INCRx length.
 */
//@{
#define BP_USBHS_BURSTSIZE_TXPBURST (8U)   //!< Bit position for USBHS_BURSTSIZE_TXPBURST.
#define BM_USBHS_BURSTSIZE_TXPBURST (0x0000FF00U) //!< Bit mask for USBHS_BURSTSIZE_TXPBURST.
#define BS_USBHS_BURSTSIZE_TXPBURST (8U)   //!< Bit field size in bits for USBHS_BURSTSIZE_TXPBURST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_BURSTSIZE_TXPBURST field.
#define BR_USBHS_BURSTSIZE_TXPBURST (HW_USBHS_BURSTSIZE.B.TXPBURST)
#endif

//! @brief Format value for bitfield USBHS_BURSTSIZE_TXPBURST.
#define BF_USBHS_BURSTSIZE_TXPBURST(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_BURSTSIZE_TXPBURST), uint32_t) & BM_USBHS_BURSTSIZE_TXPBURST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXPBURST field to a new value.
#define BW_USBHS_BURSTSIZE_TXPBURST(v) (HW_USBHS_BURSTSIZE_WR((HW_USBHS_BURSTSIZE_RD() & ~BM_USBHS_BURSTSIZE_TXPBURST) | BF_USBHS_BURSTSIZE_TXPBURST(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_TXFILLTUNING - Transmit FIFO Tuning Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_TXFILLTUNING - Transmit FIFO Tuning Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is not defined in the EHCI specification. The TXFILLTUNING
 * register controls performance tuning associated with how the module posts data to
 * the TX latency FIFO before moving the data onto the USB bus. The specific
 * areas of performance include how much data to post into the FIFO and an estimate
 * for how long that operation takes in the target system. Definitions: T 0 =
 * Standard packet overhead T 1 = Time to send data payload T s = Total packet flight
 * time (send-only) packet (T s = T 0 + T 1 ) T ff Time to fetch packet into TX
 * FIFO up to specified level T p Total packet time (fetch and send) packet (T p
 * = T ff + T s ) Upon discovery of a transmit (OUT/SETUP) packet in the data
 * structures, the host controller checks to ensure T p remains before the end of
 * the (micro)frame. If so, it pre-fills the TX FIFO. If at anytime during the
 * pre-fill operation the time remaining the (micro)frame is less than T s , packet
 * attempt ceases and tries at a later time. Although this is not an error
 * condition and the module eventually recovers, a mark is made in the scheduler health
 * counter to mark the occurrence of a back-off event. When a back-off event is
 * detected, the partial packet fetched may need to be discarded from the latency
 * buffer to make room for periodic traffic beginning after the next SOF. Too
 * many back-off events can waste bandwidth and power on the system bus and should
 * be minimized (not necessarily eliminated). The TSCHHEALTH (T ff) parameter
 * described below can minimize back-offs.
 */
typedef union _hw_usbhs_txfilltuning
{
    uint32_t U;
    struct _hw_usbhs_txfilltuning_bitfields
    {
        uint32_t TXSCHOH : 7;          //!< [6:0] Scheduler Overhead
        uint32_t RESERVED0 : 1;        //!< [7] Reserved
        uint32_t TXSCHHEALTH : 5;      //!< [12:8] Scheduler Health counter
        uint32_t RESERVED1 : 3;        //!< [15:13] Reserved
        uint32_t TXFIFOTHRES : 6;      //!< [21:16] FIFO burst Threshold
        uint32_t RESERVED2 : 10;       //!< [31:22] Reserved
    } B;
} hw_usbhs_txfilltuning_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_TXFILLTUNING register
 */
//@{
#define HW_USBHS_TXFILLTUNING_ADDR (REGS_USBHS_BASE + 0x164U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_TXFILLTUNING    (*(__IO hw_usbhs_txfilltuning_t *) HW_USBHS_TXFILLTUNING_ADDR)
#define HW_USBHS_TXFILLTUNING_RD() (HW_USBHS_TXFILLTUNING.U)
#define HW_USBHS_TXFILLTUNING_WR(v) (HW_USBHS_TXFILLTUNING.U = (v))
#define HW_USBHS_TXFILLTUNING_SET(v) (HW_USBHS_TXFILLTUNING_WR(HW_USBHS_TXFILLTUNING_RD() |  (v)))
#define HW_USBHS_TXFILLTUNING_CLR(v) (HW_USBHS_TXFILLTUNING_WR(HW_USBHS_TXFILLTUNING_RD() & ~(v)))
#define HW_USBHS_TXFILLTUNING_TOG(v) (HW_USBHS_TXFILLTUNING_WR(HW_USBHS_TXFILLTUNING_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_TXFILLTUNING bitfields
 */

/*!
 * @name Register USBHS_TXFILLTUNING, field TXSCHOH[6:0] (RW)
 *
 * These bits add an additional fixed offset to the schedule time estimator
 * described as T ff . As an approximation, the value chosen for this register should
 * limit the number of back-off events captured in the TXSCHHEALTH field to less
 * than 10 per second in a highly utilized bus. Choosing a value too high for
 * this register is not desired as it can needlessly reduce USB utilization. The
 * time unit represented in this register is 1.267 ms when a device connects in
 * high-speed mode. The time unit represented in this register is 6.333 ms when a
 * device connects in low-/full-speed mode. For most applications, TXSCHOH can be
 * set to 4 or less. A good value to begin with is: (TXFIFOTHRES x BURSTSIZE x 4)
 * / (40 x TimeUnit) Always rounded to the next higher integer. TimeUnit is 1.267
 * or 6.333 as noted earlier in this description. For example, if TXFIFOTHRES is
 * 5 and BURSTSIZE is 8, set TXSCHOH to 5(84)/(401.267) equals 4 for a
 * high-speed link. If this value of TXSCHOH results in a TXSCHHEALTH count of 0 per
 * second, low the value by 1 if optimizing performance is desired. If
 * TXSCHHEALTH exceeds 10 per second, raise the value by 1. If streaming mode is disabled
 * via the USBMODE register, treat TXFIFOTHRES as the maximum value for purposes
 * of the TXSCHOH calculation.
 */
//@{
#define BP_USBHS_TXFILLTUNING_TXSCHOH (0U) //!< Bit position for USBHS_TXFILLTUNING_TXSCHOH.
#define BM_USBHS_TXFILLTUNING_TXSCHOH (0x0000007FU) //!< Bit mask for USBHS_TXFILLTUNING_TXSCHOH.
#define BS_USBHS_TXFILLTUNING_TXSCHOH (7U) //!< Bit field size in bits for USBHS_TXFILLTUNING_TXSCHOH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_TXFILLTUNING_TXSCHOH field.
#define BR_USBHS_TXFILLTUNING_TXSCHOH (HW_USBHS_TXFILLTUNING.B.TXSCHOH)
#endif

//! @brief Format value for bitfield USBHS_TXFILLTUNING_TXSCHOH.
#define BF_USBHS_TXFILLTUNING_TXSCHOH(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_TXFILLTUNING_TXSCHOH), uint32_t) & BM_USBHS_TXFILLTUNING_TXSCHOH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXSCHOH field to a new value.
#define BW_USBHS_TXFILLTUNING_TXSCHOH(v) (HW_USBHS_TXFILLTUNING_WR((HW_USBHS_TXFILLTUNING_RD() & ~BM_USBHS_TXFILLTUNING_TXSCHOH) | BF_USBHS_TXFILLTUNING_TXSCHOH(v)))
#endif
//@}

/*!
 * @name Register USBHS_TXFILLTUNING, field TXSCHHEALTH[12:8] (RW)
 *
 * These bits increment when the host controller fails to fill the TX latency
 * FIFO to the level programmed by TXFIFOTHRES before running out of time to send
 * the packet before the next SOF. This health counter measures the number of
 * times this occurs to provide feedback to selecting a proper TXSCHOH. Writing to
 * this register clears the counter and this counter stops counting after reaching
 * the maximum of 31.
 */
//@{
#define BP_USBHS_TXFILLTUNING_TXSCHHEALTH (8U) //!< Bit position for USBHS_TXFILLTUNING_TXSCHHEALTH.
#define BM_USBHS_TXFILLTUNING_TXSCHHEALTH (0x00001F00U) //!< Bit mask for USBHS_TXFILLTUNING_TXSCHHEALTH.
#define BS_USBHS_TXFILLTUNING_TXSCHHEALTH (5U) //!< Bit field size in bits for USBHS_TXFILLTUNING_TXSCHHEALTH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_TXFILLTUNING_TXSCHHEALTH field.
#define BR_USBHS_TXFILLTUNING_TXSCHHEALTH (HW_USBHS_TXFILLTUNING.B.TXSCHHEALTH)
#endif

//! @brief Format value for bitfield USBHS_TXFILLTUNING_TXSCHHEALTH.
#define BF_USBHS_TXFILLTUNING_TXSCHHEALTH(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_TXFILLTUNING_TXSCHHEALTH), uint32_t) & BM_USBHS_TXFILLTUNING_TXSCHHEALTH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXSCHHEALTH field to a new value.
#define BW_USBHS_TXFILLTUNING_TXSCHHEALTH(v) (HW_USBHS_TXFILLTUNING_WR((HW_USBHS_TXFILLTUNING_RD() & ~BM_USBHS_TXFILLTUNING_TXSCHHEALTH) | BF_USBHS_TXFILLTUNING_TXSCHHEALTH(v)))
#endif
//@}

/*!
 * @name Register USBHS_TXFILLTUNING, field TXFIFOTHRES[21:16] (RW)
 *
 * FIFO burst threshold. Controls the number of data bursts that are posted to
 * the TX latency FIFO in host mode before the packet begins on the bus. The
 * minimum value is 2 and this value should be as low as possible to maximize USB
 * performance. Systems with unpredictable latency and/or insufficient bandwidth can
 * use a higher value where the FIFO may underrun because the data transferred
 * from the latency FIFO to USB occurs before it can replenish from system memory.
 * This value is ignored if the USBMODE[SDIS] bit is set. When the USBMODE[SDIS]
 * bit is set, the host controller behaves as if TXFIFOTHRES is set to its
 * maximum value.
 */
//@{
#define BP_USBHS_TXFILLTUNING_TXFIFOTHRES (16U) //!< Bit position for USBHS_TXFILLTUNING_TXFIFOTHRES.
#define BM_USBHS_TXFILLTUNING_TXFIFOTHRES (0x003F0000U) //!< Bit mask for USBHS_TXFILLTUNING_TXFIFOTHRES.
#define BS_USBHS_TXFILLTUNING_TXFIFOTHRES (6U) //!< Bit field size in bits for USBHS_TXFILLTUNING_TXFIFOTHRES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_TXFILLTUNING_TXFIFOTHRES field.
#define BR_USBHS_TXFILLTUNING_TXFIFOTHRES (HW_USBHS_TXFILLTUNING.B.TXFIFOTHRES)
#endif

//! @brief Format value for bitfield USBHS_TXFILLTUNING_TXFIFOTHRES.
#define BF_USBHS_TXFILLTUNING_TXFIFOTHRES(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_TXFILLTUNING_TXFIFOTHRES), uint32_t) & BM_USBHS_TXFILLTUNING_TXFIFOTHRES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXFIFOTHRES field to a new value.
#define BW_USBHS_TXFILLTUNING_TXFIFOTHRES(v) (HW_USBHS_TXFILLTUNING_WR((HW_USBHS_TXFILLTUNING_RD() & ~BM_USBHS_TXFILLTUNING_TXFIFOTHRES) | BF_USBHS_TXFILLTUNING_TXFIFOTHRES(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_ULPI_VIEWPORT - ULPI Register Access
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_ULPI_VIEWPORT - ULPI Register Access (RW)
 *
 * Reset value: 0x00000000U
 *
 * The register provides indirect access to the ULPI PHY register set. Although
 * the controller modules perform access to the ULPI PHY register set, there may
 * be circumstances where software may need direct access. Be advised that writes
 * to the ULPI through the ULPI viewport can substantially harm standard USB
 * operations. Currently no usage model has been defined where software should need
 * to execute writes directly to the ULPI. Executing read operations though the
 * ULPI viewport should have no harmful side effects to standard USB operations.
 * Also, if the ULPI interface is not enabled, this register is always read
 * cleared. There are two operations that can be performed with the ULPI viewport,
 * wake-up and read/write operations. The wake-up operation is used to put the ULPI
 * interface into normal operation mode and re-enable the clock if necessary. A
 * wake-up operation is required before accessing the registers when the ULPI
 * interface is operating in low power mode, serial mode, or carkit mode. The ULPI
 * state can be determined by reading the sync state bit (ULPI_SS). If this bit is
 * set, then the ULPI interface is running in normal operating mode and can accept
 * read/write operations. If ULPI_SS is cleared, then read/write operations are
 * not executed. Undefined behavior results if a read or write operation is
 * performed when ULPI_SS is cleared. To execute a wake-up operation, write all
 * 32-bits of the ULPI VIEWPORT where ULPI_PORT is constructed appropriately and the
 * ULPI_WU bit is set and the ULPI_RUN bit is cleared. Poll the ULPI VIEWPORT until
 * ULPI_WU is cleared for the operation to complete. To execute a read or write
 * operation, write all 32-bits of the ULPI VIEWPORT where ULPI_DATWR, ULPI_ADDR,
 * ULPI_PORT, ULPI_RW are constructed appropriately and the ULPI_RUN bit is set.
 * Poll the ULPI VIEWPORT until ULPI_RUN is cleared for the operation to
 * complete. For read operations, ULPI_DATRD is valid after ULPI_RUN is cleared. The
 * polling method above can be replaced with interrupts using the ULPI interrupt
 * defined in the USBSTS and USBINTR registers. When a wake-up or read/write
 * operation completes, the ULPI interrupt is set.
 */
typedef union _hw_usbhs_ulpi_viewport
{
    uint32_t U;
    struct _hw_usbhs_ulpi_viewport_bitfields
    {
        uint32_t ULPI_DATWR : 8;       //!< [7:0] ULPI Data Write
        uint32_t ULPI_DATRD : 8;       //!< [15:8] ULPI Data Read
        uint32_t ULPI_ADDR : 8;        //!< [23:16] ULPI data Address
        uint32_t ULPI_PORT : 3;        //!< [26:24] ULPI Port number
        uint32_t ULPI_SS : 1;          //!< [27] ULPI Sync State
        uint32_t RESERVED0 : 1;        //!< [28] Reserved
        uint32_t ULPI_RW : 1;          //!< [29] ULPI Read/Write
        uint32_t ULPI_RUN : 1;         //!< [30] ULPI Run
        uint32_t ULPI_WU : 1;          //!< [31] ULPI Wake-Up
    } B;
} hw_usbhs_ulpi_viewport_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_ULPI_VIEWPORT register
 */
//@{
#define HW_USBHS_ULPI_VIEWPORT_ADDR (REGS_USBHS_BASE + 0x170U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_ULPI_VIEWPORT   (*(__IO hw_usbhs_ulpi_viewport_t *) HW_USBHS_ULPI_VIEWPORT_ADDR)
#define HW_USBHS_ULPI_VIEWPORT_RD() (HW_USBHS_ULPI_VIEWPORT.U)
#define HW_USBHS_ULPI_VIEWPORT_WR(v) (HW_USBHS_ULPI_VIEWPORT.U = (v))
#define HW_USBHS_ULPI_VIEWPORT_SET(v) (HW_USBHS_ULPI_VIEWPORT_WR(HW_USBHS_ULPI_VIEWPORT_RD() |  (v)))
#define HW_USBHS_ULPI_VIEWPORT_CLR(v) (HW_USBHS_ULPI_VIEWPORT_WR(HW_USBHS_ULPI_VIEWPORT_RD() & ~(v)))
#define HW_USBHS_ULPI_VIEWPORT_TOG(v) (HW_USBHS_ULPI_VIEWPORT_WR(HW_USBHS_ULPI_VIEWPORT_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_ULPI_VIEWPORT bitfields
 */

/*!
 * @name Register USBHS_ULPI_VIEWPORT, field ULPI_DATWR[7:0] (RW)
 *
 * When a write operation is commanded, the data to be sent is written to this
 * field.
 */
//@{
#define BP_USBHS_ULPI_VIEWPORT_ULPI_DATWR (0U) //!< Bit position for USBHS_ULPI_VIEWPORT_ULPI_DATWR.
#define BM_USBHS_ULPI_VIEWPORT_ULPI_DATWR (0x000000FFU) //!< Bit mask for USBHS_ULPI_VIEWPORT_ULPI_DATWR.
#define BS_USBHS_ULPI_VIEWPORT_ULPI_DATWR (8U) //!< Bit field size in bits for USBHS_ULPI_VIEWPORT_ULPI_DATWR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ULPI_VIEWPORT_ULPI_DATWR field.
#define BR_USBHS_ULPI_VIEWPORT_ULPI_DATWR (HW_USBHS_ULPI_VIEWPORT.B.ULPI_DATWR)
#endif

//! @brief Format value for bitfield USBHS_ULPI_VIEWPORT_ULPI_DATWR.
#define BF_USBHS_ULPI_VIEWPORT_ULPI_DATWR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ULPI_VIEWPORT_ULPI_DATWR), uint32_t) & BM_USBHS_ULPI_VIEWPORT_ULPI_DATWR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ULPI_DATWR field to a new value.
#define BW_USBHS_ULPI_VIEWPORT_ULPI_DATWR(v) (HW_USBHS_ULPI_VIEWPORT_WR((HW_USBHS_ULPI_VIEWPORT_RD() & ~BM_USBHS_ULPI_VIEWPORT_ULPI_DATWR) | BF_USBHS_ULPI_VIEWPORT_ULPI_DATWR(v)))
#endif
//@}

/*!
 * @name Register USBHS_ULPI_VIEWPORT, field ULPI_DATRD[15:8] (RO)
 *
 * After a read operation completes, the result is placed in this field.
 */
//@{
#define BP_USBHS_ULPI_VIEWPORT_ULPI_DATRD (8U) //!< Bit position for USBHS_ULPI_VIEWPORT_ULPI_DATRD.
#define BM_USBHS_ULPI_VIEWPORT_ULPI_DATRD (0x0000FF00U) //!< Bit mask for USBHS_ULPI_VIEWPORT_ULPI_DATRD.
#define BS_USBHS_ULPI_VIEWPORT_ULPI_DATRD (8U) //!< Bit field size in bits for USBHS_ULPI_VIEWPORT_ULPI_DATRD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ULPI_VIEWPORT_ULPI_DATRD field.
#define BR_USBHS_ULPI_VIEWPORT_ULPI_DATRD (HW_USBHS_ULPI_VIEWPORT.B.ULPI_DATRD)
#endif
//@}

/*!
 * @name Register USBHS_ULPI_VIEWPORT, field ULPI_ADDR[23:16] (RW)
 *
 * When a read or write operation is commanded, the address of the operation is
 * written to this field.
 */
//@{
#define BP_USBHS_ULPI_VIEWPORT_ULPI_ADDR (16U) //!< Bit position for USBHS_ULPI_VIEWPORT_ULPI_ADDR.
#define BM_USBHS_ULPI_VIEWPORT_ULPI_ADDR (0x00FF0000U) //!< Bit mask for USBHS_ULPI_VIEWPORT_ULPI_ADDR.
#define BS_USBHS_ULPI_VIEWPORT_ULPI_ADDR (8U) //!< Bit field size in bits for USBHS_ULPI_VIEWPORT_ULPI_ADDR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ULPI_VIEWPORT_ULPI_ADDR field.
#define BR_USBHS_ULPI_VIEWPORT_ULPI_ADDR (HW_USBHS_ULPI_VIEWPORT.B.ULPI_ADDR)
#endif

//! @brief Format value for bitfield USBHS_ULPI_VIEWPORT_ULPI_ADDR.
#define BF_USBHS_ULPI_VIEWPORT_ULPI_ADDR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ULPI_VIEWPORT_ULPI_ADDR), uint32_t) & BM_USBHS_ULPI_VIEWPORT_ULPI_ADDR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ULPI_ADDR field to a new value.
#define BW_USBHS_ULPI_VIEWPORT_ULPI_ADDR(v) (HW_USBHS_ULPI_VIEWPORT_WR((HW_USBHS_ULPI_VIEWPORT_RD() & ~BM_USBHS_ULPI_VIEWPORT_ULPI_ADDR) | BF_USBHS_ULPI_VIEWPORT_ULPI_ADDR(v)))
#endif
//@}

/*!
 * @name Register USBHS_ULPI_VIEWPORT, field ULPI_PORT[26:24] (RW)
 *
 * For wake-up or read/write operations this value selects the port number to
 * which the ULPI PHY is attached. Valid values are 0 and 1.
 */
//@{
#define BP_USBHS_ULPI_VIEWPORT_ULPI_PORT (24U) //!< Bit position for USBHS_ULPI_VIEWPORT_ULPI_PORT.
#define BM_USBHS_ULPI_VIEWPORT_ULPI_PORT (0x07000000U) //!< Bit mask for USBHS_ULPI_VIEWPORT_ULPI_PORT.
#define BS_USBHS_ULPI_VIEWPORT_ULPI_PORT (3U) //!< Bit field size in bits for USBHS_ULPI_VIEWPORT_ULPI_PORT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ULPI_VIEWPORT_ULPI_PORT field.
#define BR_USBHS_ULPI_VIEWPORT_ULPI_PORT (HW_USBHS_ULPI_VIEWPORT.B.ULPI_PORT)
#endif

//! @brief Format value for bitfield USBHS_ULPI_VIEWPORT_ULPI_PORT.
#define BF_USBHS_ULPI_VIEWPORT_ULPI_PORT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ULPI_VIEWPORT_ULPI_PORT), uint32_t) & BM_USBHS_ULPI_VIEWPORT_ULPI_PORT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ULPI_PORT field to a new value.
#define BW_USBHS_ULPI_VIEWPORT_ULPI_PORT(v) (HW_USBHS_ULPI_VIEWPORT_WR((HW_USBHS_ULPI_VIEWPORT_RD() & ~BM_USBHS_ULPI_VIEWPORT_ULPI_PORT) | BF_USBHS_ULPI_VIEWPORT_ULPI_PORT(v)))
#endif
//@}

/*!
 * @name Register USBHS_ULPI_VIEWPORT, field ULPI_SS[27] (RW)
 *
 * Represents the state of the ULPI interface. Before reading this bit, the
 * ULPI_PORT field should be set accordingly if used with the multi-port host.
 * Otherwise, this field should always remain 0.
 *
 * Values:
 * - 0 - Any other state (that is, carkit, serial, low power)
 * - 1 - Normal sync state
 */
//@{
#define BP_USBHS_ULPI_VIEWPORT_ULPI_SS (27U) //!< Bit position for USBHS_ULPI_VIEWPORT_ULPI_SS.
#define BM_USBHS_ULPI_VIEWPORT_ULPI_SS (0x08000000U) //!< Bit mask for USBHS_ULPI_VIEWPORT_ULPI_SS.
#define BS_USBHS_ULPI_VIEWPORT_ULPI_SS (1U) //!< Bit field size in bits for USBHS_ULPI_VIEWPORT_ULPI_SS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ULPI_VIEWPORT_ULPI_SS field.
#define BR_USBHS_ULPI_VIEWPORT_ULPI_SS (BITBAND_ACCESS32(HW_USBHS_ULPI_VIEWPORT_ADDR, BP_USBHS_ULPI_VIEWPORT_ULPI_SS))
#endif

//! @brief Format value for bitfield USBHS_ULPI_VIEWPORT_ULPI_SS.
#define BF_USBHS_ULPI_VIEWPORT_ULPI_SS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ULPI_VIEWPORT_ULPI_SS), uint32_t) & BM_USBHS_ULPI_VIEWPORT_ULPI_SS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ULPI_SS field to a new value.
#define BW_USBHS_ULPI_VIEWPORT_ULPI_SS(v) (BITBAND_ACCESS32(HW_USBHS_ULPI_VIEWPORT_ADDR, BP_USBHS_ULPI_VIEWPORT_ULPI_SS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_ULPI_VIEWPORT, field ULPI_RW[29] (RW)
 *
 * Selects between running a read or write operation to the ULPI.
 *
 * Values:
 * - 0 - Read
 * - 1 - Write
 */
//@{
#define BP_USBHS_ULPI_VIEWPORT_ULPI_RW (29U) //!< Bit position for USBHS_ULPI_VIEWPORT_ULPI_RW.
#define BM_USBHS_ULPI_VIEWPORT_ULPI_RW (0x20000000U) //!< Bit mask for USBHS_ULPI_VIEWPORT_ULPI_RW.
#define BS_USBHS_ULPI_VIEWPORT_ULPI_RW (1U) //!< Bit field size in bits for USBHS_ULPI_VIEWPORT_ULPI_RW.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ULPI_VIEWPORT_ULPI_RW field.
#define BR_USBHS_ULPI_VIEWPORT_ULPI_RW (BITBAND_ACCESS32(HW_USBHS_ULPI_VIEWPORT_ADDR, BP_USBHS_ULPI_VIEWPORT_ULPI_RW))
#endif

//! @brief Format value for bitfield USBHS_ULPI_VIEWPORT_ULPI_RW.
#define BF_USBHS_ULPI_VIEWPORT_ULPI_RW(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ULPI_VIEWPORT_ULPI_RW), uint32_t) & BM_USBHS_ULPI_VIEWPORT_ULPI_RW)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ULPI_RW field to a new value.
#define BW_USBHS_ULPI_VIEWPORT_ULPI_RW(v) (BITBAND_ACCESS32(HW_USBHS_ULPI_VIEWPORT_ADDR, BP_USBHS_ULPI_VIEWPORT_ULPI_RW) = (v))
#endif
//@}

/*!
 * @name Register USBHS_ULPI_VIEWPORT, field ULPI_RUN[30] (RW)
 *
 * Setting this bit begins a read/write operation. This bit automatically clears
 * after the read/write is complete. After this bit is set, it can not be
 * cleared by software. The driver must never execute a wake-up and a read/write
 * operation at the same time.
 */
//@{
#define BP_USBHS_ULPI_VIEWPORT_ULPI_RUN (30U) //!< Bit position for USBHS_ULPI_VIEWPORT_ULPI_RUN.
#define BM_USBHS_ULPI_VIEWPORT_ULPI_RUN (0x40000000U) //!< Bit mask for USBHS_ULPI_VIEWPORT_ULPI_RUN.
#define BS_USBHS_ULPI_VIEWPORT_ULPI_RUN (1U) //!< Bit field size in bits for USBHS_ULPI_VIEWPORT_ULPI_RUN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ULPI_VIEWPORT_ULPI_RUN field.
#define BR_USBHS_ULPI_VIEWPORT_ULPI_RUN (BITBAND_ACCESS32(HW_USBHS_ULPI_VIEWPORT_ADDR, BP_USBHS_ULPI_VIEWPORT_ULPI_RUN))
#endif

//! @brief Format value for bitfield USBHS_ULPI_VIEWPORT_ULPI_RUN.
#define BF_USBHS_ULPI_VIEWPORT_ULPI_RUN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ULPI_VIEWPORT_ULPI_RUN), uint32_t) & BM_USBHS_ULPI_VIEWPORT_ULPI_RUN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ULPI_RUN field to a new value.
#define BW_USBHS_ULPI_VIEWPORT_ULPI_RUN(v) (BITBAND_ACCESS32(HW_USBHS_ULPI_VIEWPORT_ADDR, BP_USBHS_ULPI_VIEWPORT_ULPI_RUN) = (v))
#endif
//@}

/*!
 * @name Register USBHS_ULPI_VIEWPORT, field ULPI_WU[31] (RW)
 *
 * Setting this bit begins the wake-up operation. This bit automatically clears
 * after the wake-up is complete. After this bit is set, it can not be cleared by
 * software. The driver must never execute a wake-up and a read/write operation
 * at the same time.
 */
//@{
#define BP_USBHS_ULPI_VIEWPORT_ULPI_WU (31U) //!< Bit position for USBHS_ULPI_VIEWPORT_ULPI_WU.
#define BM_USBHS_ULPI_VIEWPORT_ULPI_WU (0x80000000U) //!< Bit mask for USBHS_ULPI_VIEWPORT_ULPI_WU.
#define BS_USBHS_ULPI_VIEWPORT_ULPI_WU (1U) //!< Bit field size in bits for USBHS_ULPI_VIEWPORT_ULPI_WU.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ULPI_VIEWPORT_ULPI_WU field.
#define BR_USBHS_ULPI_VIEWPORT_ULPI_WU (BITBAND_ACCESS32(HW_USBHS_ULPI_VIEWPORT_ADDR, BP_USBHS_ULPI_VIEWPORT_ULPI_WU))
#endif

//! @brief Format value for bitfield USBHS_ULPI_VIEWPORT_ULPI_WU.
#define BF_USBHS_ULPI_VIEWPORT_ULPI_WU(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ULPI_VIEWPORT_ULPI_WU), uint32_t) & BM_USBHS_ULPI_VIEWPORT_ULPI_WU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ULPI_WU field to a new value.
#define BW_USBHS_ULPI_VIEWPORT_ULPI_WU(v) (BITBAND_ACCESS32(HW_USBHS_ULPI_VIEWPORT_ADDR, BP_USBHS_ULPI_VIEWPORT_ULPI_WU) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_ENDPTNAK - Endpoint NAK Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_ENDPTNAK - Endpoint NAK Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_usbhs_endptnak
{
    uint32_t U;
    struct _hw_usbhs_endptnak_bitfields
    {
        uint32_t EPRN : 4;             //!< [3:0] RX Endpoint NAK
        uint32_t RESERVED0 : 12;       //!< [15:4] Reserved
        uint32_t EPTN : 4;             //!< [19:16] TX Endpoint NAK
        uint32_t RESERVED1 : 12;       //!< [31:20] Reserved
    } B;
} hw_usbhs_endptnak_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_ENDPTNAK register
 */
//@{
#define HW_USBHS_ENDPTNAK_ADDR   (REGS_USBHS_BASE + 0x178U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_ENDPTNAK        (*(__IO hw_usbhs_endptnak_t *) HW_USBHS_ENDPTNAK_ADDR)
#define HW_USBHS_ENDPTNAK_RD()   (HW_USBHS_ENDPTNAK.U)
#define HW_USBHS_ENDPTNAK_WR(v)  (HW_USBHS_ENDPTNAK.U = (v))
#define HW_USBHS_ENDPTNAK_SET(v) (HW_USBHS_ENDPTNAK_WR(HW_USBHS_ENDPTNAK_RD() |  (v)))
#define HW_USBHS_ENDPTNAK_CLR(v) (HW_USBHS_ENDPTNAK_WR(HW_USBHS_ENDPTNAK_RD() & ~(v)))
#define HW_USBHS_ENDPTNAK_TOG(v) (HW_USBHS_ENDPTNAK_WR(HW_USBHS_ENDPTNAK_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_ENDPTNAK bitfields
 */

/*!
 * @name Register USBHS_ENDPTNAK, field EPRN[3:0] (W1C)
 *
 * Each RX endpoint has 1 bit in this field. The bit is set when the device
 * sends a NAK handshake on a received OUT or PING token for the corresponding
 * endpoint. EPRN[3]-Endpoint #3 EPRN[2]-Endpoint #2 EPRN[1]-Endpoint #1
 * EPRN[0]-Endpoint #0
 */
//@{
#define BP_USBHS_ENDPTNAK_EPRN (0U)        //!< Bit position for USBHS_ENDPTNAK_EPRN.
#define BM_USBHS_ENDPTNAK_EPRN (0x0000000FU) //!< Bit mask for USBHS_ENDPTNAK_EPRN.
#define BS_USBHS_ENDPTNAK_EPRN (4U)        //!< Bit field size in bits for USBHS_ENDPTNAK_EPRN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ENDPTNAK_EPRN field.
#define BR_USBHS_ENDPTNAK_EPRN (HW_USBHS_ENDPTNAK.B.EPRN)
#endif

//! @brief Format value for bitfield USBHS_ENDPTNAK_EPRN.
#define BF_USBHS_ENDPTNAK_EPRN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ENDPTNAK_EPRN), uint32_t) & BM_USBHS_ENDPTNAK_EPRN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EPRN field to a new value.
#define BW_USBHS_ENDPTNAK_EPRN(v) (HW_USBHS_ENDPTNAK_WR((HW_USBHS_ENDPTNAK_RD() & ~BM_USBHS_ENDPTNAK_EPRN) | BF_USBHS_ENDPTNAK_EPRN(v)))
#endif
//@}

/*!
 * @name Register USBHS_ENDPTNAK, field EPTN[19:16] (W1C)
 *
 * Each TX endpoint has 1 bit in this field. The bit is set when the device
 * sends a NAK handshake on a received IN token for the corresponding endpoint.
 * EPTN[3]-Endpoint #3 EPTN[2]-Endpoint #2 EPTN[1]-Endpoint #1 EPTN[0]-Endpoint #0
 */
//@{
#define BP_USBHS_ENDPTNAK_EPTN (16U)       //!< Bit position for USBHS_ENDPTNAK_EPTN.
#define BM_USBHS_ENDPTNAK_EPTN (0x000F0000U) //!< Bit mask for USBHS_ENDPTNAK_EPTN.
#define BS_USBHS_ENDPTNAK_EPTN (4U)        //!< Bit field size in bits for USBHS_ENDPTNAK_EPTN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ENDPTNAK_EPTN field.
#define BR_USBHS_ENDPTNAK_EPTN (HW_USBHS_ENDPTNAK.B.EPTN)
#endif

//! @brief Format value for bitfield USBHS_ENDPTNAK_EPTN.
#define BF_USBHS_ENDPTNAK_EPTN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ENDPTNAK_EPTN), uint32_t) & BM_USBHS_ENDPTNAK_EPTN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EPTN field to a new value.
#define BW_USBHS_ENDPTNAK_EPTN(v) (HW_USBHS_ENDPTNAK_WR((HW_USBHS_ENDPTNAK_RD() & ~BM_USBHS_ENDPTNAK_EPTN) | BF_USBHS_ENDPTNAK_EPTN(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_ENDPTNAKEN - Endpoint NAK Enable Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_ENDPTNAKEN - Endpoint NAK Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_usbhs_endptnaken
{
    uint32_t U;
    struct _hw_usbhs_endptnaken_bitfields
    {
        uint32_t EPRNE : 4;            //!< [3:0] RX Endpoint NAK
        uint32_t RESERVED0 : 12;       //!< [15:4] Reserved
        uint32_t EPTNE : 4;            //!< [19:16] TX Endpoint NAK
        uint32_t RESERVED1 : 12;       //!< [31:20] Reserved
    } B;
} hw_usbhs_endptnaken_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_ENDPTNAKEN register
 */
//@{
#define HW_USBHS_ENDPTNAKEN_ADDR (REGS_USBHS_BASE + 0x17CU)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_ENDPTNAKEN      (*(__IO hw_usbhs_endptnaken_t *) HW_USBHS_ENDPTNAKEN_ADDR)
#define HW_USBHS_ENDPTNAKEN_RD() (HW_USBHS_ENDPTNAKEN.U)
#define HW_USBHS_ENDPTNAKEN_WR(v) (HW_USBHS_ENDPTNAKEN.U = (v))
#define HW_USBHS_ENDPTNAKEN_SET(v) (HW_USBHS_ENDPTNAKEN_WR(HW_USBHS_ENDPTNAKEN_RD() |  (v)))
#define HW_USBHS_ENDPTNAKEN_CLR(v) (HW_USBHS_ENDPTNAKEN_WR(HW_USBHS_ENDPTNAKEN_RD() & ~(v)))
#define HW_USBHS_ENDPTNAKEN_TOG(v) (HW_USBHS_ENDPTNAKEN_WR(HW_USBHS_ENDPTNAKEN_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_ENDPTNAKEN bitfields
 */

/*!
 * @name Register USBHS_ENDPTNAKEN, field EPRNE[3:0] (W1C)
 *
 * Each bit is an enable bit for the corresponding RX Endpoint NAK bit. If this
 * bit is set and the corresponding RX Endpoint NAK bit is set, the NAK Interrupt
 * bit is set. EPRNE[3]-Endpoint #3 EPRNE[2]-Endpoint #2 EPRNE[1]-Endpoint #1
 * EPRNE[0]-Endpoint #0
 */
//@{
#define BP_USBHS_ENDPTNAKEN_EPRNE (0U)     //!< Bit position for USBHS_ENDPTNAKEN_EPRNE.
#define BM_USBHS_ENDPTNAKEN_EPRNE (0x0000000FU) //!< Bit mask for USBHS_ENDPTNAKEN_EPRNE.
#define BS_USBHS_ENDPTNAKEN_EPRNE (4U)     //!< Bit field size in bits for USBHS_ENDPTNAKEN_EPRNE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ENDPTNAKEN_EPRNE field.
#define BR_USBHS_ENDPTNAKEN_EPRNE (HW_USBHS_ENDPTNAKEN.B.EPRNE)
#endif

//! @brief Format value for bitfield USBHS_ENDPTNAKEN_EPRNE.
#define BF_USBHS_ENDPTNAKEN_EPRNE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ENDPTNAKEN_EPRNE), uint32_t) & BM_USBHS_ENDPTNAKEN_EPRNE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EPRNE field to a new value.
#define BW_USBHS_ENDPTNAKEN_EPRNE(v) (HW_USBHS_ENDPTNAKEN_WR((HW_USBHS_ENDPTNAKEN_RD() & ~BM_USBHS_ENDPTNAKEN_EPRNE) | BF_USBHS_ENDPTNAKEN_EPRNE(v)))
#endif
//@}

/*!
 * @name Register USBHS_ENDPTNAKEN, field EPTNE[19:16] (W1C)
 *
 * Each bit is an enable bit for the corresponding TX Endpoint NAK bit. If this
 * bit is set and the corresponding TX Endpoint NAK bit is set, the NAK Interrupt
 * bit is set. EPTNE[3]-Endpoint #3 EPTNE[2]-Endpoint #2 EPTNE[1]-Endpoint #1
 * EPTNE[0]-Endpoint #0
 */
//@{
#define BP_USBHS_ENDPTNAKEN_EPTNE (16U)    //!< Bit position for USBHS_ENDPTNAKEN_EPTNE.
#define BM_USBHS_ENDPTNAKEN_EPTNE (0x000F0000U) //!< Bit mask for USBHS_ENDPTNAKEN_EPTNE.
#define BS_USBHS_ENDPTNAKEN_EPTNE (4U)     //!< Bit field size in bits for USBHS_ENDPTNAKEN_EPTNE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_ENDPTNAKEN_EPTNE field.
#define BR_USBHS_ENDPTNAKEN_EPTNE (HW_USBHS_ENDPTNAKEN.B.EPTNE)
#endif

//! @brief Format value for bitfield USBHS_ENDPTNAKEN_EPTNE.
#define BF_USBHS_ENDPTNAKEN_EPTNE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_ENDPTNAKEN_EPTNE), uint32_t) & BM_USBHS_ENDPTNAKEN_EPTNE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EPTNE field to a new value.
#define BW_USBHS_ENDPTNAKEN_EPTNE(v) (HW_USBHS_ENDPTNAKEN_WR((HW_USBHS_ENDPTNAKEN_RD() & ~BM_USBHS_ENDPTNAKEN_EPTNE) | BF_USBHS_ENDPTNAKEN_EPTNE(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_CONFIGFLAG - Configure Flag Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_CONFIGFLAG - Configure Flag Register (RO)
 *
 * Reset value: 0x00000001U
 *
 * This EHCI register is not used in this implementation. A read from this
 * register returns a constant of a 0x0000_0001 to indicate that all port routings
 * default to this host controller.
 */
typedef union _hw_usbhs_configflag
{
    uint32_t U;
    struct _hw_usbhs_configflag_bitfields
    {
        uint32_t RESERVED0 : 32;       //!< [31:0] Reserved
    } B;
} hw_usbhs_configflag_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_CONFIGFLAG register
 */
//@{
#define HW_USBHS_CONFIGFLAG_ADDR (REGS_USBHS_BASE + 0x180U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_CONFIGFLAG      (*(__I hw_usbhs_configflag_t *) HW_USBHS_CONFIGFLAG_ADDR)
#define HW_USBHS_CONFIGFLAG_RD() (HW_USBHS_CONFIGFLAG.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_CONFIGFLAG bitfields
 */

//-------------------------------------------------------------------------------------------
// HW_USBHS_PORTSC1 - Port Status and Control Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_PORTSC1 - Port Status and Control Registers (RW)
 *
 * Reset value: 0x80000000U
 *
 * The USB module contains a single PORTSC register. This register only resets
 * when power is initially applied or in response to a controller reset. Initial
 * conditions of a port are: No device connected Port disabled If the port has
 * port power control, this state remains until software applies power to the port
 * by setting port power to one. For the USBHS module in device mode, the USBHS
 * controller does not support power control. Port control in device mode is used
 * only for status port reset, suspend, and current connect status. It is also
 * used to initiate test mode or force signaling, and allows software to place the
 * PHY into low-power suspend mode and disable the PHY clock.
 */
typedef union _hw_usbhs_portsc1
{
    uint32_t U;
    struct _hw_usbhs_portsc1_bitfields
    {
        uint32_t CCS : 1;              //!< [0] Current Connect Status
        uint32_t CSC : 1;              //!< [1] Connect Change Status
        uint32_t PE : 1;               //!< [2] Port Enabled/disabled
        uint32_t PEC : 1;              //!< [3] Port Enable/disable Change
        uint32_t OCA : 1;              //!< [4] Over-current active
        uint32_t OCC : 1;              //!< [5] Over-Current Change
        uint32_t FPR : 1;              //!< [6] Force Port Resume
        uint32_t SUSP : 1;             //!< [7] Suspend
        uint32_t PR : 1;               //!< [8] Port Reset
        uint32_t HSP : 1;              //!< [9] High Speed Port.
        uint32_t LS : 2;               //!< [11:10] Line Status
        uint32_t PP : 1;               //!< [12] Port Power
        uint32_t PO : 1;               //!< [13] Port Owner
        uint32_t PIC : 2;              //!< [15:14] Port Indicator Control
        uint32_t PTCb : 4;             //!< [19:16] Port Test Control
        uint32_t WKCN : 1;             //!< [20] Wake on Connect enable
        uint32_t WKDS : 1;             //!< [21] Wake on Disconnect enable
        uint32_t WKOC : 1;             //!< [22] Wake on Over-Current enable
        uint32_t PHCD : 1;             //!< [23] PHY low power suspend
        uint32_t PFSC : 1;             //!< [24] Port force Full-Speed Connect
        uint32_t RESERVED0 : 1;        //!< [25] Reserved
        uint32_t PSPD : 2;             //!< [27:26] Port Speed
        uint32_t RESERVED1 : 2;        //!< [29:28] Reserved
        uint32_t PTS : 2;              //!< [31:30] Port Transceiver Select
    } B;
} hw_usbhs_portsc1_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_PORTSC1 register
 */
//@{
#define HW_USBHS_PORTSC1_ADDR    (REGS_USBHS_BASE + 0x184U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_PORTSC1         (*(__IO hw_usbhs_portsc1_t *) HW_USBHS_PORTSC1_ADDR)
#define HW_USBHS_PORTSC1_RD()    (HW_USBHS_PORTSC1.U)
#define HW_USBHS_PORTSC1_WR(v)   (HW_USBHS_PORTSC1.U = (v))
#define HW_USBHS_PORTSC1_SET(v)  (HW_USBHS_PORTSC1_WR(HW_USBHS_PORTSC1_RD() |  (v)))
#define HW_USBHS_PORTSC1_CLR(v)  (HW_USBHS_PORTSC1_WR(HW_USBHS_PORTSC1_RD() & ~(v)))
#define HW_USBHS_PORTSC1_TOG(v)  (HW_USBHS_PORTSC1_WR(HW_USBHS_PORTSC1_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_PORTSC1 bitfields
 */

/*!
 * @name Register USBHS_PORTSC1, field CCS[0] (RO)
 *
 * Indicates that a device successfully attaches and operates in high speed or
 * full speed as indicated by the PSPD bit. If clear, the device did not attach
 * successfully or forcibly disconnects by the software clearing the USBCMD[RUN]
 * bit. It does not state the device disconnected or suspended. This bit is cleared
 * if the PP bit is cleared in host mode.
 *
 * Values:
 * - 0 - No device present (host mode) or attached (device mode)
 * - 1 - Device is present (host mode) or attached (device mode)
 */
//@{
#define BP_USBHS_PORTSC1_CCS (0U)          //!< Bit position for USBHS_PORTSC1_CCS.
#define BM_USBHS_PORTSC1_CCS (0x00000001U) //!< Bit mask for USBHS_PORTSC1_CCS.
#define BS_USBHS_PORTSC1_CCS (1U)          //!< Bit field size in bits for USBHS_PORTSC1_CCS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_CCS field.
#define BR_USBHS_PORTSC1_CCS (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_CCS))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field CSC[1] (W1C)
 *
 * Host mode: This bit indicates a change occurred in the port's current connect
 * status. The controller sets this bit for all changes to the port device
 * connect status, even if system software has not cleared an existing connect status
 * change. For example, the insertion status changes twice before system software
 * has cleared the changed condition; hub hardware is setting an already-set bit
 * (i.e., the bit remains set). Software clears this bit by writing a 1 to it.
 * This field is cleared if the PP bit is cleared. Device mode: In device mode,
 * this bit is undefined.
 *
 * Values:
 * - 0 - No change
 * - 1 - Connect status has changed
 */
//@{
#define BP_USBHS_PORTSC1_CSC (1U)          //!< Bit position for USBHS_PORTSC1_CSC.
#define BM_USBHS_PORTSC1_CSC (0x00000002U) //!< Bit mask for USBHS_PORTSC1_CSC.
#define BS_USBHS_PORTSC1_CSC (1U)          //!< Bit field size in bits for USBHS_PORTSC1_CSC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_CSC field.
#define BR_USBHS_PORTSC1_CSC (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_CSC))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_CSC.
#define BF_USBHS_PORTSC1_CSC(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_CSC), uint32_t) & BM_USBHS_PORTSC1_CSC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CSC field to a new value.
#define BW_USBHS_PORTSC1_CSC(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_CSC) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PE[2] (RW)
 *
 * Host mode: Ports can only be enabled by the controller as a part of the reset
 * and enable sequence. Software cannot enable a port by setting this bit. A
 * fault condition (disconnect event or other fault condition) or host software can
 * disable ports. The bit status does not change until the port state actually
 * changes. There may be a delay in disabling or enabling a port due to other host
 * and bus events. When the port is disabled, downstream propagation of data is
 * blocked except for reset. This field is cleared if the PP bit is cleared in
 * host mode. Device mode: The device port is always enabled. (This bit is set).
 */
//@{
#define BP_USBHS_PORTSC1_PE  (2U)          //!< Bit position for USBHS_PORTSC1_PE.
#define BM_USBHS_PORTSC1_PE  (0x00000004U) //!< Bit mask for USBHS_PORTSC1_PE.
#define BS_USBHS_PORTSC1_PE  (1U)          //!< Bit field size in bits for USBHS_PORTSC1_PE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PE field.
#define BR_USBHS_PORTSC1_PE  (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PE))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PE.
#define BF_USBHS_PORTSC1_PE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PE), uint32_t) & BM_USBHS_PORTSC1_PE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PE field to a new value.
#define BW_USBHS_PORTSC1_PE(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PEC[3] (W1C)
 *
 * For the root hub, this bit gets set only when a port is disabled due to
 * disconnect on the port or due to the appropriate conditions existing at the EOF2
 * point (See Chapter 11 of the USB Specification). Software clears this by writing
 * a 1 to it. In device mode, the device port is always enabled. (This bit is
 * zero). This bit is cleared if the PP bit is cleared.
 *
 * Values:
 * - 0 - No change
 * - 1 - Port disabled
 */
//@{
#define BP_USBHS_PORTSC1_PEC (3U)          //!< Bit position for USBHS_PORTSC1_PEC.
#define BM_USBHS_PORTSC1_PEC (0x00000008U) //!< Bit mask for USBHS_PORTSC1_PEC.
#define BS_USBHS_PORTSC1_PEC (1U)          //!< Bit field size in bits for USBHS_PORTSC1_PEC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PEC field.
#define BR_USBHS_PORTSC1_PEC (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PEC))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PEC.
#define BF_USBHS_PORTSC1_PEC(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PEC), uint32_t) & BM_USBHS_PORTSC1_PEC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PEC field to a new value.
#define BW_USBHS_PORTSC1_PEC(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PEC) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field OCA[4] (RO)
 *
 * This bit automatically transitions from 1 to 0 when the over-current
 * condition is removed. For host/OTG implementations, the user can provide over-current
 * detection to the USBn_PWRFAULT signal for this condition. For device-only
 * implementations, this bit must always be cleared.
 *
 * Values:
 * - 0 - Port not in over-current condition
 * - 1 - Port currently in over-current condition
 */
//@{
#define BP_USBHS_PORTSC1_OCA (4U)          //!< Bit position for USBHS_PORTSC1_OCA.
#define BM_USBHS_PORTSC1_OCA (0x00000010U) //!< Bit mask for USBHS_PORTSC1_OCA.
#define BS_USBHS_PORTSC1_OCA (1U)          //!< Bit field size in bits for USBHS_PORTSC1_OCA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_OCA field.
#define BR_USBHS_PORTSC1_OCA (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_OCA))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field OCC[5] (W1C)
 *
 * Indicates a change to the OCA bit. Software clears this bit by writing a 1.
 * For host mode, the user can provide over-current detection to the USBn_PWRFAULT
 * signal for this condition. For device-only implementations, this bit must
 * always be cleared.
 *
 * Values:
 * - 0 - No over-current
 * - 1 - Over-current detect
 */
//@{
#define BP_USBHS_PORTSC1_OCC (5U)          //!< Bit position for USBHS_PORTSC1_OCC.
#define BM_USBHS_PORTSC1_OCC (0x00000020U) //!< Bit mask for USBHS_PORTSC1_OCC.
#define BS_USBHS_PORTSC1_OCC (1U)          //!< Bit field size in bits for USBHS_PORTSC1_OCC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_OCC field.
#define BR_USBHS_PORTSC1_OCC (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_OCC))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_OCC.
#define BF_USBHS_PORTSC1_OCC(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_OCC), uint32_t) & BM_USBHS_PORTSC1_OCC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the OCC field to a new value.
#define BW_USBHS_PORTSC1_OCC(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_OCC) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field FPR[6] (RW)
 *
 * This bit is not-EHCI compatible. Host mode: Software sets this bit to drive
 * resume signaling. The controller sets this bit if a J-to-K transition is
 * detected while the port is in suspend state (PE = SUSP = 1), which in turn sets the
 * USBSTS[PCI] bit. This bit automatically clears after the resume sequence is
 * complete. This behavior is different from EHCI where the host controller driver
 * is required to clear this bit after the resume duration is timed in the
 * driver. When the controller owns the port, the resume sequence follows the defined
 * sequence documented in the USB Specification Revision 2.0. The resume signaling
 * (full-speed K) is driven on the port as long as this bit remains set. This
 * bit remains set until the port switches to the high-speed idle. Clearing this
 * bit has no affect because the port controller times the resume operation to
 * clear the bit the port control state switches to HS or FS idle. This bit is
 * cleared if the PP bit is cleared in host mode. Device mode: If remote wakeup is
 * enabled, after the device is in suspend for 5 ms or more, software can set this
 * bit to drive resume signaling before clearing. The device controller sets this
 * bit if a J-to-K transition is detected while port is in suspend state, which in
 * turn sets the USBSTS[PCI] bit. The bit is cleared when the device returns to
 * normal operation.
 *
 * Values:
 * - 0 - No resume (K-state) detected/driven on port
 * - 1 - Resume detected/driven on port
 */
//@{
#define BP_USBHS_PORTSC1_FPR (6U)          //!< Bit position for USBHS_PORTSC1_FPR.
#define BM_USBHS_PORTSC1_FPR (0x00000040U) //!< Bit mask for USBHS_PORTSC1_FPR.
#define BS_USBHS_PORTSC1_FPR (1U)          //!< Bit field size in bits for USBHS_PORTSC1_FPR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_FPR field.
#define BR_USBHS_PORTSC1_FPR (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_FPR))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_FPR.
#define BF_USBHS_PORTSC1_FPR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_FPR), uint32_t) & BM_USBHS_PORTSC1_FPR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FPR field to a new value.
#define BW_USBHS_PORTSC1_FPR(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_FPR) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field SUSP[7] (RW)
 *
 * Host mode: The PE and SUSP bits define the port state as follows: PE SUSP
 * Port State 0 x Disable 1 0 Enable 1 1 Suspend When in suspend state, downstream
 * propagation of data is blocked on this port, except for port reset. The
 * blocking occurs at the end of the current transaction if a transaction was in
 * progress when this bit was set. In the suspend state, the port is sensitive to resume
 * detection. The bit status does not change until the port is suspended and
 * there may be a delay in suspending a port if there is a transaction currently in
 * progress on the USB. The module unconditionally clears this bit when software
 * clears the FPR bit. The host controller ignores clearing this bit. If host
 * software sets this bit when the port is not enabled (PE = 0), the results are
 * undefined. This bit is cleared if the PP bit is cleared in host mode. Device
 * mode: In device mode, this bit is a read-only status bit.
 *
 * Values:
 * - 0 - Port not in suspend state
 * - 1 - Port in suspend state
 */
//@{
#define BP_USBHS_PORTSC1_SUSP (7U)         //!< Bit position for USBHS_PORTSC1_SUSP.
#define BM_USBHS_PORTSC1_SUSP (0x00000080U) //!< Bit mask for USBHS_PORTSC1_SUSP.
#define BS_USBHS_PORTSC1_SUSP (1U)         //!< Bit field size in bits for USBHS_PORTSC1_SUSP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_SUSP field.
#define BR_USBHS_PORTSC1_SUSP (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_SUSP))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_SUSP.
#define BF_USBHS_PORTSC1_SUSP(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_SUSP), uint32_t) & BM_USBHS_PORTSC1_SUSP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUSP field to a new value.
#define BW_USBHS_PORTSC1_SUSP(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_SUSP) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PR[8] (RW)
 *
 * This field is cleared if the PP bit is cleared. Host mode: When software sets
 * this bit the bus-reset sequence as defined in the USB Specification Revision
 * 2.0 starts. This bit automatically clears after the reset sequence completes.
 * This behavior is different from EHCI where the host controller driver is
 * required to clear this bit after the reset duration is timed in the driver. Device
 * mode: This bit is a read-only status bit. Device reset from the USB bus is
 * also indicated in the USBSTS register.
 *
 * Values:
 * - 0 - Port is not in reset
 * - 1 - Port is in reset
 */
//@{
#define BP_USBHS_PORTSC1_PR  (8U)          //!< Bit position for USBHS_PORTSC1_PR.
#define BM_USBHS_PORTSC1_PR  (0x00000100U) //!< Bit mask for USBHS_PORTSC1_PR.
#define BS_USBHS_PORTSC1_PR  (1U)          //!< Bit field size in bits for USBHS_PORTSC1_PR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PR field.
#define BR_USBHS_PORTSC1_PR  (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PR))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PR.
#define BF_USBHS_PORTSC1_PR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PR), uint32_t) & BM_USBHS_PORTSC1_PR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PR field to a new value.
#define BW_USBHS_PORTSC1_PR(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PR) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field HSP[9] (RO)
 *
 * Indicates if the host/device connected is in high speed mode. This bit is
 * redundant with the PSPD bit field.
 *
 * Values:
 * - 0 - FS or LS
 * - 1 - HS
 */
//@{
#define BP_USBHS_PORTSC1_HSP (9U)          //!< Bit position for USBHS_PORTSC1_HSP.
#define BM_USBHS_PORTSC1_HSP (0x00000200U) //!< Bit mask for USBHS_PORTSC1_HSP.
#define BS_USBHS_PORTSC1_HSP (1U)          //!< Bit field size in bits for USBHS_PORTSC1_HSP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_HSP field.
#define BR_USBHS_PORTSC1_HSP (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_HSP))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field LS[11:10] (RO)
 *
 * Reflects current logical levels of the USB DP (bit 11) and DM (bit 10) signal
 * lines. In host mode, the line status by the host controller driver is not
 * necessary (unlike EHCI) because hardware manages the connection of FS and LS. In
 * device mode, LS by the device controller is not necessary.
 *
 * Values:
 * - 00 - SE0
 * - 01 - J-state
 * - 10 - K-state
 * - 11 - Undefined
 */
//@{
#define BP_USBHS_PORTSC1_LS  (10U)         //!< Bit position for USBHS_PORTSC1_LS.
#define BM_USBHS_PORTSC1_LS  (0x00000C00U) //!< Bit mask for USBHS_PORTSC1_LS.
#define BS_USBHS_PORTSC1_LS  (2U)          //!< Bit field size in bits for USBHS_PORTSC1_LS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_LS field.
#define BR_USBHS_PORTSC1_LS  (HW_USBHS_PORTSC1.B.LS)
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PP[12] (RW)
 *
 * Represents the current setting of the port power control switch (0 equals
 * off, 1 equals on). When power is not available on a port (PP = 0), it is
 * non-functional and does not report attaches, detaches, etc. When an over-current
 * condition is detected on a powered port, the host controller driver from a 1to a 0
 * (removing power from the port) transitions the PP bit in each affected port.
 */
//@{
#define BP_USBHS_PORTSC1_PP  (12U)         //!< Bit position for USBHS_PORTSC1_PP.
#define BM_USBHS_PORTSC1_PP  (0x00001000U) //!< Bit mask for USBHS_PORTSC1_PP.
#define BS_USBHS_PORTSC1_PP  (1U)          //!< Bit field size in bits for USBHS_PORTSC1_PP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PP field.
#define BR_USBHS_PORTSC1_PP  (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PP))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PP.
#define BF_USBHS_PORTSC1_PP(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PP), uint32_t) & BM_USBHS_PORTSC1_PP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PP field to a new value.
#define BW_USBHS_PORTSC1_PP(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PP) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PO[13] (RW)
 *
 * Port owner handoff is not implemented in this device.
 */
//@{
#define BP_USBHS_PORTSC1_PO  (13U)         //!< Bit position for USBHS_PORTSC1_PO.
#define BM_USBHS_PORTSC1_PO  (0x00002000U) //!< Bit mask for USBHS_PORTSC1_PO.
#define BS_USBHS_PORTSC1_PO  (1U)          //!< Bit field size in bits for USBHS_PORTSC1_PO.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PO field.
#define BR_USBHS_PORTSC1_PO  (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PO))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PO.
#define BF_USBHS_PORTSC1_PO(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PO), uint32_t) & BM_USBHS_PORTSC1_PO)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PO field to a new value.
#define BW_USBHS_PORTSC1_PO(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PO) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PIC[15:14] (RW)
 *
 * Not supported on this module.
 */
//@{
#define BP_USBHS_PORTSC1_PIC (14U)         //!< Bit position for USBHS_PORTSC1_PIC.
#define BM_USBHS_PORTSC1_PIC (0x0000C000U) //!< Bit mask for USBHS_PORTSC1_PIC.
#define BS_USBHS_PORTSC1_PIC (2U)          //!< Bit field size in bits for USBHS_PORTSC1_PIC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PIC field.
#define BR_USBHS_PORTSC1_PIC (HW_USBHS_PORTSC1.B.PIC)
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PIC.
#define BF_USBHS_PORTSC1_PIC(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PIC), uint32_t) & BM_USBHS_PORTSC1_PIC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PIC field to a new value.
#define BW_USBHS_PORTSC1_PIC(v) (HW_USBHS_PORTSC1_WR((HW_USBHS_PORTSC1_RD() & ~BM_USBHS_PORTSC1_PIC) | BF_USBHS_PORTSC1_PIC(v)))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PTC[19:16] (RW)
 *
 * Any value other than 0 indicates the port operates in test mode. Refer to
 * Chapter 7 of the USB Specification Revision 2.0 for details on each test mode.
 * The FORCE_ENABLE_FS and FORCE ENABLE_LS settings are extensions to the test mode
 * support in the EHCI specification. Writing the PTC field to any of the
 * FORCE_ENABLE values forces the port into the connected and enabled state at the
 * selected speed. Then clearing the PTC field allows the port state machines to
 * progress normally from that point.
 *
 * Values:
 * - 0000 - Not enabled
 * - 0001 - J_STATE
 * - 0010 - K_STATE
 * - 0011 - SEQ_NAK
 * - 0100 - Packet
 * - 0101 - FORCE_ENABLE_HS
 * - 0110 - FORCE_ENABLE_FS
 * - 0111 - FORCE_ENABLE_LS
 */
//@{
#define BP_USBHS_PORTSC1_PTC (16U)         //!< Bit position for USBHS_PORTSC1_PTC.
#define BM_USBHS_PORTSC1_PTC (0x000F0000U) //!< Bit mask for USBHS_PORTSC1_PTC.
#define BS_USBHS_PORTSC1_PTC (4U)          //!< Bit field size in bits for USBHS_PORTSC1_PTC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PTC field.
#define BR_USBHS_PORTSC1_PTC (HW_USBHS_PORTSC1.B.PTC)
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PTC.
#define BF_USBHS_PORTSC1_PTC(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PTC), uint32_t) & BM_USBHS_PORTSC1_PTC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PTC field to a new value.
#define BW_USBHS_PORTSC1_PTC(v) (HW_USBHS_PORTSC1_WR((HW_USBHS_PORTSC1_RD() & ~BM_USBHS_PORTSC1_PTC) | BF_USBHS_PORTSC1_PTC(v)))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field WKCN[20] (RW)
 *
 * Enables the port to be sensitive to device connects as wake-up events. This
 * field is 0 if the PP bit is cleared or the module is in device mode. In host
 * mode, this can work with an external power control circuit.
 */
//@{
#define BP_USBHS_PORTSC1_WKCN (20U)        //!< Bit position for USBHS_PORTSC1_WKCN.
#define BM_USBHS_PORTSC1_WKCN (0x00100000U) //!< Bit mask for USBHS_PORTSC1_WKCN.
#define BS_USBHS_PORTSC1_WKCN (1U)         //!< Bit field size in bits for USBHS_PORTSC1_WKCN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_WKCN field.
#define BR_USBHS_PORTSC1_WKCN (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_WKCN))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_WKCN.
#define BF_USBHS_PORTSC1_WKCN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_WKCN), uint32_t) & BM_USBHS_PORTSC1_WKCN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WKCN field to a new value.
#define BW_USBHS_PORTSC1_WKCN(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_WKCN) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field WKDS[21] (RW)
 *
 * Enables the port to be sensitive to device disconnects as wake-up events.
 * This field is 0 if the PP bit is cleared or the module is in device mode. In host
 * mode, this bit can work with an external power control circuit.
 */
//@{
#define BP_USBHS_PORTSC1_WKDS (21U)        //!< Bit position for USBHS_PORTSC1_WKDS.
#define BM_USBHS_PORTSC1_WKDS (0x00200000U) //!< Bit mask for USBHS_PORTSC1_WKDS.
#define BS_USBHS_PORTSC1_WKDS (1U)         //!< Bit field size in bits for USBHS_PORTSC1_WKDS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_WKDS field.
#define BR_USBHS_PORTSC1_WKDS (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_WKDS))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_WKDS.
#define BF_USBHS_PORTSC1_WKDS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_WKDS), uint32_t) & BM_USBHS_PORTSC1_WKDS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WKDS field to a new value.
#define BW_USBHS_PORTSC1_WKDS(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_WKDS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field WKOC[22] (RW)
 *
 * Enables the port to be sensitive to over-current conditions as wake-up
 * events. This field is 0 if the PP bit is cleared. In host mode, this bit can work
 * with an external power control circuit.
 */
//@{
#define BP_USBHS_PORTSC1_WKOC (22U)        //!< Bit position for USBHS_PORTSC1_WKOC.
#define BM_USBHS_PORTSC1_WKOC (0x00400000U) //!< Bit mask for USBHS_PORTSC1_WKOC.
#define BS_USBHS_PORTSC1_WKOC (1U)         //!< Bit field size in bits for USBHS_PORTSC1_WKOC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_WKOC field.
#define BR_USBHS_PORTSC1_WKOC (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_WKOC))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_WKOC.
#define BF_USBHS_PORTSC1_WKOC(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_WKOC), uint32_t) & BM_USBHS_PORTSC1_WKOC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WKOC field to a new value.
#define BW_USBHS_PORTSC1_WKOC(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_WKOC) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PHCD[23] (RW)
 *
 * This bit is not defined in the EHCI specification. Host mode: The PHY can be
 * placed into low-power suspend when downstream device is put into suspend mode
 * or when no downstream device connects. Software completely controls low-power
 * suspend. Device mode: For the USBHS module in device mode, the PHY can be put
 * into low power suspend when the device is not running (USBCMD[RS] = 0) or
 * suspend signaling is detected on the USB. The PHCD bit is cleared automatically
 * when the resume signaling is detected or when forcing port resumes. Reading this
 * bit indicates the status of the PHY.
 */
//@{
#define BP_USBHS_PORTSC1_PHCD (23U)        //!< Bit position for USBHS_PORTSC1_PHCD.
#define BM_USBHS_PORTSC1_PHCD (0x00800000U) //!< Bit mask for USBHS_PORTSC1_PHCD.
#define BS_USBHS_PORTSC1_PHCD (1U)         //!< Bit field size in bits for USBHS_PORTSC1_PHCD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PHCD field.
#define BR_USBHS_PORTSC1_PHCD (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PHCD))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PHCD.
#define BF_USBHS_PORTSC1_PHCD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PHCD), uint32_t) & BM_USBHS_PORTSC1_PHCD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PHCD field to a new value.
#define BW_USBHS_PORTSC1_PHCD(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PHCD) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PFSC[24] (RW)
 *
 * Disables the chirp sequence that allows the port to identify itself as a HS
 * port. useful for testing FS configurations with a HS host, hub, or device. Not
 * defined in the EHCI specification. This bit is for debugging purposes.
 *
 * Values:
 * - 0 - Allow the port to identify itself as high speed
 * - 1 - Force the port to only connect at full speed
 */
//@{
#define BP_USBHS_PORTSC1_PFSC (24U)        //!< Bit position for USBHS_PORTSC1_PFSC.
#define BM_USBHS_PORTSC1_PFSC (0x01000000U) //!< Bit mask for USBHS_PORTSC1_PFSC.
#define BS_USBHS_PORTSC1_PFSC (1U)         //!< Bit field size in bits for USBHS_PORTSC1_PFSC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PFSC field.
#define BR_USBHS_PORTSC1_PFSC (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PFSC))
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PFSC.
#define BF_USBHS_PORTSC1_PFSC(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PFSC), uint32_t) & BM_USBHS_PORTSC1_PFSC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PFSC field to a new value.
#define BW_USBHS_PORTSC1_PFSC(v) (BITBAND_ACCESS32(HW_USBHS_PORTSC1_ADDR, BP_USBHS_PORTSC1_PFSC) = (v))
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PSPD[27:26] (RO)
 *
 * This read-only register field indicates the speed the port operates. This bit
 * is not defined in the EHCI specification.
 *
 * Values:
 * - 00 - Full speed
 * - 01 - Low speed
 * - 10 - High speed
 * - 11 - Undefined
 */
//@{
#define BP_USBHS_PORTSC1_PSPD (26U)        //!< Bit position for USBHS_PORTSC1_PSPD.
#define BM_USBHS_PORTSC1_PSPD (0x0C000000U) //!< Bit mask for USBHS_PORTSC1_PSPD.
#define BS_USBHS_PORTSC1_PSPD (2U)         //!< Bit field size in bits for USBHS_PORTSC1_PSPD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PSPD field.
#define BR_USBHS_PORTSC1_PSPD (HW_USBHS_PORTSC1.B.PSPD)
#endif
//@}

/*!
 * @name Register USBHS_PORTSC1, field PTS[31:30] (RW)
 *
 * Controls which parallel transceiver interface is selected. 10 ULPI parallel
 * interface All other values are reserved. This field is not defined in the EHCI
 * specification.
 */
//@{
#define BP_USBHS_PORTSC1_PTS (30U)         //!< Bit position for USBHS_PORTSC1_PTS.
#define BM_USBHS_PORTSC1_PTS (0xC0000000U) //!< Bit mask for USBHS_PORTSC1_PTS.
#define BS_USBHS_PORTSC1_PTS (2U)          //!< Bit field size in bits for USBHS_PORTSC1_PTS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_PORTSC1_PTS field.
#define BR_USBHS_PORTSC1_PTS (HW_USBHS_PORTSC1.B.PTS)
#endif

//! @brief Format value for bitfield USBHS_PORTSC1_PTS.
#define BF_USBHS_PORTSC1_PTS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_PORTSC1_PTS), uint32_t) & BM_USBHS_PORTSC1_PTS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PTS field to a new value.
#define BW_USBHS_PORTSC1_PTS(v) (HW_USBHS_PORTSC1_WR((HW_USBHS_PORTSC1_RD() & ~BM_USBHS_PORTSC1_PTS) | BF_USBHS_PORTSC1_PTS(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_OTGSC - On-the-Go Status and Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_OTGSC - On-the-Go Status and Control Register (RW)
 *
 * Reset value: 0x00001020U
 *
 * This register is not defined in the EHCI specification. The host controller
 * implements one OTGSC register corresponding to port 0 of the host controller.
 * The OTGSC register has four sections: OTG interrupt enables (read/write) OTG
 * interrupt status (read/write to clear) OTG status inputs (read-only) OTG
 * controls (read/write) The status inputs de-bounce using a 1 ms time constant. Values
 * on the status inputs that do not persist for more than 1 ms do not cause an
 * update of the status inputs or an OTG interrupt.
 */
typedef union _hw_usbhs_otgsc
{
    uint32_t U;
    struct _hw_usbhs_otgsc_bitfields
    {
        uint32_t VD : 1;               //!< [0] VBUS Discharge
        uint32_t VC : 1;               //!< [1] VBUS Charge
        uint32_t HAAR : 1;             //!< [2] Hardware Assist Auto-Reset
        uint32_t OT : 1;               //!< [3] OTG Termination
        uint32_t DP : 1;               //!< [4] Data Pulsing
        uint32_t IDPU : 1;             //!< [5] ID Pull-Up
        uint32_t RESERVED0 : 1;        //!< [6] Reserved
        uint32_t HABA : 1;             //!< [7] Hardware Assist B-Disconnect to A-connect
        uint32_t ID : 1;               //!< [8] USB ID
        uint32_t AVV : 1;              //!< [9] A VBus Valid
        uint32_t ASV : 1;              //!< [10] A Session Valid
        uint32_t BSV : 1;              //!< [11] B Session Valid
        uint32_t BSE : 1;              //!< [12] B Session End
        uint32_t MST : 1;              //!< [13] 1 Milli-Second timer Toggle
        uint32_t DPS : 1;              //!< [14] Data bus Pulsing Status
        uint32_t RESERVED1 : 1;        //!< [15] Reserved
        uint32_t IDIS : 1;             //!< [16] USB ID Interrupt Status
        uint32_t AVVIS : 1;            //!< [17] A VBUS Valid Interrupt Status
        uint32_t ASVIS : 1;            //!< [18] A Session Valid Interrupt Status
        uint32_t BSVIS : 1;            //!< [19] B Session Valid Interrupt Status
        uint32_t BSEIS : 1;            //!< [20] B Session End Interrupt Status
        uint32_t MSS : 1;              //!< [21] 1 Milli-Second timer interrupt Status
        uint32_t DPIS : 1;             //!< [22] Data Pulse interrupt Status
        uint32_t RESERVED2 : 1;        //!< [23] Reserved
        uint32_t IDIE : 1;             //!< [24] USB ID Interrupt Enable
        uint32_t AVVIE : 1;            //!< [25] A VBUS Valid Interrupt Enable
        uint32_t ASVIE : 1;            //!< [26] A Session Valid Interrupt Enable
        uint32_t BSVIE : 1;            //!< [27] B Session Valid Interrupt Enable
        uint32_t BSEIE : 1;            //!< [28] B Session End Interrupt Enable
        uint32_t MSE : 1;              //!< [29] 1 Milli-Second timer interrupt Enable
        uint32_t DPIE : 1;             //!< [30] Data Pulse Interrupt Enable
        uint32_t RESERVED3 : 1;        //!< [31] Reserved
    } B;
} hw_usbhs_otgsc_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_OTGSC register
 */
//@{
#define HW_USBHS_OTGSC_ADDR      (REGS_USBHS_BASE + 0x1A4U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_OTGSC           (*(__IO hw_usbhs_otgsc_t *) HW_USBHS_OTGSC_ADDR)
#define HW_USBHS_OTGSC_RD()      (HW_USBHS_OTGSC.U)
#define HW_USBHS_OTGSC_WR(v)     (HW_USBHS_OTGSC.U = (v))
#define HW_USBHS_OTGSC_SET(v)    (HW_USBHS_OTGSC_WR(HW_USBHS_OTGSC_RD() |  (v)))
#define HW_USBHS_OTGSC_CLR(v)    (HW_USBHS_OTGSC_WR(HW_USBHS_OTGSC_RD() & ~(v)))
#define HW_USBHS_OTGSC_TOG(v)    (HW_USBHS_OTGSC_WR(HW_USBHS_OTGSC_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_OTGSC bitfields
 */

/*!
 * @name Register USBHS_OTGSC, field VD[0] (RW)
 *
 * Setting this bit causes VBUS to discharge through a resistor.
 */
//@{
#define BP_USBHS_OTGSC_VD    (0U)          //!< Bit position for USBHS_OTGSC_VD.
#define BM_USBHS_OTGSC_VD    (0x00000001U) //!< Bit mask for USBHS_OTGSC_VD.
#define BS_USBHS_OTGSC_VD    (1U)          //!< Bit field size in bits for USBHS_OTGSC_VD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_VD field.
#define BR_USBHS_OTGSC_VD    (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_VD))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_VD.
#define BF_USBHS_OTGSC_VD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_VD), uint32_t) & BM_USBHS_OTGSC_VD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the VD field to a new value.
#define BW_USBHS_OTGSC_VD(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_VD) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field VC[1] (RW)
 *
 * Setting this bit causes the VBUS line to charge. This is used for VBus
 * pulsing during SRP.
 */
//@{
#define BP_USBHS_OTGSC_VC    (1U)          //!< Bit position for USBHS_OTGSC_VC.
#define BM_USBHS_OTGSC_VC    (0x00000002U) //!< Bit mask for USBHS_OTGSC_VC.
#define BS_USBHS_OTGSC_VC    (1U)          //!< Bit field size in bits for USBHS_OTGSC_VC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_VC field.
#define BR_USBHS_OTGSC_VC    (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_VC))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_VC.
#define BF_USBHS_OTGSC_VC(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_VC), uint32_t) & BM_USBHS_OTGSC_VC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the VC field to a new value.
#define BW_USBHS_OTGSC_VC(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_VC) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field HAAR[2] (RW)
 *
 * Values:
 * - 0 - Disabled.
 * - 1 - Enable automatic reset after connect on host port.
 */
//@{
#define BP_USBHS_OTGSC_HAAR  (2U)          //!< Bit position for USBHS_OTGSC_HAAR.
#define BM_USBHS_OTGSC_HAAR  (0x00000004U) //!< Bit mask for USBHS_OTGSC_HAAR.
#define BS_USBHS_OTGSC_HAAR  (1U)          //!< Bit field size in bits for USBHS_OTGSC_HAAR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_HAAR field.
#define BR_USBHS_OTGSC_HAAR  (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_HAAR))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_HAAR.
#define BF_USBHS_OTGSC_HAAR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_HAAR), uint32_t) & BM_USBHS_OTGSC_HAAR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HAAR field to a new value.
#define BW_USBHS_OTGSC_HAAR(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_HAAR) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field OT[3] (RW)
 *
 * This bit must be set with the OTG module in device mode.
 *
 * Values:
 * - 0 - Disable pull-down on DM
 * - 1 - Enable pull-down on DM
 */
//@{
#define BP_USBHS_OTGSC_OT    (3U)          //!< Bit position for USBHS_OTGSC_OT.
#define BM_USBHS_OTGSC_OT    (0x00000008U) //!< Bit mask for USBHS_OTGSC_OT.
#define BS_USBHS_OTGSC_OT    (1U)          //!< Bit field size in bits for USBHS_OTGSC_OT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_OT field.
#define BR_USBHS_OTGSC_OT    (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_OT))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_OT.
#define BF_USBHS_OTGSC_OT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_OT), uint32_t) & BM_USBHS_OTGSC_OT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the OT field to a new value.
#define BW_USBHS_OTGSC_OT(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_OT) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field DP[4] (RW)
 *
 * Values:
 * - 0 - The pull-up on DP is not asserted
 * - 1 - The pull-up on DP is asserted for data pulsing during SRP
 */
//@{
#define BP_USBHS_OTGSC_DP    (4U)          //!< Bit position for USBHS_OTGSC_DP.
#define BM_USBHS_OTGSC_DP    (0x00000010U) //!< Bit mask for USBHS_OTGSC_DP.
#define BS_USBHS_OTGSC_DP    (1U)          //!< Bit field size in bits for USBHS_OTGSC_DP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_DP field.
#define BR_USBHS_OTGSC_DP    (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_DP))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_DP.
#define BF_USBHS_OTGSC_DP(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_DP), uint32_t) & BM_USBHS_OTGSC_DP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DP field to a new value.
#define BW_USBHS_OTGSC_DP(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_DP) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field IDPU[5] (RW)
 *
 * Provides control over the ID pull-up resistor.
 *
 * Values:
 * - 0 - Disable pull-up. ID input not sampled.
 * - 1 - Enable pull-up
 */
//@{
#define BP_USBHS_OTGSC_IDPU  (5U)          //!< Bit position for USBHS_OTGSC_IDPU.
#define BM_USBHS_OTGSC_IDPU  (0x00000020U) //!< Bit mask for USBHS_OTGSC_IDPU.
#define BS_USBHS_OTGSC_IDPU  (1U)          //!< Bit field size in bits for USBHS_OTGSC_IDPU.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_IDPU field.
#define BR_USBHS_OTGSC_IDPU  (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_IDPU))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_IDPU.
#define BF_USBHS_OTGSC_IDPU(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_IDPU), uint32_t) & BM_USBHS_OTGSC_IDPU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IDPU field to a new value.
#define BW_USBHS_OTGSC_IDPU(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_IDPU) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field HABA[7] (RW)
 *
 * Values:
 * - 0 - Disabled.
 * - 1 - Enable automatic B-disconnect to A-connect sequence.
 */
//@{
#define BP_USBHS_OTGSC_HABA  (7U)          //!< Bit position for USBHS_OTGSC_HABA.
#define BM_USBHS_OTGSC_HABA  (0x00000080U) //!< Bit mask for USBHS_OTGSC_HABA.
#define BS_USBHS_OTGSC_HABA  (1U)          //!< Bit field size in bits for USBHS_OTGSC_HABA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_HABA field.
#define BR_USBHS_OTGSC_HABA  (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_HABA))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_HABA.
#define BF_USBHS_OTGSC_HABA(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_HABA), uint32_t) & BM_USBHS_OTGSC_HABA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HABA field to a new value.
#define BW_USBHS_OTGSC_HABA(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_HABA) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field ID[8] (RO)
 *
 * Values:
 * - 0 - A device
 * - 1 - B device
 */
//@{
#define BP_USBHS_OTGSC_ID    (8U)          //!< Bit position for USBHS_OTGSC_ID.
#define BM_USBHS_OTGSC_ID    (0x00000100U) //!< Bit mask for USBHS_OTGSC_ID.
#define BS_USBHS_OTGSC_ID    (1U)          //!< Bit field size in bits for USBHS_OTGSC_ID.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_ID field.
#define BR_USBHS_OTGSC_ID    (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_ID))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field AVV[9] (RO)
 *
 * Values:
 * - 0 - VBus is below A VBus valid threshold
 * - 1 - VBus is above A VBus valid threshold
 */
//@{
#define BP_USBHS_OTGSC_AVV   (9U)          //!< Bit position for USBHS_OTGSC_AVV.
#define BM_USBHS_OTGSC_AVV   (0x00000200U) //!< Bit mask for USBHS_OTGSC_AVV.
#define BS_USBHS_OTGSC_AVV   (1U)          //!< Bit field size in bits for USBHS_OTGSC_AVV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_AVV field.
#define BR_USBHS_OTGSC_AVV   (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_AVV))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field ASV[10] (RO)
 *
 * Values:
 * - 0 - VBus is below A session valid threshold
 * - 1 - VBus is above A session valid threshold
 */
//@{
#define BP_USBHS_OTGSC_ASV   (10U)         //!< Bit position for USBHS_OTGSC_ASV.
#define BM_USBHS_OTGSC_ASV   (0x00000400U) //!< Bit mask for USBHS_OTGSC_ASV.
#define BS_USBHS_OTGSC_ASV   (1U)          //!< Bit field size in bits for USBHS_OTGSC_ASV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_ASV field.
#define BR_USBHS_OTGSC_ASV   (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_ASV))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field BSV[11] (RO)
 *
 * Values:
 * - 0 - VBus is below B session valid threshold
 * - 1 - VBus is above B session valid threshold
 */
//@{
#define BP_USBHS_OTGSC_BSV   (11U)         //!< Bit position for USBHS_OTGSC_BSV.
#define BM_USBHS_OTGSC_BSV   (0x00000800U) //!< Bit mask for USBHS_OTGSC_BSV.
#define BS_USBHS_OTGSC_BSV   (1U)          //!< Bit field size in bits for USBHS_OTGSC_BSV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_BSV field.
#define BR_USBHS_OTGSC_BSV   (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSV))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field BSE[12] (RO)
 *
 * Values:
 * - 0 - VBus is above B session end threshold
 * - 1 - VBus is below B session end threshold
 */
//@{
#define BP_USBHS_OTGSC_BSE   (12U)         //!< Bit position for USBHS_OTGSC_BSE.
#define BM_USBHS_OTGSC_BSE   (0x00001000U) //!< Bit mask for USBHS_OTGSC_BSE.
#define BS_USBHS_OTGSC_BSE   (1U)          //!< Bit field size in bits for USBHS_OTGSC_BSE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_BSE field.
#define BR_USBHS_OTGSC_BSE   (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSE))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field MST[13] (RO)
 *
 * This bit toggles once per millisecond.
 */
//@{
#define BP_USBHS_OTGSC_MST   (13U)         //!< Bit position for USBHS_OTGSC_MST.
#define BM_USBHS_OTGSC_MST   (0x00002000U) //!< Bit mask for USBHS_OTGSC_MST.
#define BS_USBHS_OTGSC_MST   (1U)          //!< Bit field size in bits for USBHS_OTGSC_MST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_MST field.
#define BR_USBHS_OTGSC_MST   (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_MST))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field DPS[14] (RO)
 *
 * Values:
 * - 0 - No pulsing on port
 * - 1 - Pulsing detected on port
 */
//@{
#define BP_USBHS_OTGSC_DPS   (14U)         //!< Bit position for USBHS_OTGSC_DPS.
#define BM_USBHS_OTGSC_DPS   (0x00004000U) //!< Bit mask for USBHS_OTGSC_DPS.
#define BS_USBHS_OTGSC_DPS   (1U)          //!< Bit field size in bits for USBHS_OTGSC_DPS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_DPS field.
#define BR_USBHS_OTGSC_DPS   (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_DPS))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field IDIS[16] (W1C)
 *
 * Indicates when a change on the ID input is detected. Software must write a 1
 * to clear this bit.
 */
//@{
#define BP_USBHS_OTGSC_IDIS  (16U)         //!< Bit position for USBHS_OTGSC_IDIS.
#define BM_USBHS_OTGSC_IDIS  (0x00010000U) //!< Bit mask for USBHS_OTGSC_IDIS.
#define BS_USBHS_OTGSC_IDIS  (1U)          //!< Bit field size in bits for USBHS_OTGSC_IDIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_IDIS field.
#define BR_USBHS_OTGSC_IDIS  (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_IDIS))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_IDIS.
#define BF_USBHS_OTGSC_IDIS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_IDIS), uint32_t) & BM_USBHS_OTGSC_IDIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IDIS field to a new value.
#define BW_USBHS_OTGSC_IDIS(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_IDIS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field AVVIS[17] (W1C)
 *
 * Indicates when VBUS rises above or falls below the VBUS valid threshold (4.4
 * VDC) on an A device. Software must write a 1 to clear this bit.
 */
//@{
#define BP_USBHS_OTGSC_AVVIS (17U)         //!< Bit position for USBHS_OTGSC_AVVIS.
#define BM_USBHS_OTGSC_AVVIS (0x00020000U) //!< Bit mask for USBHS_OTGSC_AVVIS.
#define BS_USBHS_OTGSC_AVVIS (1U)          //!< Bit field size in bits for USBHS_OTGSC_AVVIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_AVVIS field.
#define BR_USBHS_OTGSC_AVVIS (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_AVVIS))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_AVVIS.
#define BF_USBHS_OTGSC_AVVIS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_AVVIS), uint32_t) & BM_USBHS_OTGSC_AVVIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AVVIS field to a new value.
#define BW_USBHS_OTGSC_AVVIS(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_AVVIS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field ASVIS[18] (W1C)
 *
 * Indicates when VBUS rises above or falls below the A session valid threshold
 * (0.8 VDC). Software must write a 1 to clear this bit.
 */
//@{
#define BP_USBHS_OTGSC_ASVIS (18U)         //!< Bit position for USBHS_OTGSC_ASVIS.
#define BM_USBHS_OTGSC_ASVIS (0x00040000U) //!< Bit mask for USBHS_OTGSC_ASVIS.
#define BS_USBHS_OTGSC_ASVIS (1U)          //!< Bit field size in bits for USBHS_OTGSC_ASVIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_ASVIS field.
#define BR_USBHS_OTGSC_ASVIS (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_ASVIS))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_ASVIS.
#define BF_USBHS_OTGSC_ASVIS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_ASVIS), uint32_t) & BM_USBHS_OTGSC_ASVIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ASVIS field to a new value.
#define BW_USBHS_OTGSC_ASVIS(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_ASVIS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field BSVIS[19] (W1C)
 *
 * Indicates when VBUS rises above or falls below the B session valid threshold
 * (0.8 VDC). Software must write a 1 to clear this bit.
 */
//@{
#define BP_USBHS_OTGSC_BSVIS (19U)         //!< Bit position for USBHS_OTGSC_BSVIS.
#define BM_USBHS_OTGSC_BSVIS (0x00080000U) //!< Bit mask for USBHS_OTGSC_BSVIS.
#define BS_USBHS_OTGSC_BSVIS (1U)          //!< Bit field size in bits for USBHS_OTGSC_BSVIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_BSVIS field.
#define BR_USBHS_OTGSC_BSVIS (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSVIS))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_BSVIS.
#define BF_USBHS_OTGSC_BSVIS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_BSVIS), uint32_t) & BM_USBHS_OTGSC_BSVIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BSVIS field to a new value.
#define BW_USBHS_OTGSC_BSVIS(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSVIS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field BSEIS[20] (W1C)
 *
 * Indicates when VBUS falls below the B session end threshold. Software must
 * write a 1 to clear this bit.
 */
//@{
#define BP_USBHS_OTGSC_BSEIS (20U)         //!< Bit position for USBHS_OTGSC_BSEIS.
#define BM_USBHS_OTGSC_BSEIS (0x00100000U) //!< Bit mask for USBHS_OTGSC_BSEIS.
#define BS_USBHS_OTGSC_BSEIS (1U)          //!< Bit field size in bits for USBHS_OTGSC_BSEIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_BSEIS field.
#define BR_USBHS_OTGSC_BSEIS (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSEIS))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_BSEIS.
#define BF_USBHS_OTGSC_BSEIS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_BSEIS), uint32_t) & BM_USBHS_OTGSC_BSEIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BSEIS field to a new value.
#define BW_USBHS_OTGSC_BSEIS(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSEIS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field MSS[21] (W1C)
 *
 * This bit is set once every millisecond. Software must write a 1 to clear this
 * bit.
 */
//@{
#define BP_USBHS_OTGSC_MSS   (21U)         //!< Bit position for USBHS_OTGSC_MSS.
#define BM_USBHS_OTGSC_MSS   (0x00200000U) //!< Bit mask for USBHS_OTGSC_MSS.
#define BS_USBHS_OTGSC_MSS   (1U)          //!< Bit field size in bits for USBHS_OTGSC_MSS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_MSS field.
#define BR_USBHS_OTGSC_MSS   (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_MSS))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_MSS.
#define BF_USBHS_OTGSC_MSS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_MSS), uint32_t) & BM_USBHS_OTGSC_MSS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MSS field to a new value.
#define BW_USBHS_OTGSC_MSS(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_MSS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field DPIS[22] (W1C)
 *
 * Indicates when data bus pulsing occurs on DP or DM. Data bus pulsing only
 * detected when USBMODE[CM] equals 11 and PORTSC0[PP] is cleared. Software must
 * write a 1 to clear this bit.
 */
//@{
#define BP_USBHS_OTGSC_DPIS  (22U)         //!< Bit position for USBHS_OTGSC_DPIS.
#define BM_USBHS_OTGSC_DPIS  (0x00400000U) //!< Bit mask for USBHS_OTGSC_DPIS.
#define BS_USBHS_OTGSC_DPIS  (1U)          //!< Bit field size in bits for USBHS_OTGSC_DPIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_DPIS field.
#define BR_USBHS_OTGSC_DPIS  (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_DPIS))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_DPIS.
#define BF_USBHS_OTGSC_DPIS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_DPIS), uint32_t) & BM_USBHS_OTGSC_DPIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPIS field to a new value.
#define BW_USBHS_OTGSC_DPIS(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_DPIS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field IDIE[24] (RW)
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
//@{
#define BP_USBHS_OTGSC_IDIE  (24U)         //!< Bit position for USBHS_OTGSC_IDIE.
#define BM_USBHS_OTGSC_IDIE  (0x01000000U) //!< Bit mask for USBHS_OTGSC_IDIE.
#define BS_USBHS_OTGSC_IDIE  (1U)          //!< Bit field size in bits for USBHS_OTGSC_IDIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_IDIE field.
#define BR_USBHS_OTGSC_IDIE  (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_IDIE))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_IDIE.
#define BF_USBHS_OTGSC_IDIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_IDIE), uint32_t) & BM_USBHS_OTGSC_IDIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IDIE field to a new value.
#define BW_USBHS_OTGSC_IDIE(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_IDIE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field AVVIE[25] (RW)
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
//@{
#define BP_USBHS_OTGSC_AVVIE (25U)         //!< Bit position for USBHS_OTGSC_AVVIE.
#define BM_USBHS_OTGSC_AVVIE (0x02000000U) //!< Bit mask for USBHS_OTGSC_AVVIE.
#define BS_USBHS_OTGSC_AVVIE (1U)          //!< Bit field size in bits for USBHS_OTGSC_AVVIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_AVVIE field.
#define BR_USBHS_OTGSC_AVVIE (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_AVVIE))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_AVVIE.
#define BF_USBHS_OTGSC_AVVIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_AVVIE), uint32_t) & BM_USBHS_OTGSC_AVVIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AVVIE field to a new value.
#define BW_USBHS_OTGSC_AVVIE(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_AVVIE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field ASVIE[26] (RW)
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
//@{
#define BP_USBHS_OTGSC_ASVIE (26U)         //!< Bit position for USBHS_OTGSC_ASVIE.
#define BM_USBHS_OTGSC_ASVIE (0x04000000U) //!< Bit mask for USBHS_OTGSC_ASVIE.
#define BS_USBHS_OTGSC_ASVIE (1U)          //!< Bit field size in bits for USBHS_OTGSC_ASVIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_ASVIE field.
#define BR_USBHS_OTGSC_ASVIE (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_ASVIE))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_ASVIE.
#define BF_USBHS_OTGSC_ASVIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_ASVIE), uint32_t) & BM_USBHS_OTGSC_ASVIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ASVIE field to a new value.
#define BW_USBHS_OTGSC_ASVIE(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_ASVIE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field BSVIE[27] (RW)
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
//@{
#define BP_USBHS_OTGSC_BSVIE (27U)         //!< Bit position for USBHS_OTGSC_BSVIE.
#define BM_USBHS_OTGSC_BSVIE (0x08000000U) //!< Bit mask for USBHS_OTGSC_BSVIE.
#define BS_USBHS_OTGSC_BSVIE (1U)          //!< Bit field size in bits for USBHS_OTGSC_BSVIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_BSVIE field.
#define BR_USBHS_OTGSC_BSVIE (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSVIE))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_BSVIE.
#define BF_USBHS_OTGSC_BSVIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_BSVIE), uint32_t) & BM_USBHS_OTGSC_BSVIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BSVIE field to a new value.
#define BW_USBHS_OTGSC_BSVIE(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSVIE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field BSEIE[28] (RW)
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
//@{
#define BP_USBHS_OTGSC_BSEIE (28U)         //!< Bit position for USBHS_OTGSC_BSEIE.
#define BM_USBHS_OTGSC_BSEIE (0x10000000U) //!< Bit mask for USBHS_OTGSC_BSEIE.
#define BS_USBHS_OTGSC_BSEIE (1U)          //!< Bit field size in bits for USBHS_OTGSC_BSEIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_BSEIE field.
#define BR_USBHS_OTGSC_BSEIE (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSEIE))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_BSEIE.
#define BF_USBHS_OTGSC_BSEIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_BSEIE), uint32_t) & BM_USBHS_OTGSC_BSEIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BSEIE field to a new value.
#define BW_USBHS_OTGSC_BSEIE(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_BSEIE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field MSE[29] (RW)
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
//@{
#define BP_USBHS_OTGSC_MSE   (29U)         //!< Bit position for USBHS_OTGSC_MSE.
#define BM_USBHS_OTGSC_MSE   (0x20000000U) //!< Bit mask for USBHS_OTGSC_MSE.
#define BS_USBHS_OTGSC_MSE   (1U)          //!< Bit field size in bits for USBHS_OTGSC_MSE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_MSE field.
#define BR_USBHS_OTGSC_MSE   (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_MSE))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_MSE.
#define BF_USBHS_OTGSC_MSE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_MSE), uint32_t) & BM_USBHS_OTGSC_MSE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MSE field to a new value.
#define BW_USBHS_OTGSC_MSE(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_MSE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_OTGSC, field DPIE[30] (RW)
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
//@{
#define BP_USBHS_OTGSC_DPIE  (30U)         //!< Bit position for USBHS_OTGSC_DPIE.
#define BM_USBHS_OTGSC_DPIE  (0x40000000U) //!< Bit mask for USBHS_OTGSC_DPIE.
#define BS_USBHS_OTGSC_DPIE  (1U)          //!< Bit field size in bits for USBHS_OTGSC_DPIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_OTGSC_DPIE field.
#define BR_USBHS_OTGSC_DPIE  (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_DPIE))
#endif

//! @brief Format value for bitfield USBHS_OTGSC_DPIE.
#define BF_USBHS_OTGSC_DPIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_OTGSC_DPIE), uint32_t) & BM_USBHS_OTGSC_DPIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPIE field to a new value.
#define BW_USBHS_OTGSC_DPIE(v) (BITBAND_ACCESS32(HW_USBHS_OTGSC_ADDR, BP_USBHS_OTGSC_DPIE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_USBMODE - USB Mode Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_USBMODE - USB Mode Register (RW)
 *
 * Reset value: 0x00005000U
 *
 * This register is not defined in the EHCI specification. It controls the
 * operating mode of the module.
 */
typedef union _hw_usbhs_usbmode
{
    uint32_t U;
    struct _hw_usbhs_usbmode_bitfields
    {
        uint32_t CM : 2;               //!< [1:0] Controller Mode
        uint32_t ES : 1;               //!< [2] Endian Select
        uint32_t SLOM : 1;             //!< [3] Setup Lock-Out Mode
        uint32_t SDIS : 1;             //!< [4] Stream DISable
        uint32_t RESERVED0 : 7;        //!< [11:5] Reserved
        uint32_t TXHSD : 3;            //!< [14:12] Tx to Tx HS Delay
        uint32_t RESERVED1 : 17;       //!< [31:15] Reserved
    } B;
} hw_usbhs_usbmode_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_USBMODE register
 */
//@{
#define HW_USBHS_USBMODE_ADDR    (REGS_USBHS_BASE + 0x1A8U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_USBMODE         (*(__IO hw_usbhs_usbmode_t *) HW_USBHS_USBMODE_ADDR)
#define HW_USBHS_USBMODE_RD()    (HW_USBHS_USBMODE.U)
#define HW_USBHS_USBMODE_WR(v)   (HW_USBHS_USBMODE.U = (v))
#define HW_USBHS_USBMODE_SET(v)  (HW_USBHS_USBMODE_WR(HW_USBHS_USBMODE_RD() |  (v)))
#define HW_USBHS_USBMODE_CLR(v)  (HW_USBHS_USBMODE_WR(HW_USBHS_USBMODE_RD() & ~(v)))
#define HW_USBHS_USBMODE_TOG(v)  (HW_USBHS_USBMODE_WR(HW_USBHS_USBMODE_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_USBMODE bitfields
 */

/*!
 * @name Register USBHS_USBMODE, field CM[1:0] (RW)
 *
 * This register can be written only once after reset. If necessary to switch
 * modes, software must reset the controller by writing to the USBCMD[RST] bit
 * before reprogramming this register. The USBHS module must be initialized to the
 * desired operating mode after reset.
 *
 * Values:
 * - 00 - Idle (default for the USBHS module)
 * - 01 - Reserved
 * - 10 - Device controller
 * - 11 - Host controller
 */
//@{
#define BP_USBHS_USBMODE_CM  (0U)          //!< Bit position for USBHS_USBMODE_CM.
#define BM_USBHS_USBMODE_CM  (0x00000003U) //!< Bit mask for USBHS_USBMODE_CM.
#define BS_USBHS_USBMODE_CM  (2U)          //!< Bit field size in bits for USBHS_USBMODE_CM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBMODE_CM field.
#define BR_USBHS_USBMODE_CM  (HW_USBHS_USBMODE.B.CM)
#endif

//! @brief Format value for bitfield USBHS_USBMODE_CM.
#define BF_USBHS_USBMODE_CM(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBMODE_CM), uint32_t) & BM_USBHS_USBMODE_CM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CM field to a new value.
#define BW_USBHS_USBMODE_CM(v) (HW_USBHS_USBMODE_WR((HW_USBHS_USBMODE_RD() & ~BM_USBHS_USBMODE_CM) | BF_USBHS_USBMODE_CM(v)))
#endif
//@}

/*!
 * @name Register USBHS_USBMODE, field ES[2] (RW)
 *
 * Controls the byte ordering of the transfer buffers to match the host
 * microprocessor bus architecture. The bit fields in the register interface and the DMA
 * data structures (including the setup buffer within the device QH) are
 * unaffected by the value of this bit, because they are based upon 32-bit words.
 *
 * Values:
 * - 0 - Little endian. First byte referenced in least significant byte of
 *     32-bit word.
 * - 1 - Big endian. First byte referenced in most significant byte of 32-bit
 *     word.
 */
//@{
#define BP_USBHS_USBMODE_ES  (2U)          //!< Bit position for USBHS_USBMODE_ES.
#define BM_USBHS_USBMODE_ES  (0x00000004U) //!< Bit mask for USBHS_USBMODE_ES.
#define BS_USBHS_USBMODE_ES  (1U)          //!< Bit field size in bits for USBHS_USBMODE_ES.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBMODE_ES field.
#define BR_USBHS_USBMODE_ES  (BITBAND_ACCESS32(HW_USBHS_USBMODE_ADDR, BP_USBHS_USBMODE_ES))
#endif

//! @brief Format value for bitfield USBHS_USBMODE_ES.
#define BF_USBHS_USBMODE_ES(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBMODE_ES), uint32_t) & BM_USBHS_USBMODE_ES)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ES field to a new value.
#define BW_USBHS_USBMODE_ES(v) (BITBAND_ACCESS32(HW_USBHS_USBMODE_ADDR, BP_USBHS_USBMODE_ES) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBMODE, field SLOM[3] (RW)
 *
 * For the module in device mode, this bit controls behavior of the setup lock
 * mechanism. See section "Control Endpoint Operation."
 */
//@{
#define BP_USBHS_USBMODE_SLOM (3U)         //!< Bit position for USBHS_USBMODE_SLOM.
#define BM_USBHS_USBMODE_SLOM (0x00000008U) //!< Bit mask for USBHS_USBMODE_SLOM.
#define BS_USBHS_USBMODE_SLOM (1U)         //!< Bit field size in bits for USBHS_USBMODE_SLOM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBMODE_SLOM field.
#define BR_USBHS_USBMODE_SLOM (BITBAND_ACCESS32(HW_USBHS_USBMODE_ADDR, BP_USBHS_USBMODE_SLOM))
#endif

//! @brief Format value for bitfield USBHS_USBMODE_SLOM.
#define BF_USBHS_USBMODE_SLOM(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBMODE_SLOM), uint32_t) & BM_USBHS_USBMODE_SLOM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SLOM field to a new value.
#define BW_USBHS_USBMODE_SLOM(v) (BITBAND_ACCESS32(HW_USBHS_USBMODE_ADDR, BP_USBHS_USBMODE_SLOM) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBMODE, field SDIS[4] (RW)
 *
 * Host mode: Setting this bit ensures that overruns/underruns of the latency
 * FIFO are eliminated for low bandwidth systems where the RX and TX buffers are
 * sufficient to contain the entire packet. Enabling stream disable also has the
 * effect of ensuring the TX latency fills to capacity before the packet launches
 * onto the USB. Time duration to pre-fill the FIFO becomes significant when
 * stream disable is active. See TXFILLTUNING to characterize the adjustments needed
 * for the scheduler when using this feature. Also, in systems with high system
 * bus utilization, setting this bit ensures no overruns or underruns during
 * operation at the expense of link utilization. SDIS can be left clear and the rules
 * under the description of the TXFILLTUNING register can limit underruns/overruns
 * for those who desire optimal link performance. Device mode: Setting this bit
 * disables double priming on RX and TX for low bandwidth systems. This mode
 * ensures that when the RX and TX buffers are sufficient to contain an entire packet
 * that the standard double buffering scheme is disabled to prevent
 * overruns/underruns in bandwidth limited systems. In high-speed mode, all packets received
 * are responded to with a NYET handshake when stream disable is active.
 *
 * Values:
 * - 0 - Inactive
 * - 1 - Active
 */
//@{
#define BP_USBHS_USBMODE_SDIS (4U)         //!< Bit position for USBHS_USBMODE_SDIS.
#define BM_USBHS_USBMODE_SDIS (0x00000010U) //!< Bit mask for USBHS_USBMODE_SDIS.
#define BS_USBHS_USBMODE_SDIS (1U)         //!< Bit field size in bits for USBHS_USBMODE_SDIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBMODE_SDIS field.
#define BR_USBHS_USBMODE_SDIS (BITBAND_ACCESS32(HW_USBHS_USBMODE_ADDR, BP_USBHS_USBMODE_SDIS))
#endif

//! @brief Format value for bitfield USBHS_USBMODE_SDIS.
#define BF_USBHS_USBMODE_SDIS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBMODE_SDIS), uint32_t) & BM_USBHS_USBMODE_SDIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SDIS field to a new value.
#define BW_USBHS_USBMODE_SDIS(v) (BITBAND_ACCESS32(HW_USBHS_USBMODE_ADDR, BP_USBHS_USBMODE_SDIS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBMODE, field TXHSD[14:12] (RW)
 *
 * Controls the value of TX to TX HS Interpacket Delay by changing the internal
 * delay count. The value of the global TX to TX interpacket delay depends on
 * this internal counter and on the intrinsic PHY TX End Delay and TX Start Delay
 * values. The TX to TX interpacket gap must be within the interval [88,192] bit
 * times. 88 <= Controller internal delay - Tx End Delay + Tx Start Delay <= 192
 * (HS bit times) Below are the values of the internal controller counter in terms
 * of PHY clock cycles.
 *
 * Values:
 * - 000 - 10
 * - 001 - 11
 * - 010 - 12
 * - 011 - 13
 * - 100 - 14
 * - 101 - 15
 * - 110 - 16
 * - 111 - 17
 */
//@{
#define BP_USBHS_USBMODE_TXHSD (12U)       //!< Bit position for USBHS_USBMODE_TXHSD.
#define BM_USBHS_USBMODE_TXHSD (0x00007000U) //!< Bit mask for USBHS_USBMODE_TXHSD.
#define BS_USBHS_USBMODE_TXHSD (3U)        //!< Bit field size in bits for USBHS_USBMODE_TXHSD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBMODE_TXHSD field.
#define BR_USBHS_USBMODE_TXHSD (HW_USBHS_USBMODE.B.TXHSD)
#endif

//! @brief Format value for bitfield USBHS_USBMODE_TXHSD.
#define BF_USBHS_USBMODE_TXHSD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBMODE_TXHSD), uint32_t) & BM_USBHS_USBMODE_TXHSD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXHSD field to a new value.
#define BW_USBHS_USBMODE_TXHSD(v) (HW_USBHS_USBMODE_WR((HW_USBHS_USBMODE_RD() & ~BM_USBHS_USBMODE_TXHSD) | BF_USBHS_USBMODE_TXHSD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_EPSETUPSR - Endpoint Setup Status Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPSETUPSR - Endpoint Setup Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is not defined in the EHCI specification. This register
 * contains the endpoint setup status and is used only in device mode.
 */
typedef union _hw_usbhs_epsetupsr
{
    uint32_t U;
    struct _hw_usbhs_epsetupsr_bitfields
    {
        uint32_t EPSETUPSTAT : 4;      //!< [3:0] Setup Endpoint Status
        uint32_t RESERVED0 : 28;       //!< [31:4] Reserved
    } B;
} hw_usbhs_epsetupsr_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPSETUPSR register
 */
//@{
#define HW_USBHS_EPSETUPSR_ADDR  (REGS_USBHS_BASE + 0x1ACU)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPSETUPSR       (*(__IO hw_usbhs_epsetupsr_t *) HW_USBHS_EPSETUPSR_ADDR)
#define HW_USBHS_EPSETUPSR_RD()  (HW_USBHS_EPSETUPSR.U)
#define HW_USBHS_EPSETUPSR_WR(v) (HW_USBHS_EPSETUPSR.U = (v))
#define HW_USBHS_EPSETUPSR_SET(v) (HW_USBHS_EPSETUPSR_WR(HW_USBHS_EPSETUPSR_RD() |  (v)))
#define HW_USBHS_EPSETUPSR_CLR(v) (HW_USBHS_EPSETUPSR_WR(HW_USBHS_EPSETUPSR_RD() & ~(v)))
#define HW_USBHS_EPSETUPSR_TOG(v) (HW_USBHS_EPSETUPSR_WR(HW_USBHS_EPSETUPSR_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPSETUPSR bitfields
 */

/*!
 * @name Register USBHS_EPSETUPSR, field EPSETUPSTAT[3:0] (W1C)
 *
 * For every setup transaction received, a corresponding bit in this field is
 * set. This register is used only in device mode. Software must clear or
 * acknowledge the setup transfer by writing a 1 to a respective bit after it has read the
 * setup data from the queue head. The response to a setup packet, as in the
 * order of operations and total response time, is crucial to limit bus time outs
 * while the setup lockout mechanism engages.
 */
//@{
#define BP_USBHS_EPSETUPSR_EPSETUPSTAT (0U) //!< Bit position for USBHS_EPSETUPSR_EPSETUPSTAT.
#define BM_USBHS_EPSETUPSR_EPSETUPSTAT (0x0000000FU) //!< Bit mask for USBHS_EPSETUPSR_EPSETUPSTAT.
#define BS_USBHS_EPSETUPSR_EPSETUPSTAT (4U) //!< Bit field size in bits for USBHS_EPSETUPSR_EPSETUPSTAT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPSETUPSR_EPSETUPSTAT field.
#define BR_USBHS_EPSETUPSR_EPSETUPSTAT (HW_USBHS_EPSETUPSR.B.EPSETUPSTAT)
#endif

//! @brief Format value for bitfield USBHS_EPSETUPSR_EPSETUPSTAT.
#define BF_USBHS_EPSETUPSR_EPSETUPSTAT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPSETUPSR_EPSETUPSTAT), uint32_t) & BM_USBHS_EPSETUPSR_EPSETUPSTAT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EPSETUPSTAT field to a new value.
#define BW_USBHS_EPSETUPSR_EPSETUPSTAT(v) (HW_USBHS_EPSETUPSR_WR((HW_USBHS_EPSETUPSR_RD() & ~BM_USBHS_EPSETUPSR_EPSETUPSTAT) | BF_USBHS_EPSETUPSR_EPSETUPSTAT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_EPPRIME - Endpoint Initialization Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPPRIME - Endpoint Initialization Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is not defined in the EHCI specification. This register is used
 * to initialize endpoints and is used only in device mode.
 */
typedef union _hw_usbhs_epprime
{
    uint32_t U;
    struct _hw_usbhs_epprime_bitfields
    {
        uint32_t PERB : 4;             //!< [3:0] Prime Endpoint Receive Buffer
        uint32_t RESERVED0 : 12;       //!< [15:4] Reserved
        uint32_t PETB : 4;             //!< [19:16] Prime Endpoint tTansmit Buffer
        uint32_t RESERVED1 : 12;       //!< [31:20] Reserved
    } B;
} hw_usbhs_epprime_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPPRIME register
 */
//@{
#define HW_USBHS_EPPRIME_ADDR    (REGS_USBHS_BASE + 0x1B0U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPPRIME         (*(__IO hw_usbhs_epprime_t *) HW_USBHS_EPPRIME_ADDR)
#define HW_USBHS_EPPRIME_RD()    (HW_USBHS_EPPRIME.U)
#define HW_USBHS_EPPRIME_WR(v)   (HW_USBHS_EPPRIME.U = (v))
#define HW_USBHS_EPPRIME_SET(v)  (HW_USBHS_EPPRIME_WR(HW_USBHS_EPPRIME_RD() |  (v)))
#define HW_USBHS_EPPRIME_CLR(v)  (HW_USBHS_EPPRIME_WR(HW_USBHS_EPPRIME_RD() & ~(v)))
#define HW_USBHS_EPPRIME_TOG(v)  (HW_USBHS_EPPRIME_WR(HW_USBHS_EPPRIME_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPPRIME bitfields
 */

/*!
 * @name Register USBHS_EPPRIME, field PERB[3:0] (RW)
 *
 * For each endpoint, a corresponding bit requests that a buffer be prepared for
 * a receive operation to respond to a USB OUT transaction. Software must write
 * a 1 to the corresponding bit when posting a new transfer descriptor to an
 * endpoint. Hardware automatically uses this bit to begin parsing for a new transfer
 * descriptor from the queue head and prepare a receive buffer. Hardware clears
 * this bit when associated endpoint(s) is (are) successfully primed. These bits
 * are momentarily set by hardware during hardware re-priming operations when a
 * dTD retires, and the dQH updates.
 */
//@{
#define BP_USBHS_EPPRIME_PERB (0U)         //!< Bit position for USBHS_EPPRIME_PERB.
#define BM_USBHS_EPPRIME_PERB (0x0000000FU) //!< Bit mask for USBHS_EPPRIME_PERB.
#define BS_USBHS_EPPRIME_PERB (4U)         //!< Bit field size in bits for USBHS_EPPRIME_PERB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPPRIME_PERB field.
#define BR_USBHS_EPPRIME_PERB (HW_USBHS_EPPRIME.B.PERB)
#endif

//! @brief Format value for bitfield USBHS_EPPRIME_PERB.
#define BF_USBHS_EPPRIME_PERB(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPPRIME_PERB), uint32_t) & BM_USBHS_EPPRIME_PERB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PERB field to a new value.
#define BW_USBHS_EPPRIME_PERB(v) (HW_USBHS_EPPRIME_WR((HW_USBHS_EPPRIME_RD() & ~BM_USBHS_EPPRIME_PERB) | BF_USBHS_EPPRIME_PERB(v)))
#endif
//@}

/*!
 * @name Register USBHS_EPPRIME, field PETB[19:16] (RW)
 *
 * For each endpoint, a corresponding bit requests that a buffer be prepared for
 * a transmit operation to respond to a USB IN/INTERRUPT transaction. Software
 * must write a 1 to the corresponding bit when posting a new transfer descriptor
 * to an endpoint. Hardware automatically uses this bit to begin parsing for a
 * new transfer descriptor from the queue head and prepare a transmit buffer.
 * Hardware clears this bit when associated endpoint(s) is (are) successfully primed.
 * These bits are momentarily set by hardware during hardware re-priming
 * operations when a dTD retires, and the dQH updates.
 */
//@{
#define BP_USBHS_EPPRIME_PETB (16U)        //!< Bit position for USBHS_EPPRIME_PETB.
#define BM_USBHS_EPPRIME_PETB (0x000F0000U) //!< Bit mask for USBHS_EPPRIME_PETB.
#define BS_USBHS_EPPRIME_PETB (4U)         //!< Bit field size in bits for USBHS_EPPRIME_PETB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPPRIME_PETB field.
#define BR_USBHS_EPPRIME_PETB (HW_USBHS_EPPRIME.B.PETB)
#endif

//! @brief Format value for bitfield USBHS_EPPRIME_PETB.
#define BF_USBHS_EPPRIME_PETB(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPPRIME_PETB), uint32_t) & BM_USBHS_EPPRIME_PETB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PETB field to a new value.
#define BW_USBHS_EPPRIME_PETB(v) (HW_USBHS_EPPRIME_WR((HW_USBHS_EPPRIME_RD() & ~BM_USBHS_EPPRIME_PETB) | BF_USBHS_EPPRIME_PETB(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_EPFLUSH - Endpoint Flush Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPFLUSH - Endpoint Flush Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is not defined in the EHCI specification. This register used
 * only in device mode.
 */
typedef union _hw_usbhs_epflush
{
    uint32_t U;
    struct _hw_usbhs_epflush_bitfields
    {
        uint32_t FERB : 4;             //!< [3:0] Flush Endpoint Receive Buffer
        uint32_t RESERVED0 : 12;       //!< [15:4] Reserved
        uint32_t FETB : 4;             //!< [19:16] Flush Endpoint Transmit Buffer
        uint32_t RESERVED1 : 12;       //!< [31:20] Reserved
    } B;
} hw_usbhs_epflush_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPFLUSH register
 */
//@{
#define HW_USBHS_EPFLUSH_ADDR    (REGS_USBHS_BASE + 0x1B4U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPFLUSH         (*(__IO hw_usbhs_epflush_t *) HW_USBHS_EPFLUSH_ADDR)
#define HW_USBHS_EPFLUSH_RD()    (HW_USBHS_EPFLUSH.U)
#define HW_USBHS_EPFLUSH_WR(v)   (HW_USBHS_EPFLUSH.U = (v))
#define HW_USBHS_EPFLUSH_SET(v)  (HW_USBHS_EPFLUSH_WR(HW_USBHS_EPFLUSH_RD() |  (v)))
#define HW_USBHS_EPFLUSH_CLR(v)  (HW_USBHS_EPFLUSH_WR(HW_USBHS_EPFLUSH_RD() & ~(v)))
#define HW_USBHS_EPFLUSH_TOG(v)  (HW_USBHS_EPFLUSH_WR(HW_USBHS_EPFLUSH_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPFLUSH bitfields
 */

/*!
 * @name Register USBHS_EPFLUSH, field FERB[3:0] (RW)
 *
 * Writing a 1 to a bit in this field causes the associated endpoint to clear
 * any primed buffers. If a packet is in progress for an associated endpoint, that
 * transfer continues until completion. Hardware clears this register after the
 * endpoint flush operation is successful. FERB[3] corresponds to endpoint 3.
 */
//@{
#define BP_USBHS_EPFLUSH_FERB (0U)         //!< Bit position for USBHS_EPFLUSH_FERB.
#define BM_USBHS_EPFLUSH_FERB (0x0000000FU) //!< Bit mask for USBHS_EPFLUSH_FERB.
#define BS_USBHS_EPFLUSH_FERB (4U)         //!< Bit field size in bits for USBHS_EPFLUSH_FERB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPFLUSH_FERB field.
#define BR_USBHS_EPFLUSH_FERB (HW_USBHS_EPFLUSH.B.FERB)
#endif

//! @brief Format value for bitfield USBHS_EPFLUSH_FERB.
#define BF_USBHS_EPFLUSH_FERB(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPFLUSH_FERB), uint32_t) & BM_USBHS_EPFLUSH_FERB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FERB field to a new value.
#define BW_USBHS_EPFLUSH_FERB(v) (HW_USBHS_EPFLUSH_WR((HW_USBHS_EPFLUSH_RD() & ~BM_USBHS_EPFLUSH_FERB) | BF_USBHS_EPFLUSH_FERB(v)))
#endif
//@}

/*!
 * @name Register USBHS_EPFLUSH, field FETB[19:16] (RW)
 *
 * Writing a 1 to a bit in this field causes the associated endpoint to clear
 * any primed buffers. If a packet is in progress for an associated endpoint, that
 * transfer continues until completion. Hardware clears this register after the
 * endpoint flush operation is successful.
 */
//@{
#define BP_USBHS_EPFLUSH_FETB (16U)        //!< Bit position for USBHS_EPFLUSH_FETB.
#define BM_USBHS_EPFLUSH_FETB (0x000F0000U) //!< Bit mask for USBHS_EPFLUSH_FETB.
#define BS_USBHS_EPFLUSH_FETB (4U)         //!< Bit field size in bits for USBHS_EPFLUSH_FETB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPFLUSH_FETB field.
#define BR_USBHS_EPFLUSH_FETB (HW_USBHS_EPFLUSH.B.FETB)
#endif

//! @brief Format value for bitfield USBHS_EPFLUSH_FETB.
#define BF_USBHS_EPFLUSH_FETB(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPFLUSH_FETB), uint32_t) & BM_USBHS_EPFLUSH_FETB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FETB field to a new value.
#define BW_USBHS_EPFLUSH_FETB(v) (HW_USBHS_EPFLUSH_WR((HW_USBHS_EPFLUSH_RD() & ~BM_USBHS_EPFLUSH_FETB) | BF_USBHS_EPFLUSH_FETB(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_EPSR - Endpoint Status Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPSR - Endpoint Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is not defined in the EHCI specification. This register is only
 * used in device mode.
 */
typedef union _hw_usbhs_epsr
{
    uint32_t U;
    struct _hw_usbhs_epsr_bitfields
    {
        uint32_t ERBR : 4;             //!< [3:0] Endpoint Receive Buffer Ready
        uint32_t RESERVED0 : 12;       //!< [15:4] Reserved
        uint32_t ETBR : 4;             //!< [19:16] Endpoint Transmit Buffer Ready
        uint32_t RESERVED1 : 12;       //!< [31:20] Reserved
    } B;
} hw_usbhs_epsr_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPSR register
 */
//@{
#define HW_USBHS_EPSR_ADDR       (REGS_USBHS_BASE + 0x1B8U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPSR            (*(__I hw_usbhs_epsr_t *) HW_USBHS_EPSR_ADDR)
#define HW_USBHS_EPSR_RD()       (HW_USBHS_EPSR.U)
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPSR bitfields
 */

/*!
 * @name Register USBHS_EPSR, field ERBR[3:0] (RO)
 *
 * One bit for each endpoint indicates status of the respective endpoint buffer.
 * The hardware sets this bit in response to receiving a command from a
 * corresponding bit in the EPPRIME register. A constant delay exists between setting a
 * bit in the EPPRIME register and endpoint indicating ready. This delay time
 * varies based upon the current USB traffic and the number of bits set in the
 * EPPRIME register. USB reset, USB DMA system, or EPFLUSH register clears the buffer
 * ready. ERBR[3] (bit 19) corresponds to endpoint 3. Hardware momentarily clears
 * these bits during hardware endpoint re-priming operations when a dTD is
 * retired, and the dQH is updated.
 */
//@{
#define BP_USBHS_EPSR_ERBR   (0U)          //!< Bit position for USBHS_EPSR_ERBR.
#define BM_USBHS_EPSR_ERBR   (0x0000000FU) //!< Bit mask for USBHS_EPSR_ERBR.
#define BS_USBHS_EPSR_ERBR   (4U)          //!< Bit field size in bits for USBHS_EPSR_ERBR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPSR_ERBR field.
#define BR_USBHS_EPSR_ERBR   (HW_USBHS_EPSR.B.ERBR)
#endif
//@}

/*!
 * @name Register USBHS_EPSR, field ETBR[19:16] (RO)
 *
 * One bit for each endpoint indicates status of the respective endpoint buffer.
 * The hardware sets this bit in response to receiving a command from a
 * corresponding bit in the EPPRIME register. A constant delay exists between setting a
 * bit in the EPPRIME register and endpoint indicating ready. This delay time
 * varies based upon the current USB traffic and the number of bits set in the
 * EPPRIME register. USB reset, USB DMA system, or EPFLUSH register clears the buffer
 * ready. ETBR[3] (bit 19) corresponds to endpoint 3. Hardware momentarily clears
 * these bits during hardware endpoint re-priming operations when a dTD is
 * retired, and the dQH is updated.
 */
//@{
#define BP_USBHS_EPSR_ETBR   (16U)         //!< Bit position for USBHS_EPSR_ETBR.
#define BM_USBHS_EPSR_ETBR   (0x000F0000U) //!< Bit mask for USBHS_EPSR_ETBR.
#define BS_USBHS_EPSR_ETBR   (4U)          //!< Bit field size in bits for USBHS_EPSR_ETBR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPSR_ETBR field.
#define BR_USBHS_EPSR_ETBR   (HW_USBHS_EPSR.B.ETBR)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_EPCOMPLETE - Endpoint Complete Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPCOMPLETE - Endpoint Complete Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is not defined in the EHCI specification. This register is used
 * only in device mode.
 */
typedef union _hw_usbhs_epcomplete
{
    uint32_t U;
    struct _hw_usbhs_epcomplete_bitfields
    {
        uint32_t ERCE : 4;             //!< [3:0] Endpoint Receive Complete Event
        uint32_t RESERVED0 : 12;       //!< [15:4] Reserved
        uint32_t ETCE : 4;             //!< [19:16] Endpoint Transmit Complete Event
        uint32_t RESERVED1 : 12;       //!< [31:20] Reserved
    } B;
} hw_usbhs_epcomplete_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPCOMPLETE register
 */
//@{
#define HW_USBHS_EPCOMPLETE_ADDR (REGS_USBHS_BASE + 0x1BCU)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPCOMPLETE      (*(__IO hw_usbhs_epcomplete_t *) HW_USBHS_EPCOMPLETE_ADDR)
#define HW_USBHS_EPCOMPLETE_RD() (HW_USBHS_EPCOMPLETE.U)
#define HW_USBHS_EPCOMPLETE_WR(v) (HW_USBHS_EPCOMPLETE.U = (v))
#define HW_USBHS_EPCOMPLETE_SET(v) (HW_USBHS_EPCOMPLETE_WR(HW_USBHS_EPCOMPLETE_RD() |  (v)))
#define HW_USBHS_EPCOMPLETE_CLR(v) (HW_USBHS_EPCOMPLETE_WR(HW_USBHS_EPCOMPLETE_RD() & ~(v)))
#define HW_USBHS_EPCOMPLETE_TOG(v) (HW_USBHS_EPCOMPLETE_WR(HW_USBHS_EPCOMPLETE_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPCOMPLETE bitfields
 */

/*!
 * @name Register USBHS_EPCOMPLETE, field ERCE[3:0] (W1C)
 *
 * Each bit indicates a received event (OUT/SETUP) occurs and software must read
 * the corresponding endpoint queue to determine the transfer status. If the
 * corresponding IOC bit is set in the transfer descriptor, this bit is set
 * simultaneously with the USBINT. Writing a 1 clears the corresponding bit in this
 * register. ERCE[3] corresponds to endpoint 3.
 */
//@{
#define BP_USBHS_EPCOMPLETE_ERCE (0U)      //!< Bit position for USBHS_EPCOMPLETE_ERCE.
#define BM_USBHS_EPCOMPLETE_ERCE (0x0000000FU) //!< Bit mask for USBHS_EPCOMPLETE_ERCE.
#define BS_USBHS_EPCOMPLETE_ERCE (4U)      //!< Bit field size in bits for USBHS_EPCOMPLETE_ERCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCOMPLETE_ERCE field.
#define BR_USBHS_EPCOMPLETE_ERCE (HW_USBHS_EPCOMPLETE.B.ERCE)
#endif

//! @brief Format value for bitfield USBHS_EPCOMPLETE_ERCE.
#define BF_USBHS_EPCOMPLETE_ERCE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCOMPLETE_ERCE), uint32_t) & BM_USBHS_EPCOMPLETE_ERCE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERCE field to a new value.
#define BW_USBHS_EPCOMPLETE_ERCE(v) (HW_USBHS_EPCOMPLETE_WR((HW_USBHS_EPCOMPLETE_RD() & ~BM_USBHS_EPCOMPLETE_ERCE) | BF_USBHS_EPCOMPLETE_ERCE(v)))
#endif
//@}

/*!
 * @name Register USBHS_EPCOMPLETE, field ETCE[19:16] (W1C)
 *
 * Each bit indicates a transmit event (IN/INTERRUPT) occurs and software must
 * read the corresponding endpoint queue to determine the endpoint status. If the
 * corresponding IOC bit is set in the transfer descriptor, this bit is set
 * simultaneously with the USBINT. Writing a 1 clears the corresponding bit in this
 * register. ETCE[3] (bit 19) corresponds to endpoint 3.
 */
//@{
#define BP_USBHS_EPCOMPLETE_ETCE (16U)     //!< Bit position for USBHS_EPCOMPLETE_ETCE.
#define BM_USBHS_EPCOMPLETE_ETCE (0x000F0000U) //!< Bit mask for USBHS_EPCOMPLETE_ETCE.
#define BS_USBHS_EPCOMPLETE_ETCE (4U)      //!< Bit field size in bits for USBHS_EPCOMPLETE_ETCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCOMPLETE_ETCE field.
#define BR_USBHS_EPCOMPLETE_ETCE (HW_USBHS_EPCOMPLETE.B.ETCE)
#endif

//! @brief Format value for bitfield USBHS_EPCOMPLETE_ETCE.
#define BF_USBHS_EPCOMPLETE_ETCE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCOMPLETE_ETCE), uint32_t) & BM_USBHS_EPCOMPLETE_ETCE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ETCE field to a new value.
#define BW_USBHS_EPCOMPLETE_ETCE(v) (HW_USBHS_EPCOMPLETE_WR((HW_USBHS_EPCOMPLETE_RD() & ~BM_USBHS_EPCOMPLETE_ETCE) | BF_USBHS_EPCOMPLETE_ETCE(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_EPCR0 - Endpoint Control Register 0
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPCR0 - Endpoint Control Register 0 (RW)
 *
 * Reset value: 0x00800080U
 *
 * This register is not defined in the EHCI specification. Every device
 * implements endpoint 0 as a control endpoint.
 */
typedef union _hw_usbhs_epcr0
{
    uint32_t U;
    struct _hw_usbhs_epcr0_bitfields
    {
        uint32_t RXS : 1;              //!< [0] RX endpoint Stall
        uint32_t RESERVED0 : 1;        //!< [1] Reserved
        uint32_t RXT : 2;              //!< [3:2] RX endpoint Type
        uint32_t RESERVED1 : 3;        //!< [6:4] Reserved
        uint32_t RXE : 1;              //!< [7] RX endpoint Enable
        uint32_t RESERVED2 : 8;        //!< [15:8] Reserved
        uint32_t TXS : 1;              //!< [16] TX Endpoint Stall
        uint32_t RESERVED3 : 1;        //!< [17] Reserved
        uint32_t TXT : 2;              //!< [19:18] TX Endpoint Type
        uint32_t RESERVED4 : 3;        //!< [22:20] Reserved
        uint32_t TXE : 1;              //!< [23] TX Endpoint Enable
        uint32_t RESERVED5 : 8;        //!< [31:24] This register is not defined in
                                       //! the EHCI specification. Every device implements endpoint 0 as a
                                       //! control endpoint.
    } B;
} hw_usbhs_epcr0_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPCR0 register
 */
//@{
#define HW_USBHS_EPCR0_ADDR      (REGS_USBHS_BASE + 0x1C0U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPCR0           (*(__IO hw_usbhs_epcr0_t *) HW_USBHS_EPCR0_ADDR)
#define HW_USBHS_EPCR0_RD()      (HW_USBHS_EPCR0.U)
#define HW_USBHS_EPCR0_WR(v)     (HW_USBHS_EPCR0.U = (v))
#define HW_USBHS_EPCR0_SET(v)    (HW_USBHS_EPCR0_WR(HW_USBHS_EPCR0_RD() |  (v)))
#define HW_USBHS_EPCR0_CLR(v)    (HW_USBHS_EPCR0_WR(HW_USBHS_EPCR0_RD() & ~(v)))
#define HW_USBHS_EPCR0_TOG(v)    (HW_USBHS_EPCR0_WR(HW_USBHS_EPCR0_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPCR0 bitfields
 */

/*!
 * @name Register USBHS_EPCR0, field RXS[0] (RW)
 *
 * Software can write a 1 to this bit to force the endpoint to return a STALL
 * handshake to the host. It continues returning STALL until software clears the
 * bit or it automatically clears upon receipt of a new SETUP request.
 *
 * Values:
 * - 0 - Endpoint OK
 * - 1 - Endpoint stalled
 */
//@{
#define BP_USBHS_EPCR0_RXS   (0U)          //!< Bit position for USBHS_EPCR0_RXS.
#define BM_USBHS_EPCR0_RXS   (0x00000001U) //!< Bit mask for USBHS_EPCR0_RXS.
#define BS_USBHS_EPCR0_RXS   (1U)          //!< Bit field size in bits for USBHS_EPCR0_RXS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR0_RXS field.
#define BR_USBHS_EPCR0_RXS   (BITBAND_ACCESS32(HW_USBHS_EPCR0_ADDR, BP_USBHS_EPCR0_RXS))
#endif

//! @brief Format value for bitfield USBHS_EPCR0_RXS.
#define BF_USBHS_EPCR0_RXS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR0_RXS), uint32_t) & BM_USBHS_EPCR0_RXS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXS field to a new value.
#define BW_USBHS_EPCR0_RXS(v) (BITBAND_ACCESS32(HW_USBHS_EPCR0_ADDR, BP_USBHS_EPCR0_RXS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR0, field RXT[3:2] (RO)
 *
 * Endpoint zero is always a control endpoint.
 *
 * Values:
 * - 00 - Control
 */
//@{
#define BP_USBHS_EPCR0_RXT   (2U)          //!< Bit position for USBHS_EPCR0_RXT.
#define BM_USBHS_EPCR0_RXT   (0x0000000CU) //!< Bit mask for USBHS_EPCR0_RXT.
#define BS_USBHS_EPCR0_RXT   (2U)          //!< Bit field size in bits for USBHS_EPCR0_RXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR0_RXT field.
#define BR_USBHS_EPCR0_RXT   (HW_USBHS_EPCR0.B.RXT)
#endif
//@}

/*!
 * @name Register USBHS_EPCR0, field RXE[7] (RO)
 *
 * Endpoint zero is always enabled.
 *
 * Values:
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_EPCR0_RXE   (7U)          //!< Bit position for USBHS_EPCR0_RXE.
#define BM_USBHS_EPCR0_RXE   (0x00000080U) //!< Bit mask for USBHS_EPCR0_RXE.
#define BS_USBHS_EPCR0_RXE   (1U)          //!< Bit field size in bits for USBHS_EPCR0_RXE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR0_RXE field.
#define BR_USBHS_EPCR0_RXE   (BITBAND_ACCESS32(HW_USBHS_EPCR0_ADDR, BP_USBHS_EPCR0_RXE))
#endif
//@}

/*!
 * @name Register USBHS_EPCR0, field TXS[16] (RW)
 *
 * Software can write a 1 to this bit to force the endpoint to return a STALL
 * handshake to the host. It continues returning STALL until software clears the
 * bit or it automatically clears upon receipt of a new SETUP request.
 *
 * Values:
 * - 0 - Endpoint OK
 * - 1 - Endpoint stalled
 */
//@{
#define BP_USBHS_EPCR0_TXS   (16U)         //!< Bit position for USBHS_EPCR0_TXS.
#define BM_USBHS_EPCR0_TXS   (0x00010000U) //!< Bit mask for USBHS_EPCR0_TXS.
#define BS_USBHS_EPCR0_TXS   (1U)          //!< Bit field size in bits for USBHS_EPCR0_TXS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR0_TXS field.
#define BR_USBHS_EPCR0_TXS   (BITBAND_ACCESS32(HW_USBHS_EPCR0_ADDR, BP_USBHS_EPCR0_TXS))
#endif

//! @brief Format value for bitfield USBHS_EPCR0_TXS.
#define BF_USBHS_EPCR0_TXS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR0_TXS), uint32_t) & BM_USBHS_EPCR0_TXS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXS field to a new value.
#define BW_USBHS_EPCR0_TXS(v) (BITBAND_ACCESS32(HW_USBHS_EPCR0_ADDR, BP_USBHS_EPCR0_TXS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR0, field TXT[19:18] (RO)
 *
 * Endpoint zero is always a control endpoint.
 *
 * Values:
 * - 00 - Control
 */
//@{
#define BP_USBHS_EPCR0_TXT   (18U)         //!< Bit position for USBHS_EPCR0_TXT.
#define BM_USBHS_EPCR0_TXT   (0x000C0000U) //!< Bit mask for USBHS_EPCR0_TXT.
#define BS_USBHS_EPCR0_TXT   (2U)          //!< Bit field size in bits for USBHS_EPCR0_TXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR0_TXT field.
#define BR_USBHS_EPCR0_TXT   (HW_USBHS_EPCR0.B.TXT)
#endif
//@}

/*!
 * @name Register USBHS_EPCR0, field TXE[23] (RO)
 *
 * Endpoint zero is always enabled.
 *
 * Values:
 * - 1 - Enable
 */
//@{
#define BP_USBHS_EPCR0_TXE   (23U)         //!< Bit position for USBHS_EPCR0_TXE.
#define BM_USBHS_EPCR0_TXE   (0x00800000U) //!< Bit mask for USBHS_EPCR0_TXE.
#define BS_USBHS_EPCR0_TXE   (1U)          //!< Bit field size in bits for USBHS_EPCR0_TXE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR0_TXE field.
#define BR_USBHS_EPCR0_TXE   (BITBAND_ACCESS32(HW_USBHS_EPCR0_ADDR, BP_USBHS_EPCR0_TXE))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_EPCR1 - Endpoint Control Register n
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPCR1 - Endpoint Control Register n (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers are not defined in the EHCI specification. There is an EPCRn
 * register for each endpoint in a device.
 */
typedef union _hw_usbhs_epcr1
{
    uint32_t U;
    struct _hw_usbhs_epcr1_bitfields
    {
        uint32_t RXS : 1;              //!< [0] RX endpoint Stall
        uint32_t RXD : 1;              //!< [1] RX endpoint Data sink
        uint32_t RXT : 2;              //!< [3:2] RX endpoint Type
        uint32_t RESERVED0 : 1;        //!< [4] Reserved
        uint32_t RXI : 1;              //!< [5] RX data toggle Inhibit
        uint32_t RXR : 1;              //!< [6] RX data toggle Reset
        uint32_t RXE : 1;              //!< [7] RX endpoint Enable
        uint32_t RESERVED1 : 8;        //!< [15:8] Reserved
        uint32_t TXS : 1;              //!< [16] TX endpoint Stall
        uint32_t TXD : 1;              //!< [17] TX endpoint Data source
        uint32_t TXT : 2;              //!< [19:18] TX endpoint Type
        uint32_t RESERVED2 : 1;        //!< [20] Reserved
        uint32_t TXI : 1;              //!< [21] TX data toggle Inhibit
        uint32_t TXR : 1;              //!< [22] TX data toggle Reset
        uint32_t TXE : 1;              //!< [23] TX endpoint Enable
        uint32_t RESERVED3 : 8;        //!< [31:24] Reserved
    } B;
} hw_usbhs_epcr1_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPCR1 register
 */
//@{
#define HW_USBHS_EPCR1_ADDR      (REGS_USBHS_BASE + 0x1C4U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPCR1           (*(__IO hw_usbhs_epcr1_t *) HW_USBHS_EPCR1_ADDR)
#define HW_USBHS_EPCR1_RD()      (HW_USBHS_EPCR1.U)
#define HW_USBHS_EPCR1_WR(v)     (HW_USBHS_EPCR1.U = (v))
#define HW_USBHS_EPCR1_SET(v)    (HW_USBHS_EPCR1_WR(HW_USBHS_EPCR1_RD() |  (v)))
#define HW_USBHS_EPCR1_CLR(v)    (HW_USBHS_EPCR1_WR(HW_USBHS_EPCR1_RD() & ~(v)))
#define HW_USBHS_EPCR1_TOG(v)    (HW_USBHS_EPCR1_WR(HW_USBHS_EPCR1_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPCR1 bitfields
 */

/*!
 * @name Register USBHS_EPCR1, field RXS[0] (RW)
 *
 * Values:
 * - 0 - Endpoint OK
 * - 1 - Endpoint stalled
 */
//@{
#define BP_USBHS_EPCR1_RXS   (0U)          //!< Bit position for USBHS_EPCR1_RXS.
#define BM_USBHS_EPCR1_RXS   (0x00000001U) //!< Bit mask for USBHS_EPCR1_RXS.
#define BS_USBHS_EPCR1_RXS   (1U)          //!< Bit field size in bits for USBHS_EPCR1_RXS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_RXS field.
#define BR_USBHS_EPCR1_RXS   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXS))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_RXS.
#define BF_USBHS_EPCR1_RXS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_RXS), uint32_t) & BM_USBHS_EPCR1_RXS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXS field to a new value.
#define BW_USBHS_EPCR1_RXS(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field RXD[1] (RW)
 */
//@{
#define BP_USBHS_EPCR1_RXD   (1U)          //!< Bit position for USBHS_EPCR1_RXD.
#define BM_USBHS_EPCR1_RXD   (0x00000002U) //!< Bit mask for USBHS_EPCR1_RXD.
#define BS_USBHS_EPCR1_RXD   (1U)          //!< Bit field size in bits for USBHS_EPCR1_RXD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_RXD field.
#define BR_USBHS_EPCR1_RXD   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXD))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_RXD.
#define BF_USBHS_EPCR1_RXD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_RXD), uint32_t) & BM_USBHS_EPCR1_RXD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXD field to a new value.
#define BW_USBHS_EPCR1_RXD(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXD) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field RXT[3:2] (RW)
 *
 * Values:
 * - 00 - Control
 * - 01 - Isochronous
 * - 10 - Bulk
 * - 11 - Interrupt
 */
//@{
#define BP_USBHS_EPCR1_RXT   (2U)          //!< Bit position for USBHS_EPCR1_RXT.
#define BM_USBHS_EPCR1_RXT   (0x0000000CU) //!< Bit mask for USBHS_EPCR1_RXT.
#define BS_USBHS_EPCR1_RXT   (2U)          //!< Bit field size in bits for USBHS_EPCR1_RXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_RXT field.
#define BR_USBHS_EPCR1_RXT   (HW_USBHS_EPCR1.B.RXT)
#endif

//! @brief Format value for bitfield USBHS_EPCR1_RXT.
#define BF_USBHS_EPCR1_RXT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_RXT), uint32_t) & BM_USBHS_EPCR1_RXT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXT field to a new value.
#define BW_USBHS_EPCR1_RXT(v) (HW_USBHS_EPCR1_WR((HW_USBHS_EPCR1_RD() & ~BM_USBHS_EPCR1_RXT) | BF_USBHS_EPCR1_RXT(v)))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field RXI[5] (RW)
 *
 * Values:
 * - 0 - PID sequencing enabled
 * - 1 - PID sequencing disabled
 */
//@{
#define BP_USBHS_EPCR1_RXI   (5U)          //!< Bit position for USBHS_EPCR1_RXI.
#define BM_USBHS_EPCR1_RXI   (0x00000020U) //!< Bit mask for USBHS_EPCR1_RXI.
#define BS_USBHS_EPCR1_RXI   (1U)          //!< Bit field size in bits for USBHS_EPCR1_RXI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_RXI field.
#define BR_USBHS_EPCR1_RXI   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXI))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_RXI.
#define BF_USBHS_EPCR1_RXI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_RXI), uint32_t) & BM_USBHS_EPCR1_RXI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXI field to a new value.
#define BW_USBHS_EPCR1_RXI(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field RXR[6] (WO)
 */
//@{
#define BP_USBHS_EPCR1_RXR   (6U)          //!< Bit position for USBHS_EPCR1_RXR.
#define BM_USBHS_EPCR1_RXR   (0x00000040U) //!< Bit mask for USBHS_EPCR1_RXR.
#define BS_USBHS_EPCR1_RXR   (1U)          //!< Bit field size in bits for USBHS_EPCR1_RXR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_RXR field.
#define BR_USBHS_EPCR1_RXR   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXR))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_RXR.
#define BF_USBHS_EPCR1_RXR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_RXR), uint32_t) & BM_USBHS_EPCR1_RXR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXR field to a new value.
#define BW_USBHS_EPCR1_RXR(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXR) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field RXE[7] (RW)
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_EPCR1_RXE   (7U)          //!< Bit position for USBHS_EPCR1_RXE.
#define BM_USBHS_EPCR1_RXE   (0x00000080U) //!< Bit mask for USBHS_EPCR1_RXE.
#define BS_USBHS_EPCR1_RXE   (1U)          //!< Bit field size in bits for USBHS_EPCR1_RXE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_RXE field.
#define BR_USBHS_EPCR1_RXE   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXE))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_RXE.
#define BF_USBHS_EPCR1_RXE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_RXE), uint32_t) & BM_USBHS_EPCR1_RXE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXE field to a new value.
#define BW_USBHS_EPCR1_RXE(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_RXE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field TXS[16] (RW)
 *
 * Values:
 * - 0 - Endpoint OK
 * - 1 - Endpoint stalled
 */
//@{
#define BP_USBHS_EPCR1_TXS   (16U)         //!< Bit position for USBHS_EPCR1_TXS.
#define BM_USBHS_EPCR1_TXS   (0x00010000U) //!< Bit mask for USBHS_EPCR1_TXS.
#define BS_USBHS_EPCR1_TXS   (1U)          //!< Bit field size in bits for USBHS_EPCR1_TXS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_TXS field.
#define BR_USBHS_EPCR1_TXS   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXS))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_TXS.
#define BF_USBHS_EPCR1_TXS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_TXS), uint32_t) & BM_USBHS_EPCR1_TXS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXS field to a new value.
#define BW_USBHS_EPCR1_TXS(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field TXD[17] (RW)
 */
//@{
#define BP_USBHS_EPCR1_TXD   (17U)         //!< Bit position for USBHS_EPCR1_TXD.
#define BM_USBHS_EPCR1_TXD   (0x00020000U) //!< Bit mask for USBHS_EPCR1_TXD.
#define BS_USBHS_EPCR1_TXD   (1U)          //!< Bit field size in bits for USBHS_EPCR1_TXD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_TXD field.
#define BR_USBHS_EPCR1_TXD   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXD))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_TXD.
#define BF_USBHS_EPCR1_TXD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_TXD), uint32_t) & BM_USBHS_EPCR1_TXD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXD field to a new value.
#define BW_USBHS_EPCR1_TXD(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXD) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field TXT[19:18] (RW)
 *
 * Values:
 * - 00 - Control
 * - 01 - Isochronous
 * - 10 - Bulk
 * - 11 - Interrupt
 */
//@{
#define BP_USBHS_EPCR1_TXT   (18U)         //!< Bit position for USBHS_EPCR1_TXT.
#define BM_USBHS_EPCR1_TXT   (0x000C0000U) //!< Bit mask for USBHS_EPCR1_TXT.
#define BS_USBHS_EPCR1_TXT   (2U)          //!< Bit field size in bits for USBHS_EPCR1_TXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_TXT field.
#define BR_USBHS_EPCR1_TXT   (HW_USBHS_EPCR1.B.TXT)
#endif

//! @brief Format value for bitfield USBHS_EPCR1_TXT.
#define BF_USBHS_EPCR1_TXT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_TXT), uint32_t) & BM_USBHS_EPCR1_TXT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXT field to a new value.
#define BW_USBHS_EPCR1_TXT(v) (HW_USBHS_EPCR1_WR((HW_USBHS_EPCR1_RD() & ~BM_USBHS_EPCR1_TXT) | BF_USBHS_EPCR1_TXT(v)))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field TXI[21] (RW)
 *
 * Values:
 * - 0 - PID sequencing enabled
 * - 1 - PID sequencing disabled
 */
//@{
#define BP_USBHS_EPCR1_TXI   (21U)         //!< Bit position for USBHS_EPCR1_TXI.
#define BM_USBHS_EPCR1_TXI   (0x00200000U) //!< Bit mask for USBHS_EPCR1_TXI.
#define BS_USBHS_EPCR1_TXI   (1U)          //!< Bit field size in bits for USBHS_EPCR1_TXI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_TXI field.
#define BR_USBHS_EPCR1_TXI   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXI))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_TXI.
#define BF_USBHS_EPCR1_TXI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_TXI), uint32_t) & BM_USBHS_EPCR1_TXI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXI field to a new value.
#define BW_USBHS_EPCR1_TXI(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field TXR[22] (WO)
 */
//@{
#define BP_USBHS_EPCR1_TXR   (22U)         //!< Bit position for USBHS_EPCR1_TXR.
#define BM_USBHS_EPCR1_TXR   (0x00400000U) //!< Bit mask for USBHS_EPCR1_TXR.
#define BS_USBHS_EPCR1_TXR   (1U)          //!< Bit field size in bits for USBHS_EPCR1_TXR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_TXR field.
#define BR_USBHS_EPCR1_TXR   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXR))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_TXR.
#define BF_USBHS_EPCR1_TXR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_TXR), uint32_t) & BM_USBHS_EPCR1_TXR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXR field to a new value.
#define BW_USBHS_EPCR1_TXR(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXR) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR1, field TXE[23] (RW)
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_EPCR1_TXE   (23U)         //!< Bit position for USBHS_EPCR1_TXE.
#define BM_USBHS_EPCR1_TXE   (0x00800000U) //!< Bit mask for USBHS_EPCR1_TXE.
#define BS_USBHS_EPCR1_TXE   (1U)          //!< Bit field size in bits for USBHS_EPCR1_TXE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR1_TXE field.
#define BR_USBHS_EPCR1_TXE   (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXE))
#endif

//! @brief Format value for bitfield USBHS_EPCR1_TXE.
#define BF_USBHS_EPCR1_TXE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR1_TXE), uint32_t) & BM_USBHS_EPCR1_TXE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXE field to a new value.
#define BW_USBHS_EPCR1_TXE(v) (BITBAND_ACCESS32(HW_USBHS_EPCR1_ADDR, BP_USBHS_EPCR1_TXE) = (v))
#endif
//@}
//-------------------------------------------------------------------------------------------
// HW_USBHS_EPCR2 - Endpoint Control Register n
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPCR2 - Endpoint Control Register n (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers are not defined in the EHCI specification. There is an EPCRn
 * register for each endpoint in a device.
 */
typedef union _hw_usbhs_epcr2
{
    uint32_t U;
    struct _hw_usbhs_epcr2_bitfields
    {
        uint32_t RXS : 1;              //!< [0] RX endpoint Stall
        uint32_t RXD : 1;              //!< [1] RX endpoint Data sink
        uint32_t RXT : 2;              //!< [3:2] RX endpoint Type
        uint32_t RESERVED0 : 1;        //!< [4] Reserved
        uint32_t RXI : 1;              //!< [5] RX data toggle Inhibit
        uint32_t RXR : 1;              //!< [6] RX data toggle Reset
        uint32_t RXE : 1;              //!< [7] RX endpoint Enable
        uint32_t RESERVED1 : 8;        //!< [15:8] Reserved
        uint32_t TXS : 1;              //!< [16] TX endpoint Stall
        uint32_t TXD : 1;              //!< [17] TX endpoint Data source
        uint32_t TXT : 2;              //!< [19:18] TX endpoint Type
        uint32_t RESERVED2 : 1;        //!< [20] Reserved
        uint32_t TXI : 1;              //!< [21] TX data toggle Inhibit
        uint32_t TXR : 1;              //!< [22] TX data toggle Reset
        uint32_t TXE : 1;              //!< [23] TX endpoint Enable
        uint32_t RESERVED3 : 8;        //!< [31:24] Reserved
    } B;
} hw_usbhs_epcr2_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPCR2 register
 */
//@{
#define HW_USBHS_EPCR2_ADDR      (REGS_USBHS_BASE + 0x1C8U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPCR2           (*(__IO hw_usbhs_epcr2_t *) HW_USBHS_EPCR2_ADDR)
#define HW_USBHS_EPCR2_RD()      (HW_USBHS_EPCR2.U)
#define HW_USBHS_EPCR2_WR(v)     (HW_USBHS_EPCR2.U = (v))
#define HW_USBHS_EPCR2_SET(v)    (HW_USBHS_EPCR2_WR(HW_USBHS_EPCR2_RD() |  (v)))
#define HW_USBHS_EPCR2_CLR(v)    (HW_USBHS_EPCR2_WR(HW_USBHS_EPCR2_RD() & ~(v)))
#define HW_USBHS_EPCR2_TOG(v)    (HW_USBHS_EPCR2_WR(HW_USBHS_EPCR2_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPCR2 bitfields
 */

/*!
 * @name Register USBHS_EPCR2, field RXS[0] (RW)
 *
 * Values:
 * - 0 - Endpoint OK
 * - 1 - Endpoint stalled
 */
//@{
#define BP_USBHS_EPCR2_RXS   (0U)          //!< Bit position for USBHS_EPCR2_RXS.
#define BM_USBHS_EPCR2_RXS   (0x00000001U) //!< Bit mask for USBHS_EPCR2_RXS.
#define BS_USBHS_EPCR2_RXS   (1U)          //!< Bit field size in bits for USBHS_EPCR2_RXS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_RXS field.
#define BR_USBHS_EPCR2_RXS   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXS))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_RXS.
#define BF_USBHS_EPCR2_RXS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_RXS), uint32_t) & BM_USBHS_EPCR2_RXS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXS field to a new value.
#define BW_USBHS_EPCR2_RXS(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field RXD[1] (RW)
 */
//@{
#define BP_USBHS_EPCR2_RXD   (1U)          //!< Bit position for USBHS_EPCR2_RXD.
#define BM_USBHS_EPCR2_RXD   (0x00000002U) //!< Bit mask for USBHS_EPCR2_RXD.
#define BS_USBHS_EPCR2_RXD   (1U)          //!< Bit field size in bits for USBHS_EPCR2_RXD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_RXD field.
#define BR_USBHS_EPCR2_RXD   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXD))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_RXD.
#define BF_USBHS_EPCR2_RXD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_RXD), uint32_t) & BM_USBHS_EPCR2_RXD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXD field to a new value.
#define BW_USBHS_EPCR2_RXD(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXD) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field RXT[3:2] (RW)
 *
 * Values:
 * - 00 - Control
 * - 01 - Isochronous
 * - 10 - Bulk
 * - 11 - Interrupt
 */
//@{
#define BP_USBHS_EPCR2_RXT   (2U)          //!< Bit position for USBHS_EPCR2_RXT.
#define BM_USBHS_EPCR2_RXT   (0x0000000CU) //!< Bit mask for USBHS_EPCR2_RXT.
#define BS_USBHS_EPCR2_RXT   (2U)          //!< Bit field size in bits for USBHS_EPCR2_RXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_RXT field.
#define BR_USBHS_EPCR2_RXT   (HW_USBHS_EPCR2.B.RXT)
#endif

//! @brief Format value for bitfield USBHS_EPCR2_RXT.
#define BF_USBHS_EPCR2_RXT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_RXT), uint32_t) & BM_USBHS_EPCR2_RXT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXT field to a new value.
#define BW_USBHS_EPCR2_RXT(v) (HW_USBHS_EPCR2_WR((HW_USBHS_EPCR2_RD() & ~BM_USBHS_EPCR2_RXT) | BF_USBHS_EPCR2_RXT(v)))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field RXI[5] (RW)
 *
 * Values:
 * - 0 - PID sequencing enabled
 * - 1 - PID sequencing disabled
 */
//@{
#define BP_USBHS_EPCR2_RXI   (5U)          //!< Bit position for USBHS_EPCR2_RXI.
#define BM_USBHS_EPCR2_RXI   (0x00000020U) //!< Bit mask for USBHS_EPCR2_RXI.
#define BS_USBHS_EPCR2_RXI   (1U)          //!< Bit field size in bits for USBHS_EPCR2_RXI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_RXI field.
#define BR_USBHS_EPCR2_RXI   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXI))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_RXI.
#define BF_USBHS_EPCR2_RXI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_RXI), uint32_t) & BM_USBHS_EPCR2_RXI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXI field to a new value.
#define BW_USBHS_EPCR2_RXI(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field RXR[6] (WO)
 */
//@{
#define BP_USBHS_EPCR2_RXR   (6U)          //!< Bit position for USBHS_EPCR2_RXR.
#define BM_USBHS_EPCR2_RXR   (0x00000040U) //!< Bit mask for USBHS_EPCR2_RXR.
#define BS_USBHS_EPCR2_RXR   (1U)          //!< Bit field size in bits for USBHS_EPCR2_RXR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_RXR field.
#define BR_USBHS_EPCR2_RXR   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXR))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_RXR.
#define BF_USBHS_EPCR2_RXR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_RXR), uint32_t) & BM_USBHS_EPCR2_RXR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXR field to a new value.
#define BW_USBHS_EPCR2_RXR(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXR) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field RXE[7] (RW)
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_EPCR2_RXE   (7U)          //!< Bit position for USBHS_EPCR2_RXE.
#define BM_USBHS_EPCR2_RXE   (0x00000080U) //!< Bit mask for USBHS_EPCR2_RXE.
#define BS_USBHS_EPCR2_RXE   (1U)          //!< Bit field size in bits for USBHS_EPCR2_RXE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_RXE field.
#define BR_USBHS_EPCR2_RXE   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXE))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_RXE.
#define BF_USBHS_EPCR2_RXE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_RXE), uint32_t) & BM_USBHS_EPCR2_RXE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXE field to a new value.
#define BW_USBHS_EPCR2_RXE(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_RXE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field TXS[16] (RW)
 *
 * Values:
 * - 0 - Endpoint OK
 * - 1 - Endpoint stalled
 */
//@{
#define BP_USBHS_EPCR2_TXS   (16U)         //!< Bit position for USBHS_EPCR2_TXS.
#define BM_USBHS_EPCR2_TXS   (0x00010000U) //!< Bit mask for USBHS_EPCR2_TXS.
#define BS_USBHS_EPCR2_TXS   (1U)          //!< Bit field size in bits for USBHS_EPCR2_TXS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_TXS field.
#define BR_USBHS_EPCR2_TXS   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXS))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_TXS.
#define BF_USBHS_EPCR2_TXS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_TXS), uint32_t) & BM_USBHS_EPCR2_TXS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXS field to a new value.
#define BW_USBHS_EPCR2_TXS(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field TXD[17] (RW)
 */
//@{
#define BP_USBHS_EPCR2_TXD   (17U)         //!< Bit position for USBHS_EPCR2_TXD.
#define BM_USBHS_EPCR2_TXD   (0x00020000U) //!< Bit mask for USBHS_EPCR2_TXD.
#define BS_USBHS_EPCR2_TXD   (1U)          //!< Bit field size in bits for USBHS_EPCR2_TXD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_TXD field.
#define BR_USBHS_EPCR2_TXD   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXD))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_TXD.
#define BF_USBHS_EPCR2_TXD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_TXD), uint32_t) & BM_USBHS_EPCR2_TXD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXD field to a new value.
#define BW_USBHS_EPCR2_TXD(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXD) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field TXT[19:18] (RW)
 *
 * Values:
 * - 00 - Control
 * - 01 - Isochronous
 * - 10 - Bulk
 * - 11 - Interrupt
 */
//@{
#define BP_USBHS_EPCR2_TXT   (18U)         //!< Bit position for USBHS_EPCR2_TXT.
#define BM_USBHS_EPCR2_TXT   (0x000C0000U) //!< Bit mask for USBHS_EPCR2_TXT.
#define BS_USBHS_EPCR2_TXT   (2U)          //!< Bit field size in bits for USBHS_EPCR2_TXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_TXT field.
#define BR_USBHS_EPCR2_TXT   (HW_USBHS_EPCR2.B.TXT)
#endif

//! @brief Format value for bitfield USBHS_EPCR2_TXT.
#define BF_USBHS_EPCR2_TXT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_TXT), uint32_t) & BM_USBHS_EPCR2_TXT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXT field to a new value.
#define BW_USBHS_EPCR2_TXT(v) (HW_USBHS_EPCR2_WR((HW_USBHS_EPCR2_RD() & ~BM_USBHS_EPCR2_TXT) | BF_USBHS_EPCR2_TXT(v)))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field TXI[21] (RW)
 *
 * Values:
 * - 0 - PID sequencing enabled
 * - 1 - PID sequencing disabled
 */
//@{
#define BP_USBHS_EPCR2_TXI   (21U)         //!< Bit position for USBHS_EPCR2_TXI.
#define BM_USBHS_EPCR2_TXI   (0x00200000U) //!< Bit mask for USBHS_EPCR2_TXI.
#define BS_USBHS_EPCR2_TXI   (1U)          //!< Bit field size in bits for USBHS_EPCR2_TXI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_TXI field.
#define BR_USBHS_EPCR2_TXI   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXI))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_TXI.
#define BF_USBHS_EPCR2_TXI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_TXI), uint32_t) & BM_USBHS_EPCR2_TXI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXI field to a new value.
#define BW_USBHS_EPCR2_TXI(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field TXR[22] (WO)
 */
//@{
#define BP_USBHS_EPCR2_TXR   (22U)         //!< Bit position for USBHS_EPCR2_TXR.
#define BM_USBHS_EPCR2_TXR   (0x00400000U) //!< Bit mask for USBHS_EPCR2_TXR.
#define BS_USBHS_EPCR2_TXR   (1U)          //!< Bit field size in bits for USBHS_EPCR2_TXR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_TXR field.
#define BR_USBHS_EPCR2_TXR   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXR))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_TXR.
#define BF_USBHS_EPCR2_TXR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_TXR), uint32_t) & BM_USBHS_EPCR2_TXR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXR field to a new value.
#define BW_USBHS_EPCR2_TXR(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXR) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR2, field TXE[23] (RW)
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_EPCR2_TXE   (23U)         //!< Bit position for USBHS_EPCR2_TXE.
#define BM_USBHS_EPCR2_TXE   (0x00800000U) //!< Bit mask for USBHS_EPCR2_TXE.
#define BS_USBHS_EPCR2_TXE   (1U)          //!< Bit field size in bits for USBHS_EPCR2_TXE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR2_TXE field.
#define BR_USBHS_EPCR2_TXE   (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXE))
#endif

//! @brief Format value for bitfield USBHS_EPCR2_TXE.
#define BF_USBHS_EPCR2_TXE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR2_TXE), uint32_t) & BM_USBHS_EPCR2_TXE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXE field to a new value.
#define BW_USBHS_EPCR2_TXE(v) (BITBAND_ACCESS32(HW_USBHS_EPCR2_ADDR, BP_USBHS_EPCR2_TXE) = (v))
#endif
//@}
//-------------------------------------------------------------------------------------------
// HW_USBHS_EPCR3 - Endpoint Control Register n
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_EPCR3 - Endpoint Control Register n (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers are not defined in the EHCI specification. There is an EPCRn
 * register for each endpoint in a device.
 */
typedef union _hw_usbhs_epcr3
{
    uint32_t U;
    struct _hw_usbhs_epcr3_bitfields
    {
        uint32_t RXS : 1;              //!< [0] RX endpoint Stall
        uint32_t RXD : 1;              //!< [1] RX endpoint Data sink
        uint32_t RXT : 2;              //!< [3:2] RX endpoint Type
        uint32_t RESERVED0 : 1;        //!< [4] Reserved
        uint32_t RXI : 1;              //!< [5] RX data toggle Inhibit
        uint32_t RXR : 1;              //!< [6] RX data toggle Reset
        uint32_t RXE : 1;              //!< [7] RX endpoint Enable
        uint32_t RESERVED1 : 8;        //!< [15:8] Reserved
        uint32_t TXS : 1;              //!< [16] TX endpoint Stall
        uint32_t TXD : 1;              //!< [17] TX endpoint Data source
        uint32_t TXT : 2;              //!< [19:18] TX endpoint Type
        uint32_t RESERVED2 : 1;        //!< [20] Reserved
        uint32_t TXI : 1;              //!< [21] TX data toggle Inhibit
        uint32_t TXR : 1;              //!< [22] TX data toggle Reset
        uint32_t TXE : 1;              //!< [23] TX endpoint Enable
        uint32_t RESERVED3 : 8;        //!< [31:24] Reserved
    } B;
} hw_usbhs_epcr3_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_EPCR3 register
 */
//@{
#define HW_USBHS_EPCR3_ADDR      (REGS_USBHS_BASE + 0x1CCU)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_EPCR3           (*(__IO hw_usbhs_epcr3_t *) HW_USBHS_EPCR3_ADDR)
#define HW_USBHS_EPCR3_RD()      (HW_USBHS_EPCR3.U)
#define HW_USBHS_EPCR3_WR(v)     (HW_USBHS_EPCR3.U = (v))
#define HW_USBHS_EPCR3_SET(v)    (HW_USBHS_EPCR3_WR(HW_USBHS_EPCR3_RD() |  (v)))
#define HW_USBHS_EPCR3_CLR(v)    (HW_USBHS_EPCR3_WR(HW_USBHS_EPCR3_RD() & ~(v)))
#define HW_USBHS_EPCR3_TOG(v)    (HW_USBHS_EPCR3_WR(HW_USBHS_EPCR3_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_EPCR3 bitfields
 */

/*!
 * @name Register USBHS_EPCR3, field RXS[0] (RW)
 *
 * Values:
 * - 0 - Endpoint OK
 * - 1 - Endpoint stalled
 */
//@{
#define BP_USBHS_EPCR3_RXS   (0U)          //!< Bit position for USBHS_EPCR3_RXS.
#define BM_USBHS_EPCR3_RXS   (0x00000001U) //!< Bit mask for USBHS_EPCR3_RXS.
#define BS_USBHS_EPCR3_RXS   (1U)          //!< Bit field size in bits for USBHS_EPCR3_RXS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_RXS field.
#define BR_USBHS_EPCR3_RXS   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXS))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_RXS.
#define BF_USBHS_EPCR3_RXS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_RXS), uint32_t) & BM_USBHS_EPCR3_RXS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXS field to a new value.
#define BW_USBHS_EPCR3_RXS(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field RXD[1] (RW)
 */
//@{
#define BP_USBHS_EPCR3_RXD   (1U)          //!< Bit position for USBHS_EPCR3_RXD.
#define BM_USBHS_EPCR3_RXD   (0x00000002U) //!< Bit mask for USBHS_EPCR3_RXD.
#define BS_USBHS_EPCR3_RXD   (1U)          //!< Bit field size in bits for USBHS_EPCR3_RXD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_RXD field.
#define BR_USBHS_EPCR3_RXD   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXD))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_RXD.
#define BF_USBHS_EPCR3_RXD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_RXD), uint32_t) & BM_USBHS_EPCR3_RXD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXD field to a new value.
#define BW_USBHS_EPCR3_RXD(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXD) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field RXT[3:2] (RW)
 *
 * Values:
 * - 00 - Control
 * - 01 - Isochronous
 * - 10 - Bulk
 * - 11 - Interrupt
 */
//@{
#define BP_USBHS_EPCR3_RXT   (2U)          //!< Bit position for USBHS_EPCR3_RXT.
#define BM_USBHS_EPCR3_RXT   (0x0000000CU) //!< Bit mask for USBHS_EPCR3_RXT.
#define BS_USBHS_EPCR3_RXT   (2U)          //!< Bit field size in bits for USBHS_EPCR3_RXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_RXT field.
#define BR_USBHS_EPCR3_RXT   (HW_USBHS_EPCR3.B.RXT)
#endif

//! @brief Format value for bitfield USBHS_EPCR3_RXT.
#define BF_USBHS_EPCR3_RXT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_RXT), uint32_t) & BM_USBHS_EPCR3_RXT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXT field to a new value.
#define BW_USBHS_EPCR3_RXT(v) (HW_USBHS_EPCR3_WR((HW_USBHS_EPCR3_RD() & ~BM_USBHS_EPCR3_RXT) | BF_USBHS_EPCR3_RXT(v)))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field RXI[5] (RW)
 *
 * Values:
 * - 0 - PID sequencing enabled
 * - 1 - PID sequencing disabled
 */
//@{
#define BP_USBHS_EPCR3_RXI   (5U)          //!< Bit position for USBHS_EPCR3_RXI.
#define BM_USBHS_EPCR3_RXI   (0x00000020U) //!< Bit mask for USBHS_EPCR3_RXI.
#define BS_USBHS_EPCR3_RXI   (1U)          //!< Bit field size in bits for USBHS_EPCR3_RXI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_RXI field.
#define BR_USBHS_EPCR3_RXI   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXI))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_RXI.
#define BF_USBHS_EPCR3_RXI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_RXI), uint32_t) & BM_USBHS_EPCR3_RXI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXI field to a new value.
#define BW_USBHS_EPCR3_RXI(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field RXR[6] (WO)
 */
//@{
#define BP_USBHS_EPCR3_RXR   (6U)          //!< Bit position for USBHS_EPCR3_RXR.
#define BM_USBHS_EPCR3_RXR   (0x00000040U) //!< Bit mask for USBHS_EPCR3_RXR.
#define BS_USBHS_EPCR3_RXR   (1U)          //!< Bit field size in bits for USBHS_EPCR3_RXR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_RXR field.
#define BR_USBHS_EPCR3_RXR   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXR))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_RXR.
#define BF_USBHS_EPCR3_RXR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_RXR), uint32_t) & BM_USBHS_EPCR3_RXR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXR field to a new value.
#define BW_USBHS_EPCR3_RXR(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXR) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field RXE[7] (RW)
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_EPCR3_RXE   (7U)          //!< Bit position for USBHS_EPCR3_RXE.
#define BM_USBHS_EPCR3_RXE   (0x00000080U) //!< Bit mask for USBHS_EPCR3_RXE.
#define BS_USBHS_EPCR3_RXE   (1U)          //!< Bit field size in bits for USBHS_EPCR3_RXE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_RXE field.
#define BR_USBHS_EPCR3_RXE   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXE))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_RXE.
#define BF_USBHS_EPCR3_RXE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_RXE), uint32_t) & BM_USBHS_EPCR3_RXE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RXE field to a new value.
#define BW_USBHS_EPCR3_RXE(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_RXE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field TXS[16] (RW)
 *
 * Values:
 * - 0 - Endpoint OK
 * - 1 - Endpoint stalled
 */
//@{
#define BP_USBHS_EPCR3_TXS   (16U)         //!< Bit position for USBHS_EPCR3_TXS.
#define BM_USBHS_EPCR3_TXS   (0x00010000U) //!< Bit mask for USBHS_EPCR3_TXS.
#define BS_USBHS_EPCR3_TXS   (1U)          //!< Bit field size in bits for USBHS_EPCR3_TXS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_TXS field.
#define BR_USBHS_EPCR3_TXS   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXS))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_TXS.
#define BF_USBHS_EPCR3_TXS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_TXS), uint32_t) & BM_USBHS_EPCR3_TXS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXS field to a new value.
#define BW_USBHS_EPCR3_TXS(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXS) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field TXD[17] (RW)
 */
//@{
#define BP_USBHS_EPCR3_TXD   (17U)         //!< Bit position for USBHS_EPCR3_TXD.
#define BM_USBHS_EPCR3_TXD   (0x00020000U) //!< Bit mask for USBHS_EPCR3_TXD.
#define BS_USBHS_EPCR3_TXD   (1U)          //!< Bit field size in bits for USBHS_EPCR3_TXD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_TXD field.
#define BR_USBHS_EPCR3_TXD   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXD))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_TXD.
#define BF_USBHS_EPCR3_TXD(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_TXD), uint32_t) & BM_USBHS_EPCR3_TXD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXD field to a new value.
#define BW_USBHS_EPCR3_TXD(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXD) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field TXT[19:18] (RW)
 *
 * Values:
 * - 00 - Control
 * - 01 - Isochronous
 * - 10 - Bulk
 * - 11 - Interrupt
 */
//@{
#define BP_USBHS_EPCR3_TXT   (18U)         //!< Bit position for USBHS_EPCR3_TXT.
#define BM_USBHS_EPCR3_TXT   (0x000C0000U) //!< Bit mask for USBHS_EPCR3_TXT.
#define BS_USBHS_EPCR3_TXT   (2U)          //!< Bit field size in bits for USBHS_EPCR3_TXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_TXT field.
#define BR_USBHS_EPCR3_TXT   (HW_USBHS_EPCR3.B.TXT)
#endif

//! @brief Format value for bitfield USBHS_EPCR3_TXT.
#define BF_USBHS_EPCR3_TXT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_TXT), uint32_t) & BM_USBHS_EPCR3_TXT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXT field to a new value.
#define BW_USBHS_EPCR3_TXT(v) (HW_USBHS_EPCR3_WR((HW_USBHS_EPCR3_RD() & ~BM_USBHS_EPCR3_TXT) | BF_USBHS_EPCR3_TXT(v)))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field TXI[21] (RW)
 *
 * Values:
 * - 0 - PID sequencing enabled
 * - 1 - PID sequencing disabled
 */
//@{
#define BP_USBHS_EPCR3_TXI   (21U)         //!< Bit position for USBHS_EPCR3_TXI.
#define BM_USBHS_EPCR3_TXI   (0x00200000U) //!< Bit mask for USBHS_EPCR3_TXI.
#define BS_USBHS_EPCR3_TXI   (1U)          //!< Bit field size in bits for USBHS_EPCR3_TXI.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_TXI field.
#define BR_USBHS_EPCR3_TXI   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXI))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_TXI.
#define BF_USBHS_EPCR3_TXI(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_TXI), uint32_t) & BM_USBHS_EPCR3_TXI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXI field to a new value.
#define BW_USBHS_EPCR3_TXI(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXI) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field TXR[22] (WO)
 */
//@{
#define BP_USBHS_EPCR3_TXR   (22U)         //!< Bit position for USBHS_EPCR3_TXR.
#define BM_USBHS_EPCR3_TXR   (0x00400000U) //!< Bit mask for USBHS_EPCR3_TXR.
#define BS_USBHS_EPCR3_TXR   (1U)          //!< Bit field size in bits for USBHS_EPCR3_TXR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_TXR field.
#define BR_USBHS_EPCR3_TXR   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXR))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_TXR.
#define BF_USBHS_EPCR3_TXR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_TXR), uint32_t) & BM_USBHS_EPCR3_TXR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXR field to a new value.
#define BW_USBHS_EPCR3_TXR(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXR) = (v))
#endif
//@}

/*!
 * @name Register USBHS_EPCR3, field TXE[23] (RW)
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_EPCR3_TXE   (23U)         //!< Bit position for USBHS_EPCR3_TXE.
#define BM_USBHS_EPCR3_TXE   (0x00800000U) //!< Bit mask for USBHS_EPCR3_TXE.
#define BS_USBHS_EPCR3_TXE   (1U)          //!< Bit field size in bits for USBHS_EPCR3_TXE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_EPCR3_TXE field.
#define BR_USBHS_EPCR3_TXE   (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXE))
#endif

//! @brief Format value for bitfield USBHS_EPCR3_TXE.
#define BF_USBHS_EPCR3_TXE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_EPCR3_TXE), uint32_t) & BM_USBHS_EPCR3_TXE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TXE field to a new value.
#define BW_USBHS_EPCR3_TXE(v) (BITBAND_ACCESS32(HW_USBHS_EPCR3_ADDR, BP_USBHS_EPCR3_TXE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_USBHS_USBGENCTRL - USB General Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_USBHS_USBGENCTRL - USB General Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is not defined in the EHCI specification.
 */
typedef union _hw_usbhs_usbgenctrl
{
    uint32_t U;
    struct _hw_usbhs_usbgenctrl_bitfields
    {
        uint32_t WU_IE : 1;            //!< [0] Wakeup Interrupt Enable
        uint32_t WU_ULPI_EN : 1;       //!< [1] Wakeup on ULPI Interrupt Event
        uint32_t RESERVED0 : 3;        //!< [4:2] Reserved
        uint32_t WU_INT_CLR : 1;       //!< [5] Wakeup Interrupt Clear
        uint32_t RESERVED1 : 26;       //!< [31:6] Reserved
    } B;
} hw_usbhs_usbgenctrl_t;
#endif

/*!
 * @name Constants and macros for entire USBHS_USBGENCTRL register
 */
//@{
#define HW_USBHS_USBGENCTRL_ADDR (REGS_USBHS_BASE + 0x200U)

#ifndef __LANGUAGE_ASM__
#define HW_USBHS_USBGENCTRL      (*(__IO hw_usbhs_usbgenctrl_t *) HW_USBHS_USBGENCTRL_ADDR)
#define HW_USBHS_USBGENCTRL_RD() (HW_USBHS_USBGENCTRL.U)
#define HW_USBHS_USBGENCTRL_WR(v) (HW_USBHS_USBGENCTRL.U = (v))
#define HW_USBHS_USBGENCTRL_SET(v) (HW_USBHS_USBGENCTRL_WR(HW_USBHS_USBGENCTRL_RD() |  (v)))
#define HW_USBHS_USBGENCTRL_CLR(v) (HW_USBHS_USBGENCTRL_WR(HW_USBHS_USBGENCTRL_RD() & ~(v)))
#define HW_USBHS_USBGENCTRL_TOG(v) (HW_USBHS_USBGENCTRL_WR(HW_USBHS_USBGENCTRL_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual USBHS_USBGENCTRL bitfields
 */

/*!
 * @name Register USBHS_USBGENCTRL, field WU_IE[0] (RW)
 *
 * This bit is used to enable the low power wakeup interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBGENCTRL_WU_IE (0U)     //!< Bit position for USBHS_USBGENCTRL_WU_IE.
#define BM_USBHS_USBGENCTRL_WU_IE (0x00000001U) //!< Bit mask for USBHS_USBGENCTRL_WU_IE.
#define BS_USBHS_USBGENCTRL_WU_IE (1U)     //!< Bit field size in bits for USBHS_USBGENCTRL_WU_IE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBGENCTRL_WU_IE field.
#define BR_USBHS_USBGENCTRL_WU_IE (BITBAND_ACCESS32(HW_USBHS_USBGENCTRL_ADDR, BP_USBHS_USBGENCTRL_WU_IE))
#endif

//! @brief Format value for bitfield USBHS_USBGENCTRL_WU_IE.
#define BF_USBHS_USBGENCTRL_WU_IE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBGENCTRL_WU_IE), uint32_t) & BM_USBHS_USBGENCTRL_WU_IE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WU_IE field to a new value.
#define BW_USBHS_USBGENCTRL_WU_IE(v) (BITBAND_ACCESS32(HW_USBHS_USBGENCTRL_ADDR, BP_USBHS_USBGENCTRL_WU_IE) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBGENCTRL, field WU_ULPI_EN[1] (RW)
 *
 * This bit is used to enable the wake up from the ULPI I/F.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
//@{
#define BP_USBHS_USBGENCTRL_WU_ULPI_EN (1U) //!< Bit position for USBHS_USBGENCTRL_WU_ULPI_EN.
#define BM_USBHS_USBGENCTRL_WU_ULPI_EN (0x00000002U) //!< Bit mask for USBHS_USBGENCTRL_WU_ULPI_EN.
#define BS_USBHS_USBGENCTRL_WU_ULPI_EN (1U) //!< Bit field size in bits for USBHS_USBGENCTRL_WU_ULPI_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBGENCTRL_WU_ULPI_EN field.
#define BR_USBHS_USBGENCTRL_WU_ULPI_EN (BITBAND_ACCESS32(HW_USBHS_USBGENCTRL_ADDR, BP_USBHS_USBGENCTRL_WU_ULPI_EN))
#endif

//! @brief Format value for bitfield USBHS_USBGENCTRL_WU_ULPI_EN.
#define BF_USBHS_USBGENCTRL_WU_ULPI_EN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBGENCTRL_WU_ULPI_EN), uint32_t) & BM_USBHS_USBGENCTRL_WU_ULPI_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WU_ULPI_EN field to a new value.
#define BW_USBHS_USBGENCTRL_WU_ULPI_EN(v) (BITBAND_ACCESS32(HW_USBHS_USBGENCTRL_ADDR, BP_USBHS_USBGENCTRL_WU_ULPI_EN) = (v))
#endif
//@}

/*!
 * @name Register USBHS_USBGENCTRL, field WU_INT_CLR[5] (RW)
 *
 * Values:
 * - 0 - Default, no action.
 * - 1 - Clear the wake-up interrupt.
 */
//@{
#define BP_USBHS_USBGENCTRL_WU_INT_CLR (5U) //!< Bit position for USBHS_USBGENCTRL_WU_INT_CLR.
#define BM_USBHS_USBGENCTRL_WU_INT_CLR (0x00000020U) //!< Bit mask for USBHS_USBGENCTRL_WU_INT_CLR.
#define BS_USBHS_USBGENCTRL_WU_INT_CLR (1U) //!< Bit field size in bits for USBHS_USBGENCTRL_WU_INT_CLR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the USBHS_USBGENCTRL_WU_INT_CLR field.
#define BR_USBHS_USBGENCTRL_WU_INT_CLR (BITBAND_ACCESS32(HW_USBHS_USBGENCTRL_ADDR, BP_USBHS_USBGENCTRL_WU_INT_CLR))
#endif

//! @brief Format value for bitfield USBHS_USBGENCTRL_WU_INT_CLR.
#define BF_USBHS_USBGENCTRL_WU_INT_CLR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_USBHS_USBGENCTRL_WU_INT_CLR), uint32_t) & BM_USBHS_USBGENCTRL_WU_INT_CLR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WU_INT_CLR field to a new value.
#define BW_USBHS_USBGENCTRL_WU_INT_CLR(v) (BITBAND_ACCESS32(HW_USBHS_USBGENCTRL_ADDR, BP_USBHS_USBGENCTRL_WU_INT_CLR) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_usbhs_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All USBHS module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_usbhs
{
    __I hw_usbhs_id_t ID;                  //!< [0x0] Identification Register
    __I hw_usbhs_hwgeneral_t HWGENERAL;    //!< [0x4] General Hardware Parameters Register
    __I hw_usbhs_hwhost_t HWHOST;          //!< [0x8] Host Hardware Parameters Register
    __I hw_usbhs_hwdevice_t HWDEVICE;      //!< [0xC] Device Hardware Parameters Register
    __I hw_usbhs_hwtxbuf_t HWTXBUF;        //!< [0x10] Transmit Buffer Hardware Parameters Register
    __I hw_usbhs_hwrxbuf_t HWRXBUF;        //!< [0x14] Receive Buffer Hardware Parameters Register
    uint8_t _reserved0[104];
    __IO hw_usbhs_gptimer0ld_t GPTIMER0LD; //!< [0x80] General Purpose Timer n Load Register
    __IO hw_usbhs_gptimer0ctl_t GPTIMER0CTL; //!< [0x84] General Purpose Timer n Control Register
    __IO hw_usbhs_gptimer1ld_t GPTIMER1LD; //!< [0x88] General Purpose Timer n Load Register
    __IO hw_usbhs_gptimer1ctl_t GPTIMER1CTL; //!< [0x8C] General Purpose Timer n Control Register
    __IO hw_usbhs_usb_sbuscfg_t USB_SBUSCFG; //!< [0x90] System Bus Interface Configuration Register
    uint8_t _reserved1[108];
    __I hw_usbhs_hciversion_t HCIVERSION;  //!< [0x100] Host Controller Interface Version and Capability Registers Length Register
    __I hw_usbhs_hcsparams_t HCSPARAMS;    //!< [0x104] Host Controller Structural Parameters Register
    __I hw_usbhs_hccparams_t HCCPARAMS;    //!< [0x108] Host Controller Capability Parameters Register
    uint8_t _reserved2[22];
    __I hw_usbhs_dciversion_t DCIVERSION;  //!< [0x122] Device Controller Interface Version
    __I hw_usbhs_dccparams_t DCCPARAMS;    //!< [0x124] Device Controller Capability Parameters
    uint8_t _reserved3[24];
    __IO hw_usbhs_usbcmd_t USBCMD;         //!< [0x140] USB Command Register
    __IO hw_usbhs_usbsts_t USBSTS;         //!< [0x144] USB Status Register
    __IO hw_usbhs_usbintr_t USBINTR;       //!< [0x148] USB Interrupt Enable Register
    __IO hw_usbhs_frindex_t FRINDEX;       //!< [0x14C] Frame Index Register
    uint8_t _reserved4[4];
    union {
        __IO hw_usbhs_deviceaddr_t DEVICEADDR; //!< [0x154] Device Address Register
        __IO hw_usbhs_periodiclistbase_t PERIODICLISTBASE; //!< [0x154] Periodic Frame List Base Address Register
    };
    union {
        __IO hw_usbhs_asynclistaddr_t ASYNCLISTADDR; //!< [0x158] Current Asynchronous List Address Register
        __IO hw_usbhs_eplistaddr_t EPLISTADDR; //!< [0x158] Endpoint List Address Register
    };
    __I hw_usbhs_ttctrl_t TTCTRL;          //!< [0x15C] Host TT Asynchronous Buffer Control
    __IO hw_usbhs_burstsize_t BURSTSIZE;   //!< [0x160] Master Interface Data Burst Size Register
    __IO hw_usbhs_txfilltuning_t TXFILLTUNING; //!< [0x164] Transmit FIFO Tuning Control Register
    uint8_t _reserved5[8];
    __IO hw_usbhs_ulpi_viewport_t ULPI_VIEWPORT; //!< [0x170] ULPI Register Access
    uint8_t _reserved6[4];
    __IO hw_usbhs_endptnak_t ENDPTNAK;     //!< [0x178] Endpoint NAK Register
    __IO hw_usbhs_endptnaken_t ENDPTNAKEN; //!< [0x17C] Endpoint NAK Enable Register
    __I hw_usbhs_configflag_t CONFIGFLAG;  //!< [0x180] Configure Flag Register
    __IO hw_usbhs_portsc1_t PORTSC1;       //!< [0x184] Port Status and Control Registers
    uint8_t _reserved7[28];
    __IO hw_usbhs_otgsc_t OTGSC;           //!< [0x1A4] On-the-Go Status and Control Register
    __IO hw_usbhs_usbmode_t USBMODE;       //!< [0x1A8] USB Mode Register
    __IO hw_usbhs_epsetupsr_t EPSETUPSR;   //!< [0x1AC] Endpoint Setup Status Register
    __IO hw_usbhs_epprime_t EPPRIME;       //!< [0x1B0] Endpoint Initialization Register
    __IO hw_usbhs_epflush_t EPFLUSH;       //!< [0x1B4] Endpoint Flush Register
    __I hw_usbhs_epsr_t EPSR;              //!< [0x1B8] Endpoint Status Register
    __IO hw_usbhs_epcomplete_t EPCOMPLETE; //!< [0x1BC] Endpoint Complete Register
    __IO hw_usbhs_epcr0_t EPCR0;           //!< [0x1C0] Endpoint Control Register 0
    __IO hw_usbhs_epcr1_t EPCR1;           //!< [0x1C4] Endpoint Control Register n
    __IO hw_usbhs_epcr2_t EPCR2;           //!< [0x1C8] Endpoint Control Register n
    __IO hw_usbhs_epcr3_t EPCR3;           //!< [0x1CC] Endpoint Control Register n
    uint8_t _reserved8[48];
    __IO hw_usbhs_usbgenctrl_t USBGENCTRL; //!< [0x200] USB General Control Register
} hw_usbhs_t;
#pragma pack()

//! @brief Macro to access all USBHS registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_USBHS</code>.
#define HW_USBHS       (*(hw_usbhs_t *) REGS_USBHS_BASE)
#endif

#endif // __HW_USBHS_REGISTERS_H__
// v22/130726/0.9
// EOF

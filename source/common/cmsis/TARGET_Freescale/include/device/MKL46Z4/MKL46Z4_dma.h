/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_DMA_REGISTERS_H__
#define __HW_DMA_REGISTERS_H__

#include "MKL46Z4.h"
#include "fsl_bitband.h"

/*
 * MKL46Z4 DMA
 *
 * DMA Controller
 *
 * Registers defined in this header file:
 * - HW_DMA_SARn - Source Address Register
 * - HW_DMA_DARn - Destination Address Register
 * - HW_DMA_DSRn - DMA_DSR0 register.
 * - HW_DMA_DSR_BCRn - DMA Status Register / Byte Count Register
 * - HW_DMA_DCRn - DMA Control Register
 *
 * - hw_dma_t - Struct containing all module registers.
 */

#define HW_DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */

/*******************************************************************************
 * HW_DMA_SARn - Source Address Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_SARn - Source Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For this register: Only 32-bit writes are allowed. 16-bit and 8-bit writes
 * result in a bus error. Only four values are allowed to be written to bits 31-20
 * of this register. A write of any other value to these bits causes a
 * configuration error when the channel starts to execute. For more information about the
 * configuration error, see the description of the CEConfiguration error field of
 * DSR.
 */
typedef union _hw_dma_sarn
{
    uint32_t U;
    struct _hw_dma_sarn_bitfields
    {
        uint32_t SAR : 32;             /*!< [31:0]  */
    } B;
} hw_dma_sarn_t;

/*!
 * @name Constants and macros for entire DMA_SARn register
 */
/*@{*/
#define HW_DMA_SARn_COUNT (4U)

#define HW_DMA_SARn_ADDR(x, n)   ((x) + 0x100U + (0x10U * (n)))

#define HW_DMA_SARn(x, n)        (*(__IO hw_dma_sarn_t *) HW_DMA_SARn_ADDR(x, n))
#define HW_DMA_SARn_RD(x, n)     (HW_DMA_SARn(x, n).U)
#define HW_DMA_SARn_WR(x, n, v)  (HW_DMA_SARn(x, n).U = (v))
#define HW_DMA_SARn_SET(x, n, v) (BME_OR32(HW_DMA_SARn_ADDR(x, n), (uint32_t)(v)))
#define HW_DMA_SARn_CLR(x, n, v) (BME_AND32(HW_DMA_SARn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_DMA_SARn_TOG(x, n, v) (BME_XOR32(HW_DMA_SARn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_SARn bitfields
 */

/*!
 * @name Register DMA_SARn, field SAR[31:0] (RW)
 *
 * Each SAR contains the byte address used by the DMA controller to read data.
 * The SARn is typically aligned on a 0-modulo-ssize boundary-that is, on the
 * natural alignment of the source data. Bits 31-20 of this register must be written
 * with one of only four allowed values. Each of these four allowed values
 * corresponds to a valid region of the device's memory map. The allowed values are:
 * 0x000x_xxxx 0x1FFx_xxxx 0x200x_xxxx 0x400x_xxxx After being written with one of
 * the allowed values, bits 31-20 read back as the written value. After being
 * written with any other value, bits 31-20 read back as an indeterminate value.
 */
/*@{*/
#define BP_DMA_SARn_SAR      (0U)          /*!< Bit position for DMA_SARn_SAR. */
#define BM_DMA_SARn_SAR      (0xFFFFFFFFU) /*!< Bit mask for DMA_SARn_SAR. */
#define BS_DMA_SARn_SAR      (32U)         /*!< Bit field size in bits for DMA_SARn_SAR. */

/*! @brief Read current value of the DMA_SARn_SAR field. */
#define BR_DMA_SARn_SAR(x, n) (HW_DMA_SARn(x, n).U)

/*! @brief Format value for bitfield DMA_SARn_SAR. */
#define BF_DMA_SARn_SAR(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_SARn_SAR) & BM_DMA_SARn_SAR)

/*! @brief Set the SAR field to a new value. */
#define BW_DMA_SARn_SAR(x, n, v) (HW_DMA_SARn_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_DARn - Destination Address Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_DARn - Destination Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For this register: Only 32-bit writes are allowed. 16-bit and 8-bit writes
 * result in a bus error. Only four values are allowed to be written to bits 31-20
 * of this register. A write of any other value to these bits causes a
 * configuration error when the channel starts to execute. For more information about the
 * configuration error, see the description of the CEConfiguration error field of
 * DSR.
 */
typedef union _hw_dma_darn
{
    uint32_t U;
    struct _hw_dma_darn_bitfields
    {
        uint32_t DAR : 32;             /*!< [31:0]  */
    } B;
} hw_dma_darn_t;

/*!
 * @name Constants and macros for entire DMA_DARn register
 */
/*@{*/
#define HW_DMA_DARn_COUNT (4U)

#define HW_DMA_DARn_ADDR(x, n)   ((x) + 0x104U + (0x10U * (n)))

#define HW_DMA_DARn(x, n)        (*(__IO hw_dma_darn_t *) HW_DMA_DARn_ADDR(x, n))
#define HW_DMA_DARn_RD(x, n)     (HW_DMA_DARn(x, n).U)
#define HW_DMA_DARn_WR(x, n, v)  (HW_DMA_DARn(x, n).U = (v))
#define HW_DMA_DARn_SET(x, n, v) (BME_OR32(HW_DMA_DARn_ADDR(x, n), (uint32_t)(v)))
#define HW_DMA_DARn_CLR(x, n, v) (BME_AND32(HW_DMA_DARn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_DMA_DARn_TOG(x, n, v) (BME_XOR32(HW_DMA_DARn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_DARn bitfields
 */

/*!
 * @name Register DMA_DARn, field DAR[31:0] (RW)
 *
 * Each DAR contains the byte address used by the DMA controller to write data.
 * The DARn is typically aligned on a 0-modulo-dsize boundary-that is, on the
 * natural alignment of the destination data. Bits 31-20 of this register must be
 * written with one of only four allowed values. Each of these four allowed values
 * corresponds to a valid region of the device's memory map. The allowed values
 * are: 0x000x_xxxx 0x1FFx_xxxx 0x200x_xxxx 0x400x_xxxx After being written with
 * one of the allowed values, bits 31-20 read back as the written value. After
 * being written with any other value, bits 31-20 read back as an indeterminate
 * value.
 */
/*@{*/
#define BP_DMA_DARn_DAR      (0U)          /*!< Bit position for DMA_DARn_DAR. */
#define BM_DMA_DARn_DAR      (0xFFFFFFFFU) /*!< Bit mask for DMA_DARn_DAR. */
#define BS_DMA_DARn_DAR      (32U)         /*!< Bit field size in bits for DMA_DARn_DAR. */

/*! @brief Read current value of the DMA_DARn_DAR field. */
#define BR_DMA_DARn_DAR(x, n) (HW_DMA_DARn(x, n).U)

/*! @brief Format value for bitfield DMA_DARn_DAR. */
#define BF_DMA_DARn_DAR(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_DARn_DAR) & BM_DMA_DARn_DAR)

/*! @brief Set the DAR field to a new value. */
#define BW_DMA_DARn_DAR(x, n, v) (HW_DMA_DARn_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_DSRn - DMA_DSR0 register.
 ******************************************************************************/

/*!
 * @brief HW_DMA_DSRn - DMA_DSR0 register. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_dma_dsrn
{
    uint8_t U;
    struct _hw_dma_dsrn_bitfields
    {
        uint8_t RESERVED0 : 8;         /*!< [7:0]  */
    } B;
} hw_dma_dsrn_t;

/*!
 * @name Constants and macros for entire DMA_DSRn register
 */
/*@{*/
#define HW_DMA_DSRn_COUNT (4U)

#define HW_DMA_DSRn_ADDR(x, n)   ((x) + 0x10BU + (0x10U * (n)))

#define HW_DMA_DSRn(x, n)        (*(__IO hw_dma_dsrn_t *) HW_DMA_DSRn_ADDR(x, n))
#define HW_DMA_DSRn_RD(x, n)     (HW_DMA_DSRn(x, n).U)
#define HW_DMA_DSRn_WR(x, n, v)  (HW_DMA_DSRn(x, n).U = (v))
#define HW_DMA_DSRn_SET(x, n, v) (BME_OR8(HW_DMA_DSRn_ADDR(x, n), (uint8_t)(v)))
#define HW_DMA_DSRn_CLR(x, n, v) (BME_AND8(HW_DMA_DSRn_ADDR(x, n), (uint8_t)(~(v))))
#define HW_DMA_DSRn_TOG(x, n, v) (BME_XOR8(HW_DMA_DSRn_ADDR(x, n), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_DSRn bitfields
 */
/*******************************************************************************
 * HW_DMA_DSR_BCRn - DMA Status Register / Byte Count Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_DSR_BCRn - DMA Status Register / Byte Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * DSR and BCR are two logical registers that occupy one 32-bit address. DSRn
 * occupies bits 31-24, and BCRn occupies bits 23-0. DSRn contains flags indicating
 * the channel status, and BCRn contains the number of bytes yet to be
 * transferred for a given block. On the successful completion of the write transfer, BCRn
 * decrements by 1, 2, or 4 for 8-bit, 16-bit, or 32-bit accesses, respectively.
 * BCRn is cleared if a 1 is written to DSR[DONE]. In response to an event, the
 * DMA controller writes to the appropriate DSRn bit. Only a write to DSRn[DONE]
 * results in action. DSRn[DONE] is set when the block transfer is complete. When
 * a transfer sequence is initiated and BCRn[BCR] is not a multiple of 4 or 2
 * when the DMA is configured for 32-bit or 16-bit transfers, respectively,
 * DSRn[CE] is set and no transfer occurs.
 */
typedef union _hw_dma_dsr_bcrn
{
    uint32_t U;
    struct _hw_dma_dsr_bcrn_bitfields
    {
        uint32_t BCR : 24;             /*!< [23:0]  */
        uint32_t DONE : 1;             /*!< [24] Transactions done */
        uint32_t BSY : 1;              /*!< [25] Busy */
        uint32_t REQ : 1;              /*!< [26] Request */
        uint32_t RESERVED0 : 1;        /*!< [27]  */
        uint32_t BED : 1;              /*!< [28] Bus error on destination */
        uint32_t BES : 1;              /*!< [29] Bus error on source */
        uint32_t CE : 1;               /*!< [30] Configuration error */
        uint32_t RESERVED1 : 1;        /*!< [31]  */
    } B;
} hw_dma_dsr_bcrn_t;

/*!
 * @name Constants and macros for entire DMA_DSR_BCRn register
 */
/*@{*/
#define HW_DMA_DSR_BCRn_COUNT (4U)

#define HW_DMA_DSR_BCRn_ADDR(x, n) ((x) + 0x108U + (0x10U * (n)))

#define HW_DMA_DSR_BCRn(x, n)    (*(__IO hw_dma_dsr_bcrn_t *) HW_DMA_DSR_BCRn_ADDR(x, n))
#define HW_DMA_DSR_BCRn_RD(x, n) (HW_DMA_DSR_BCRn(x, n).U)
#define HW_DMA_DSR_BCRn_WR(x, n, v) (HW_DMA_DSR_BCRn(x, n).U = (v))
#define HW_DMA_DSR_BCRn_SET(x, n, v) (BME_OR32(HW_DMA_DSR_BCRn_ADDR(x, n), (uint32_t)(v)))
#define HW_DMA_DSR_BCRn_CLR(x, n, v) (BME_AND32(HW_DMA_DSR_BCRn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_DMA_DSR_BCRn_TOG(x, n, v) (BME_XOR32(HW_DMA_DSR_BCRn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_DSR_BCRn bitfields
 */

/*!
 * @name Register DMA_DSR_BCRn, field BCR[23:0] (RW)
 *
 * This field contains the number of bytes yet to be transferred for a given
 * block. BCR must be written with a value equal to or less than 0F_FFFFh. After
 * being written with a value in this range, bits 23-20 of BCR read back as 1110b. A
 * write to BCR of a value greater than 0F_FFFFh causes a configuration error
 * when the channel starts to execute. After being written with a value in this
 * range, bits 23-20 of BCR read back as 1111b.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_BCR  (0U)          /*!< Bit position for DMA_DSR_BCRn_BCR. */
#define BM_DMA_DSR_BCRn_BCR  (0x00FFFFFFU) /*!< Bit mask for DMA_DSR_BCRn_BCR. */
#define BS_DMA_DSR_BCRn_BCR  (24U)         /*!< Bit field size in bits for DMA_DSR_BCRn_BCR. */

/*! @brief Read current value of the DMA_DSR_BCRn_BCR field. */
#define BR_DMA_DSR_BCRn_BCR(x, n) (HW_DMA_DSR_BCRn(x, n).B.BCR)

/*! @brief Format value for bitfield DMA_DSR_BCRn_BCR. */
#define BF_DMA_DSR_BCRn_BCR(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DSR_BCRn_BCR) & BM_DMA_DSR_BCRn_BCR)

/*! @brief Set the BCR field to a new value. */
#define BW_DMA_DSR_BCRn_BCR(x, n, v) (HW_DMA_DSR_BCRn_WR(x, n, (HW_DMA_DSR_BCRn_RD(x, n) & ~BM_DMA_DSR_BCRn_BCR) | BF_DMA_DSR_BCRn_BCR(v)))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field DONE[24] (W1C)
 *
 * Set when all DMA controller transactions complete as determined by transfer
 * count, or based on error conditions. When BCR reaches zero, DONE is set when
 * the final transfer completes successfully. DONE can also be used to abort a
 * transfer by resetting the status bits. When a transfer completes, software must
 * clear DONE before reprogramming the DMA.
 *
 * Values:
 * - 0 - DMA transfer is not yet complete. Writing a 0 has no effect.
 * - 1 - DMA transfer completed. Writing a 1 to this bit clears all DMA status
 *     bits and should be used in an interrupt service routine to clear the DMA
 *     interrupt and error bits.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_DONE (24U)         /*!< Bit position for DMA_DSR_BCRn_DONE. */
#define BM_DMA_DSR_BCRn_DONE (0x01000000U) /*!< Bit mask for DMA_DSR_BCRn_DONE. */
#define BS_DMA_DSR_BCRn_DONE (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_DONE. */

/*! @brief Read current value of the DMA_DSR_BCRn_DONE field. */
#define BR_DMA_DSR_BCRn_DONE(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_DONE, BS_DMA_DSR_BCRn_DONE))

/*! @brief Format value for bitfield DMA_DSR_BCRn_DONE. */
#define BF_DMA_DSR_BCRn_DONE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DSR_BCRn_DONE) & BM_DMA_DSR_BCRn_DONE)

/*! @brief Set the DONE field to a new value. */
#define BW_DMA_DSR_BCRn_DONE(x, n, v) (BME_BFI32(HW_DMA_DSR_BCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DSR_BCRn_DONE), BP_DMA_DSR_BCRn_DONE, 1))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field BSY[25] (RO)
 *
 * Values:
 * - 0 - DMA channel is inactive. Cleared when the DMA has finished the last
 *     transaction.
 * - 1 - BSY is set the first time the channel is enabled after a transfer is
 *     initiated.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_BSY  (25U)         /*!< Bit position for DMA_DSR_BCRn_BSY. */
#define BM_DMA_DSR_BCRn_BSY  (0x02000000U) /*!< Bit mask for DMA_DSR_BCRn_BSY. */
#define BS_DMA_DSR_BCRn_BSY  (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_BSY. */

/*! @brief Read current value of the DMA_DSR_BCRn_BSY field. */
#define BR_DMA_DSR_BCRn_BSY(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_BSY, BS_DMA_DSR_BCRn_BSY))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field REQ[26] (RO)
 *
 * Values:
 * - 0 - No request is pending or the channel is currently active. Cleared when
 *     the channel is selected.
 * - 1 - The DMA channel has a transfer remaining and the channel is not
 *     selected.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_REQ  (26U)         /*!< Bit position for DMA_DSR_BCRn_REQ. */
#define BM_DMA_DSR_BCRn_REQ  (0x04000000U) /*!< Bit mask for DMA_DSR_BCRn_REQ. */
#define BS_DMA_DSR_BCRn_REQ  (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_REQ. */

/*! @brief Read current value of the DMA_DSR_BCRn_REQ field. */
#define BR_DMA_DSR_BCRn_REQ(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_REQ, BS_DMA_DSR_BCRn_REQ))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field BED[28] (RO)
 *
 * BED is cleared at hardware reset or by writing a 1 to the DONE bit.
 *
 * Values:
 * - 0 - No bus error occurred.
 * - 1 - The DMA channel terminated with a bus error during the write portion of
 *     a transfer.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_BED  (28U)         /*!< Bit position for DMA_DSR_BCRn_BED. */
#define BM_DMA_DSR_BCRn_BED  (0x10000000U) /*!< Bit mask for DMA_DSR_BCRn_BED. */
#define BS_DMA_DSR_BCRn_BED  (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_BED. */

/*! @brief Read current value of the DMA_DSR_BCRn_BED field. */
#define BR_DMA_DSR_BCRn_BED(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_BED, BS_DMA_DSR_BCRn_BED))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field BES[29] (RO)
 *
 * BES is cleared at hardware reset or by writing a 1 to the DONE bit.
 *
 * Values:
 * - 0 - No bus error occurred.
 * - 1 - The DMA channel terminated with a bus error during the read portion of
 *     a transfer.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_BES  (29U)         /*!< Bit position for DMA_DSR_BCRn_BES. */
#define BM_DMA_DSR_BCRn_BES  (0x20000000U) /*!< Bit mask for DMA_DSR_BCRn_BES. */
#define BS_DMA_DSR_BCRn_BES  (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_BES. */

/*! @brief Read current value of the DMA_DSR_BCRn_BES field. */
#define BR_DMA_DSR_BCRn_BES(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_BES, BS_DMA_DSR_BCRn_BES))
/*@}*/

/*!
 * @name Register DMA_DSR_BCRn, field CE[30] (RO)
 *
 * Any of the following conditions causes a configuration error: BCR, SAR, or
 * DAR does not match the requested transfer size. A value greater than 0F_FFFFh is
 * written to BCR. Bits 31-20 of SAR or DAR are written with a value other than
 * one of the allowed values. See SAR and DAR . SSIZE or DSIZE is set to an
 * unsupported value. BCR equals 0 when the DMA receives a start condition. CE is
 * cleared at hardware reset or by writing a 1 to the DONE bit.
 *
 * Values:
 * - 0 - No configuration error exists.
 * - 1 - A configuration error has occurred.
 */
/*@{*/
#define BP_DMA_DSR_BCRn_CE   (30U)         /*!< Bit position for DMA_DSR_BCRn_CE. */
#define BM_DMA_DSR_BCRn_CE   (0x40000000U) /*!< Bit mask for DMA_DSR_BCRn_CE. */
#define BS_DMA_DSR_BCRn_CE   (1U)          /*!< Bit field size in bits for DMA_DSR_BCRn_CE. */

/*! @brief Read current value of the DMA_DSR_BCRn_CE field. */
#define BR_DMA_DSR_BCRn_CE(x, n) (BME_UBFX32(HW_DMA_DSR_BCRn_ADDR(x, n), BP_DMA_DSR_BCRn_CE, BS_DMA_DSR_BCRn_CE))
/*@}*/
/*******************************************************************************
 * HW_DMA_DCRn - DMA Control Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_DCRn - DMA Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_dcrn
{
    uint32_t U;
    struct _hw_dma_dcrn_bitfields
    {
        uint32_t LCH2 : 2;             /*!< [1:0] Link channel 2 */
        uint32_t LCH1 : 2;             /*!< [3:2] Link channel 1 */
        uint32_t LINKCC : 2;           /*!< [5:4] Link channel control */
        uint32_t RESERVED0 : 1;        /*!< [6]  */
        uint32_t D_REQ : 1;            /*!< [7] Disable request */
        uint32_t DMOD : 4;             /*!< [11:8] Destination address modulo */
        uint32_t SMOD : 4;             /*!< [15:12] Source address modulo */
        uint32_t START : 1;            /*!< [16] Start transfer */
        uint32_t DSIZE : 2;            /*!< [18:17] Destination size */
        uint32_t DINC : 1;             /*!< [19] Destination increment */
        uint32_t SSIZE : 2;            /*!< [21:20] Source size */
        uint32_t SINC : 1;             /*!< [22] Source increment */
        uint32_t EADREQ : 1;           /*!< [23] Enable asynchronous DMA requests */
        uint32_t RESERVED1 : 4;        /*!< [27:24]  */
        uint32_t AA : 1;               /*!< [28] Auto-align */
        uint32_t CS : 1;               /*!< [29] Cycle steal */
        uint32_t ERQ : 1;              /*!< [30] Enable peripheral request */
        uint32_t EINT : 1;             /*!< [31] Enable interrupt on completion of
                                        * transfer */
    } B;
} hw_dma_dcrn_t;

/*!
 * @name Constants and macros for entire DMA_DCRn register
 */
/*@{*/
#define HW_DMA_DCRn_COUNT (4U)

#define HW_DMA_DCRn_ADDR(x, n)   ((x) + 0x10CU + (0x10U * (n)))

#define HW_DMA_DCRn(x, n)        (*(__IO hw_dma_dcrn_t *) HW_DMA_DCRn_ADDR(x, n))
#define HW_DMA_DCRn_RD(x, n)     (HW_DMA_DCRn(x, n).U)
#define HW_DMA_DCRn_WR(x, n, v)  (HW_DMA_DCRn(x, n).U = (v))
#define HW_DMA_DCRn_SET(x, n, v) (BME_OR32(HW_DMA_DCRn_ADDR(x, n), (uint32_t)(v)))
#define HW_DMA_DCRn_CLR(x, n, v) (BME_AND32(HW_DMA_DCRn_ADDR(x, n), (uint32_t)(~(v))))
#define HW_DMA_DCRn_TOG(x, n, v) (BME_XOR32(HW_DMA_DCRn_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCRn bitfields
 */

/*!
 * @name Register DMA_DCRn, field LCH2[1:0] (RW)
 *
 * Indicates the DMA channel assigned as link channel 2. The link channel number
 * cannot be the same as the currently executing channel, and generates a
 * configuration error if this is attempted (DSRn[CE] is set).
 *
 * Values:
 * - 00 - DMA Channel 0
 * - 01 - DMA Channel 1
 * - 10 - DMA Channel 2
 * - 11 - DMA Channel 3
 */
/*@{*/
#define BP_DMA_DCRn_LCH2     (0U)          /*!< Bit position for DMA_DCRn_LCH2. */
#define BM_DMA_DCRn_LCH2     (0x00000003U) /*!< Bit mask for DMA_DCRn_LCH2. */
#define BS_DMA_DCRn_LCH2     (2U)          /*!< Bit field size in bits for DMA_DCRn_LCH2. */

/*! @brief Read current value of the DMA_DCRn_LCH2 field. */
#define BR_DMA_DCRn_LCH2(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_LCH2, BS_DMA_DCRn_LCH2))

/*! @brief Format value for bitfield DMA_DCRn_LCH2. */
#define BF_DMA_DCRn_LCH2(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_LCH2) & BM_DMA_DCRn_LCH2)

/*! @brief Set the LCH2 field to a new value. */
#define BW_DMA_DCRn_LCH2(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_LCH2), BP_DMA_DCRn_LCH2, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field LCH1[3:2] (RW)
 *
 * Indicates the DMA channel assigned as link channel 1. The link channel number
 * cannot be the same as the currently executing channel, and generates a
 * configuration error if this is attempted (DSRn[CE] is set).
 *
 * Values:
 * - 00 - DMA Channel 0
 * - 01 - DMA Channel 1
 * - 10 - DMA Channel 2
 * - 11 - DMA Channel 3
 */
/*@{*/
#define BP_DMA_DCRn_LCH1     (2U)          /*!< Bit position for DMA_DCRn_LCH1. */
#define BM_DMA_DCRn_LCH1     (0x0000000CU) /*!< Bit mask for DMA_DCRn_LCH1. */
#define BS_DMA_DCRn_LCH1     (2U)          /*!< Bit field size in bits for DMA_DCRn_LCH1. */

/*! @brief Read current value of the DMA_DCRn_LCH1 field. */
#define BR_DMA_DCRn_LCH1(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_LCH1, BS_DMA_DCRn_LCH1))

/*! @brief Format value for bitfield DMA_DCRn_LCH1. */
#define BF_DMA_DCRn_LCH1(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_LCH1) & BM_DMA_DCRn_LCH1)

/*! @brief Set the LCH1 field to a new value. */
#define BW_DMA_DCRn_LCH1(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_LCH1), BP_DMA_DCRn_LCH1, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field LINKCC[5:4] (RW)
 *
 * Allows DMA channels to have their transfers linked. The current DMA channel
 * triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the
 * condition described by the LINKCC bits. If not in cycle steal mode (DCRn[CS]=0)
 * and LINKCC equals 01 or 10, no link to LCH1 occurs. If LINKCC equals 01, a
 * link to LCH1 is created after each cycle-steal transfer performed by the current
 * DMA channel is completed. As the last cycle-steal is performed and the BCR
 * reaches zero, then the link to LCH1 is closed and a link to LCH2 is created.
 *
 * Values:
 * - 00 - No channel-to-channel linking
 * - 01 - Perform a link to channel LCH1 after each cycle-steal transfer
 *     followed by a link to LCH2 after the BCR decrements to zero
 * - 10 - Perform a link to channel LCH1 after each cycle-steal transfer
 * - 11 - Perform a link to channel LCH1 after the BCR decrements to zero
 */
/*@{*/
#define BP_DMA_DCRn_LINKCC   (4U)          /*!< Bit position for DMA_DCRn_LINKCC. */
#define BM_DMA_DCRn_LINKCC   (0x00000030U) /*!< Bit mask for DMA_DCRn_LINKCC. */
#define BS_DMA_DCRn_LINKCC   (2U)          /*!< Bit field size in bits for DMA_DCRn_LINKCC. */

/*! @brief Read current value of the DMA_DCRn_LINKCC field. */
#define BR_DMA_DCRn_LINKCC(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_LINKCC, BS_DMA_DCRn_LINKCC))

/*! @brief Format value for bitfield DMA_DCRn_LINKCC. */
#define BF_DMA_DCRn_LINKCC(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_LINKCC) & BM_DMA_DCRn_LINKCC)

/*! @brief Set the LINKCC field to a new value. */
#define BW_DMA_DCRn_LINKCC(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_LINKCC), BP_DMA_DCRn_LINKCC, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field D_REQ[7] (RW)
 *
 * DMA hardware automatically clears the corresponding DCRn[ERQ] bit when the
 * byte count register reaches zero.
 *
 * Values:
 * - 0 - ERQ bit is not affected.
 * - 1 - ERQ bit is cleared when the BCR is exhausted.
 */
/*@{*/
#define BP_DMA_DCRn_D_REQ    (7U)          /*!< Bit position for DMA_DCRn_D_REQ. */
#define BM_DMA_DCRn_D_REQ    (0x00000080U) /*!< Bit mask for DMA_DCRn_D_REQ. */
#define BS_DMA_DCRn_D_REQ    (1U)          /*!< Bit field size in bits for DMA_DCRn_D_REQ. */

/*! @brief Read current value of the DMA_DCRn_D_REQ field. */
#define BR_DMA_DCRn_D_REQ(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_D_REQ, BS_DMA_DCRn_D_REQ))

/*! @brief Format value for bitfield DMA_DCRn_D_REQ. */
#define BF_DMA_DCRn_D_REQ(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_D_REQ) & BM_DMA_DCRn_D_REQ)

/*! @brief Set the D_REQ field to a new value. */
#define BW_DMA_DCRn_D_REQ(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_D_REQ), BP_DMA_DCRn_D_REQ, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field DMOD[11:8] (RW)
 *
 * Defines the size of the destination data circular buffer used by the DMA
 * Controller. If enabled (DMOD value is non-zero), the buffer base address is
 * located on a boundary of the buffer size. The value of this boundary depends on the
 * initial destination address (DAR). The base address should be aligned to a
 * 0-modulo-(circular buffer size) boundary. Misaligned buffers are not possible.
 * The boundary is forced to the value determined by the upper address bits in the
 * field selection.
 *
 * Values:
 * - 0000 - Buffer disabled
 * - 0001 - Circular buffer size is 16 bytes
 * - 0010 - Circular buffer size is 32 bytes
 * - 0011 - Circular buffer size is 64 bytes
 * - 0100 - Circular buffer size is 128 bytes
 * - 0101 - Circular buffer size is 256 bytes
 * - 0110 - Circular buffer size is 512 bytes
 * - 0111 - Circular buffer size is 1 KB
 * - 1000 - Circular buffer size is 2 KB
 * - 1001 - Circular buffer size is 4 KB
 * - 1010 - Circular buffer size is 8 KB
 * - 1011 - Circular buffer size is 16 KB
 * - 1100 - Circular buffer size is 32 KB
 * - 1101 - Circular buffer size is 64 KB
 * - 1110 - Circular buffer size is 128 KB
 * - 1111 - Circular buffer size is 256 KB
 */
/*@{*/
#define BP_DMA_DCRn_DMOD     (8U)          /*!< Bit position for DMA_DCRn_DMOD. */
#define BM_DMA_DCRn_DMOD     (0x00000F00U) /*!< Bit mask for DMA_DCRn_DMOD. */
#define BS_DMA_DCRn_DMOD     (4U)          /*!< Bit field size in bits for DMA_DCRn_DMOD. */

/*! @brief Read current value of the DMA_DCRn_DMOD field. */
#define BR_DMA_DCRn_DMOD(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_DMOD, BS_DMA_DCRn_DMOD))

/*! @brief Format value for bitfield DMA_DCRn_DMOD. */
#define BF_DMA_DCRn_DMOD(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_DMOD) & BM_DMA_DCRn_DMOD)

/*! @brief Set the DMOD field to a new value. */
#define BW_DMA_DCRn_DMOD(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_DMOD), BP_DMA_DCRn_DMOD, 4))
/*@}*/

/*!
 * @name Register DMA_DCRn, field SMOD[15:12] (RW)
 *
 * Defines the size of the source data circular buffer used by the DMA
 * Controller. If enabled (SMOD is non-zero), the buffer base address is located on a
 * boundary of the buffer size. The value of this boundary is based upon the initial
 * source address (SAR). The base address should be aligned to a
 * 0-modulo-(circular buffer size) boundary. Misaligned buffers are not possible. The boundary is
 * forced to the value determined by the upper address bits in the field
 * selection.
 *
 * Values:
 * - 0000 - Buffer disabled
 * - 0001 - Circular buffer size is 16 bytes
 * - 0010 - Circular buffer size is 32 bytes
 * - 0011 - Circular buffer size is 64 bytes
 * - 0100 - Circular buffer size is 128 bytes
 * - 0101 - Circular buffer size is 256 bytes
 * - 0110 - Circular buffer size is 512 bytes
 * - 0111 - Circular buffer size is 1 KB
 * - 1000 - Circular buffer size is 2 KB
 * - 1001 - Circular buffer size is 4 KB
 * - 1010 - Circular buffer size is 8 KB
 * - 1011 - Circular buffer size is 16 KB
 * - 1100 - Circular buffer size is 32 KB
 * - 1101 - Circular buffer size is 64 KB
 * - 1110 - Circular buffer size is 128 KB
 * - 1111 - Circular buffer size is 256 KB
 */
/*@{*/
#define BP_DMA_DCRn_SMOD     (12U)         /*!< Bit position for DMA_DCRn_SMOD. */
#define BM_DMA_DCRn_SMOD     (0x0000F000U) /*!< Bit mask for DMA_DCRn_SMOD. */
#define BS_DMA_DCRn_SMOD     (4U)          /*!< Bit field size in bits for DMA_DCRn_SMOD. */

/*! @brief Read current value of the DMA_DCRn_SMOD field. */
#define BR_DMA_DCRn_SMOD(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_SMOD, BS_DMA_DCRn_SMOD))

/*! @brief Format value for bitfield DMA_DCRn_SMOD. */
#define BF_DMA_DCRn_SMOD(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_SMOD) & BM_DMA_DCRn_SMOD)

/*! @brief Set the SMOD field to a new value. */
#define BW_DMA_DCRn_SMOD(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_SMOD), BP_DMA_DCRn_SMOD, 4))
/*@}*/

/*!
 * @name Register DMA_DCRn, field START[16] (WORZ)
 *
 * Values:
 * - 0 - DMA inactive
 * - 1 - The DMA begins the transfer in accordance to the values in the TCDn.
 *     START is cleared automatically after one module clock and always reads as
 *     logic 0.
 */
/*@{*/
#define BP_DMA_DCRn_START    (16U)         /*!< Bit position for DMA_DCRn_START. */
#define BM_DMA_DCRn_START    (0x00010000U) /*!< Bit mask for DMA_DCRn_START. */
#define BS_DMA_DCRn_START    (1U)          /*!< Bit field size in bits for DMA_DCRn_START. */

/*! @brief Format value for bitfield DMA_DCRn_START. */
#define BF_DMA_DCRn_START(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_START) & BM_DMA_DCRn_START)

/*! @brief Set the START field to a new value. */
#define BW_DMA_DCRn_START(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_START), BP_DMA_DCRn_START, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field DSIZE[18:17] (RW)
 *
 * Determines the data size of the destination bus cycle for the DMA controller.
 *
 * Values:
 * - 00 - 32-bit
 * - 01 - 8-bit
 * - 10 - 16-bit
 * - 11 - Reserved (generates a configuration error (DSRn[CE]) if incorrectly
 *     specified at time of channel activation)
 */
/*@{*/
#define BP_DMA_DCRn_DSIZE    (17U)         /*!< Bit position for DMA_DCRn_DSIZE. */
#define BM_DMA_DCRn_DSIZE    (0x00060000U) /*!< Bit mask for DMA_DCRn_DSIZE. */
#define BS_DMA_DCRn_DSIZE    (2U)          /*!< Bit field size in bits for DMA_DCRn_DSIZE. */

/*! @brief Read current value of the DMA_DCRn_DSIZE field. */
#define BR_DMA_DCRn_DSIZE(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_DSIZE, BS_DMA_DCRn_DSIZE))

/*! @brief Format value for bitfield DMA_DCRn_DSIZE. */
#define BF_DMA_DCRn_DSIZE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_DSIZE) & BM_DMA_DCRn_DSIZE)

/*! @brief Set the DSIZE field to a new value. */
#define BW_DMA_DCRn_DSIZE(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_DSIZE), BP_DMA_DCRn_DSIZE, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field DINC[19] (RW)
 *
 * Controls whether the destination address increments after each successful
 * transfer.
 *
 * Values:
 * - 0 - No change to the DAR after a successful transfer.
 * - 1 - The DAR increments by 1, 2, 4 depending upon the size of the transfer.
 */
/*@{*/
#define BP_DMA_DCRn_DINC     (19U)         /*!< Bit position for DMA_DCRn_DINC. */
#define BM_DMA_DCRn_DINC     (0x00080000U) /*!< Bit mask for DMA_DCRn_DINC. */
#define BS_DMA_DCRn_DINC     (1U)          /*!< Bit field size in bits for DMA_DCRn_DINC. */

/*! @brief Read current value of the DMA_DCRn_DINC field. */
#define BR_DMA_DCRn_DINC(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_DINC, BS_DMA_DCRn_DINC))

/*! @brief Format value for bitfield DMA_DCRn_DINC. */
#define BF_DMA_DCRn_DINC(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_DINC) & BM_DMA_DCRn_DINC)

/*! @brief Set the DINC field to a new value. */
#define BW_DMA_DCRn_DINC(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_DINC), BP_DMA_DCRn_DINC, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field SSIZE[21:20] (RW)
 *
 * Determines the data size of the source bus cycle for the DMA controller.
 *
 * Values:
 * - 00 - 32-bit
 * - 01 - 8-bit
 * - 10 - 16-bit
 * - 11 - Reserved (generates a configuration error (DSRn[CE]) if incorrectly
 *     specified at time of channel activation)
 */
/*@{*/
#define BP_DMA_DCRn_SSIZE    (20U)         /*!< Bit position for DMA_DCRn_SSIZE. */
#define BM_DMA_DCRn_SSIZE    (0x00300000U) /*!< Bit mask for DMA_DCRn_SSIZE. */
#define BS_DMA_DCRn_SSIZE    (2U)          /*!< Bit field size in bits for DMA_DCRn_SSIZE. */

/*! @brief Read current value of the DMA_DCRn_SSIZE field. */
#define BR_DMA_DCRn_SSIZE(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_SSIZE, BS_DMA_DCRn_SSIZE))

/*! @brief Format value for bitfield DMA_DCRn_SSIZE. */
#define BF_DMA_DCRn_SSIZE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_SSIZE) & BM_DMA_DCRn_SSIZE)

/*! @brief Set the SSIZE field to a new value. */
#define BW_DMA_DCRn_SSIZE(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_SSIZE), BP_DMA_DCRn_SSIZE, 2))
/*@}*/

/*!
 * @name Register DMA_DCRn, field SINC[22] (RW)
 *
 * Controls whether the source address increments after each successful transfer.
 *
 * Values:
 * - 0 - No change to SAR after a successful transfer.
 * - 1 - The SAR increments by 1, 2, 4 as determined by the transfer size.
 */
/*@{*/
#define BP_DMA_DCRn_SINC     (22U)         /*!< Bit position for DMA_DCRn_SINC. */
#define BM_DMA_DCRn_SINC     (0x00400000U) /*!< Bit mask for DMA_DCRn_SINC. */
#define BS_DMA_DCRn_SINC     (1U)          /*!< Bit field size in bits for DMA_DCRn_SINC. */

/*! @brief Read current value of the DMA_DCRn_SINC field. */
#define BR_DMA_DCRn_SINC(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_SINC, BS_DMA_DCRn_SINC))

/*! @brief Format value for bitfield DMA_DCRn_SINC. */
#define BF_DMA_DCRn_SINC(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_SINC) & BM_DMA_DCRn_SINC)

/*! @brief Set the SINC field to a new value. */
#define BW_DMA_DCRn_SINC(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_SINC), BP_DMA_DCRn_SINC, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field EADREQ[23] (RW)
 *
 * Enables the channel to support asynchronous DREQs while the MCU is in Stop
 * mode.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_DMA_DCRn_EADREQ   (23U)         /*!< Bit position for DMA_DCRn_EADREQ. */
#define BM_DMA_DCRn_EADREQ   (0x00800000U) /*!< Bit mask for DMA_DCRn_EADREQ. */
#define BS_DMA_DCRn_EADREQ   (1U)          /*!< Bit field size in bits for DMA_DCRn_EADREQ. */

/*! @brief Read current value of the DMA_DCRn_EADREQ field. */
#define BR_DMA_DCRn_EADREQ(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_EADREQ, BS_DMA_DCRn_EADREQ))

/*! @brief Format value for bitfield DMA_DCRn_EADREQ. */
#define BF_DMA_DCRn_EADREQ(v) ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_EADREQ) & BM_DMA_DCRn_EADREQ)

/*! @brief Set the EADREQ field to a new value. */
#define BW_DMA_DCRn_EADREQ(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_EADREQ), BP_DMA_DCRn_EADREQ, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field AA[28] (RW)
 *
 * AA and SIZE bits determine whether the source or destination is auto-aligned;
 * that is, transfers are optimized based on the address and size.
 *
 * Values:
 * - 0 - Auto-align disabled
 * - 1 - If SSIZE indicates a transfer no smaller than DSIZE, source accesses
 *     are auto-aligned; otherwise, destination accesses are auto-aligned. Source
 *     alignment takes precedence over destination alignment. If auto-alignment is
 *     enabled, the appropriate address register increments, regardless of DINC
 *     or SINC.
 */
/*@{*/
#define BP_DMA_DCRn_AA       (28U)         /*!< Bit position for DMA_DCRn_AA. */
#define BM_DMA_DCRn_AA       (0x10000000U) /*!< Bit mask for DMA_DCRn_AA. */
#define BS_DMA_DCRn_AA       (1U)          /*!< Bit field size in bits for DMA_DCRn_AA. */

/*! @brief Read current value of the DMA_DCRn_AA field. */
#define BR_DMA_DCRn_AA(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_AA, BS_DMA_DCRn_AA))

/*! @brief Format value for bitfield DMA_DCRn_AA. */
#define BF_DMA_DCRn_AA(v)    ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_AA) & BM_DMA_DCRn_AA)

/*! @brief Set the AA field to a new value. */
#define BW_DMA_DCRn_AA(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_AA), BP_DMA_DCRn_AA, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field CS[29] (RW)
 *
 * Values:
 * - 0 - DMA continuously makes read/write transfers until the BCR decrements to
 *     0.
 * - 1 - Forces a single read/write transfer per request.
 */
/*@{*/
#define BP_DMA_DCRn_CS       (29U)         /*!< Bit position for DMA_DCRn_CS. */
#define BM_DMA_DCRn_CS       (0x20000000U) /*!< Bit mask for DMA_DCRn_CS. */
#define BS_DMA_DCRn_CS       (1U)          /*!< Bit field size in bits for DMA_DCRn_CS. */

/*! @brief Read current value of the DMA_DCRn_CS field. */
#define BR_DMA_DCRn_CS(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_CS, BS_DMA_DCRn_CS))

/*! @brief Format value for bitfield DMA_DCRn_CS. */
#define BF_DMA_DCRn_CS(v)    ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_CS) & BM_DMA_DCRn_CS)

/*! @brief Set the CS field to a new value. */
#define BW_DMA_DCRn_CS(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_CS), BP_DMA_DCRn_CS, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field ERQ[30] (RW)
 *
 * Be careful: a collision can occur between the START bit and D_REQ when the
 * ERQ bit is 1.
 *
 * Values:
 * - 0 - Peripheral request is ignored.
 * - 1 - Enables peripheral request to initiate transfer. A software-initiated
 *     request (setting the START bit) is always enabled.
 */
/*@{*/
#define BP_DMA_DCRn_ERQ      (30U)         /*!< Bit position for DMA_DCRn_ERQ. */
#define BM_DMA_DCRn_ERQ      (0x40000000U) /*!< Bit mask for DMA_DCRn_ERQ. */
#define BS_DMA_DCRn_ERQ      (1U)          /*!< Bit field size in bits for DMA_DCRn_ERQ. */

/*! @brief Read current value of the DMA_DCRn_ERQ field. */
#define BR_DMA_DCRn_ERQ(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_ERQ, BS_DMA_DCRn_ERQ))

/*! @brief Format value for bitfield DMA_DCRn_ERQ. */
#define BF_DMA_DCRn_ERQ(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_ERQ) & BM_DMA_DCRn_ERQ)

/*! @brief Set the ERQ field to a new value. */
#define BW_DMA_DCRn_ERQ(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_ERQ), BP_DMA_DCRn_ERQ, 1))
/*@}*/

/*!
 * @name Register DMA_DCRn, field EINT[31] (RW)
 *
 * Determines whether an interrupt is generated by completing a transfer or by
 * the occurrence of an error condition.
 *
 * Values:
 * - 0 - No interrupt is generated.
 * - 1 - Interrupt signal is enabled.
 */
/*@{*/
#define BP_DMA_DCRn_EINT     (31U)         /*!< Bit position for DMA_DCRn_EINT. */
#define BM_DMA_DCRn_EINT     (0x80000000U) /*!< Bit mask for DMA_DCRn_EINT. */
#define BS_DMA_DCRn_EINT     (1U)          /*!< Bit field size in bits for DMA_DCRn_EINT. */

/*! @brief Read current value of the DMA_DCRn_EINT field. */
#define BR_DMA_DCRn_EINT(x, n) (BME_UBFX32(HW_DMA_DCRn_ADDR(x, n), BP_DMA_DCRn_EINT, BS_DMA_DCRn_EINT))

/*! @brief Format value for bitfield DMA_DCRn_EINT. */
#define BF_DMA_DCRn_EINT(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_DCRn_EINT) & BM_DMA_DCRn_EINT)

/*! @brief Set the EINT field to a new value. */
#define BW_DMA_DCRn_EINT(x, n, v) (BME_BFI32(HW_DMA_DCRn_ADDR(x, n), ((uint32_t)(v) << BP_DMA_DCRn_EINT), BP_DMA_DCRn_EINT, 1))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_dma_t - module struct
 ******************************************************************************/
/*!
 * @brief All DMA module registers.
 */
#pragma pack(1)
typedef struct _hw_dma
{
    uint8_t _reserved0[256];
    struct {
        __IO hw_dma_sarn_t SARn;           /*!< [0x100] Source Address Register */
        __IO hw_dma_darn_t DARn;           /*!< [0x104] Destination Address Register */
        union {
            struct {
                uint8_t _reserved0[3];
                __IO hw_dma_dsrn_t DSRn;   /*!< [0x10B] DMA_DSR0 register. */
            } DMA_DSR_ACCESS8BIT;
            __IO hw_dma_dsr_bcrn_t DSR_BCRn; /*!< [0x108] DMA Status Register / Byte Count Register */
        };
        __IO hw_dma_dcrn_t DCRn;           /*!< [0x10C] DMA Control Register */
    } DMA[4];
} hw_dma_t;
#pragma pack()

/*! @brief Macro to access all DMA registers. */
/*! @param x DMA module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_DMA(DMA_BASE)</code>. */
#define HW_DMA(x)      (*(hw_dma_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

#endif /* __HW_DMA_REGISTERS_H__ */
/* v33/140401/2.1.0 */
/* EOF */

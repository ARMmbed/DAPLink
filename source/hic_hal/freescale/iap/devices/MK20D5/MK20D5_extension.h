/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          GNU C Compiler - CodeSourcery Sourcery G++
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    K20P64M50SF0RM Rev. 1, Oct 2011
**     Version:             rev. 2.1, 2013-06-24
**     Build:               b150215
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2013 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2011-12-15)
**         Initial version
**     - rev. 2.0 (2012-03-19)
**         PDB Peripheral register structure updated.
**         DMA Registers and bits for unsupported DMA channels removed.
**     - rev. 2.1 (2013-06-24)
**         NV_FOPT register - NMI_DIS bit added.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __MK20D5_EXTENSION_H__
#define __MK20D5_EXTENSION_H__

#include "MK20D5.h"
#include "fsl_bitaccess.h"

/*
 * MK20D5 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - ADC_SC1 - ADC status and control registers 1
 * - ADC_CFG1 - ADC configuration register 1
 * - ADC_CFG2 - Configuration register 2
 * - ADC_R - ADC data result register
 * - ADC_CV1 - Compare value registers
 * - ADC_CV2 - Compare value registers
 * - ADC_SC2 - Status and control register 2
 * - ADC_SC3 - Status and control register 3
 * - ADC_OFS - ADC offset correction register
 * - ADC_PG - ADC plus-side gain register
 * - ADC_MG - ADC minus-side gain register
 * - ADC_CLPD - ADC plus-side general calibration value register
 * - ADC_CLPS - ADC plus-side general calibration value register
 * - ADC_CLP4 - ADC plus-side general calibration value register
 * - ADC_CLP3 - ADC plus-side general calibration value register
 * - ADC_CLP2 - ADC plus-side general calibration value register
 * - ADC_CLP1 - ADC plus-side general calibration value register
 * - ADC_CLP0 - ADC plus-side general calibration value register
 * - ADC_CLMD - ADC minus-side general calibration value register
 * - ADC_CLMS - ADC minus-side general calibration value register
 * - ADC_CLM4 - ADC minus-side general calibration value register
 * - ADC_CLM3 - ADC minus-side general calibration value register
 * - ADC_CLM2 - ADC minus-side general calibration value register
 * - ADC_CLM1 - ADC minus-side general calibration value register
 * - ADC_CLM0 - ADC minus-side general calibration value register
 */

#define ADC_INSTANCE_COUNT (1U) /*!< Number of instances of the ADC module. */
#define ADC0_IDX (0U) /*!< Instance number for ADC0. */

/*******************************************************************************
 * ADC_SC1 - ADC status and control registers 1
 ******************************************************************************/

/*!
 * @brief ADC_SC1 - ADC status and control registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The SC1A register is used for both software and hardware trigger modes of
 * operation. To allow sequential conversions of the ADC to be triggered by internal
 * peripherals, the ADC can have more then one status and control register: one
 * for each conversion. The SC1B-SC1n registers indicate potentially multiple SC1
 * registers for use only in hardware trigger mode. Refer to the Chip
 * Configuration information about the number of SC1n registers specific to this device.
 * The SC1n registers have identical fields, and are used in a "ping-pong" approach
 * to control ADC operation. At any one point in time, only one of the SC1n
 * registers is actively controlling ADC conversions. Updating SC1A while SC1n is
 * actively controlling a conversion is allowed (and vice-versa for any of the SC1n
 * registers specific to this MCU). Writing SC1A while SC1A is actively
 * controlling a conversion aborts the current conversion. In software trigger mode
 * (ADTRG=0), writes to the SC1A register subsequently initiate a new conversion (if
 * the ADCH bits are equal to a value other than all 1s). Similarly, writing any of
 * the SC1n registers while that specific SC1n register is actively controlling
 * a conversion aborts the current conversion. None of the SC1B-SC1n registers
 * are used for software trigger operation and therefore writes to the SC1B - SC1n
 * registers do not initiate a new conversion.
 */
/*!
 * @name Constants and macros for entire ADC_SC1 register
 */
/*@{*/
#define ADC_RD_SC1(base, index)  (ADC_SC1_REG(base, index))
#define ADC_WR_SC1(base, index, value) (ADC_SC1_REG(base, index) = (value))
#define ADC_RMW_SC1(base, index, mask, value) (ADC_WR_SC1(base, index, (ADC_RD_SC1(base, index) & ~(mask)) | (value)))
#define ADC_SET_SC1(base, index, value) (ADC_WR_SC1(base, index, ADC_RD_SC1(base, index) |  (value)))
#define ADC_CLR_SC1(base, index, value) (ADC_WR_SC1(base, index, ADC_RD_SC1(base, index) & ~(value)))
#define ADC_TOG_SC1(base, index, value) (ADC_WR_SC1(base, index, ADC_RD_SC1(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1 bitfields
 */

/*!
 * @name Register ADC_SC1, field ADCH[4:0] (RW)
 *
 * Values:
 * - 00000 - AD0 is selected as input.
 * - 00001 - AD1 is selected as input.
 * - 00010 - AD2 is selected as input.
 * - 00011 - AD3 is selected as input.
 * - 00100 - AD4 is selected as input.
 * - 00101 - AD5 is selected as input.
 * - 00110 - AD6 is selected as input.
 * - 00111 - AD7 is selected as input.
 * - 01000 - AD8 is selected as input.
 * - 01001 - AD9 is selected as input.
 * - 01010 - AD10 is selected as input.
 * - 01011 - AD11 is selected as input.
 * - 01100 - AD12 is selected as input.
 * - 01101 - AD13 is selected as input.
 * - 01110 - AD14 is selected as input.
 * - 01111 - AD15 is selected as input.
 * - 10000 - AD16 is selected as input.
 * - 10001 - AD17 is selected as input.
 * - 10010 - AD18 is selected as input.
 * - 10011 - AD19 is selected as input.
 * - 10100 - AD20 is selected as input.
 * - 10101 - AD21 is selected as input.
 * - 10110 - AD22 is selected as input.
 * - 10111 - AD23 is selected as input.
 * - 11000 - Reserved.
 * - 11001 - Reserved.
 * - 11010 - Temp sensor (single-ended) is selected as input.
 * - 11011 - Bandgap (single-ended) is selected as input.
 * - 11100 - Reserved.
 * - 11101 - VREFSH is selected as input. Voltage reference selected is
 *     determined by the REFSEL bits in the SC2 register.
 * - 11110 - VREFSL is selected as input. Voltage reference selected is
 *     determined by the REFSEL bits in the SC2 register.
 * - 11111 - Module disabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_ADCH field. */
#define ADC_RD_SC1_ADCH(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_ADCH_MASK) >> ADC_SC1_ADCH_SHIFT)
#define ADC_BRD_SC1_ADCH(base, index) (ADC_RD_SC1_ADCH(base, index))

/*! @brief Set the ADCH field to a new value. */
#define ADC_WR_SC1_ADCH(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_ADCH_MASK, ADC_SC1_ADCH(value)))
#define ADC_BWR_SC1_ADCH(base, index, value) (ADC_WR_SC1_ADCH(base, index, value))
/*@}*/

/*!
 * @name Register ADC_SC1, field DIFF[5] (RW)
 *
 * Values:
 * - 0 - Single-ended conversions and input channels are selected.
 * - 1 - Differential conversions and input channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_DIFF field. */
#define ADC_RD_SC1_DIFF(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_DIFF_MASK) >> ADC_SC1_DIFF_SHIFT)
#define ADC_BRD_SC1_DIFF(base, index) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_DIFF_SHIFT))

/*! @brief Set the DIFF field to a new value. */
#define ADC_WR_SC1_DIFF(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_DIFF_MASK, ADC_SC1_DIFF(value)))
#define ADC_BWR_SC1_DIFF(base, index, value) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_DIFF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC1, field AIEN[6] (RW)
 *
 * Values:
 * - 0 - Conversion complete interrupt disabled.
 * - 1 - Conversion complete interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_AIEN field. */
#define ADC_RD_SC1_AIEN(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT)
#define ADC_BRD_SC1_AIEN(base, index) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT))

/*! @brief Set the AIEN field to a new value. */
#define ADC_WR_SC1_AIEN(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_AIEN_MASK, ADC_SC1_AIEN(value)))
#define ADC_BWR_SC1_AIEN(base, index, value) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC1, field COCO[7] (RO)
 *
 * Values:
 * - 0 - Conversion not completed.
 * - 1 - Conversion completed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_COCO field. */
#define ADC_RD_SC1_COCO(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT)
#define ADC_BRD_SC1_COCO(base, index) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_COCO_SHIFT))
/*@}*/

/*******************************************************************************
 * ADC_CFG1 - ADC configuration register 1
 ******************************************************************************/

/*!
 * @brief ADC_CFG1 - ADC configuration register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * CFG1 register selects the mode of operation, clock source, clock divide, and
 * configure for low power or long sample time.
 */
/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define ADC_RD_CFG1(base)        (ADC_CFG1_REG(base))
#define ADC_WR_CFG1(base, value) (ADC_CFG1_REG(base) = (value))
#define ADC_RMW_CFG1(base, mask, value) (ADC_WR_CFG1(base, (ADC_RD_CFG1(base) & ~(mask)) | (value)))
#define ADC_SET_CFG1(base, value) (ADC_WR_CFG1(base, ADC_RD_CFG1(base) |  (value)))
#define ADC_CLR_CFG1(base, value) (ADC_WR_CFG1(base, ADC_RD_CFG1(base) & ~(value)))
#define ADC_TOG_CFG1(base, value) (ADC_WR_CFG1(base, ADC_RD_CFG1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * ADICLK bits select the input clock source to generate the internal clock,
 * ADCK. Note that when the ADACK clock source is selected, it is not required to be
 * active prior to conversion start. When it is selected and it is not active
 * prior to a conversion start (ADACKEN=0), the asynchronous clock is activated at
 * the start of a conversion and shuts off when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock source
 * is re-activated.
 *
 * Values:
 * - 00 - Bus clock.
 * - 01 - Bus clock divided by 2.
 * - 10 - Alternate clock (ALTCLK).
 * - 11 - Asynchronous clock (ADACK).
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define ADC_RD_CFG1_ADICLK(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
#define ADC_BRD_CFG1_ADICLK(base) (ADC_RD_CFG1_ADICLK(base))

/*! @brief Set the ADICLK field to a new value. */
#define ADC_WR_CFG1_ADICLK(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADICLK_MASK, ADC_CFG1_ADICLK(value)))
#define ADC_BWR_CFG1_ADICLK(base, value) (ADC_WR_CFG1_ADICLK(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * MODE bits are used to select the ADC resolution mode.
 *
 * Values:
 * - 00 - It is single-ended 8-bit conversion.
 * - 01 - It is single-ended 12-bit conversion.
 * - 10 - It is single-ended 10-bit conversion.
 * - 11 - It is single-ended 16-bit conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define ADC_RD_CFG1_MODE(base) ((ADC_CFG1_REG(base) & ADC_CFG1_MODE_MASK) >> ADC_CFG1_MODE_SHIFT)
#define ADC_BRD_CFG1_MODE(base) (ADC_RD_CFG1_MODE(base))

/*! @brief Set the MODE field to a new value. */
#define ADC_WR_CFG1_MODE(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_MODE_MASK, ADC_CFG1_MODE(value)))
#define ADC_BWR_CFG1_MODE(base, value) (ADC_WR_CFG1_MODE(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * ADLSMP selects between different sample times based on the conversion mode
 * selected. This bit adjusts the sample period to allow higher impedance inputs to
 * be accurately sampled or to maximize conversion speed for lower impedance
 * inputs. Longer sample times can also be used to lower overall power consumption
 * if continuous conversions are enabled and high conversion rates are not
 * required. When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select
 * the extent of the long sample time.
 *
 * Values:
 * - 0 - Short sample time.
 * - 1 - Long sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define ADC_RD_CFG1_ADLSMP(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLSMP_MASK) >> ADC_CFG1_ADLSMP_SHIFT)
#define ADC_BRD_CFG1_ADLSMP(base) (BITBAND_ACCESS32(&ADC_CFG1_REG(base), ADC_CFG1_ADLSMP_SHIFT))

/*! @brief Set the ADLSMP field to a new value. */
#define ADC_WR_CFG1_ADLSMP(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLSMP_MASK, ADC_CFG1_ADLSMP(value)))
#define ADC_BWR_CFG1_ADLSMP(base, value) (BITBAND_ACCESS32(&ADC_CFG1_REG(base), ADC_CFG1_ADLSMP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * ADIV selects the divide ratio used by the ADC to generate the internal clock
 * ADCK.
 *
 * Values:
 * - 00 - The divide ratio is 1 and the clock rate is input clock.
 * - 01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define ADC_RD_CFG1_ADIV(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
#define ADC_BRD_CFG1_ADIV(base) (ADC_RD_CFG1_ADIV(base))

/*! @brief Set the ADIV field to a new value. */
#define ADC_WR_CFG1_ADIV(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADIV_MASK, ADC_CFG1_ADIV(value)))
#define ADC_BWR_CFG1_ADIV(base, value) (ADC_WR_CFG1_ADIV(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * ADLPC controls the power configuration of the successive approximation
 * converter. This optimizes power consumption when higher sample rates are not
 * required.
 *
 * Values:
 * - 0 - Normal power configuration.
 * - 1 - Low power configuration. The power is reduced at the expense of maximum
 *     clock speed.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define ADC_RD_CFG1_ADLPC(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLPC_MASK) >> ADC_CFG1_ADLPC_SHIFT)
#define ADC_BRD_CFG1_ADLPC(base) (BITBAND_ACCESS32(&ADC_CFG1_REG(base), ADC_CFG1_ADLPC_SHIFT))

/*! @brief Set the ADLPC field to a new value. */
#define ADC_WR_CFG1_ADLPC(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLPC_MASK, ADC_CFG1_ADLPC(value)))
#define ADC_BWR_CFG1_ADLPC(base, value) (BITBAND_ACCESS32(&ADC_CFG1_REG(base), ADC_CFG1_ADLPC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * ADC_CFG2 - Configuration register 2
 ******************************************************************************/

/*!
 * @brief ADC_CFG2 - Configuration register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * CFG2 register selects the special high speed configuration for very high
 * speed conversions and selects the long sample time duration during long sample
 * mode.
 */
/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define ADC_RD_CFG2(base)        (ADC_CFG2_REG(base))
#define ADC_WR_CFG2(base, value) (ADC_CFG2_REG(base) = (value))
#define ADC_RMW_CFG2(base, mask, value) (ADC_WR_CFG2(base, (ADC_RD_CFG2(base) & ~(mask)) | (value)))
#define ADC_SET_CFG2(base, value) (ADC_WR_CFG2(base, ADC_RD_CFG2(base) |  (value)))
#define ADC_CLR_CFG2(base, value) (ADC_WR_CFG2(base, ADC_RD_CFG2(base) & ~(value)))
#define ADC_TOG_CFG2(base, value) (ADC_WR_CFG2(base, ADC_RD_CFG2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * ADLSTS selects between the extended sample times when long sample time is
 * selected (ADLSMP=1). This allows higher impedance inputs to be accurately sampled
 * or to maximize conversion speed for lower impedance inputs. Longer sample
 * times can also be used to lower overall power consumption when continuous
 * conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 00 - Default longest sample time (20 extra ADCK cycles; 24 ADCK cycles
 *     total).
 * - 01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define ADC_RD_CFG2_ADLSTS(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADLSTS_MASK) >> ADC_CFG2_ADLSTS_SHIFT)
#define ADC_BRD_CFG2_ADLSTS(base) (ADC_RD_CFG2_ADLSTS(base))

/*! @brief Set the ADLSTS field to a new value. */
#define ADC_WR_CFG2_ADLSTS(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADLSTS_MASK, ADC_CFG2_ADLSTS(value)))
#define ADC_BWR_CFG2_ADLSTS(base, value) (ADC_WR_CFG2_ADLSTS(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * ADHSC configures the ADC for very high speed operation. The conversion
 * sequence is altered (2 ADCK cycles added to the conversion time) to allow higher
 * speed conversion clocks.
 *
 * Values:
 * - 0 - Normal conversion sequence selected.
 * - 1 - High speed conversion sequence selected (2 additional ADCK cycles to
 *     total conversion time).
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define ADC_RD_CFG2_ADHSC(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADHSC_MASK) >> ADC_CFG2_ADHSC_SHIFT)
#define ADC_BRD_CFG2_ADHSC(base) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_ADHSC_SHIFT))

/*! @brief Set the ADHSC field to a new value. */
#define ADC_WR_CFG2_ADHSC(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADHSC_MASK, ADC_CFG2_ADHSC(value)))
#define ADC_BWR_CFG2_ADHSC(base, value) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_ADHSC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * ADACKEN enables the ADC's asynchronous clock source and the clock source
 * output regardless of the conversion and input clock select (ADICLK bits) status of
 * the ADC. Based on MCU configuration, the asynchronous clock may be used by
 * other modules (see Chip Configuration information). Setting this bit allows the
 * clock to be used even while the ADC is idle or operating from a different
 * clock source. Also, latency of initiating a single or first-continuous conversion
 * with the asynchronous clock selected is reduced since the ADACK clock is
 * already operational.
 *
 * Values:
 * - 0 - Asynchronous clock output disabled; Asynchronous clock only enabled if
 *     selected by ADICLK and a conversion is active.
 * - 1 - Asynchronous clock and clock output enabled regardless of the state of
 *     the ADC.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define ADC_RD_CFG2_ADACKEN(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADACKEN_MASK) >> ADC_CFG2_ADACKEN_SHIFT)
#define ADC_BRD_CFG2_ADACKEN(base) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_ADACKEN_SHIFT))

/*! @brief Set the ADACKEN field to a new value. */
#define ADC_WR_CFG2_ADACKEN(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADACKEN_MASK, ADC_CFG2_ADACKEN(value)))
#define ADC_BWR_CFG2_ADACKEN(base, value) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_ADACKEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * ADC Mux select bit is used to change the ADC mux setting to select between
 * alternate sets of ADC channels.
 *
 * Values:
 * - 0 - ADxxa channels are selected.
 * - 1 - ADxxb channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define ADC_RD_CFG2_MUXSEL(base) ((ADC_CFG2_REG(base) & ADC_CFG2_MUXSEL_MASK) >> ADC_CFG2_MUXSEL_SHIFT)
#define ADC_BRD_CFG2_MUXSEL(base) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_MUXSEL_SHIFT))

/*! @brief Set the MUXSEL field to a new value. */
#define ADC_WR_CFG2_MUXSEL(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_MUXSEL_MASK, ADC_CFG2_MUXSEL(value)))
#define ADC_BWR_CFG2_MUXSEL(base, value) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_MUXSEL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * ADC_R - ADC data result register
 ******************************************************************************/

/*!
 * @brief ADC_R - ADC data result register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in the Rn register are cleared in
 * unsigned right justified modes and carry the sign bit (MSB) in sign extended 2's
 * complement modes. The following table describes the behavior of the data result
 * registers in the different modes of operation. Data result register description
 * Conversion mode D15 D14 D13 D12 D11 D10 D9 D8 D7 D6 D5 D4 D3 D2 D1 D0 Format
 * 16-bit differential S D D D D D D D D D D D D D D D Signed 2's complement
 * 16-bit single-ended D D D D D D D D D D D D D D D D Unsigned right justified
 * 12-bit single-ended 0 0 0 0 D D D D D D D D D D D D Unsigned right justified 10-bit
 * single-ended 0 0 0 0 0 0 D D D D D D D D D D Unsigned right justified 8-bit
 * single-ended 0 0 0 0 0 0 0 0 D D D D D D D D Unsigned right justified S: Sign
 * bit or sign bit extension; D: Data (2's complement data if indicated)
 */
/*!
 * @name Constants and macros for entire ADC_R register
 */
/*@{*/
#define ADC_RD_R(base, index)    (ADC_R_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual ADC_R bitfields
 */

/*!
 * @name Register ADC_R, field D[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ADC_R_D field. */
#define ADC_RD_R_D(base, index) ((ADC_R_REG(base, index) & ADC_R_D_MASK) >> ADC_R_D_SHIFT)
#define ADC_BRD_R_D(base, index) (ADC_RD_R_D(base, index))
/*@}*/

/*******************************************************************************
 * ADC_CV1 - Compare value registers
 ******************************************************************************/

/*!
 * @brief ADC_CV1 - Compare value registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The compare value registers (CV1 and CV2) contain a compare value used to
 * compare with the conversion result when the compare function is enabled (ACFE=1).
 * This register is formatted the same for both bit position definition and
 * value format (unsigned or sign-extended 2's complement) as the data result
 * registers (Rn) in the different modes of operation. Therefore, the compare function
 * only uses the compare value register bits that are related to the ADC mode of
 * operation. The compare value 2 register (CV2) is utilized only when the compare
 * range function is enabled (ACREN=1).
 */
/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define ADC_RD_CV1(base)         (ADC_CV1_REG(base))
#define ADC_WR_CV1(base, value)  (ADC_CV1_REG(base) = (value))
#define ADC_RMW_CV1(base, mask, value) (ADC_WR_CV1(base, (ADC_RD_CV1(base) & ~(mask)) | (value)))
#define ADC_SET_CV1(base, value) (ADC_WR_CV1(base, ADC_RD_CV1(base) |  (value)))
#define ADC_CLR_CV1(base, value) (ADC_WR_CV1(base, ADC_RD_CV1(base) & ~(value)))
#define ADC_TOG_CV1(base, value) (ADC_WR_CV1(base, ADC_RD_CV1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV1_CV field. */
#define ADC_RD_CV1_CV(base)  ((ADC_CV1_REG(base) & ADC_CV1_CV_MASK) >> ADC_CV1_CV_SHIFT)
#define ADC_BRD_CV1_CV(base) (ADC_RD_CV1_CV(base))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV1_CV(base, value) (ADC_RMW_CV1(base, ADC_CV1_CV_MASK, ADC_CV1_CV(value)))
#define ADC_BWR_CV1_CV(base, value) (ADC_WR_CV1_CV(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CV2 - Compare value registers
 ******************************************************************************/

/*!
 * @brief ADC_CV2 - Compare value registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The compare value registers (CV1 and CV2) contain a compare value used to
 * compare with the conversion result when the compare function is enabled (ACFE=1).
 * This register is formatted the same for both bit position definition and
 * value format (unsigned or sign-extended 2's complement) as the data result
 * registers (Rn) in the different modes of operation. Therefore, the compare function
 * only uses the compare value register bits that are related to the ADC mode of
 * operation. The compare value 2 register (CV2) is utilized only when the compare
 * range function is enabled (ACREN=1).
 */
/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define ADC_RD_CV2(base)         (ADC_CV2_REG(base))
#define ADC_WR_CV2(base, value)  (ADC_CV2_REG(base) = (value))
#define ADC_RMW_CV2(base, mask, value) (ADC_WR_CV2(base, (ADC_RD_CV2(base) & ~(mask)) | (value)))
#define ADC_SET_CV2(base, value) (ADC_WR_CV2(base, ADC_RD_CV2(base) |  (value)))
#define ADC_CLR_CV2(base, value) (ADC_WR_CV2(base, ADC_RD_CV2(base) & ~(value)))
#define ADC_TOG_CV2(base, value) (ADC_WR_CV2(base, ADC_RD_CV2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV2_CV field. */
#define ADC_RD_CV2_CV(base)  ((ADC_CV2_REG(base) & ADC_CV2_CV_MASK) >> ADC_CV2_CV_SHIFT)
#define ADC_BRD_CV2_CV(base) (ADC_RD_CV2_CV(base))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV2_CV(base, value) (ADC_RMW_CV2(base, ADC_CV2_CV_MASK, ADC_CV2_CV(value)))
#define ADC_BWR_CV2_CV(base, value) (ADC_WR_CV2_CV(base, value))
/*@}*/

/*******************************************************************************
 * ADC_SC2 - Status and control register 2
 ******************************************************************************/

/*!
 * @brief ADC_SC2 - Status and control register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SC2 register contains the conversion active, hardware/software trigger
 * select, compare function and voltage reference select of the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define ADC_RD_SC2(base)         (ADC_SC2_REG(base))
#define ADC_WR_SC2(base, value)  (ADC_SC2_REG(base) = (value))
#define ADC_RMW_SC2(base, mask, value) (ADC_WR_SC2(base, (ADC_RD_SC2(base) & ~(mask)) | (value)))
#define ADC_SET_SC2(base, value) (ADC_WR_SC2(base, ADC_RD_SC2(base) |  (value)))
#define ADC_CLR_SC2(base, value) (ADC_WR_SC2(base, ADC_RD_SC2(base) & ~(value)))
#define ADC_TOG_SC2(base, value) (ADC_WR_SC2(base, ADC_RD_SC2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * REFSEL bits select the voltage reference source used for conversions.
 *
 * Values:
 * - 00 - Default voltage reference pin pair (external pins VREFH and VREFL)
 * - 01 - Alternate reference pair (VALTH and VALTL). This pair may be
 *     additional external pins or internal sources depending on MCU configuration.
 *     Consult the Chip Configuration information for details specific to this MCU.
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define ADC_RD_SC2_REFSEL(base) ((ADC_SC2_REG(base) & ADC_SC2_REFSEL_MASK) >> ADC_SC2_REFSEL_SHIFT)
#define ADC_BRD_SC2_REFSEL(base) (ADC_RD_SC2_REFSEL(base))

/*! @brief Set the REFSEL field to a new value. */
#define ADC_WR_SC2_REFSEL(base, value) (ADC_RMW_SC2(base, ADC_SC2_REFSEL_MASK, ADC_SC2_REFSEL(value)))
#define ADC_BWR_SC2_REFSEL(base, value) (ADC_WR_SC2_REFSEL(base, value))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled and will assert the ADC DMA request during a ADC
 *     conversion complete event noted by the assertion of any of the ADC COCO flags.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define ADC_RD_SC2_DMAEN(base) ((ADC_SC2_REG(base) & ADC_SC2_DMAEN_MASK) >> ADC_SC2_DMAEN_SHIFT)
#define ADC_BRD_SC2_DMAEN(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define ADC_WR_SC2_DMAEN(base, value) (ADC_RMW_SC2(base, ADC_SC2_DMAEN_MASK, ADC_SC2_DMAEN(value)))
#define ADC_BWR_SC2_DMAEN(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * ACREN configures the compare function to check if the conversion result of
 * the input being monitored is either between or outside the range formed by the
 * compare value registers (CV1 and CV2) determined by the value of ACFGT. The
 * ACFE bit must be set for ACFGT to have any effect.
 *
 * Values:
 * - 0 - Range function disabled. Only the compare value 1 register (CV1) is
 *     compared.
 * - 1 - Range function enabled. Both compare value registers (CV1 and CV2) are
 *     compared.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define ADC_RD_SC2_ACREN(base) ((ADC_SC2_REG(base) & ADC_SC2_ACREN_MASK) >> ADC_SC2_ACREN_SHIFT)
#define ADC_BRD_SC2_ACREN(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT))

/*! @brief Set the ACREN field to a new value. */
#define ADC_WR_SC2_ACREN(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACREN_MASK, ADC_SC2_ACREN(value)))
#define ADC_BWR_SC2_ACREN(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * ACFGT configures the compare function to check the conversion result relative
 * to the compare value register(s) (CV1 and CV2) based upon the value of ACREN.
 * The ACFE bit must be set for ACFGT to have any effect.
 *
 * Values:
 * - 0 - Configures less than threshold, outside range not inclusive and inside
 *     range not inclusive functionality based on the values placed in the CV1
 *     and CV2 registers.
 * - 1 - Configures greater than or equal to threshold, outside range inclusive
 *     and inside range inclusive functionality based on the values placed in the
 *     CV1 and CV2 registers.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define ADC_RD_SC2_ACFGT(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFGT_MASK) >> ADC_SC2_ACFGT_SHIFT)
#define ADC_BRD_SC2_ACFGT(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT))

/*! @brief Set the ACFGT field to a new value. */
#define ADC_WR_SC2_ACFGT(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFGT_MASK, ADC_SC2_ACFGT(value)))
#define ADC_BWR_SC2_ACFGT(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * ACFE enables the compare function.
 *
 * Values:
 * - 0 - Compare function disabled.
 * - 1 - Compare function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define ADC_RD_SC2_ACFE(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFE_MASK) >> ADC_SC2_ACFE_SHIFT)
#define ADC_BRD_SC2_ACFE(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT))

/*! @brief Set the ACFE field to a new value. */
#define ADC_WR_SC2_ACFE(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFE_MASK, ADC_SC2_ACFE(value)))
#define ADC_BWR_SC2_ACFE(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * ADTRG selects the type of trigger used for initiating a conversion. Two types
 * of trigger are selectable: software trigger and hardware trigger. When
 * software trigger is selected, a conversion is initiated following a write to SC1A.
 * When hardware trigger is selected, a conversion is initiated following the
 * assertion of the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0 - Software trigger selected.
 * - 1 - Hardware trigger selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define ADC_RD_SC2_ADTRG(base) ((ADC_SC2_REG(base) & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT)
#define ADC_BRD_SC2_ADTRG(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT))

/*! @brief Set the ADTRG field to a new value. */
#define ADC_WR_SC2_ADTRG(base, value) (ADC_RMW_SC2(base, ADC_SC2_ADTRG_MASK, ADC_SC2_ADTRG(value)))
#define ADC_BWR_SC2_ADTRG(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * ADACT indicates that a conversion or hardware averaging is in progress. ADACT
 * is set when a conversion is initiated and cleared when a conversion is
 * completed or aborted.
 *
 * Values:
 * - 0 - Conversion not in progress.
 * - 1 - Conversion in progress.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define ADC_RD_SC2_ADACT(base) ((ADC_SC2_REG(base) & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT)
#define ADC_BRD_SC2_ADACT(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ADACT_SHIFT))
/*@}*/

/*******************************************************************************
 * ADC_SC3 - Status and control register 3
 ******************************************************************************/

/*!
 * @brief ADC_SC3 - Status and control register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SC3 register controls the calibration, continuous convert, and hardware
 * averaging functions of the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define ADC_RD_SC3(base)         (ADC_SC3_REG(base))
#define ADC_WR_SC3(base, value)  (ADC_SC3_REG(base) = (value))
#define ADC_RMW_SC3(base, mask, value) (ADC_WR_SC3(base, (ADC_RD_SC3(base) & ~(mask)) | (value)))
#define ADC_SET_SC3(base, value) (ADC_WR_SC3(base, ADC_RD_SC3(base) |  (value)))
#define ADC_CLR_SC3(base, value) (ADC_WR_SC3(base, ADC_RD_SC3(base) & ~(value)))
#define ADC_TOG_SC3(base, value) (ADC_WR_SC3(base, ADC_RD_SC3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * AVGS determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 00 - 4 samples averaged.
 * - 01 - 8 samples averaged.
 * - 10 - 16 samples averaged.
 * - 11 - 32 samples averaged.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define ADC_RD_SC3_AVGS(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
#define ADC_BRD_SC3_AVGS(base) (ADC_RD_SC3_AVGS(base))

/*! @brief Set the AVGS field to a new value. */
#define ADC_WR_SC3_AVGS(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGS_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGS(value)))
#define ADC_BWR_SC3_AVGS(base, value) (ADC_WR_SC3_AVGS(base, value))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * AVGE enables the hardware average function of the ADC.
 *
 * Values:
 * - 0 - Hardware average function disabled.
 * - 1 - Hardware average function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define ADC_RD_SC3_AVGE(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGE_MASK) >> ADC_SC3_AVGE_SHIFT)
#define ADC_BRD_SC3_AVGE(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT))

/*! @brief Set the AVGE field to a new value. */
#define ADC_WR_SC3_AVGE(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGE_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGE(value)))
#define ADC_BWR_SC3_AVGE(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * ADCO enables continuous conversions.
 *
 * Values:
 * - 0 - One conversion or one set of conversions if the hardware average
 *     function is enabled (AVGE=1) after initiating a conversion.
 * - 1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled (AVGE=1) after initiating a conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define ADC_RD_SC3_ADCO(base) ((ADC_SC3_REG(base) & ADC_SC3_ADCO_MASK) >> ADC_SC3_ADCO_SHIFT)
#define ADC_BRD_SC3_ADCO(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT))

/*! @brief Set the ADCO field to a new value. */
#define ADC_WR_SC3_ADCO(base, value) (ADC_RMW_SC3(base, (ADC_SC3_ADCO_MASK | ADC_SC3_CALF_MASK), ADC_SC3_ADCO(value)))
#define ADC_BWR_SC3_ADCO(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (W1C)
 *
 * CALF displays the result of the calibration sequence. The calibration
 * sequence will fail if ADTRG = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. The CALF bit is cleared by
 * writing a 1 to this bit.
 *
 * Values:
 * - 0 - Calibration completed normally.
 * - 1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CALF field. */
#define ADC_RD_SC3_CALF(base) ((ADC_SC3_REG(base) & ADC_SC3_CALF_MASK) >> ADC_SC3_CALF_SHIFT)
#define ADC_BRD_SC3_CALF(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT))

/*! @brief Set the CALF field to a new value. */
#define ADC_WR_SC3_CALF(base, value) (ADC_RMW_SC3(base, ADC_SC3_CALF_MASK, ADC_SC3_CALF(value)))
#define ADC_BWR_SC3_CALF(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * CAL begins the calibration sequence when set. This bit stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. The CALF bit must be checked to determine the result of the calibration
 * sequence. Once started, the calibration routine cannot be interrupted by
 * writes to the ADC registers or the results will be invalid and the CALF bit will
 * set. Setting the CAL bit will abort any current conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CAL field. */
#define ADC_RD_SC3_CAL(base) ((ADC_SC3_REG(base) & ADC_SC3_CAL_MASK) >> ADC_SC3_CAL_SHIFT)
#define ADC_BRD_SC3_CAL(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT))

/*! @brief Set the CAL field to a new value. */
#define ADC_WR_SC3_CAL(base, value) (ADC_RMW_SC3(base, (ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK), ADC_SC3_CAL(value)))
#define ADC_BWR_SC3_CAL(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * ADC_OFS - ADC offset correction register
 ******************************************************************************/

/*!
 * @brief ADC_OFS - ADC offset correction register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC offset correction register (OFS) contains the user selected or
 * calibration generated offset error correction value. This register is a 2's
 * complement, left justified, 16-bit value. The value in the offset correction registers
 * (OFS) is subtracted from the conversion and the result is transferred into
 * the result registers (Rn). If the result is above the maximum or below the
 * minimum result value, it is forced to the appropriate limit for the current mode of
 * operation.
 */
/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define ADC_RD_OFS(base)         (ADC_OFS_REG(base))
#define ADC_WR_OFS(base, value)  (ADC_OFS_REG(base) = (value))
#define ADC_RMW_OFS(base, mask, value) (ADC_WR_OFS(base, (ADC_RD_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_OFS(base, value) (ADC_WR_OFS(base, ADC_RD_OFS(base) |  (value)))
#define ADC_CLR_OFS(base, value) (ADC_WR_OFS(base, ADC_RD_OFS(base) & ~(value)))
#define ADC_TOG_OFS(base, value) (ADC_WR_OFS(base, ADC_RD_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_OFS_OFS field. */
#define ADC_RD_OFS_OFS(base) ((ADC_OFS_REG(base) & ADC_OFS_OFS_MASK) >> ADC_OFS_OFS_SHIFT)
#define ADC_BRD_OFS_OFS(base) (ADC_RD_OFS_OFS(base))

/*! @brief Set the OFS field to a new value. */
#define ADC_WR_OFS_OFS(base, value) (ADC_RMW_OFS(base, ADC_OFS_OFS_MASK, ADC_OFS_OFS(value)))
#define ADC_BWR_OFS_OFS(base, value) (ADC_WR_OFS_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_PG - ADC plus-side gain register
 ******************************************************************************/

/*!
 * @brief ADC_PG - ADC plus-side gain register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The plus-side gain register (PG) contains the gain error correction for the
 * overall conversion in single-ended mode. PG, a 16-bit real number in binary
 * format, is the gain adjustment factor, with the radix point fixed between ADPG15
 * and ADPG14. This register must be written by the user with the value described
 * in the calibration procedure or the gain error specifications may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define ADC_RD_PG(base)          (ADC_PG_REG(base))
#define ADC_WR_PG(base, value)   (ADC_PG_REG(base) = (value))
#define ADC_RMW_PG(base, mask, value) (ADC_WR_PG(base, (ADC_RD_PG(base) & ~(mask)) | (value)))
#define ADC_SET_PG(base, value)  (ADC_WR_PG(base, ADC_RD_PG(base) |  (value)))
#define ADC_CLR_PG(base, value)  (ADC_WR_PG(base, ADC_RD_PG(base) & ~(value)))
#define ADC_TOG_PG(base, value)  (ADC_WR_PG(base, ADC_RD_PG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_PG_PG field. */
#define ADC_RD_PG_PG(base)   ((ADC_PG_REG(base) & ADC_PG_PG_MASK) >> ADC_PG_PG_SHIFT)
#define ADC_BRD_PG_PG(base)  (ADC_RD_PG_PG(base))

/*! @brief Set the PG field to a new value. */
#define ADC_WR_PG_PG(base, value) (ADC_RMW_PG(base, ADC_PG_PG_MASK, ADC_PG_PG(value)))
#define ADC_BWR_PG_PG(base, value) (ADC_WR_PG_PG(base, value))
/*@}*/

/*******************************************************************************
 * ADC_MG - ADC minus-side gain register
 ******************************************************************************/

/*!
 * @brief ADC_MG - ADC minus-side gain register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The minus-side gain register (MG) contains the gain error correction for the
 * minus-side input in differential mode. This register is ignored in
 * single-ended mode. MG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between ADMG15 and ADMG14. This register must
 * be written by the user with the value described in the calibration procedure or
 * the gain error specifications may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_MG register
 */
/*@{*/
#define ADC_RD_MG(base)          (ADC_MG_REG(base))
#define ADC_WR_MG(base, value)   (ADC_MG_REG(base) = (value))
#define ADC_RMW_MG(base, mask, value) (ADC_WR_MG(base, (ADC_RD_MG(base) & ~(mask)) | (value)))
#define ADC_SET_MG(base, value)  (ADC_WR_MG(base, ADC_RD_MG(base) |  (value)))
#define ADC_CLR_MG(base, value)  (ADC_WR_MG(base, ADC_RD_MG(base) & ~(value)))
#define ADC_TOG_MG(base, value)  (ADC_WR_MG(base, ADC_RD_MG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_MG bitfields
 */

/*!
 * @name Register ADC_MG, field MG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_MG_MG field. */
#define ADC_RD_MG_MG(base)   ((ADC_MG_REG(base) & ADC_MG_MG_MASK) >> ADC_MG_MG_SHIFT)
#define ADC_BRD_MG_MG(base)  (ADC_RD_MG_MG(base))

/*! @brief Set the MG field to a new value. */
#define ADC_WR_MG_MG(base, value) (ADC_RMW_MG(base, ADC_MG_MG_MASK, ADC_MG_MG(value)))
#define ADC_BWR_MG_MG(base, value) (ADC_WR_MG_MG(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLPD - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLPD - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The plus-side general calibration value registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * once the self calibration sequence is done (CAL is cleared). If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define ADC_RD_CLPD(base)        (ADC_CLPD_REG(base))
#define ADC_WR_CLPD(base, value) (ADC_CLPD_REG(base) = (value))
#define ADC_RMW_CLPD(base, mask, value) (ADC_WR_CLPD(base, (ADC_RD_CLPD(base) & ~(mask)) | (value)))
#define ADC_SET_CLPD(base, value) (ADC_WR_CLPD(base, ADC_RD_CLPD(base) |  (value)))
#define ADC_CLR_CLPD(base, value) (ADC_WR_CLPD(base, ADC_RD_CLPD(base) & ~(value)))
#define ADC_TOG_CLPD(base, value) (ADC_WR_CLPD(base, ADC_RD_CLPD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define ADC_RD_CLPD_CLPD(base) ((ADC_CLPD_REG(base) & ADC_CLPD_CLPD_MASK) >> ADC_CLPD_CLPD_SHIFT)
#define ADC_BRD_CLPD_CLPD(base) (ADC_RD_CLPD_CLPD(base))

/*! @brief Set the CLPD field to a new value. */
#define ADC_WR_CLPD_CLPD(base, value) (ADC_RMW_CLPD(base, ADC_CLPD_CLPD_MASK, ADC_CLPD_CLPD(value)))
#define ADC_BWR_CLPD_CLPD(base, value) (ADC_WR_CLPD_CLPD(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLPS - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLPS - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, refer to CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define ADC_RD_CLPS(base)        (ADC_CLPS_REG(base))
#define ADC_WR_CLPS(base, value) (ADC_CLPS_REG(base) = (value))
#define ADC_RMW_CLPS(base, mask, value) (ADC_WR_CLPS(base, (ADC_RD_CLPS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPS(base, value) (ADC_WR_CLPS(base, ADC_RD_CLPS(base) |  (value)))
#define ADC_CLR_CLPS(base, value) (ADC_WR_CLPS(base, ADC_RD_CLPS(base) & ~(value)))
#define ADC_TOG_CLPS(base, value) (ADC_WR_CLPS(base, ADC_RD_CLPS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define ADC_RD_CLPS_CLPS(base) ((ADC_CLPS_REG(base) & ADC_CLPS_CLPS_MASK) >> ADC_CLPS_CLPS_SHIFT)
#define ADC_BRD_CLPS_CLPS(base) (ADC_RD_CLPS_CLPS(base))

/*! @brief Set the CLPS field to a new value. */
#define ADC_WR_CLPS_CLPS(base, value) (ADC_RMW_CLPS(base, ADC_CLPS_CLPS_MASK, ADC_CLPS_CLPS(value)))
#define ADC_BWR_CLPS_CLPS(base, value) (ADC_WR_CLPS_CLPS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP4 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLP4 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, refer to CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define ADC_RD_CLP4(base)        (ADC_CLP4_REG(base))
#define ADC_WR_CLP4(base, value) (ADC_CLP4_REG(base) = (value))
#define ADC_RMW_CLP4(base, mask, value) (ADC_WR_CLP4(base, (ADC_RD_CLP4(base) & ~(mask)) | (value)))
#define ADC_SET_CLP4(base, value) (ADC_WR_CLP4(base, ADC_RD_CLP4(base) |  (value)))
#define ADC_CLR_CLP4(base, value) (ADC_WR_CLP4(base, ADC_RD_CLP4(base) & ~(value)))
#define ADC_TOG_CLP4(base, value) (ADC_WR_CLP4(base, ADC_RD_CLP4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define ADC_RD_CLP4_CLP4(base) ((ADC_CLP4_REG(base) & ADC_CLP4_CLP4_MASK) >> ADC_CLP4_CLP4_SHIFT)
#define ADC_BRD_CLP4_CLP4(base) (ADC_RD_CLP4_CLP4(base))

/*! @brief Set the CLP4 field to a new value. */
#define ADC_WR_CLP4_CLP4(base, value) (ADC_RMW_CLP4(base, ADC_CLP4_CLP4_MASK, ADC_CLP4_CLP4(value)))
#define ADC_BWR_CLP4_CLP4(base, value) (ADC_WR_CLP4_CLP4(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP3 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLP3 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, refer to CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define ADC_RD_CLP3(base)        (ADC_CLP3_REG(base))
#define ADC_WR_CLP3(base, value) (ADC_CLP3_REG(base) = (value))
#define ADC_RMW_CLP3(base, mask, value) (ADC_WR_CLP3(base, (ADC_RD_CLP3(base) & ~(mask)) | (value)))
#define ADC_SET_CLP3(base, value) (ADC_WR_CLP3(base, ADC_RD_CLP3(base) |  (value)))
#define ADC_CLR_CLP3(base, value) (ADC_WR_CLP3(base, ADC_RD_CLP3(base) & ~(value)))
#define ADC_TOG_CLP3(base, value) (ADC_WR_CLP3(base, ADC_RD_CLP3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define ADC_RD_CLP3_CLP3(base) ((ADC_CLP3_REG(base) & ADC_CLP3_CLP3_MASK) >> ADC_CLP3_CLP3_SHIFT)
#define ADC_BRD_CLP3_CLP3(base) (ADC_RD_CLP3_CLP3(base))

/*! @brief Set the CLP3 field to a new value. */
#define ADC_WR_CLP3_CLP3(base, value) (ADC_RMW_CLP3(base, ADC_CLP3_CLP3_MASK, ADC_CLP3_CLP3(value)))
#define ADC_BWR_CLP3_CLP3(base, value) (ADC_WR_CLP3_CLP3(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP2 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLP2 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, refer to CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define ADC_RD_CLP2(base)        (ADC_CLP2_REG(base))
#define ADC_WR_CLP2(base, value) (ADC_CLP2_REG(base) = (value))
#define ADC_RMW_CLP2(base, mask, value) (ADC_WR_CLP2(base, (ADC_RD_CLP2(base) & ~(mask)) | (value)))
#define ADC_SET_CLP2(base, value) (ADC_WR_CLP2(base, ADC_RD_CLP2(base) |  (value)))
#define ADC_CLR_CLP2(base, value) (ADC_WR_CLP2(base, ADC_RD_CLP2(base) & ~(value)))
#define ADC_TOG_CLP2(base, value) (ADC_WR_CLP2(base, ADC_RD_CLP2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define ADC_RD_CLP2_CLP2(base) ((ADC_CLP2_REG(base) & ADC_CLP2_CLP2_MASK) >> ADC_CLP2_CLP2_SHIFT)
#define ADC_BRD_CLP2_CLP2(base) (ADC_RD_CLP2_CLP2(base))

/*! @brief Set the CLP2 field to a new value. */
#define ADC_WR_CLP2_CLP2(base, value) (ADC_RMW_CLP2(base, ADC_CLP2_CLP2_MASK, ADC_CLP2_CLP2(value)))
#define ADC_BWR_CLP2_CLP2(base, value) (ADC_WR_CLP2_CLP2(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP1 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLP1 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, refer to CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define ADC_RD_CLP1(base)        (ADC_CLP1_REG(base))
#define ADC_WR_CLP1(base, value) (ADC_CLP1_REG(base) = (value))
#define ADC_RMW_CLP1(base, mask, value) (ADC_WR_CLP1(base, (ADC_RD_CLP1(base) & ~(mask)) | (value)))
#define ADC_SET_CLP1(base, value) (ADC_WR_CLP1(base, ADC_RD_CLP1(base) |  (value)))
#define ADC_CLR_CLP1(base, value) (ADC_WR_CLP1(base, ADC_RD_CLP1(base) & ~(value)))
#define ADC_TOG_CLP1(base, value) (ADC_WR_CLP1(base, ADC_RD_CLP1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define ADC_RD_CLP1_CLP1(base) ((ADC_CLP1_REG(base) & ADC_CLP1_CLP1_MASK) >> ADC_CLP1_CLP1_SHIFT)
#define ADC_BRD_CLP1_CLP1(base) (ADC_RD_CLP1_CLP1(base))

/*! @brief Set the CLP1 field to a new value. */
#define ADC_WR_CLP1_CLP1(base, value) (ADC_RMW_CLP1(base, ADC_CLP1_CLP1_MASK, ADC_CLP1_CLP1(value)))
#define ADC_BWR_CLP1_CLP1(base, value) (ADC_WR_CLP1_CLP1(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP0 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLP0 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, refer to CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define ADC_RD_CLP0(base)        (ADC_CLP0_REG(base))
#define ADC_WR_CLP0(base, value) (ADC_CLP0_REG(base) = (value))
#define ADC_RMW_CLP0(base, mask, value) (ADC_WR_CLP0(base, (ADC_RD_CLP0(base) & ~(mask)) | (value)))
#define ADC_SET_CLP0(base, value) (ADC_WR_CLP0(base, ADC_RD_CLP0(base) |  (value)))
#define ADC_CLR_CLP0(base, value) (ADC_WR_CLP0(base, ADC_RD_CLP0(base) & ~(value)))
#define ADC_TOG_CLP0(base, value) (ADC_WR_CLP0(base, ADC_RD_CLP0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define ADC_RD_CLP0_CLP0(base) ((ADC_CLP0_REG(base) & ADC_CLP0_CLP0_MASK) >> ADC_CLP0_CLP0_SHIFT)
#define ADC_BRD_CLP0_CLP0(base) (ADC_RD_CLP0_CLP0(base))

/*! @brief Set the CLP0 field to a new value. */
#define ADC_WR_CLP0_CLP0(base, value) (ADC_RMW_CLP0(base, ADC_CLP0_CLP0_MASK, ADC_CLP0_CLP0(value)))
#define ADC_BWR_CLP0_CLP0(base, value) (ADC_WR_CLP0_CLP0(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLMD - ADC minus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLMD - ADC minus-side general calibration value register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * CLMx contain calibration information that is generated by the calibration
 * function. These registers contain seven calibration values of varying widths:
 * CLM0[5:0], CLM1[6:0], CLM2[7:0], CLM3[8:0], CLM4[9:0], CLMS[5:0], and CLMD[5:0].
 * CLMx are automatically set once the self calibration sequence is done (CAL is
 * cleared). If these registers are written by the user after calibration, the
 * linearity error specifications may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_CLMD register
 */
/*@{*/
#define ADC_RD_CLMD(base)        (ADC_CLMD_REG(base))
#define ADC_WR_CLMD(base, value) (ADC_CLMD_REG(base) = (value))
#define ADC_RMW_CLMD(base, mask, value) (ADC_WR_CLMD(base, (ADC_RD_CLMD(base) & ~(mask)) | (value)))
#define ADC_SET_CLMD(base, value) (ADC_WR_CLMD(base, ADC_RD_CLMD(base) |  (value)))
#define ADC_CLR_CLMD(base, value) (ADC_WR_CLMD(base, ADC_RD_CLMD(base) & ~(value)))
#define ADC_TOG_CLMD(base, value) (ADC_WR_CLMD(base, ADC_RD_CLMD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMD bitfields
 */

/*!
 * @name Register ADC_CLMD, field CLMD[5:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMD_CLMD field. */
#define ADC_RD_CLMD_CLMD(base) ((ADC_CLMD_REG(base) & ADC_CLMD_CLMD_MASK) >> ADC_CLMD_CLMD_SHIFT)
#define ADC_BRD_CLMD_CLMD(base) (ADC_RD_CLMD_CLMD(base))

/*! @brief Set the CLMD field to a new value. */
#define ADC_WR_CLMD_CLMD(base, value) (ADC_RMW_CLMD(base, ADC_CLMD_CLMD_MASK, ADC_CLMD_CLMD(value)))
#define ADC_BWR_CLMD_CLMD(base, value) (ADC_WR_CLMD_CLMD(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLMS - ADC minus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLMS - ADC minus-side general calibration value register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, refer to CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLMS register
 */
/*@{*/
#define ADC_RD_CLMS(base)        (ADC_CLMS_REG(base))
#define ADC_WR_CLMS(base, value) (ADC_CLMS_REG(base) = (value))
#define ADC_RMW_CLMS(base, mask, value) (ADC_WR_CLMS(base, (ADC_RD_CLMS(base) & ~(mask)) | (value)))
#define ADC_SET_CLMS(base, value) (ADC_WR_CLMS(base, ADC_RD_CLMS(base) |  (value)))
#define ADC_CLR_CLMS(base, value) (ADC_WR_CLMS(base, ADC_RD_CLMS(base) & ~(value)))
#define ADC_TOG_CLMS(base, value) (ADC_WR_CLMS(base, ADC_RD_CLMS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMS bitfields
 */

/*!
 * @name Register ADC_CLMS, field CLMS[5:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMS_CLMS field. */
#define ADC_RD_CLMS_CLMS(base) ((ADC_CLMS_REG(base) & ADC_CLMS_CLMS_MASK) >> ADC_CLMS_CLMS_SHIFT)
#define ADC_BRD_CLMS_CLMS(base) (ADC_RD_CLMS_CLMS(base))

/*! @brief Set the CLMS field to a new value. */
#define ADC_WR_CLMS_CLMS(base, value) (ADC_RMW_CLMS(base, ADC_CLMS_CLMS_MASK, ADC_CLMS_CLMS(value)))
#define ADC_BWR_CLMS_CLMS(base, value) (ADC_WR_CLMS_CLMS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM4 - ADC minus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLM4 - ADC minus-side general calibration value register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, refer to CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM4 register
 */
/*@{*/
#define ADC_RD_CLM4(base)        (ADC_CLM4_REG(base))
#define ADC_WR_CLM4(base, value) (ADC_CLM4_REG(base) = (value))
#define ADC_RMW_CLM4(base, mask, value) (ADC_WR_CLM4(base, (ADC_RD_CLM4(base) & ~(mask)) | (value)))
#define ADC_SET_CLM4(base, value) (ADC_WR_CLM4(base, ADC_RD_CLM4(base) |  (value)))
#define ADC_CLR_CLM4(base, value) (ADC_WR_CLM4(base, ADC_RD_CLM4(base) & ~(value)))
#define ADC_TOG_CLM4(base, value) (ADC_WR_CLM4(base, ADC_RD_CLM4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM4 bitfields
 */

/*!
 * @name Register ADC_CLM4, field CLM4[9:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM4_CLM4 field. */
#define ADC_RD_CLM4_CLM4(base) ((ADC_CLM4_REG(base) & ADC_CLM4_CLM4_MASK) >> ADC_CLM4_CLM4_SHIFT)
#define ADC_BRD_CLM4_CLM4(base) (ADC_RD_CLM4_CLM4(base))

/*! @brief Set the CLM4 field to a new value. */
#define ADC_WR_CLM4_CLM4(base, value) (ADC_RMW_CLM4(base, ADC_CLM4_CLM4_MASK, ADC_CLM4_CLM4(value)))
#define ADC_BWR_CLM4_CLM4(base, value) (ADC_WR_CLM4_CLM4(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM3 - ADC minus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLM3 - ADC minus-side general calibration value register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, refer to CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM3 register
 */
/*@{*/
#define ADC_RD_CLM3(base)        (ADC_CLM3_REG(base))
#define ADC_WR_CLM3(base, value) (ADC_CLM3_REG(base) = (value))
#define ADC_RMW_CLM3(base, mask, value) (ADC_WR_CLM3(base, (ADC_RD_CLM3(base) & ~(mask)) | (value)))
#define ADC_SET_CLM3(base, value) (ADC_WR_CLM3(base, ADC_RD_CLM3(base) |  (value)))
#define ADC_CLR_CLM3(base, value) (ADC_WR_CLM3(base, ADC_RD_CLM3(base) & ~(value)))
#define ADC_TOG_CLM3(base, value) (ADC_WR_CLM3(base, ADC_RD_CLM3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM3 bitfields
 */

/*!
 * @name Register ADC_CLM3, field CLM3[8:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM3_CLM3 field. */
#define ADC_RD_CLM3_CLM3(base) ((ADC_CLM3_REG(base) & ADC_CLM3_CLM3_MASK) >> ADC_CLM3_CLM3_SHIFT)
#define ADC_BRD_CLM3_CLM3(base) (ADC_RD_CLM3_CLM3(base))

/*! @brief Set the CLM3 field to a new value. */
#define ADC_WR_CLM3_CLM3(base, value) (ADC_RMW_CLM3(base, ADC_CLM3_CLM3_MASK, ADC_CLM3_CLM3(value)))
#define ADC_BWR_CLM3_CLM3(base, value) (ADC_WR_CLM3_CLM3(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM2 - ADC minus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLM2 - ADC minus-side general calibration value register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, refer to CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM2 register
 */
/*@{*/
#define ADC_RD_CLM2(base)        (ADC_CLM2_REG(base))
#define ADC_WR_CLM2(base, value) (ADC_CLM2_REG(base) = (value))
#define ADC_RMW_CLM2(base, mask, value) (ADC_WR_CLM2(base, (ADC_RD_CLM2(base) & ~(mask)) | (value)))
#define ADC_SET_CLM2(base, value) (ADC_WR_CLM2(base, ADC_RD_CLM2(base) |  (value)))
#define ADC_CLR_CLM2(base, value) (ADC_WR_CLM2(base, ADC_RD_CLM2(base) & ~(value)))
#define ADC_TOG_CLM2(base, value) (ADC_WR_CLM2(base, ADC_RD_CLM2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM2 bitfields
 */

/*!
 * @name Register ADC_CLM2, field CLM2[7:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM2_CLM2 field. */
#define ADC_RD_CLM2_CLM2(base) ((ADC_CLM2_REG(base) & ADC_CLM2_CLM2_MASK) >> ADC_CLM2_CLM2_SHIFT)
#define ADC_BRD_CLM2_CLM2(base) (ADC_RD_CLM2_CLM2(base))

/*! @brief Set the CLM2 field to a new value. */
#define ADC_WR_CLM2_CLM2(base, value) (ADC_RMW_CLM2(base, ADC_CLM2_CLM2_MASK, ADC_CLM2_CLM2(value)))
#define ADC_BWR_CLM2_CLM2(base, value) (ADC_WR_CLM2_CLM2(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM1 - ADC minus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLM1 - ADC minus-side general calibration value register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, refer to CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM1 register
 */
/*@{*/
#define ADC_RD_CLM1(base)        (ADC_CLM1_REG(base))
#define ADC_WR_CLM1(base, value) (ADC_CLM1_REG(base) = (value))
#define ADC_RMW_CLM1(base, mask, value) (ADC_WR_CLM1(base, (ADC_RD_CLM1(base) & ~(mask)) | (value)))
#define ADC_SET_CLM1(base, value) (ADC_WR_CLM1(base, ADC_RD_CLM1(base) |  (value)))
#define ADC_CLR_CLM1(base, value) (ADC_WR_CLM1(base, ADC_RD_CLM1(base) & ~(value)))
#define ADC_TOG_CLM1(base, value) (ADC_WR_CLM1(base, ADC_RD_CLM1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM1 bitfields
 */

/*!
 * @name Register ADC_CLM1, field CLM1[6:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM1_CLM1 field. */
#define ADC_RD_CLM1_CLM1(base) ((ADC_CLM1_REG(base) & ADC_CLM1_CLM1_MASK) >> ADC_CLM1_CLM1_SHIFT)
#define ADC_BRD_CLM1_CLM1(base) (ADC_RD_CLM1_CLM1(base))

/*! @brief Set the CLM1 field to a new value. */
#define ADC_WR_CLM1_CLM1(base, value) (ADC_RMW_CLM1(base, ADC_CLM1_CLM1_MASK, ADC_CLM1_CLM1(value)))
#define ADC_BWR_CLM1_CLM1(base, value) (ADC_WR_CLM1_CLM1(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM0 - ADC minus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief ADC_CLM0 - ADC minus-side general calibration value register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, refer to CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM0 register
 */
/*@{*/
#define ADC_RD_CLM0(base)        (ADC_CLM0_REG(base))
#define ADC_WR_CLM0(base, value) (ADC_CLM0_REG(base) = (value))
#define ADC_RMW_CLM0(base, mask, value) (ADC_WR_CLM0(base, (ADC_RD_CLM0(base) & ~(mask)) | (value)))
#define ADC_SET_CLM0(base, value) (ADC_WR_CLM0(base, ADC_RD_CLM0(base) |  (value)))
#define ADC_CLR_CLM0(base, value) (ADC_WR_CLM0(base, ADC_RD_CLM0(base) & ~(value)))
#define ADC_TOG_CLM0(base, value) (ADC_WR_CLM0(base, ADC_RD_CLM0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM0 bitfields
 */

/*!
 * @name Register ADC_CLM0, field CLM0[5:0] (RW)
 *
 * Calibration value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM0_CLM0 field. */
#define ADC_RD_CLM0_CLM0(base) ((ADC_CLM0_REG(base) & ADC_CLM0_CLM0_MASK) >> ADC_CLM0_CLM0_SHIFT)
#define ADC_BRD_CLM0_CLM0(base) (ADC_RD_CLM0_CLM0(base))

/*! @brief Set the CLM0 field to a new value. */
#define ADC_WR_CLM0_CLM0(base, value) (ADC_RMW_CLM0(base, ADC_CLM0_CLM0_MASK, ADC_CLM0_CLM0(value)))
#define ADC_BWR_CLM0_CLM0(base, value) (ADC_WR_CLM0_CLM0(base, value))
/*@}*/

/*
 * MK20D5 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - CMP_CR0 - CMP Control Register 0
 * - CMP_CR1 - CMP Control Register 1
 * - CMP_FPR - CMP Filter Period Register
 * - CMP_SCR - CMP Status and Control Register
 * - CMP_DACCR - DAC Control Register
 * - CMP_MUXCR - MUX Control Register
 */

#define CMP_INSTANCE_COUNT (2U) /*!< Number of instances of the CMP module. */
#define CMP0_IDX (0U) /*!< Instance number for CMP0. */
#define CMP1_IDX (1U) /*!< Instance number for CMP1. */

/*******************************************************************************
 * CMP_CR0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief CMP_CR0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR0 register
 */
/*@{*/
#define CMP_RD_CR0(base)         (CMP_CR0_REG(base))
#define CMP_WR_CR0(base, value)  (CMP_CR0_REG(base) = (value))
#define CMP_RMW_CR0(base, mask, value) (CMP_WR_CR0(base, (CMP_RD_CR0(base) & ~(mask)) | (value)))
#define CMP_SET_CR0(base, value) (CMP_WR_CR0(base, CMP_RD_CR0(base) |  (value)))
#define CMP_CLR_CR0(base, value) (CMP_WR_CR0(base, CMP_RD_CR0(base) & ~(value)))
#define CMP_TOG_CR0(base, value) (CMP_WR_CR0(base, CMP_RD_CR0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR0 bitfields
 */

/*!
 * @name Register CMP_CR0, field HYSTCTR[1:0] (RW)
 *
 * Defines the programmable hysteresis level. The hysteresis values associated
 * with each level is device-specific. See the device's data sheet for the exact
 * values.
 *
 * Values:
 * - 00 - Level 0
 * - 01 - Level 1
 * - 10 - Level 2
 * - 11 - Level 3
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_HYSTCTR field. */
#define CMP_RD_CR0_HYSTCTR(base) ((CMP_CR0_REG(base) & CMP_CR0_HYSTCTR_MASK) >> CMP_CR0_HYSTCTR_SHIFT)
#define CMP_BRD_CR0_HYSTCTR(base) (CMP_RD_CR0_HYSTCTR(base))

/*! @brief Set the HYSTCTR field to a new value. */
#define CMP_WR_CR0_HYSTCTR(base, value) (CMP_RMW_CR0(base, CMP_CR0_HYSTCTR_MASK, CMP_CR0_HYSTCTR(value)))
#define CMP_BWR_CR0_HYSTCTR(base, value) (CMP_WR_CR0_HYSTCTR(base, value))
/*@}*/

/*!
 * @name Register CMP_CR0, field FILTER_CNT[6:4] (RW)
 *
 * These bits represent the number of consecutive samples that must agree prior
 * to the comparator ouput filter accepting a new output state. For information
 * regarding filter programming and latency reference the Functional Description.
 *
 * Values:
 * - 000 - Filter is disabled. If SE = 1, then COUT is a logic zero (this is not
 *     a legal state, and is not recommended). If SE = 0, COUT = COUTA.
 * - 001 - 1 consecutive sample must agree (comparator output is simply sampled).
 * - 010 - 2 consecutive samples must agree.
 * - 011 - 3 consecutive samples must agree.
 * - 100 - 4 consecutive samples must agree.
 * - 101 - 5 consecutive samples must agree.
 * - 110 - 6 consecutive samples must agree.
 * - 111 - 7 consecutive samples must agree.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_FILTER_CNT field. */
#define CMP_RD_CR0_FILTER_CNT(base) ((CMP_CR0_REG(base) & CMP_CR0_FILTER_CNT_MASK) >> CMP_CR0_FILTER_CNT_SHIFT)
#define CMP_BRD_CR0_FILTER_CNT(base) (CMP_RD_CR0_FILTER_CNT(base))

/*! @brief Set the FILTER_CNT field to a new value. */
#define CMP_WR_CR0_FILTER_CNT(base, value) (CMP_RMW_CR0(base, CMP_CR0_FILTER_CNT_MASK, CMP_CR0_FILTER_CNT(value)))
#define CMP_BWR_CR0_FILTER_CNT(base, value) (CMP_WR_CR0_FILTER_CNT(base, value))
/*@}*/

/*******************************************************************************
 * CMP_CR1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief CMP_CR1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR1 register
 */
/*@{*/
#define CMP_RD_CR1(base)         (CMP_CR1_REG(base))
#define CMP_WR_CR1(base, value)  (CMP_CR1_REG(base) = (value))
#define CMP_RMW_CR1(base, mask, value) (CMP_WR_CR1(base, (CMP_RD_CR1(base) & ~(mask)) | (value)))
#define CMP_SET_CR1(base, value) (CMP_WR_CR1(base, CMP_RD_CR1(base) |  (value)))
#define CMP_CLR_CR1(base, value) (CMP_WR_CR1(base, CMP_RD_CR1(base) & ~(value)))
#define CMP_TOG_CR1(base, value) (CMP_WR_CR1(base, CMP_RD_CR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR1 bitfields
 */

/*!
 * @name Register CMP_CR1, field EN[0] (RW)
 *
 * The EN bit enables the Analog Comparator Module. When the module is not
 * enabled, it remains in the off state, and consumes no power. When you select the
 * same input from analog mux to the positive and negative port, the comparator is
 * disabled automatically.
 *
 * Values:
 * - 0 - Analog Comparator disabled.
 * - 1 - Analog Comparator enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_EN field. */
#define CMP_RD_CR1_EN(base)  ((CMP_CR1_REG(base) & CMP_CR1_EN_MASK) >> CMP_CR1_EN_SHIFT)
#define CMP_BRD_CR1_EN(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_EN_SHIFT))

/*! @brief Set the EN field to a new value. */
#define CMP_WR_CR1_EN(base, value) (CMP_RMW_CR1(base, CMP_CR1_EN_MASK, CMP_CR1_EN(value)))
#define CMP_BWR_CR1_EN(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field OPE[1] (RW)
 *
 * Values:
 * - 0 - The comparator output (CMPO) is not available on the associated CMPO
 *     output pin.
 * - 1 - The comparator output (CMPO) is available on the associated CMPO output
 *     pin.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_OPE field. */
#define CMP_RD_CR1_OPE(base) ((CMP_CR1_REG(base) & CMP_CR1_OPE_MASK) >> CMP_CR1_OPE_SHIFT)
#define CMP_BRD_CR1_OPE(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_OPE_SHIFT))

/*! @brief Set the OPE field to a new value. */
#define CMP_WR_CR1_OPE(base, value) (CMP_RMW_CR1(base, CMP_CR1_OPE_MASK, CMP_CR1_OPE(value)))
#define CMP_BWR_CR1_OPE(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_OPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field COS[2] (RW)
 *
 * Values:
 * - 0 - Set CMPO to equal COUT (filtered comparator output).
 * - 1 - Set CMPO to equal COUTA (unfiltered comparator output).
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_COS field. */
#define CMP_RD_CR1_COS(base) ((CMP_CR1_REG(base) & CMP_CR1_COS_MASK) >> CMP_CR1_COS_SHIFT)
#define CMP_BRD_CR1_COS(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_COS_SHIFT))

/*! @brief Set the COS field to a new value. */
#define CMP_WR_CR1_COS(base, value) (CMP_RMW_CR1(base, CMP_CR1_COS_MASK, CMP_CR1_COS(value)))
#define CMP_BWR_CR1_COS(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_COS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field INV[3] (RW)
 *
 * This bit allows you to select the polarity of the analog comparator function.
 * It is also driven to the COUT output (on both the device pin and as
 * SCR[COUT]) when CR1[OPE]=0.
 *
 * Values:
 * - 0 - Does not invert the comparator output.
 * - 1 - Inverts the comparator output.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_INV field. */
#define CMP_RD_CR1_INV(base) ((CMP_CR1_REG(base) & CMP_CR1_INV_MASK) >> CMP_CR1_INV_SHIFT)
#define CMP_BRD_CR1_INV(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_INV_SHIFT))

/*! @brief Set the INV field to a new value. */
#define CMP_WR_CR1_INV(base, value) (CMP_RMW_CR1(base, CMP_CR1_INV_MASK, CMP_CR1_INV(value)))
#define CMP_BWR_CR1_INV(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_INV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field PMODE[4] (RW)
 *
 * Refer to the device data sheet's CMP electrical specifications table for
 * details on the impact of the modes below.
 *
 * Values:
 * - 0 - Low Speed (LS) comparison mode selected. In this mode, CMP has slower
 *     output propagation delay and lower current consumption.
 * - 1 - High Speed (HS) comparison mode selected. In this mode, CMP has faster
 *     output propagation delay and higher current consumption.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_PMODE field. */
#define CMP_RD_CR1_PMODE(base) ((CMP_CR1_REG(base) & CMP_CR1_PMODE_MASK) >> CMP_CR1_PMODE_SHIFT)
#define CMP_BRD_CR1_PMODE(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_PMODE_SHIFT))

/*! @brief Set the PMODE field to a new value. */
#define CMP_WR_CR1_PMODE(base, value) (CMP_RMW_CR1(base, CMP_CR1_PMODE_MASK, CMP_CR1_PMODE(value)))
#define CMP_BWR_CR1_PMODE(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_PMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field WE[6] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * ones to both bit locations because this "11" case is reserved and may change in
 * future implementations.
 *
 * Values:
 * - 0 - Windowing mode not selected.
 * - 1 - Windowing mode selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_WE field. */
#define CMP_RD_CR1_WE(base)  ((CMP_CR1_REG(base) & CMP_CR1_WE_MASK) >> CMP_CR1_WE_SHIFT)
#define CMP_BRD_CR1_WE(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_WE_SHIFT))

/*! @brief Set the WE field to a new value. */
#define CMP_WR_CR1_WE(base, value) (CMP_RMW_CR1(base, CMP_CR1_WE_MASK, CMP_CR1_WE(value)))
#define CMP_BWR_CR1_WE(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field SE[7] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * ones to both bit locations because this "11" case is reserved and may change in
 * future implementations.
 *
 * Values:
 * - 0 - Sampling mode not selected.
 * - 1 - Sampling mode selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_SE field. */
#define CMP_RD_CR1_SE(base)  ((CMP_CR1_REG(base) & CMP_CR1_SE_MASK) >> CMP_CR1_SE_SHIFT)
#define CMP_BRD_CR1_SE(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_SE_SHIFT))

/*! @brief Set the SE field to a new value. */
#define CMP_WR_CR1_SE(base, value) (CMP_RMW_CR1(base, CMP_CR1_SE_MASK, CMP_CR1_SE(value)))
#define CMP_BWR_CR1_SE(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_SE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CMP_FPR - CMP Filter Period Register
 ******************************************************************************/

/*!
 * @brief CMP_FPR - CMP Filter Period Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_FPR register
 */
/*@{*/
#define CMP_RD_FPR(base)         (CMP_FPR_REG(base))
#define CMP_WR_FPR(base, value)  (CMP_FPR_REG(base) = (value))
#define CMP_RMW_FPR(base, mask, value) (CMP_WR_FPR(base, (CMP_RD_FPR(base) & ~(mask)) | (value)))
#define CMP_SET_FPR(base, value) (CMP_WR_FPR(base, CMP_RD_FPR(base) |  (value)))
#define CMP_CLR_FPR(base, value) (CMP_WR_FPR(base, CMP_RD_FPR(base) & ~(value)))
#define CMP_TOG_FPR(base, value) (CMP_WR_FPR(base, CMP_RD_FPR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMP_SCR - CMP Status and Control Register
 ******************************************************************************/

/*!
 * @brief CMP_SCR - CMP Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_SCR register
 */
/*@{*/
#define CMP_RD_SCR(base)         (CMP_SCR_REG(base))
#define CMP_WR_SCR(base, value)  (CMP_SCR_REG(base) = (value))
#define CMP_RMW_SCR(base, mask, value) (CMP_WR_SCR(base, (CMP_RD_SCR(base) & ~(mask)) | (value)))
#define CMP_SET_SCR(base, value) (CMP_WR_SCR(base, CMP_RD_SCR(base) |  (value)))
#define CMP_CLR_SCR(base, value) (CMP_WR_SCR(base, CMP_RD_SCR(base) & ~(value)))
#define CMP_TOG_SCR(base, value) (CMP_WR_SCR(base, CMP_RD_SCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_SCR bitfields
 */

/*!
 * @name Register CMP_SCR, field COUT[0] (RO)
 *
 * Reading the COUT bit will return the current value of the analog comparator
 * output. The register bit is reset to zero and will read as CR1[INV] when the
 * Analog Comparator module is disabled (CR1[EN] = 0). Writes to this bit are
 * ignored.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_COUT field. */
#define CMP_RD_SCR_COUT(base) ((CMP_SCR_REG(base) & CMP_SCR_COUT_MASK) >> CMP_SCR_COUT_SHIFT)
#define CMP_BRD_SCR_COUT(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_COUT_SHIFT))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFF[1] (W1C)
 *
 * During normal operation, the CFF bit is set when a falling edge on COUT has
 * been detected. The CFF bit is cleared by writing a logic one to the bit. During
 * Stop modes, CFF is level senstive.
 *
 * Values:
 * - 0 - Falling edge on COUT has not been detected.
 * - 1 - Falling edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFF field. */
#define CMP_RD_SCR_CFF(base) ((CMP_SCR_REG(base) & CMP_SCR_CFF_MASK) >> CMP_SCR_CFF_SHIFT)
#define CMP_BRD_SCR_CFF(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_CFF_SHIFT))

/*! @brief Set the CFF field to a new value. */
#define CMP_WR_SCR_CFF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_CFF(value)))
#define CMP_BWR_SCR_CFF(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_CFF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFR[2] (W1C)
 *
 * During normal operation, the CFR bit is set when a rising edge on COUT has
 * been detected. The CFR bit is cleared by writing a logic one to the bit. During
 * Stop modes, CFR is level sensitive.
 *
 * Values:
 * - 0 - Rising edge on COUT has not been detected.
 * - 1 - Rising edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFR field. */
#define CMP_RD_SCR_CFR(base) ((CMP_SCR_REG(base) & CMP_SCR_CFR_MASK) >> CMP_SCR_CFR_SHIFT)
#define CMP_BRD_SCR_CFR(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_CFR_SHIFT))

/*! @brief Set the CFR field to a new value. */
#define CMP_WR_SCR_CFR(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFR_MASK | CMP_SCR_CFF_MASK), CMP_SCR_CFR(value)))
#define CMP_BWR_SCR_CFR(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_CFR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_SCR, field IEF[3] (RW)
 *
 * The IEF bit enables the CFF interrupt from the CMP. When this bit is set, an
 * interrupt will be asserted when the CFF bit is set.
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IEF field. */
#define CMP_RD_SCR_IEF(base) ((CMP_SCR_REG(base) & CMP_SCR_IEF_MASK) >> CMP_SCR_IEF_SHIFT)
#define CMP_BRD_SCR_IEF(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_IEF_SHIFT))

/*! @brief Set the IEF field to a new value. */
#define CMP_WR_SCR_IEF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IEF_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IEF(value)))
#define CMP_BWR_SCR_IEF(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_IEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_SCR, field IER[4] (RW)
 *
 * The IER bit enables the CFR interrupt from the CMP. When this bit is set, an
 * interrupt will be asserted when the CFR bit is set.
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IER field. */
#define CMP_RD_SCR_IER(base) ((CMP_SCR_REG(base) & CMP_SCR_IER_MASK) >> CMP_SCR_IER_SHIFT)
#define CMP_BRD_SCR_IER(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_IER_SHIFT))

/*! @brief Set the IER field to a new value. */
#define CMP_WR_SCR_IER(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IER_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IER(value)))
#define CMP_BWR_SCR_IER(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_IER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_SCR, field DMAEN[6] (RW)
 *
 * The DMAEN bit enables the DMA transfer triggered from the CMP module. When
 * this bit is set, a DMA request is asserted when the CFR or CFF bit is set.
 *
 * Values:
 * - 0 - DMA disabled.
 * - 1 - DMA enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_DMAEN field. */
#define CMP_RD_SCR_DMAEN(base) ((CMP_SCR_REG(base) & CMP_SCR_DMAEN_MASK) >> CMP_SCR_DMAEN_SHIFT)
#define CMP_BRD_SCR_DMAEN(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define CMP_WR_SCR_DMAEN(base, value) (CMP_RMW_SCR(base, (CMP_SCR_DMAEN_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_DMAEN(value)))
#define CMP_BWR_SCR_DMAEN(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_DMAEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CMP_DACCR - DAC Control Register
 ******************************************************************************/

/*!
 * @brief CMP_DACCR - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_DACCR register
 */
/*@{*/
#define CMP_RD_DACCR(base)       (CMP_DACCR_REG(base))
#define CMP_WR_DACCR(base, value) (CMP_DACCR_REG(base) = (value))
#define CMP_RMW_DACCR(base, mask, value) (CMP_WR_DACCR(base, (CMP_RD_DACCR(base) & ~(mask)) | (value)))
#define CMP_SET_DACCR(base, value) (CMP_WR_DACCR(base, CMP_RD_DACCR(base) |  (value)))
#define CMP_CLR_DACCR(base, value) (CMP_WR_DACCR(base, CMP_RD_DACCR(base) & ~(value)))
#define CMP_TOG_DACCR(base, value) (CMP_WR_DACCR(base, CMP_RD_DACCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_DACCR bitfields
 */

/*!
 * @name Register CMP_DACCR, field VOSEL[5:0] (RW)
 *
 * This bit selects an output voltage from one of 64 distinct levels. DACO =
 * (Vin/64) * (VOSEL[5:0] + 1), so the DACO range is from Vin/64 to Vin.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VOSEL field. */
#define CMP_RD_DACCR_VOSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VOSEL_MASK) >> CMP_DACCR_VOSEL_SHIFT)
#define CMP_BRD_DACCR_VOSEL(base) (CMP_RD_DACCR_VOSEL(base))

/*! @brief Set the VOSEL field to a new value. */
#define CMP_WR_DACCR_VOSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VOSEL_MASK, CMP_DACCR_VOSEL(value)))
#define CMP_BWR_DACCR_VOSEL(base, value) (CMP_WR_DACCR_VOSEL(base, value))
/*@}*/

/*!
 * @name Register CMP_DACCR, field VRSEL[6] (RW)
 *
 * Values:
 * - 0 - Vin1 is selected as resistor ladder network supply reference Vin.
 * - 1 - Vin2 is selected as resistor ladder network supply reference Vin.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VRSEL field. */
#define CMP_RD_DACCR_VRSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VRSEL_MASK) >> CMP_DACCR_VRSEL_SHIFT)
#define CMP_BRD_DACCR_VRSEL(base) (BITBAND_ACCESS8(&CMP_DACCR_REG(base), CMP_DACCR_VRSEL_SHIFT))

/*! @brief Set the VRSEL field to a new value. */
#define CMP_WR_DACCR_VRSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VRSEL_MASK, CMP_DACCR_VRSEL(value)))
#define CMP_BWR_DACCR_VRSEL(base, value) (BITBAND_ACCESS8(&CMP_DACCR_REG(base), CMP_DACCR_VRSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_DACCR, field DACEN[7] (RW)
 *
 * This bit is used to enable the DAC. When the DAC is disabled, it is powered
 * down to conserve power.
 *
 * Values:
 * - 0 - DAC is disabled.
 * - 1 - DAC is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_DACEN field. */
#define CMP_RD_DACCR_DACEN(base) ((CMP_DACCR_REG(base) & CMP_DACCR_DACEN_MASK) >> CMP_DACCR_DACEN_SHIFT)
#define CMP_BRD_DACCR_DACEN(base) (BITBAND_ACCESS8(&CMP_DACCR_REG(base), CMP_DACCR_DACEN_SHIFT))

/*! @brief Set the DACEN field to a new value. */
#define CMP_WR_DACCR_DACEN(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_DACEN_MASK, CMP_DACCR_DACEN(value)))
#define CMP_BWR_DACCR_DACEN(base, value) (BITBAND_ACCESS8(&CMP_DACCR_REG(base), CMP_DACCR_DACEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CMP_MUXCR - MUX Control Register
 ******************************************************************************/

/*!
 * @brief CMP_MUXCR - MUX Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_MUXCR register
 */
/*@{*/
#define CMP_RD_MUXCR(base)       (CMP_MUXCR_REG(base))
#define CMP_WR_MUXCR(base, value) (CMP_MUXCR_REG(base) = (value))
#define CMP_RMW_MUXCR(base, mask, value) (CMP_WR_MUXCR(base, (CMP_RD_MUXCR(base) & ~(mask)) | (value)))
#define CMP_SET_MUXCR(base, value) (CMP_WR_MUXCR(base, CMP_RD_MUXCR(base) |  (value)))
#define CMP_CLR_MUXCR(base, value) (CMP_WR_MUXCR(base, CMP_RD_MUXCR(base) & ~(value)))
#define CMP_TOG_MUXCR(base, value) (CMP_WR_MUXCR(base, CMP_RD_MUXCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_MUXCR bitfields
 */

/*!
 * @name Register CMP_MUXCR, field MSEL[2:0] (RW)
 *
 * Determines which input is selected for the minus input of the comparator. For
 * INx inputs, refer to CMP, DAC and ANMUX Blocks Diagram. When an inappropriate
 * operation selects the same input for both MUXes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_MSEL field. */
#define CMP_RD_MUXCR_MSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_MSEL_MASK) >> CMP_MUXCR_MSEL_SHIFT)
#define CMP_BRD_MUXCR_MSEL(base) (CMP_RD_MUXCR_MSEL(base))

/*! @brief Set the MSEL field to a new value. */
#define CMP_WR_MUXCR_MSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_MSEL_MASK, CMP_MUXCR_MSEL(value)))
#define CMP_BWR_MUXCR_MSEL(base, value) (CMP_WR_MUXCR_MSEL(base, value))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSEL[5:3] (RW)
 *
 * Determines which input is selected for the plus input of the comparator. For
 * INx inputs, refer to CMP, DAC and ANMUX Blocks Diagram. When an inappropriate
 * operation selects the same input for both MUXes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_PSEL field. */
#define CMP_RD_MUXCR_PSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_PSEL_MASK) >> CMP_MUXCR_PSEL_SHIFT)
#define CMP_BRD_MUXCR_PSEL(base) (CMP_RD_MUXCR_PSEL(base))

/*! @brief Set the PSEL field to a new value. */
#define CMP_WR_MUXCR_PSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_PSEL_MASK, CMP_MUXCR_PSEL(value)))
#define CMP_BWR_MUXCR_PSEL(base, value) (CMP_WR_MUXCR_PSEL(base, value))
/*@}*/

/*
 * MK20D5 CMT
 *
 * Carrier Modulator Transmitter
 *
 * Registers defined in this header file:
 * - CMT_CGH1 - CMT Carrier Generator High Data Register 1
 * - CMT_CGL1 - CMT Carrier Generator Low Data Register 1
 * - CMT_CGH2 - CMT Carrier Generator High Data Register 2
 * - CMT_CGL2 - CMT Carrier Generator Low Data Register 2
 * - CMT_OC - CMT Output Control Register
 * - CMT_MSC - CMT Modulator Status and Control Register
 * - CMT_CMD1 - CMT Modulator Data Register Mark High
 * - CMT_CMD2 - CMT Modulator Data Register Mark Low
 * - CMT_CMD3 - CMT Modulator Data Register Space High
 * - CMT_CMD4 - CMT Modulator Data Register Space Low
 * - CMT_PPS - CMT Primary Prescaler Register
 * - CMT_DMA - CMT Direct Memory Access
 */

#define CMT_INSTANCE_COUNT (1U) /*!< Number of instances of the CMT module. */
#define CMT_IDX (0U) /*!< Instance number for CMT. */

/*******************************************************************************
 * CMT_CGH1 - CMT Carrier Generator High Data Register 1
 ******************************************************************************/

/*!
 * @brief CMT_CGH1 - CMT Carrier Generator High Data Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contain the primary high value for generating the carrier
 * output.
 */
/*!
 * @name Constants and macros for entire CMT_CGH1 register
 */
/*@{*/
#define CMT_RD_CGH1(base)        (CMT_CGH1_REG(base))
#define CMT_WR_CGH1(base, value) (CMT_CGH1_REG(base) = (value))
#define CMT_RMW_CGH1(base, mask, value) (CMT_WR_CGH1(base, (CMT_RD_CGH1(base) & ~(mask)) | (value)))
#define CMT_SET_CGH1(base, value) (CMT_WR_CGH1(base, CMT_RD_CGH1(base) |  (value)))
#define CMT_CLR_CGH1(base, value) (CMT_WR_CGH1(base, CMT_RD_CGH1(base) & ~(value)))
#define CMT_TOG_CGH1(base, value) (CMT_WR_CGH1(base, CMT_RD_CGH1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMT_CGL1 - CMT Carrier Generator Low Data Register 1
 ******************************************************************************/

/*!
 * @brief CMT_CGL1 - CMT Carrier Generator Low Data Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contain the primary low value for generating the carrier
 * output.
 */
/*!
 * @name Constants and macros for entire CMT_CGL1 register
 */
/*@{*/
#define CMT_RD_CGL1(base)        (CMT_CGL1_REG(base))
#define CMT_WR_CGL1(base, value) (CMT_CGL1_REG(base) = (value))
#define CMT_RMW_CGL1(base, mask, value) (CMT_WR_CGL1(base, (CMT_RD_CGL1(base) & ~(mask)) | (value)))
#define CMT_SET_CGL1(base, value) (CMT_WR_CGL1(base, CMT_RD_CGL1(base) |  (value)))
#define CMT_CLR_CGL1(base, value) (CMT_WR_CGL1(base, CMT_RD_CGL1(base) & ~(value)))
#define CMT_TOG_CGL1(base, value) (CMT_WR_CGL1(base, CMT_RD_CGL1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMT_CGH2 - CMT Carrier Generator High Data Register 2
 ******************************************************************************/

/*!
 * @brief CMT_CGH2 - CMT Carrier Generator High Data Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contain the secondary high value for generating the
 * carrier output.
 */
/*!
 * @name Constants and macros for entire CMT_CGH2 register
 */
/*@{*/
#define CMT_RD_CGH2(base)        (CMT_CGH2_REG(base))
#define CMT_WR_CGH2(base, value) (CMT_CGH2_REG(base) = (value))
#define CMT_RMW_CGH2(base, mask, value) (CMT_WR_CGH2(base, (CMT_RD_CGH2(base) & ~(mask)) | (value)))
#define CMT_SET_CGH2(base, value) (CMT_WR_CGH2(base, CMT_RD_CGH2(base) |  (value)))
#define CMT_CLR_CGH2(base, value) (CMT_WR_CGH2(base, CMT_RD_CGH2(base) & ~(value)))
#define CMT_TOG_CGH2(base, value) (CMT_WR_CGH2(base, CMT_RD_CGH2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMT_CGL2 - CMT Carrier Generator Low Data Register 2
 ******************************************************************************/

/*!
 * @brief CMT_CGL2 - CMT Carrier Generator Low Data Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contain the secondary low value for generating the carrier
 * output.
 */
/*!
 * @name Constants and macros for entire CMT_CGL2 register
 */
/*@{*/
#define CMT_RD_CGL2(base)        (CMT_CGL2_REG(base))
#define CMT_WR_CGL2(base, value) (CMT_CGL2_REG(base) = (value))
#define CMT_RMW_CGL2(base, mask, value) (CMT_WR_CGL2(base, (CMT_RD_CGL2(base) & ~(mask)) | (value)))
#define CMT_SET_CGL2(base, value) (CMT_WR_CGL2(base, CMT_RD_CGL2(base) |  (value)))
#define CMT_CLR_CGL2(base, value) (CMT_WR_CGL2(base, CMT_RD_CGL2(base) & ~(value)))
#define CMT_TOG_CGL2(base, value) (CMT_WR_CGL2(base, CMT_RD_CGL2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMT_OC - CMT Output Control Register
 ******************************************************************************/

/*!
 * @brief CMT_OC - CMT Output Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is used to control the IRO signal of the CMT module.
 */
/*!
 * @name Constants and macros for entire CMT_OC register
 */
/*@{*/
#define CMT_RD_OC(base)          (CMT_OC_REG(base))
#define CMT_WR_OC(base, value)   (CMT_OC_REG(base) = (value))
#define CMT_RMW_OC(base, mask, value) (CMT_WR_OC(base, (CMT_RD_OC(base) & ~(mask)) | (value)))
#define CMT_SET_OC(base, value)  (CMT_WR_OC(base, CMT_RD_OC(base) |  (value)))
#define CMT_CLR_OC(base, value)  (CMT_WR_OC(base, CMT_RD_OC(base) & ~(value)))
#define CMT_TOG_OC(base, value)  (CMT_WR_OC(base, CMT_RD_OC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMT_OC bitfields
 */

/*!
 * @name Register CMT_OC, field IROPEN[5] (RW)
 *
 * The IROPEN bit is used to enable and disable the CMT_IRO signal. When CMT_IRO
 * signal is enabled, it is an output that drives out either the CMT transmitter
 * output or the state of the IROL bit depending on whether MSC[MCGEN] bit is
 * set or not. Also, the state of the output is either inverted or not depending on
 * the state of the CMTPOL bit. When CMT_IRO signal is disabled, it is in a high
 * impedance state so as not to draw any current. This signal is disabled during
 * reset.
 *
 * Values:
 * - 0 - CMT_IRO signal disabled
 * - 1 - CMT_IRO signal enabled as output
 */
/*@{*/
/*! @brief Read current value of the CMT_OC_IROPEN field. */
#define CMT_RD_OC_IROPEN(base) ((CMT_OC_REG(base) & CMT_OC_IROPEN_MASK) >> CMT_OC_IROPEN_SHIFT)
#define CMT_BRD_OC_IROPEN(base) (BITBAND_ACCESS8(&CMT_OC_REG(base), CMT_OC_IROPEN_SHIFT))

/*! @brief Set the IROPEN field to a new value. */
#define CMT_WR_OC_IROPEN(base, value) (CMT_RMW_OC(base, CMT_OC_IROPEN_MASK, CMT_OC_IROPEN(value)))
#define CMT_BWR_OC_IROPEN(base, value) (BITBAND_ACCESS8(&CMT_OC_REG(base), CMT_OC_IROPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMT_OC, field CMTPOL[6] (RW)
 *
 * The CMTPOL bit controls the polarity of the CMT_IRO signal of the CMT.
 *
 * Values:
 * - 0 - CMT_IRO signal is active low
 * - 1 - CMT_IRO signal is active high
 */
/*@{*/
/*! @brief Read current value of the CMT_OC_CMTPOL field. */
#define CMT_RD_OC_CMTPOL(base) ((CMT_OC_REG(base) & CMT_OC_CMTPOL_MASK) >> CMT_OC_CMTPOL_SHIFT)
#define CMT_BRD_OC_CMTPOL(base) (BITBAND_ACCESS8(&CMT_OC_REG(base), CMT_OC_CMTPOL_SHIFT))

/*! @brief Set the CMTPOL field to a new value. */
#define CMT_WR_OC_CMTPOL(base, value) (CMT_RMW_OC(base, CMT_OC_CMTPOL_MASK, CMT_OC_CMTPOL(value)))
#define CMT_BWR_OC_CMTPOL(base, value) (BITBAND_ACCESS8(&CMT_OC_REG(base), CMT_OC_CMTPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMT_OC, field IROL[7] (RW)
 *
 * Reading IROL reads the state of the IRO latch. Writing to IROL changes the
 * state of the CMT_IRO signal when MSC[MCGEN] bit is cleared and the IROPEN bit is
 * set.
 */
/*@{*/
/*! @brief Read current value of the CMT_OC_IROL field. */
#define CMT_RD_OC_IROL(base) ((CMT_OC_REG(base) & CMT_OC_IROL_MASK) >> CMT_OC_IROL_SHIFT)
#define CMT_BRD_OC_IROL(base) (BITBAND_ACCESS8(&CMT_OC_REG(base), CMT_OC_IROL_SHIFT))

/*! @brief Set the IROL field to a new value. */
#define CMT_WR_OC_IROL(base, value) (CMT_RMW_OC(base, CMT_OC_IROL_MASK, CMT_OC_IROL(value)))
#define CMT_BWR_OC_IROL(base, value) (BITBAND_ACCESS8(&CMT_OC_REG(base), CMT_OC_IROL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CMT_MSC - CMT Modulator Status and Control Register
 ******************************************************************************/

/*!
 * @brief CMT_MSC - CMT Modulator Status and Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The MSC register contains the modulator and carrier generator enable (MCGEN),
 * end of cycle interrupt enable (EOCIE), FSK mode select (FSK), baseband enable
 * (BASE), extended space (EXSPC), prescaler (CMTDIV) bits, and the end of cycle
 * (EOCF) status bit.
 */
/*!
 * @name Constants and macros for entire CMT_MSC register
 */
/*@{*/
#define CMT_RD_MSC(base)         (CMT_MSC_REG(base))
#define CMT_WR_MSC(base, value)  (CMT_MSC_REG(base) = (value))
#define CMT_RMW_MSC(base, mask, value) (CMT_WR_MSC(base, (CMT_RD_MSC(base) & ~(mask)) | (value)))
#define CMT_SET_MSC(base, value) (CMT_WR_MSC(base, CMT_RD_MSC(base) |  (value)))
#define CMT_CLR_MSC(base, value) (CMT_WR_MSC(base, CMT_RD_MSC(base) & ~(value)))
#define CMT_TOG_MSC(base, value) (CMT_WR_MSC(base, CMT_RD_MSC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMT_MSC bitfields
 */

/*!
 * @name Register CMT_MSC, field MCGEN[0] (RW)
 *
 * Setting MCGEN will initialize the carrier generator and modulator and will
 * enable all clocks. Once enabled, the carrier generator and modulator will
 * function continuously. When MCGEN is cleared, the current modulator cycle will be
 * allowed to expire before all carrier and modulator clocks are disabled (to save
 * power) and the modulator output is forced low. To prevent spurious operation,
 * the user should initialize all data and control registers before enabling the
 * system.
 *
 * Values:
 * - 0 - Modulator and carrier generator disabled
 * - 1 - Modulator and carrier generator enabled
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_MCGEN field. */
#define CMT_RD_MSC_MCGEN(base) ((CMT_MSC_REG(base) & CMT_MSC_MCGEN_MASK) >> CMT_MSC_MCGEN_SHIFT)
#define CMT_BRD_MSC_MCGEN(base) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_MCGEN_SHIFT))

/*! @brief Set the MCGEN field to a new value. */
#define CMT_WR_MSC_MCGEN(base, value) (CMT_RMW_MSC(base, CMT_MSC_MCGEN_MASK, CMT_MSC_MCGEN(value)))
#define CMT_BWR_MSC_MCGEN(base, value) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_MCGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMT_MSC, field EOCIE[1] (RW)
 *
 * A CPU interrupt will be requested when EOCF is set if EOCIE is high.
 *
 * Values:
 * - 0 - CPU interrupt disabled
 * - 1 - CPU interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_EOCIE field. */
#define CMT_RD_MSC_EOCIE(base) ((CMT_MSC_REG(base) & CMT_MSC_EOCIE_MASK) >> CMT_MSC_EOCIE_SHIFT)
#define CMT_BRD_MSC_EOCIE(base) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_EOCIE_SHIFT))

/*! @brief Set the EOCIE field to a new value. */
#define CMT_WR_MSC_EOCIE(base, value) (CMT_RMW_MSC(base, CMT_MSC_EOCIE_MASK, CMT_MSC_EOCIE(value)))
#define CMT_BWR_MSC_EOCIE(base, value) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_EOCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMT_MSC, field FSK[2] (RW)
 *
 * The FSK bit enables FSK operation.
 *
 * Values:
 * - 0 - CMT operates in Time or Baseband mode
 * - 1 - CMT operates in FSK mode
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_FSK field. */
#define CMT_RD_MSC_FSK(base) ((CMT_MSC_REG(base) & CMT_MSC_FSK_MASK) >> CMT_MSC_FSK_SHIFT)
#define CMT_BRD_MSC_FSK(base) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_FSK_SHIFT))

/*! @brief Set the FSK field to a new value. */
#define CMT_WR_MSC_FSK(base, value) (CMT_RMW_MSC(base, CMT_MSC_FSK_MASK, CMT_MSC_FSK(value)))
#define CMT_BWR_MSC_FSK(base, value) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_FSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMT_MSC, field BASE[3] (RW)
 *
 * When set, the BASE bit disables the carrier generator and forces the carrier
 * output high for generation of baseband protocols. When BASE is cleared, the
 * carrier generator is enabled and the carrier output toggles at the frequency
 * determined by values stored in the carrier data registers. This bit is cleared by
 * reset. This bit is not double buffered and should not be written to during a
 * transmission.
 *
 * Values:
 * - 0 - Baseband mode disabled
 * - 1 - Baseband mode enabled
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_BASE field. */
#define CMT_RD_MSC_BASE(base) ((CMT_MSC_REG(base) & CMT_MSC_BASE_MASK) >> CMT_MSC_BASE_SHIFT)
#define CMT_BRD_MSC_BASE(base) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_BASE_SHIFT))

/*! @brief Set the BASE field to a new value. */
#define CMT_WR_MSC_BASE(base, value) (CMT_RMW_MSC(base, CMT_MSC_BASE_MASK, CMT_MSC_BASE(value)))
#define CMT_BWR_MSC_BASE(base, value) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_BASE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMT_MSC, field EXSPC[4] (RW)
 *
 * The EXSPC bit enables extended space operation.
 *
 * Values:
 * - 0 - Extended space disabled
 * - 1 - Extended space enabled
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_EXSPC field. */
#define CMT_RD_MSC_EXSPC(base) ((CMT_MSC_REG(base) & CMT_MSC_EXSPC_MASK) >> CMT_MSC_EXSPC_SHIFT)
#define CMT_BRD_MSC_EXSPC(base) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_EXSPC_SHIFT))

/*! @brief Set the EXSPC field to a new value. */
#define CMT_WR_MSC_EXSPC(base, value) (CMT_RMW_MSC(base, CMT_MSC_EXSPC_MASK, CMT_MSC_EXSPC(value)))
#define CMT_BWR_MSC_EXSPC(base, value) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_EXSPC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMT_MSC, field CMTDIV[6:5] (RW)
 *
 * The Secondary Prescaler causes the CMT to be clocked at the IF signal
 * frequency, or the IF frequency divided by 2 ,4, or 8. Since these bits are not double
 * buffered, they should not be changed during a transmission.
 *
 * Values:
 * - 00 - IF * 1
 * - 01 - IF * 2
 * - 10 - IF * 4
 * - 11 - IF * 8
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_CMTDIV field. */
#define CMT_RD_MSC_CMTDIV(base) ((CMT_MSC_REG(base) & CMT_MSC_CMTDIV_MASK) >> CMT_MSC_CMTDIV_SHIFT)
#define CMT_BRD_MSC_CMTDIV(base) (CMT_RD_MSC_CMTDIV(base))

/*! @brief Set the CMTDIV field to a new value. */
#define CMT_WR_MSC_CMTDIV(base, value) (CMT_RMW_MSC(base, CMT_MSC_CMTDIV_MASK, CMT_MSC_CMTDIV(value)))
#define CMT_BWR_MSC_CMTDIV(base, value) (CMT_WR_MSC_CMTDIV(base, value))
/*@}*/

/*!
 * @name Register CMT_MSC, field EOCF[7] (RO)
 *
 * The EOCF bit is set when: The modulator is not currently active and the MCGEN
 * bit is set to begin the initial CMT transmission. At the end of each
 * modulation cycle while the MCGEN bit is set. This is recognized when a match occurs
 * between the contents of the space period register and the down counter. At this
 * time, the counter is initialized with the (possibly new) contents of the mark
 * period buffer, CMT_CMD1 and CMT_CMD2, and the space period register is loaded
 * with the (possibly new) contents of the space period buffer, CMT_CMD3 and
 * CMT_CMD4. This flag is cleared by a read of the MSC register followed by an access
 * of CMD2 or CMD4 or by the DMA transfer.
 *
 * Values:
 * - 0 - No end of modulation cycle occurrence since flag last cleared
 * - 1 - End of modulator cycle has occurred
 */
/*@{*/
/*! @brief Read current value of the CMT_MSC_EOCF field. */
#define CMT_RD_MSC_EOCF(base) ((CMT_MSC_REG(base) & CMT_MSC_EOCF_MASK) >> CMT_MSC_EOCF_SHIFT)
#define CMT_BRD_MSC_EOCF(base) (BITBAND_ACCESS8(&CMT_MSC_REG(base), CMT_MSC_EOCF_SHIFT))
/*@}*/

/*******************************************************************************
 * CMT_CMD1 - CMT Modulator Data Register Mark High
 ******************************************************************************/

/*!
 * @brief CMT_CMD1 - CMT Modulator Data Register Mark High (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the modulator down counter
 * upon the completion of a modulation period.
 */
/*!
 * @name Constants and macros for entire CMT_CMD1 register
 */
/*@{*/
#define CMT_RD_CMD1(base)        (CMT_CMD1_REG(base))
#define CMT_WR_CMD1(base, value) (CMT_CMD1_REG(base) = (value))
#define CMT_RMW_CMD1(base, mask, value) (CMT_WR_CMD1(base, (CMT_RD_CMD1(base) & ~(mask)) | (value)))
#define CMT_SET_CMD1(base, value) (CMT_WR_CMD1(base, CMT_RD_CMD1(base) |  (value)))
#define CMT_CLR_CMD1(base, value) (CMT_WR_CMD1(base, CMT_RD_CMD1(base) & ~(value)))
#define CMT_TOG_CMD1(base, value) (CMT_WR_CMD1(base, CMT_RD_CMD1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMT_CMD2 - CMT Modulator Data Register Mark Low
 ******************************************************************************/

/*!
 * @brief CMT_CMD2 - CMT Modulator Data Register Mark Low (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the modulator down counter
 * upon the completion of a modulation period.
 */
/*!
 * @name Constants and macros for entire CMT_CMD2 register
 */
/*@{*/
#define CMT_RD_CMD2(base)        (CMT_CMD2_REG(base))
#define CMT_WR_CMD2(base, value) (CMT_CMD2_REG(base) = (value))
#define CMT_RMW_CMD2(base, mask, value) (CMT_WR_CMD2(base, (CMT_RD_CMD2(base) & ~(mask)) | (value)))
#define CMT_SET_CMD2(base, value) (CMT_WR_CMD2(base, CMT_RD_CMD2(base) |  (value)))
#define CMT_CLR_CMD2(base, value) (CMT_WR_CMD2(base, CMT_RD_CMD2(base) & ~(value)))
#define CMT_TOG_CMD2(base, value) (CMT_WR_CMD2(base, CMT_RD_CMD2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMT_CMD3 - CMT Modulator Data Register Space High
 ******************************************************************************/

/*!
 * @brief CMT_CMD3 - CMT Modulator Data Register Space High (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the space period register
 * upon the completion of a modulation period.
 */
/*!
 * @name Constants and macros for entire CMT_CMD3 register
 */
/*@{*/
#define CMT_RD_CMD3(base)        (CMT_CMD3_REG(base))
#define CMT_WR_CMD3(base, value) (CMT_CMD3_REG(base) = (value))
#define CMT_RMW_CMD3(base, mask, value) (CMT_WR_CMD3(base, (CMT_RD_CMD3(base) & ~(mask)) | (value)))
#define CMT_SET_CMD3(base, value) (CMT_WR_CMD3(base, CMT_RD_CMD3(base) |  (value)))
#define CMT_CLR_CMD3(base, value) (CMT_WR_CMD3(base, CMT_RD_CMD3(base) & ~(value)))
#define CMT_TOG_CMD3(base, value) (CMT_WR_CMD3(base, CMT_RD_CMD3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMT_CMD4 - CMT Modulator Data Register Space Low
 ******************************************************************************/

/*!
 * @brief CMT_CMD4 - CMT Modulator Data Register Space Low (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the space period register
 * upon the completion of a modulation period.
 */
/*!
 * @name Constants and macros for entire CMT_CMD4 register
 */
/*@{*/
#define CMT_RD_CMD4(base)        (CMT_CMD4_REG(base))
#define CMT_WR_CMD4(base, value) (CMT_CMD4_REG(base) = (value))
#define CMT_RMW_CMD4(base, mask, value) (CMT_WR_CMD4(base, (CMT_RD_CMD4(base) & ~(mask)) | (value)))
#define CMT_SET_CMD4(base, value) (CMT_WR_CMD4(base, CMT_RD_CMD4(base) |  (value)))
#define CMT_CLR_CMD4(base, value) (CMT_WR_CMD4(base, CMT_RD_CMD4(base) & ~(value)))
#define CMT_TOG_CMD4(base, value) (CMT_WR_CMD4(base, CMT_RD_CMD4(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMT_PPS - CMT Primary Prescaler Register
 ******************************************************************************/

/*!
 * @brief CMT_PPS - CMT Primary Prescaler Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is used to set the primary prescaler bits (PPSDIV).
 */
/*!
 * @name Constants and macros for entire CMT_PPS register
 */
/*@{*/
#define CMT_RD_PPS(base)         (CMT_PPS_REG(base))
#define CMT_WR_PPS(base, value)  (CMT_PPS_REG(base) = (value))
#define CMT_RMW_PPS(base, mask, value) (CMT_WR_PPS(base, (CMT_RD_PPS(base) & ~(mask)) | (value)))
#define CMT_SET_PPS(base, value) (CMT_WR_PPS(base, CMT_RD_PPS(base) |  (value)))
#define CMT_CLR_PPS(base, value) (CMT_WR_PPS(base, CMT_RD_PPS(base) & ~(value)))
#define CMT_TOG_PPS(base, value) (CMT_WR_PPS(base, CMT_RD_PPS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMT_PPS bitfields
 */

/*!
 * @name Register CMT_PPS, field PPSDIV[3:0] (RW)
 *
 * The primary prescaler divides the CMT clock to generate the Intermediate
 * Frequency clock enable to the secondary prescaler.
 *
 * Values:
 * - 0000 - Bus Clock * 1
 * - 0001 - Bus Clock * 2
 * - 0010 - Bus Clock * 3
 * - 0011 - Bus Clock * 4
 * - 0100 - Bus Clock * 5
 * - 0101 - Bus Clock * 6
 * - 0110 - Bus Clock * 7
 * - 0111 - Bus Clock * 8
 * - 1000 - Bus Clock * 9
 * - 1001 - Bus Clock * 10
 * - 1010 - Bus Clock * 11
 * - 1011 - Bus Clock * 12
 * - 1100 - Bus Clock * 13
 * - 1101 - Bus Clock * 14
 * - 1110 - Bus Clock * 15
 * - 1111 - Bus Clock * 16
 */
/*@{*/
/*! @brief Read current value of the CMT_PPS_PPSDIV field. */
#define CMT_RD_PPS_PPSDIV(base) ((CMT_PPS_REG(base) & CMT_PPS_PPSDIV_MASK) >> CMT_PPS_PPSDIV_SHIFT)
#define CMT_BRD_PPS_PPSDIV(base) (CMT_RD_PPS_PPSDIV(base))

/*! @brief Set the PPSDIV field to a new value. */
#define CMT_WR_PPS_PPSDIV(base, value) (CMT_RMW_PPS(base, CMT_PPS_PPSDIV_MASK, CMT_PPS_PPSDIV(value)))
#define CMT_BWR_PPS_PPSDIV(base, value) (CMT_WR_PPS_PPSDIV(base, value))
/*@}*/

/*******************************************************************************
 * CMT_DMA - CMT Direct Memory Access
 ******************************************************************************/

/*!
 * @brief CMT_DMA - CMT Direct Memory Access (RW)
 *
 * Reset value: 0x00U
 *
 * This register is used to enable/disable direct memory access (DMA).
 */
/*!
 * @name Constants and macros for entire CMT_DMA register
 */
/*@{*/
#define CMT_RD_DMA(base)         (CMT_DMA_REG(base))
#define CMT_WR_DMA(base, value)  (CMT_DMA_REG(base) = (value))
#define CMT_RMW_DMA(base, mask, value) (CMT_WR_DMA(base, (CMT_RD_DMA(base) & ~(mask)) | (value)))
#define CMT_SET_DMA(base, value) (CMT_WR_DMA(base, CMT_RD_DMA(base) |  (value)))
#define CMT_CLR_DMA(base, value) (CMT_WR_DMA(base, CMT_RD_DMA(base) & ~(value)))
#define CMT_TOG_DMA(base, value) (CMT_WR_DMA(base, CMT_RD_DMA(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMT_DMA bitfields
 */

/*!
 * @name Register CMT_DMA, field DMA[0] (RW)
 *
 * This bit enables the DMA protocol.
 *
 * Values:
 * - 0 - DMA transfer request and done are disabled
 * - 1 - DMA transfer request and done are enabled
 */
/*@{*/
/*! @brief Read current value of the CMT_DMA_DMA field. */
#define CMT_RD_DMA_DMA(base) ((CMT_DMA_REG(base) & CMT_DMA_DMA_MASK) >> CMT_DMA_DMA_SHIFT)
#define CMT_BRD_DMA_DMA(base) (BITBAND_ACCESS8(&CMT_DMA_REG(base), CMT_DMA_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define CMT_WR_DMA_DMA(base, value) (CMT_RMW_DMA(base, CMT_DMA_DMA_MASK, CMT_DMA_DMA(value)))
#define CMT_BWR_DMA_DMA(base, value) (BITBAND_ACCESS8(&CMT_DMA_REG(base), CMT_DMA_DMA_SHIFT) = (value))
/*@}*/

/*
 * MK20D5 CRC
 *
 * Cyclic Redundancy Check
 *
 * Registers defined in this header file:
 * - CRC_CRCL - CRC_CRCL register.
 * - CRC_CRCH - CRC_CRCH register.
 * - CRC_CRCLL - CRC_CRCLL register.
 * - CRC_CRCLU - CRC_CRCLU register.
 * - CRC_CRCHL - CRC_CRCHL register.
 * - CRC_CRCHU - CRC_CRCHU register.
 * - CRC_CRC - CRC Data Register
 * - CRC_GPOLY - CRC Polynomial Register
 * - CRC_GPOLYL - CRC_GPOLYL register.
 * - CRC_GPOLYH - CRC_GPOLYH register.
 * - CRC_GPOLYLL - CRC_GPOLYLL register.
 * - CRC_GPOLYLU - CRC_GPOLYLU register.
 * - CRC_GPOLYHL - CRC_GPOLYHL register.
 * - CRC_GPOLYHU - CRC_GPOLYHU register.
 * - CRC_CTRL - CRC Control Register
 * - CRC_CTRLHU - CRC_CTRLHU register.
 */

#define CRC_INSTANCE_COUNT (1U) /*!< Number of instances of the CRC module. */
#define CRC_IDX (0U) /*!< Instance number for CRC. */

/*******************************************************************************
 * CRC_CRCLL - CRC_CRCLL register.
 ******************************************************************************/

/*!
 * @brief CRC_CRCLL - CRC_CRCLL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_CRCLL register
 */
/*@{*/
#define CRC_RD_CRCLL(base)       (CRC_CRCLL_REG(base))
#define CRC_WR_CRCLL(base, value) (CRC_CRCLL_REG(base) = (value))
#define CRC_RMW_CRCLL(base, mask, value) (CRC_WR_CRCLL(base, (CRC_RD_CRCLL(base) & ~(mask)) | (value)))
#define CRC_SET_CRCLL(base, value) (CRC_WR_CRCLL(base, CRC_RD_CRCLL(base) |  (value)))
#define CRC_CLR_CRCLL(base, value) (CRC_WR_CRCLL(base, CRC_RD_CRCLL(base) & ~(value)))
#define CRC_TOG_CRCLL(base, value) (CRC_WR_CRCLL(base, CRC_RD_CRCLL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_CRCL - CRC_CRCL register.
 ******************************************************************************/

/*!
 * @brief CRC_CRCL - CRC_CRCL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_CRCL register
 */
/*@{*/
#define CRC_RD_CRCL(base)        (CRC_CRCL_REG(base))
#define CRC_WR_CRCL(base, value) (CRC_CRCL_REG(base) = (value))
#define CRC_RMW_CRCL(base, mask, value) (CRC_WR_CRCL(base, (CRC_RD_CRCL(base) & ~(mask)) | (value)))
#define CRC_SET_CRCL(base, value) (CRC_WR_CRCL(base, CRC_RD_CRCL(base) |  (value)))
#define CRC_CLR_CRCL(base, value) (CRC_WR_CRCL(base, CRC_RD_CRCL(base) & ~(value)))
#define CRC_TOG_CRCL(base, value) (CRC_WR_CRCL(base, CRC_RD_CRCL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_CRC - CRC Data Register
 ******************************************************************************/

/*!
 * @brief CRC_CRC - CRC Data Register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The CRC data register contains the value of the seed, data, and checksum.
 * When the CTRL[WAS] bit is set, any write to the data register is regarded as the
 * seed value. When the CTRL[WAS] bit is cleared, any write to the data register
 * is regarded as data for general CRC computation. In 16-bit CRC mode, the HU
 * and HL fields are not used for programming the seed value, and reads of these
 * fields return an indeterminate value. In 32-bit CRC mode, all fields are used
 * for programming the seed value. When programming data values, the values can be
 * written 8 bits, 16 bits, or 32 bits at a time, provided all bytes are
 * contiguous; with MSB of data value written first. After all data values are written,
 * the CRC result can be read from this data register. In 16-bit CRC mode, the CRC
 * result is available in the LU and LL fields. In 32-bit CRC mode, all fields
 * contain the result. Reads of this register at any time return the intermediate
 * CRC value, provided the CRC module is configured.
 */
/*!
 * @name Constants and macros for entire CRC_CRC register
 */
/*@{*/
#define CRC_RD_CRC(base)         (CRC_CRC_REG(base))
#define CRC_WR_CRC(base, value)  (CRC_CRC_REG(base) = (value))
#define CRC_RMW_CRC(base, mask, value) (CRC_WR_CRC(base, (CRC_RD_CRC(base) & ~(mask)) | (value)))
#define CRC_SET_CRC(base, value) (CRC_WR_CRC(base, CRC_RD_CRC(base) |  (value)))
#define CRC_CLR_CRC(base, value) (CRC_WR_CRC(base, CRC_RD_CRC(base) & ~(value)))
#define CRC_TOG_CRC(base, value) (CRC_WR_CRC(base, CRC_RD_CRC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CRC bitfields
 */

/*!
 * @name Register CRC_CRC, field LL[7:0] (RW)
 *
 * When the CTRL[WAS] bit is 1, values written to this field are part of the
 * seed value. When the CTRL[WAS] bit is 0, data written to this field is used for
 * CRC checksum generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_CRC_LL field. */
#define CRC_RD_CRC_LL(base)  ((CRC_CRC_REG(base) & CRC_CRC_LL_MASK) >> CRC_CRC_LL_SHIFT)
#define CRC_BRD_CRC_LL(base) (CRC_RD_CRC_LL(base))

/*! @brief Set the LL field to a new value. */
#define CRC_WR_CRC_LL(base, value) (CRC_RMW_CRC(base, CRC_CRC_LL_MASK, CRC_CRC_LL(value)))
#define CRC_BWR_CRC_LL(base, value) (CRC_WR_CRC_LL(base, value))
/*@}*/

/*!
 * @name Register CRC_CRC, field LU[15:8] (RW)
 *
 * When the CTRL[WAS] bit is 1, values written to this field are part of the
 * seed value. When the CTRL[WAS] bit is 0, data written to this field is used for
 * CRC checksum generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_CRC_LU field. */
#define CRC_RD_CRC_LU(base)  ((CRC_CRC_REG(base) & CRC_CRC_LU_MASK) >> CRC_CRC_LU_SHIFT)
#define CRC_BRD_CRC_LU(base) (CRC_RD_CRC_LU(base))

/*! @brief Set the LU field to a new value. */
#define CRC_WR_CRC_LU(base, value) (CRC_RMW_CRC(base, CRC_CRC_LU_MASK, CRC_CRC_LU(value)))
#define CRC_BWR_CRC_LU(base, value) (CRC_WR_CRC_LU(base, value))
/*@}*/

/*!
 * @name Register CRC_CRC, field HL[23:16] (RW)
 *
 * In 16-bit CRC mode (the CTRL[TCRC] bit is 0), this field is not used for
 * programming a seed value. In 32-bit CRC mode (the CTRL[TCRC] bit is 1), values
 * written to this field are part of the seed value when the CTRL[WAS] bit is 1.
 * When the CTRL[WAS] bit is 0, data written to this field is used for CRC checksum
 * generation in both 16-bit and 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_CRC_HL field. */
#define CRC_RD_CRC_HL(base)  ((CRC_CRC_REG(base) & CRC_CRC_HL_MASK) >> CRC_CRC_HL_SHIFT)
#define CRC_BRD_CRC_HL(base) (CRC_RD_CRC_HL(base))

/*! @brief Set the HL field to a new value. */
#define CRC_WR_CRC_HL(base, value) (CRC_RMW_CRC(base, CRC_CRC_HL_MASK, CRC_CRC_HL(value)))
#define CRC_BWR_CRC_HL(base, value) (CRC_WR_CRC_HL(base, value))
/*@}*/

/*!
 * @name Register CRC_CRC, field HU[31:24] (RW)
 *
 * In 16-bit CRC mode (the CTRL[TCRC] bit is 0), this field is not used for
 * programming a seed value. In 32-bit CRC mode (the CTRL[TCRC] bit is 1), values
 * written to this field are part of the seed value when the CTRL[WAS] bit is 1.
 * When the CTRL[WAS] bit is 0, data written to this field is used for CRC checksum
 * generation in both 16-bit and 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_CRC_HU field. */
#define CRC_RD_CRC_HU(base)  ((CRC_CRC_REG(base) & CRC_CRC_HU_MASK) >> CRC_CRC_HU_SHIFT)
#define CRC_BRD_CRC_HU(base) (CRC_RD_CRC_HU(base))

/*! @brief Set the HU field to a new value. */
#define CRC_WR_CRC_HU(base, value) (CRC_RMW_CRC(base, CRC_CRC_HU_MASK, CRC_CRC_HU(value)))
#define CRC_BWR_CRC_HU(base, value) (CRC_WR_CRC_HU(base, value))
/*@}*/

/*******************************************************************************
 * CRC_CRCLU - CRC_CRCLU register.
 ******************************************************************************/

/*!
 * @brief CRC_CRCLU - CRC_CRCLU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_CRCLU register
 */
/*@{*/
#define CRC_RD_CRCLU(base)       (CRC_CRCLU_REG(base))
#define CRC_WR_CRCLU(base, value) (CRC_CRCLU_REG(base) = (value))
#define CRC_RMW_CRCLU(base, mask, value) (CRC_WR_CRCLU(base, (CRC_RD_CRCLU(base) & ~(mask)) | (value)))
#define CRC_SET_CRCLU(base, value) (CRC_WR_CRCLU(base, CRC_RD_CRCLU(base) |  (value)))
#define CRC_CLR_CRCLU(base, value) (CRC_WR_CRCLU(base, CRC_RD_CRCLU(base) & ~(value)))
#define CRC_TOG_CRCLU(base, value) (CRC_WR_CRCLU(base, CRC_RD_CRCLU(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_CRCHL - CRC_CRCHL register.
 ******************************************************************************/

/*!
 * @brief CRC_CRCHL - CRC_CRCHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_CRCHL register
 */
/*@{*/
#define CRC_RD_CRCHL(base)       (CRC_CRCHL_REG(base))
#define CRC_WR_CRCHL(base, value) (CRC_CRCHL_REG(base) = (value))
#define CRC_RMW_CRCHL(base, mask, value) (CRC_WR_CRCHL(base, (CRC_RD_CRCHL(base) & ~(mask)) | (value)))
#define CRC_SET_CRCHL(base, value) (CRC_WR_CRCHL(base, CRC_RD_CRCHL(base) |  (value)))
#define CRC_CLR_CRCHL(base, value) (CRC_WR_CRCHL(base, CRC_RD_CRCHL(base) & ~(value)))
#define CRC_TOG_CRCHL(base, value) (CRC_WR_CRCHL(base, CRC_RD_CRCHL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_CRCH - CRC_CRCH register.
 ******************************************************************************/

/*!
 * @brief CRC_CRCH - CRC_CRCH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_CRCH register
 */
/*@{*/
#define CRC_RD_CRCH(base)        (CRC_CRCH_REG(base))
#define CRC_WR_CRCH(base, value) (CRC_CRCH_REG(base) = (value))
#define CRC_RMW_CRCH(base, mask, value) (CRC_WR_CRCH(base, (CRC_RD_CRCH(base) & ~(mask)) | (value)))
#define CRC_SET_CRCH(base, value) (CRC_WR_CRCH(base, CRC_RD_CRCH(base) |  (value)))
#define CRC_CLR_CRCH(base, value) (CRC_WR_CRCH(base, CRC_RD_CRCH(base) & ~(value)))
#define CRC_TOG_CRCH(base, value) (CRC_WR_CRCH(base, CRC_RD_CRCH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_CRCHU - CRC_CRCHU register.
 ******************************************************************************/

/*!
 * @brief CRC_CRCHU - CRC_CRCHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_CRCHU register
 */
/*@{*/
#define CRC_RD_CRCHU(base)       (CRC_CRCHU_REG(base))
#define CRC_WR_CRCHU(base, value) (CRC_CRCHU_REG(base) = (value))
#define CRC_RMW_CRCHU(base, mask, value) (CRC_WR_CRCHU(base, (CRC_RD_CRCHU(base) & ~(mask)) | (value)))
#define CRC_SET_CRCHU(base, value) (CRC_WR_CRCHU(base, CRC_RD_CRCHU(base) |  (value)))
#define CRC_CLR_CRCHU(base, value) (CRC_WR_CRCHU(base, CRC_RD_CRCHU(base) & ~(value)))
#define CRC_TOG_CRCHU(base, value) (CRC_WR_CRCHU(base, CRC_RD_CRCHU(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLL - CRC_GPOLYLL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLL - CRC_GPOLYLL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLL register
 */
/*@{*/
#define CRC_RD_GPOLYLL(base)     (CRC_GPOLYLL_REG(base))
#define CRC_WR_GPOLYLL(base, value) (CRC_GPOLYLL_REG(base) = (value))
#define CRC_RMW_GPOLYLL(base, mask, value) (CRC_WR_GPOLYLL(base, (CRC_RD_GPOLYLL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLL(base, value) (CRC_WR_GPOLYLL(base, CRC_RD_GPOLYLL(base) |  (value)))
#define CRC_CLR_GPOLYLL(base, value) (CRC_WR_GPOLYLL(base, CRC_RD_GPOLYLL(base) & ~(value)))
#define CRC_TOG_GPOLYLL(base, value) (CRC_WR_GPOLYLL(base, CRC_RD_GPOLYLL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLY - CRC Polynomial Register
 ******************************************************************************/

/*!
 * @brief CRC_GPOLY - CRC Polynomial Register (RW)
 *
 * Reset value: 0x00001021U
 *
 * This register contains the value of the polynomial for the CRC calculation.
 * The HIGH field contains the upper 16 bits of the CRC polynomial, which are used
 * only in 32-bit CRC mode. Writes to the HIGH field are ignored in 16-bit CRC
 * mode. The LOW field contains the lower 16 bits of the CRC polynomial, which are
 * used in both 16- and 32-bit CRC modes.
 */
/*!
 * @name Constants and macros for entire CRC_GPOLY register
 */
/*@{*/
#define CRC_RD_GPOLY(base)       (CRC_GPOLY_REG(base))
#define CRC_WR_GPOLY(base, value) (CRC_GPOLY_REG(base) = (value))
#define CRC_RMW_GPOLY(base, mask, value) (CRC_WR_GPOLY(base, (CRC_RD_GPOLY(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLY(base, value) (CRC_WR_GPOLY(base, CRC_RD_GPOLY(base) |  (value)))
#define CRC_CLR_GPOLY(base, value) (CRC_WR_GPOLY(base, CRC_RD_GPOLY(base) & ~(value)))
#define CRC_TOG_GPOLY(base, value) (CRC_WR_GPOLY(base, CRC_RD_GPOLY(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLY bitfields
 */

/*!
 * @name Register CRC_GPOLY, field LOW[15:0] (RW)
 *
 * This field is writable and readable in both 32-bit and 16-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_LOW field. */
#define CRC_RD_GPOLY_LOW(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_LOW_MASK) >> CRC_GPOLY_LOW_SHIFT)
#define CRC_BRD_GPOLY_LOW(base) (CRC_RD_GPOLY_LOW(base))

/*! @brief Set the LOW field to a new value. */
#define CRC_WR_GPOLY_LOW(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_LOW_MASK, CRC_GPOLY_LOW(value)))
#define CRC_BWR_GPOLY_LOW(base, value) (CRC_WR_GPOLY_LOW(base, value))
/*@}*/

/*!
 * @name Register CRC_GPOLY, field HIGH[31:16] (RW)
 *
 * This field is writable and readable in 32-bit CRC mode (the CTRL[TCRC] bit is
 * 1). This field is not writable in 16-bit CRC mode (the CTRL[TCRC] bit is 0).
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_HIGH field. */
#define CRC_RD_GPOLY_HIGH(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_HIGH_MASK) >> CRC_GPOLY_HIGH_SHIFT)
#define CRC_BRD_GPOLY_HIGH(base) (CRC_RD_GPOLY_HIGH(base))

/*! @brief Set the HIGH field to a new value. */
#define CRC_WR_GPOLY_HIGH(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_HIGH_MASK, CRC_GPOLY_HIGH(value)))
#define CRC_BWR_GPOLY_HIGH(base, value) (CRC_WR_GPOLY_HIGH(base, value))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYL - CRC_GPOLYL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYL - CRC_GPOLYL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYL register
 */
/*@{*/
#define CRC_RD_GPOLYL(base)      (CRC_GPOLYL_REG(base))
#define CRC_WR_GPOLYL(base, value) (CRC_GPOLYL_REG(base) = (value))
#define CRC_RMW_GPOLYL(base, mask, value) (CRC_WR_GPOLYL(base, (CRC_RD_GPOLYL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYL(base, value) (CRC_WR_GPOLYL(base, CRC_RD_GPOLYL(base) |  (value)))
#define CRC_CLR_GPOLYL(base, value) (CRC_WR_GPOLYL(base, CRC_RD_GPOLYL(base) & ~(value)))
#define CRC_TOG_GPOLYL(base, value) (CRC_WR_GPOLYL(base, CRC_RD_GPOLYL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLU - CRC_GPOLYLU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLU - CRC_GPOLYLU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLU register
 */
/*@{*/
#define CRC_RD_GPOLYLU(base)     (CRC_GPOLYLU_REG(base))
#define CRC_WR_GPOLYLU(base, value) (CRC_GPOLYLU_REG(base) = (value))
#define CRC_RMW_GPOLYLU(base, mask, value) (CRC_WR_GPOLYLU(base, (CRC_RD_GPOLYLU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLU(base, value) (CRC_WR_GPOLYLU(base, CRC_RD_GPOLYLU(base) |  (value)))
#define CRC_CLR_GPOLYLU(base, value) (CRC_WR_GPOLYLU(base, CRC_RD_GPOLYLU(base) & ~(value)))
#define CRC_TOG_GPOLYLU(base, value) (CRC_WR_GPOLYLU(base, CRC_RD_GPOLYLU(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYH - CRC_GPOLYH register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYH - CRC_GPOLYH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYH register
 */
/*@{*/
#define CRC_RD_GPOLYH(base)      (CRC_GPOLYH_REG(base))
#define CRC_WR_GPOLYH(base, value) (CRC_GPOLYH_REG(base) = (value))
#define CRC_RMW_GPOLYH(base, mask, value) (CRC_WR_GPOLYH(base, (CRC_RD_GPOLYH(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYH(base, value) (CRC_WR_GPOLYH(base, CRC_RD_GPOLYH(base) |  (value)))
#define CRC_CLR_GPOLYH(base, value) (CRC_WR_GPOLYH(base, CRC_RD_GPOLYH(base) & ~(value)))
#define CRC_TOG_GPOLYH(base, value) (CRC_WR_GPOLYH(base, CRC_RD_GPOLYH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHL - CRC_GPOLYHL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHL - CRC_GPOLYHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHL register
 */
/*@{*/
#define CRC_RD_GPOLYHL(base)     (CRC_GPOLYHL_REG(base))
#define CRC_WR_GPOLYHL(base, value) (CRC_GPOLYHL_REG(base) = (value))
#define CRC_RMW_GPOLYHL(base, mask, value) (CRC_WR_GPOLYHL(base, (CRC_RD_GPOLYHL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHL(base, value) (CRC_WR_GPOLYHL(base, CRC_RD_GPOLYHL(base) |  (value)))
#define CRC_CLR_GPOLYHL(base, value) (CRC_WR_GPOLYHL(base, CRC_RD_GPOLYHL(base) & ~(value)))
#define CRC_TOG_GPOLYHL(base, value) (CRC_WR_GPOLYHL(base, CRC_RD_GPOLYHL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHU - CRC_GPOLYHU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHU - CRC_GPOLYHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHU register
 */
/*@{*/
#define CRC_RD_GPOLYHU(base)     (CRC_GPOLYHU_REG(base))
#define CRC_WR_GPOLYHU(base, value) (CRC_GPOLYHU_REG(base) = (value))
#define CRC_RMW_GPOLYHU(base, mask, value) (CRC_WR_GPOLYHU(base, (CRC_RD_GPOLYHU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHU(base, value) (CRC_WR_GPOLYHU(base, CRC_RD_GPOLYHU(base) |  (value)))
#define CRC_CLR_GPOLYHU(base, value) (CRC_WR_GPOLYHU(base, CRC_RD_GPOLYHU(base) & ~(value)))
#define CRC_TOG_GPOLYHU(base, value) (CRC_WR_GPOLYHU(base, CRC_RD_GPOLYHU(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_CTRL - CRC Control Register
 ******************************************************************************/

/*!
 * @brief CRC_CTRL - CRC Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the configuration and working of the CRC module.
 * Appropriate bits must be set before starting a new CRC calculation. A new CRC
 * calculation is initialized by asserting the CTRL[WAS] bit and then writing the seed
 * into the CRC data register.
 */
/*!
 * @name Constants and macros for entire CRC_CTRL register
 */
/*@{*/
#define CRC_RD_CTRL(base)        (CRC_CTRL_REG(base))
#define CRC_WR_CTRL(base, value) (CRC_CTRL_REG(base) = (value))
#define CRC_RMW_CTRL(base, mask, value) (CRC_WR_CTRL(base, (CRC_RD_CTRL(base) & ~(mask)) | (value)))
#define CRC_SET_CTRL(base, value) (CRC_WR_CTRL(base, CRC_RD_CTRL(base) |  (value)))
#define CRC_CLR_CTRL(base, value) (CRC_WR_CTRL(base, CRC_RD_CTRL(base) & ~(value)))
#define CRC_TOG_CTRL(base, value) (CRC_WR_CTRL(base, CRC_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRL bitfields
 */

/*!
 * @name Register CRC_CTRL, field TCRC[24] (RW)
 *
 * Width of CRC protocol.
 *
 * Values:
 * - 0 - 16-bit CRC protocol.
 * - 1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TCRC field. */
#define CRC_RD_CTRL_TCRC(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TCRC_MASK) >> CRC_CTRL_TCRC_SHIFT)
#define CRC_BRD_CTRL_TCRC(base) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRL_TCRC(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TCRC_MASK, CRC_CTRL_TCRC(value)))
#define CRC_BWR_CTRL_TCRC(base, value) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field WAS[25] (RW)
 *
 * When this bit is asserted, a value written to the CRC data register is
 * considered a seed value. When this bit is de-asserted, a value written to the CRC
 * data register is taken as data for CRC computation.
 *
 * Values:
 * - 0 - Writes to the CRC data register are data values.
 * - 1 - Writes to the CRC data register are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_WAS field. */
#define CRC_RD_CTRL_WAS(base) ((CRC_CTRL_REG(base) & CRC_CTRL_WAS_MASK) >> CRC_CTRL_WAS_SHIFT)
#define CRC_BRD_CTRL_WAS(base) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRL_WAS(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_WAS_MASK, CRC_CTRL_WAS(value)))
#define CRC_BWR_CTRL_WAS(base, value) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field FXOR[26] (RW)
 *
 * Some CRC protocols require the final checksum to be XORed with 0xFFFFFFFF or
 * 0xFFFF. Asserting this bit enables "on the fly" complementing of read data.
 *
 * Values:
 * - 0 - No XOR on reading.
 * - 1 - Invert or complement the read value of the CRC data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_FXOR field. */
#define CRC_RD_CTRL_FXOR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_FXOR_MASK) >> CRC_CTRL_FXOR_SHIFT)
#define CRC_BRD_CTRL_FXOR(base) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRL_FXOR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_FXOR_MASK, CRC_CTRL_FXOR(value)))
#define CRC_BWR_CTRL_FXOR(base, value) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOTR[29:28] (RW)
 *
 * These bits identify the transpose configuration of the value read from the
 * CRC data register. Refer to the description of the transpose feature for the
 * available transpose options.
 *
 * Values:
 * - 00 - No transposition.
 * - 01 - Bits in bytes are transposed; bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOTR field. */
#define CRC_RD_CTRL_TOTR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOTR_MASK) >> CRC_CTRL_TOTR_SHIFT)
#define CRC_BRD_CTRL_TOTR(base) (CRC_RD_CTRL_TOTR(base))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRL_TOTR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOTR_MASK, CRC_CTRL_TOTR(value)))
#define CRC_BWR_CTRL_TOTR(base, value) (CRC_WR_CTRL_TOTR(base, value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOT[31:30] (RW)
 *
 * These bits define the transpose configuration of the data written to the CRC
 * data register. Refer to the description of the transpose feature for the
 * available transpose options.
 *
 * Values:
 * - 00 - No transposition.
 * - 01 - Bits in bytes are transposed; bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOT field. */
#define CRC_RD_CTRL_TOT(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOT_MASK) >> CRC_CTRL_TOT_SHIFT)
#define CRC_BRD_CTRL_TOT(base) (CRC_RD_CTRL_TOT(base))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRL_TOT(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOT_MASK, CRC_CTRL_TOT(value)))
#define CRC_BWR_CTRL_TOT(base, value) (CRC_WR_CTRL_TOT(base, value))
/*@}*/

/*******************************************************************************
 * CRC_CTRLHU - CRC_CTRLHU register.
 ******************************************************************************/

/*!
 * @brief CRC_CTRLHU - CRC_CTRLHU register. (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CRC_CTRLHU register
 */
/*@{*/
#define CRC_RD_CTRLHU(base)      (CRC_CTRLHU_REG(base))
#define CRC_WR_CTRLHU(base, value) (CRC_CTRLHU_REG(base) = (value))
#define CRC_RMW_CTRLHU(base, mask, value) (CRC_WR_CTRLHU(base, (CRC_RD_CTRLHU(base) & ~(mask)) | (value)))
#define CRC_SET_CTRLHU(base, value) (CRC_WR_CTRLHU(base, CRC_RD_CTRLHU(base) |  (value)))
#define CRC_CLR_CTRLHU(base, value) (CRC_WR_CTRLHU(base, CRC_RD_CTRLHU(base) & ~(value)))
#define CRC_TOG_CTRLHU(base, value) (CRC_WR_CTRLHU(base, CRC_RD_CTRLHU(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRLHU bitfields
 */

/*!
 * @name Register CRC_CTRLHU, field TCRC[0] (RW)
 *
 * Values:
 * - 0 - 16-bit CRC protocol.
 * - 1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TCRC field. */
#define CRC_RD_CTRLHU_TCRC(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TCRC_MASK) >> CRC_CTRLHU_TCRC_SHIFT)
#define CRC_BRD_CTRLHU_TCRC(base) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TCRC_SHIFT))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRLHU_TCRC(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TCRC_MASK, CRC_CTRLHU_TCRC(value)))
#define CRC_BWR_CTRLHU_TCRC(base, value) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TCRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field WAS[1] (RW)
 *
 * Values:
 * - 0 - Writes to CRC data register are data values.
 * - 1 - Writes to CRC data reguster are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_WAS field. */
#define CRC_RD_CTRLHU_WAS(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_WAS_MASK) >> CRC_CTRLHU_WAS_SHIFT)
#define CRC_BRD_CTRLHU_WAS(base) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_WAS_SHIFT))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRLHU_WAS(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_WAS_MASK, CRC_CTRLHU_WAS(value)))
#define CRC_BWR_CTRLHU_WAS(base, value) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_WAS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field FXOR[2] (RW)
 *
 * Values:
 * - 0 - No XOR on reading.
 * - 1 - Invert or complement the read value of CRC data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_FXOR field. */
#define CRC_RD_CTRLHU_FXOR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_FXOR_MASK) >> CRC_CTRLHU_FXOR_SHIFT)
#define CRC_BRD_CTRLHU_FXOR(base) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_FXOR_SHIFT))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRLHU_FXOR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_FXOR_MASK, CRC_CTRLHU_FXOR(value)))
#define CRC_BWR_CTRLHU_FXOR(base, value) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_FXOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOTR[5:4] (RW)
 *
 * Values:
 * - 00 - No Transposition.
 * - 01 - Bits in bytes are transposed, bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOTR field. */
#define CRC_RD_CTRLHU_TOTR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOTR_MASK) >> CRC_CTRLHU_TOTR_SHIFT)
#define CRC_BRD_CTRLHU_TOTR(base) (CRC_RD_CTRLHU_TOTR(base))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRLHU_TOTR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOTR_MASK, CRC_CTRLHU_TOTR(value)))
#define CRC_BWR_CTRLHU_TOTR(base, value) (CRC_WR_CTRLHU_TOTR(base, value))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOT[7:6] (RW)
 *
 * Values:
 * - 00 - No Transposition.
 * - 01 - Bits in bytes are transposed, bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOT field. */
#define CRC_RD_CTRLHU_TOT(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOT_MASK) >> CRC_CTRLHU_TOT_SHIFT)
#define CRC_BRD_CTRLHU_TOT(base) (CRC_RD_CTRLHU_TOT(base))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRLHU_TOT(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOT_MASK, CRC_CTRLHU_TOT(value)))
#define CRC_BWR_CTRLHU_TOT(base, value) (CRC_WR_CTRLHU_TOT(base, value))
/*@}*/

/*
 * MK20D5 DMA
 *
 * Enhanced direct memory access controller
 *
 * Registers defined in this header file:
 * - DMA_CR - Control Register
 * - DMA_ES - Error Status Register
 * - DMA_ERQ - Enable Request Register
 * - DMA_EEI - Enable Error Interrupt Register
 * - DMA_CEEI - Clear Enable Error Interrupt Register
 * - DMA_SEEI - Set Enable Error Interrupt Register
 * - DMA_CERQ - Clear Enable Request Register
 * - DMA_SERQ - Set Enable Request Register
 * - DMA_CDNE - Clear DONE Status Bit Register
 * - DMA_SSRT - Set START Bit Register
 * - DMA_CERR - Clear Error Register
 * - DMA_CINT - Clear Interrupt Request Register
 * - DMA_INT - Interrupt Request Register
 * - DMA_ERR - Error Register
 * - DMA_HRS - Hardware Request Status Register
 * - DMA_DCHPRI3 - Channel n Priority Register
 * - DMA_DCHPRI2 - Channel n Priority Register
 * - DMA_DCHPRI1 - Channel n Priority Register
 * - DMA_DCHPRI0 - Channel n Priority Register
 * - DMA_SADDR - TCD Source Address
 * - DMA_SOFF - TCD Signed Source Address Offset
 * - DMA_ATTR - TCD Transfer Attributes
 * - DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - DMA_SLAST - TCD Last Source Address Adjustment
 * - DMA_DADDR - TCD Destination Address
 * - DMA_DOFF - TCD Signed Destination Address Offset
 * - DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_CSR - TCD Control and Status
 * - DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 */

#define DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */
#define DMA_IDX (0U) /*!< Instance number for DMA. */

/*******************************************************************************
 * DMA_CR - Control Register
 ******************************************************************************/

/*!
 * @brief DMA_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CR defines the basic operating configuration of the DMA. Arbitration can
 * be configured to use either a fixed-priority or a round-robin scheme. In
 * fixed-priority arbitration, the highest priority channel requesting service is
 * selected to execute. The channel priority registers assign the priorities; see the
 * DCHPRIn registers. In round-robin arbitration mode, the channel priorities
 * are ignored and channels are cycled through without regard to priority. For
 * proper operation, writes to the CR register must be performed only when the DMA
 * channels are inactive; that is, when TCDn_CSR[ACTIVE] bits are cleared.
 */
/*!
 * @name Constants and macros for entire DMA_CR register
 */
/*@{*/
#define DMA_RD_CR(base)          (DMA_CR_REG(base))
#define DMA_WR_CR(base, value)   (DMA_CR_REG(base) = (value))
#define DMA_RMW_CR(base, mask, value) (DMA_WR_CR(base, (DMA_RD_CR(base) & ~(mask)) | (value)))
#define DMA_SET_CR(base, value)  (DMA_WR_CR(base, DMA_RD_CR(base) |  (value)))
#define DMA_CLR_CR(base, value)  (DMA_WR_CR(base, DMA_RD_CR(base) & ~(value)))
#define DMA_TOG_CR(base, value)  (DMA_WR_CR(base, DMA_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CR bitfields
 */

/*!
 * @name Register DMA_CR, field EDBG[1] (RW)
 *
 * Values:
 * - 0 - When in debug mode, the DMA continues to operate.
 * - 1 - When in debug mode, the DMA stalls the start of a new channel.
 *     Executing channels are allowed to complete. Channel execution resumes when the
 *     system exits debug mode or the EDBG bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EDBG field. */
#define DMA_RD_CR_EDBG(base) ((DMA_CR_REG(base) & DMA_CR_EDBG_MASK) >> DMA_CR_EDBG_SHIFT)
#define DMA_BRD_CR_EDBG(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EDBG_SHIFT))

/*! @brief Set the EDBG field to a new value. */
#define DMA_WR_CR_EDBG(base, value) (DMA_RMW_CR(base, DMA_CR_EDBG_MASK, DMA_CR_EDBG(value)))
#define DMA_BWR_CR_EDBG(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EDBG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field ERCA[2] (RW)
 *
 * Values:
 * - 0 - Fixed priority arbitration is used for channel selection.
 * - 1 - Round robin arbitration is used for channel selection.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ERCA field. */
#define DMA_RD_CR_ERCA(base) ((DMA_CR_REG(base) & DMA_CR_ERCA_MASK) >> DMA_CR_ERCA_SHIFT)
#define DMA_BRD_CR_ERCA(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ERCA_SHIFT))

/*! @brief Set the ERCA field to a new value. */
#define DMA_WR_CR_ERCA(base, value) (DMA_RMW_CR(base, DMA_CR_ERCA_MASK, DMA_CR_ERCA(value)))
#define DMA_BWR_CR_ERCA(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ERCA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field HOE[4] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Any error causes the HALT bit to set. Subsequently, all service
 *     requests are ignored until the HALT bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HOE field. */
#define DMA_RD_CR_HOE(base)  ((DMA_CR_REG(base) & DMA_CR_HOE_MASK) >> DMA_CR_HOE_SHIFT)
#define DMA_BRD_CR_HOE(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HOE_SHIFT))

/*! @brief Set the HOE field to a new value. */
#define DMA_WR_CR_HOE(base, value) (DMA_RMW_CR(base, DMA_CR_HOE_MASK, DMA_CR_HOE(value)))
#define DMA_BWR_CR_HOE(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field HALT[5] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Stall the start of any new channels. Executing channels are allowed to
 *     complete. Channel execution resumes when this bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HALT field. */
#define DMA_RD_CR_HALT(base) ((DMA_CR_REG(base) & DMA_CR_HALT_MASK) >> DMA_CR_HALT_SHIFT)
#define DMA_BRD_CR_HALT(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HALT_SHIFT))

/*! @brief Set the HALT field to a new value. */
#define DMA_WR_CR_HALT(base, value) (DMA_RMW_CR(base, DMA_CR_HALT_MASK, DMA_CR_HALT(value)))
#define DMA_BWR_CR_HALT(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HALT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field CLM[6] (RW)
 *
 * Values:
 * - 0 - A minor loop channel link made to itself goes through channel
 *     arbitration before being activated again.
 * - 1 - A minor loop channel link made to itself does not go through channel
 *     arbitration before being activated again. Upon minor loop completion, the
 *     channel activates again if that channel has a minor loop channel link
 *     enabled and the link channel is itself. This effectively applies the minor loop
 *     offsets and restarts the next minor loop.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CLM field. */
#define DMA_RD_CR_CLM(base)  ((DMA_CR_REG(base) & DMA_CR_CLM_MASK) >> DMA_CR_CLM_SHIFT)
#define DMA_BRD_CR_CLM(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CLM_SHIFT))

/*! @brief Set the CLM field to a new value. */
#define DMA_WR_CR_CLM(base, value) (DMA_RMW_CR(base, DMA_CR_CLM_MASK, DMA_CR_CLM(value)))
#define DMA_BWR_CR_CLM(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CLM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field EMLM[7] (RW)
 *
 * Values:
 * - 0 - Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
 * - 1 - Enabled. TCDn.word2 is redefined to include individual enable fields,
 *     an offset field, and the NBYTES field. The individual enable fields allow
 *     the minor loop offset to be applied to the source address, the destination
 *     address, or both. The NBYTES field is reduced when either offset is
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EMLM field. */
#define DMA_RD_CR_EMLM(base) ((DMA_CR_REG(base) & DMA_CR_EMLM_MASK) >> DMA_CR_EMLM_SHIFT)
#define DMA_BRD_CR_EMLM(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EMLM_SHIFT))

/*! @brief Set the EMLM field to a new value. */
#define DMA_WR_CR_EMLM(base, value) (DMA_RMW_CR(base, DMA_CR_EMLM_MASK, DMA_CR_EMLM(value)))
#define DMA_BWR_CR_EMLM(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EMLM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field ECX[16] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer in the same fashion as the CX bit.
 *     Stop the executing channel and force the minor loop to finish. The cancel
 *     takes effect after the last write of the current read/write sequence. The
 *     ECX bit clears itself after the cancel is honored. In addition to
 *     cancelling the transfer, ECX treats the cancel as an error condition, thus updating
 *     the ES register and generating an optional error interrupt.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ECX field. */
#define DMA_RD_CR_ECX(base)  ((DMA_CR_REG(base) & DMA_CR_ECX_MASK) >> DMA_CR_ECX_SHIFT)
#define DMA_BRD_CR_ECX(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ECX_SHIFT))

/*! @brief Set the ECX field to a new value. */
#define DMA_WR_CR_ECX(base, value) (DMA_RMW_CR(base, DMA_CR_ECX_MASK, DMA_CR_ECX(value)))
#define DMA_BWR_CR_ECX(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ECX_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field CX[17] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer. Stop the executing channel and
 *     force the minor loop to finish. The cancel takes effect after the last write
 *     of the current read/write sequence. The CX bit clears itself after the
 *     cancel has been honored. This cancel retires the channel normally as if the
 *     minor loop was completed.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CX field. */
#define DMA_RD_CR_CX(base)   ((DMA_CR_REG(base) & DMA_CR_CX_MASK) >> DMA_CR_CX_SHIFT)
#define DMA_BRD_CR_CX(base)  (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CX_SHIFT))

/*! @brief Set the CX field to a new value. */
#define DMA_WR_CR_CX(base, value) (DMA_RMW_CR(base, DMA_CR_CX_MASK, DMA_CR_CX(value)))
#define DMA_BWR_CR_CX(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CX_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_ES - Error Status Register
 ******************************************************************************/

/*!
 * @brief DMA_ES - Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The ES provides information concerning the last recorded channel error.
 * Channel errors can be caused by: A configuration error, that is: An illegal setting
 * in the transfer-control descriptor, or An illegal priority register setting
 * in fixed-arbitration mode An error termination to a bus master read or write
 * cycle See the Error Reporting and Handling section for more details.
 */
/*!
 * @name Constants and macros for entire DMA_ES register
 */
/*@{*/
#define DMA_RD_ES(base)          (DMA_ES_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_ES bitfields
 */

/*!
 * @name Register DMA_ES, field DBE[0] (RO)
 *
 * Values:
 * - 0 - No destination bus error
 * - 1 - The last recorded error was a bus error on a destination write
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DBE field. */
#define DMA_RD_ES_DBE(base)  ((DMA_ES_REG(base) & DMA_ES_DBE_MASK) >> DMA_ES_DBE_SHIFT)
#define DMA_BRD_ES_DBE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_DBE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SBE[1] (RO)
 *
 * Values:
 * - 0 - No source bus error
 * - 1 - The last recorded error was a bus error on a source read
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SBE field. */
#define DMA_RD_ES_SBE(base)  ((DMA_ES_REG(base) & DMA_ES_SBE_MASK) >> DMA_ES_SBE_SHIFT)
#define DMA_BRD_ES_SBE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SBE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SGE[2] (RO)
 *
 * Values:
 * - 0 - No scatter/gather configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather
 *     operation after major loop completion if TCDn_CSR[ESG] is enabled.
 *     TCDn_DLASTSGA is not on a 32 byte boundary.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SGE field. */
#define DMA_RD_ES_SGE(base)  ((DMA_ES_REG(base) & DMA_ES_SGE_MASK) >> DMA_ES_SGE_SHIFT)
#define DMA_BRD_ES_SGE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SGE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field NCE[3] (RO)
 *
 * Values:
 * - 0 - No NBYTES/CITER configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of
 *     TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or
 *     TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_NCE field. */
#define DMA_RD_ES_NCE(base)  ((DMA_ES_REG(base) & DMA_ES_NCE_MASK) >> DMA_ES_NCE_SHIFT)
#define DMA_BRD_ES_NCE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_NCE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field DOE[4] (RO)
 *
 * Values:
 * - 0 - No destination offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DOE field. */
#define DMA_RD_ES_DOE(base)  ((DMA_ES_REG(base) & DMA_ES_DOE_MASK) >> DMA_ES_DOE_SHIFT)
#define DMA_BRD_ES_DOE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_DOE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field DAE[5] (RO)
 *
 * Values:
 * - 0 - No destination address configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DAE field. */
#define DMA_RD_ES_DAE(base)  ((DMA_ES_REG(base) & DMA_ES_DAE_MASK) >> DMA_ES_DAE_SHIFT)
#define DMA_BRD_ES_DAE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_DAE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SOE[6] (RO)
 *
 * Values:
 * - 0 - No source offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SOE field. */
#define DMA_RD_ES_SOE(base)  ((DMA_ES_REG(base) & DMA_ES_SOE_MASK) >> DMA_ES_SOE_SHIFT)
#define DMA_BRD_ES_SOE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SOE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SAE[7] (RO)
 *
 * Values:
 * - 0 - No source address configuration error.
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SAE field. */
#define DMA_RD_ES_SAE(base)  ((DMA_ES_REG(base) & DMA_ES_SAE_MASK) >> DMA_ES_SAE_SHIFT)
#define DMA_BRD_ES_SAE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SAE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field ERRCHN[11:8] (RO)
 *
 * The channel number of the last recorded error (excluding CPE errors) or last
 * recorded error cancelled transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ERRCHN field. */
#define DMA_RD_ES_ERRCHN(base) ((DMA_ES_REG(base) & DMA_ES_ERRCHN_MASK) >> DMA_ES_ERRCHN_SHIFT)
#define DMA_BRD_ES_ERRCHN(base) (DMA_RD_ES_ERRCHN(base))
/*@}*/

/*!
 * @name Register DMA_ES, field CPE[14] (RO)
 *
 * Values:
 * - 0 - No channel priority error
 * - 1 - The last recorded error was a configuration error in the channel
 *     priorities. Channel priorities are not unique.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_CPE field. */
#define DMA_RD_ES_CPE(base)  ((DMA_ES_REG(base) & DMA_ES_CPE_MASK) >> DMA_ES_CPE_SHIFT)
#define DMA_BRD_ES_CPE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_CPE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field ECX[16] (RO)
 *
 * Values:
 * - 0 - No cancelled transfers
 * - 1 - The last recorded entry was a cancelled transfer by the error cancel
 *     transfer input
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ECX field. */
#define DMA_RD_ES_ECX(base)  ((DMA_ES_REG(base) & DMA_ES_ECX_MASK) >> DMA_ES_ECX_SHIFT)
#define DMA_BRD_ES_ECX(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_ECX_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field VLD[31] (RO)
 *
 * Logical OR of all ERR status bits
 *
 * Values:
 * - 0 - No ERR bits are set
 * - 1 - At least one ERR bit is set indicating a valid error exists that has
 *     not been cleared
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_VLD field. */
#define DMA_RD_ES_VLD(base)  ((DMA_ES_REG(base) & DMA_ES_VLD_MASK) >> DMA_ES_VLD_SHIFT)
#define DMA_BRD_ES_VLD(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_VLD_SHIFT))
/*@}*/

/*******************************************************************************
 * DMA_ERQ - Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_ERQ - Enable Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERQ register provides a bit map for the 16 implemented channels to enable
 * the request signal for each channel. The state of any given channel enable is
 * directly affected by writes to this register; it is also affected by writes
 * to the SERQ and CERQ. The {S,C}ERQ registers are provided so the request enable
 * for a single channel can easily be modified without needing to perform a
 * read-modify-write sequence to the ERQ. DMA request input signals and this enable
 * request flag must be asserted before a channel's hardware service request is
 * accepted. The state of the DMA enable request flag does not affect a channel
 * service request made explicitly through software or a linked channel request.
 */
/*!
 * @name Constants and macros for entire DMA_ERQ register
 */
/*@{*/
#define DMA_RD_ERQ(base)         (DMA_ERQ_REG(base))
#define DMA_WR_ERQ(base, value)  (DMA_ERQ_REG(base) = (value))
#define DMA_RMW_ERQ(base, mask, value) (DMA_WR_ERQ(base, (DMA_RD_ERQ(base) & ~(mask)) | (value)))
#define DMA_SET_ERQ(base, value) (DMA_WR_ERQ(base, DMA_RD_ERQ(base) |  (value)))
#define DMA_CLR_ERQ(base, value) (DMA_WR_ERQ(base, DMA_RD_ERQ(base) & ~(value)))
#define DMA_TOG_ERQ(base, value) (DMA_WR_ERQ(base, DMA_RD_ERQ(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERQ bitfields
 */

/*!
 * @name Register DMA_ERQ, field ERQ0[0] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ0 field. */
#define DMA_RD_ERQ_ERQ0(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ0_MASK) >> DMA_ERQ_ERQ0_SHIFT)
#define DMA_BRD_ERQ_ERQ0(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ0_SHIFT))

/*! @brief Set the ERQ0 field to a new value. */
#define DMA_WR_ERQ_ERQ0(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ0_MASK, DMA_ERQ_ERQ0(value)))
#define DMA_BWR_ERQ_ERQ0(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ1[1] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ1 field. */
#define DMA_RD_ERQ_ERQ1(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ1_MASK) >> DMA_ERQ_ERQ1_SHIFT)
#define DMA_BRD_ERQ_ERQ1(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ1_SHIFT))

/*! @brief Set the ERQ1 field to a new value. */
#define DMA_WR_ERQ_ERQ1(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ1_MASK, DMA_ERQ_ERQ1(value)))
#define DMA_BWR_ERQ_ERQ1(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ2[2] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ2 field. */
#define DMA_RD_ERQ_ERQ2(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ2_MASK) >> DMA_ERQ_ERQ2_SHIFT)
#define DMA_BRD_ERQ_ERQ2(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ2_SHIFT))

/*! @brief Set the ERQ2 field to a new value. */
#define DMA_WR_ERQ_ERQ2(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ2_MASK, DMA_ERQ_ERQ2(value)))
#define DMA_BWR_ERQ_ERQ2(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ3[3] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ3 field. */
#define DMA_RD_ERQ_ERQ3(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ3_MASK) >> DMA_ERQ_ERQ3_SHIFT)
#define DMA_BRD_ERQ_ERQ3(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ3_SHIFT))

/*! @brief Set the ERQ3 field to a new value. */
#define DMA_WR_ERQ_ERQ3(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ3_MASK, DMA_ERQ_ERQ3(value)))
#define DMA_BWR_ERQ_ERQ3(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_EEI - Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_EEI - Enable Error Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The EEI register provides a bit map for the 16 channels to enable the error
 * interrupt signal for each channel. The state of any given channel's error
 * interrupt enable is directly affected by writes to this register; it is also
 * affected by writes to the SEEI and CEEI. The {S,C}EEI are provided so the error
 * interrupt enable for a single channel can easily be modified without the need to
 * perform a read-modify-write sequence to the EEI register. The DMA error
 * indicator and the error interrupt enable flag must be asserted before an error
 * interrupt request for a given channel is asserted to the interrupt controller.
 */
/*!
 * @name Constants and macros for entire DMA_EEI register
 */
/*@{*/
#define DMA_RD_EEI(base)         (DMA_EEI_REG(base))
#define DMA_WR_EEI(base, value)  (DMA_EEI_REG(base) = (value))
#define DMA_RMW_EEI(base, mask, value) (DMA_WR_EEI(base, (DMA_RD_EEI(base) & ~(mask)) | (value)))
#define DMA_SET_EEI(base, value) (DMA_WR_EEI(base, DMA_RD_EEI(base) |  (value)))
#define DMA_CLR_EEI(base, value) (DMA_WR_EEI(base, DMA_RD_EEI(base) & ~(value)))
#define DMA_TOG_EEI(base, value) (DMA_WR_EEI(base, DMA_RD_EEI(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EEI bitfields
 */

/*!
 * @name Register DMA_EEI, field EEI0[0] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI0 field. */
#define DMA_RD_EEI_EEI0(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI0_MASK) >> DMA_EEI_EEI0_SHIFT)
#define DMA_BRD_EEI_EEI0(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI0_SHIFT))

/*! @brief Set the EEI0 field to a new value. */
#define DMA_WR_EEI_EEI0(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI0_MASK, DMA_EEI_EEI0(value)))
#define DMA_BWR_EEI_EEI0(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI1[1] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI1 field. */
#define DMA_RD_EEI_EEI1(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI1_MASK) >> DMA_EEI_EEI1_SHIFT)
#define DMA_BRD_EEI_EEI1(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI1_SHIFT))

/*! @brief Set the EEI1 field to a new value. */
#define DMA_WR_EEI_EEI1(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI1_MASK, DMA_EEI_EEI1(value)))
#define DMA_BWR_EEI_EEI1(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI2[2] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI2 field. */
#define DMA_RD_EEI_EEI2(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI2_MASK) >> DMA_EEI_EEI2_SHIFT)
#define DMA_BRD_EEI_EEI2(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI2_SHIFT))

/*! @brief Set the EEI2 field to a new value. */
#define DMA_WR_EEI_EEI2(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI2_MASK, DMA_EEI_EEI2(value)))
#define DMA_BWR_EEI_EEI2(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI3[3] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI3 field. */
#define DMA_RD_EEI_EEI3(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI3_MASK) >> DMA_EEI_EEI3_SHIFT)
#define DMA_BRD_EEI_EEI3(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI3_SHIFT))

/*! @brief Set the EEI3 field to a new value. */
#define DMA_WR_EEI_EEI3(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI3_MASK, DMA_EEI_EEI3(value)))
#define DMA_BWR_EEI_EEI3(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CEEI - Clear Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_CEEI - Clear Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CEEI provides a simple memory-mapped mechanism to clear a given bit in
 * the EEI to disable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be cleared. Setting
 * the CAEE bit provides a global clear function, forcing the EEI contents to be
 * cleared, disabling all DMA request inputs. If the NOP bit is set, the command
 * is ignored. This allows you to write multiple-byte registers as a 32-bit word.
 * Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CEEI register
 */
/*@{*/
#define DMA_RD_CEEI(base)        (DMA_CEEI_REG(base))
#define DMA_WR_CEEI(base, value) (DMA_CEEI_REG(base) = (value))
#define DMA_RMW_CEEI(base, mask, value) (DMA_WR_CEEI(base, (DMA_RD_CEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CEEI bitfields
 */

/*!
 * @name Register DMA_CEEI, field CEEI[3:0] (WORZ)
 *
 * Clears the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the CEEI field to a new value. */
#define DMA_WR_CEEI_CEEI(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CEEI_MASK, DMA_CEEI_CEEI(value)))
#define DMA_BWR_CEEI_CEEI(base, value) (DMA_WR_CEEI_CEEI(base, value))
/*@}*/

/*!
 * @name Register DMA_CEEI, field CAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the EEI bit specified in the CEEI field
 * - 1 - Clear all bits in EEI
 */
/*@{*/
/*! @brief Set the CAEE field to a new value. */
#define DMA_WR_CEEI_CAEE(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CAEE_MASK, DMA_CEEI_CAEE(value)))
#define DMA_BWR_CEEI_CAEE(base, value) (BITBAND_ACCESS8(&DMA_CEEI_REG(base), DMA_CEEI_CAEE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CEEI_NOP(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_NOP_MASK, DMA_CEEI_NOP(value)))
#define DMA_BWR_CEEI_NOP(base, value) (BITBAND_ACCESS8(&DMA_CEEI_REG(base), DMA_CEEI_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SEEI - Set Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_SEEI - Set Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SEEI provides a simple memory-mapped mechanism to set a given bit in the
 * EEI to enable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be set. Setting the
 * SAEE bit provides a global set function, forcing the entire EEI contents to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SEEI register
 */
/*@{*/
#define DMA_RD_SEEI(base)        (DMA_SEEI_REG(base))
#define DMA_WR_SEEI(base, value) (DMA_SEEI_REG(base) = (value))
#define DMA_RMW_SEEI(base, mask, value) (DMA_WR_SEEI(base, (DMA_RD_SEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SEEI bitfields
 */

/*!
 * @name Register DMA_SEEI, field SEEI[3:0] (WORZ)
 *
 * Sets the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the SEEI field to a new value. */
#define DMA_WR_SEEI_SEEI(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SEEI_MASK, DMA_SEEI_SEEI(value)))
#define DMA_BWR_SEEI_SEEI(base, value) (DMA_WR_SEEI_SEEI(base, value))
/*@}*/

/*!
 * @name Register DMA_SEEI, field SAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the EEI bit specified in the SEEI field.
 * - 1 - Sets all bits in EEI
 */
/*@{*/
/*! @brief Set the SAEE field to a new value. */
#define DMA_WR_SEEI_SAEE(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SAEE_MASK, DMA_SEEI_SAEE(value)))
#define DMA_BWR_SEEI_SAEE(base, value) (BITBAND_ACCESS8(&DMA_SEEI_REG(base), DMA_SEEI_SAEE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_SEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SEEI_NOP(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_NOP_MASK, DMA_SEEI_NOP(value)))
#define DMA_BWR_SEEI_NOP(base, value) (BITBAND_ACCESS8(&DMA_SEEI_REG(base), DMA_SEEI_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CERQ - Clear Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CERQ - Clear Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERQ provides a simple memory-mapped mechanism to clear a given bit in
 * the ERQ to disable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be cleared. Setting the
 * CAER bit provides a global clear function, forcing the entire contents of the
 * ERQ to be cleared, disabling all DMA request inputs. If NOP is set, the
 * command is ignored. This allows you to write multiple-byte registers as a 32-bit
 * word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERQ register
 */
/*@{*/
#define DMA_RD_CERQ(base)        (DMA_CERQ_REG(base))
#define DMA_WR_CERQ(base, value) (DMA_CERQ_REG(base) = (value))
#define DMA_RMW_CERQ(base, mask, value) (DMA_WR_CERQ(base, (DMA_RD_CERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERQ bitfields
 */

/*!
 * @name Register DMA_CERQ, field CERQ[3:0] (WORZ)
 *
 * Clears the corresponding bit in ERQ
 */
/*@{*/
/*! @brief Set the CERQ field to a new value. */
#define DMA_WR_CERQ_CERQ(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CERQ_MASK, DMA_CERQ_CERQ(value)))
#define DMA_BWR_CERQ_CERQ(base, value) (DMA_WR_CERQ_CERQ(base, value))
/*@}*/

/*!
 * @name Register DMA_CERQ, field CAER[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERQ bit specified in the CERQ field
 * - 1 - Clear all bits in ERQ
 */
/*@{*/
/*! @brief Set the CAER field to a new value. */
#define DMA_WR_CERQ_CAER(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CAER_MASK, DMA_CERQ_CAER(value)))
#define DMA_BWR_CERQ_CAER(base, value) (BITBAND_ACCESS8(&DMA_CERQ_REG(base), DMA_CERQ_CAER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERQ_NOP(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_NOP_MASK, DMA_CERQ_NOP(value)))
#define DMA_BWR_CERQ_NOP(base, value) (BITBAND_ACCESS8(&DMA_CERQ_REG(base), DMA_CERQ_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SERQ - Set Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_SERQ - Set Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SERQ provides a simple memory-mapped mechanism to set a given bit in the
 * ERQ to enable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be set. Setting the SAER
 * bit provides a global set function, forcing the entire contents of ERQ to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SERQ register
 */
/*@{*/
#define DMA_RD_SERQ(base)        (DMA_SERQ_REG(base))
#define DMA_WR_SERQ(base, value) (DMA_SERQ_REG(base) = (value))
#define DMA_RMW_SERQ(base, mask, value) (DMA_WR_SERQ(base, (DMA_RD_SERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SERQ bitfields
 */

/*!
 * @name Register DMA_SERQ, field SERQ[3:0] (WORZ)
 *
 * Sets the corresponding bit in ERQ
 */
/*@{*/
/*! @brief Set the SERQ field to a new value. */
#define DMA_WR_SERQ_SERQ(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SERQ_MASK, DMA_SERQ_SERQ(value)))
#define DMA_BWR_SERQ_SERQ(base, value) (DMA_WR_SERQ_SERQ(base, value))
/*@}*/

/*!
 * @name Register DMA_SERQ, field SAER[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the ERQ bit specified in the SERQ field
 * - 1 - Set all bits in ERQ
 */
/*@{*/
/*! @brief Set the SAER field to a new value. */
#define DMA_WR_SERQ_SAER(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SAER_MASK, DMA_SERQ_SAER(value)))
#define DMA_BWR_SERQ_SAER(base, value) (BITBAND_ACCESS8(&DMA_SERQ_REG(base), DMA_SERQ_SAER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_SERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SERQ_NOP(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_NOP_MASK, DMA_SERQ_NOP(value)))
#define DMA_BWR_SERQ_NOP(base, value) (BITBAND_ACCESS8(&DMA_SERQ_REG(base), DMA_SERQ_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CDNE - Clear DONE Status Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_CDNE - Clear DONE Status Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CDNE provides a simple memory-mapped mechanism to clear the DONE bit in
 * the TCD of the given channel. The data value on a register write causes the
 * DONE bit in the corresponding transfer control descriptor to be cleared. Setting
 * the CADN bit provides a global clear function, forcing all DONE bits to be
 * cleared. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CDNE register
 */
/*@{*/
#define DMA_RD_CDNE(base)        (DMA_CDNE_REG(base))
#define DMA_WR_CDNE(base, value) (DMA_CDNE_REG(base) = (value))
#define DMA_RMW_CDNE(base, mask, value) (DMA_WR_CDNE(base, (DMA_RD_CDNE(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CDNE bitfields
 */

/*!
 * @name Register DMA_CDNE, field CDNE[3:0] (WORZ)
 *
 * Clears the corresponding bit in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CDNE field to a new value. */
#define DMA_WR_CDNE_CDNE(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CDNE_MASK, DMA_CDNE_CDNE(value)))
#define DMA_BWR_CDNE_CDNE(base, value) (DMA_WR_CDNE_CDNE(base, value))
/*@}*/

/*!
 * @name Register DMA_CDNE, field CADN[6] (WORZ)
 *
 * Values:
 * - 0 - Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
 * - 1 - Clears all bits in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CADN field to a new value. */
#define DMA_WR_CDNE_CADN(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CADN_MASK, DMA_CDNE_CADN(value)))
#define DMA_BWR_CDNE_CADN(base, value) (BITBAND_ACCESS8(&DMA_CDNE_REG(base), DMA_CDNE_CADN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CDNE, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CDNE_NOP(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_NOP_MASK, DMA_CDNE_NOP(value)))
#define DMA_BWR_CDNE_NOP(base, value) (BITBAND_ACCESS8(&DMA_CDNE_REG(base), DMA_CDNE_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SSRT - Set START Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_SSRT - Set START Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SSRT provides a simple memory-mapped mechanism to set the START bit in
 * the TCD of the given channel. The data value on a register write causes the
 * START bit in the corresponding transfer control descriptor to be set. Setting the
 * SAST bit provides a global set function, forcing all START bits to be set. If
 * the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SSRT register
 */
/*@{*/
#define DMA_RD_SSRT(base)        (DMA_SSRT_REG(base))
#define DMA_WR_SSRT(base, value) (DMA_SSRT_REG(base) = (value))
#define DMA_RMW_SSRT(base, mask, value) (DMA_WR_SSRT(base, (DMA_RD_SSRT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SSRT bitfields
 */

/*!
 * @name Register DMA_SSRT, field SSRT[3:0] (WORZ)
 *
 * Sets the corresponding bit in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SSRT field to a new value. */
#define DMA_WR_SSRT_SSRT(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SSRT_MASK, DMA_SSRT_SSRT(value)))
#define DMA_BWR_SSRT_SSRT(base, value) (DMA_WR_SSRT_SSRT(base, value))
/*@}*/

/*!
 * @name Register DMA_SSRT, field SAST[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the TCDn_CSR[START] bit specified in the SSRT field
 * - 1 - Set all bits in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SAST field to a new value. */
#define DMA_WR_SSRT_SAST(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SAST_MASK, DMA_SSRT_SAST(value)))
#define DMA_BWR_SSRT_SAST(base, value) (BITBAND_ACCESS8(&DMA_SSRT_REG(base), DMA_SSRT_SAST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_SSRT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SSRT_NOP(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_NOP_MASK, DMA_SSRT_NOP(value)))
#define DMA_BWR_SSRT_NOP(base, value) (BITBAND_ACCESS8(&DMA_SSRT_REG(base), DMA_SSRT_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CERR - Clear Error Register
 ******************************************************************************/

/*!
 * @brief DMA_CERR - Clear Error Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERR provides a simple memory-mapped mechanism to clear a given bit in
 * the ERR to disable the error condition flag for a given channel. The given value
 * on a register write causes the corresponding bit in the ERR to be cleared.
 * Setting the CAEI bit provides a global clear function, forcing the ERR contents
 * to be cleared, clearing all channel error indicators. If the NOP bit is set,
 * the command is ignored. This allows you to write multiple-byte registers as a
 * 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERR register
 */
/*@{*/
#define DMA_RD_CERR(base)        (DMA_CERR_REG(base))
#define DMA_WR_CERR(base, value) (DMA_CERR_REG(base) = (value))
#define DMA_RMW_CERR(base, mask, value) (DMA_WR_CERR(base, (DMA_RD_CERR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERR bitfields
 */

/*!
 * @name Register DMA_CERR, field CERR[3:0] (WORZ)
 *
 * Clears the corresponding bit in ERR
 */
/*@{*/
/*! @brief Set the CERR field to a new value. */
#define DMA_WR_CERR_CERR(base, value) (DMA_RMW_CERR(base, DMA_CERR_CERR_MASK, DMA_CERR_CERR(value)))
#define DMA_BWR_CERR_CERR(base, value) (DMA_WR_CERR_CERR(base, value))
/*@}*/

/*!
 * @name Register DMA_CERR, field CAEI[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERR bit specified in the CERR field
 * - 1 - Clear all bits in ERR
 */
/*@{*/
/*! @brief Set the CAEI field to a new value. */
#define DMA_WR_CERR_CAEI(base, value) (DMA_RMW_CERR(base, DMA_CERR_CAEI_MASK, DMA_CERR_CAEI(value)))
#define DMA_BWR_CERR_CAEI(base, value) (BITBAND_ACCESS8(&DMA_CERR_REG(base), DMA_CERR_CAEI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CERR, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERR_NOP(base, value) (DMA_RMW_CERR(base, DMA_CERR_NOP_MASK, DMA_CERR_NOP(value)))
#define DMA_BWR_CERR_NOP(base, value) (BITBAND_ACCESS8(&DMA_CERR_REG(base), DMA_CERR_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CINT - Clear Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CINT - Clear Interrupt Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CINT provides a simple, memory-mapped mechanism to clear a given bit in
 * the INT to disable the interrupt request for a given channel. The given value
 * on a register write causes the corresponding bit in the INT to be cleared.
 * Setting the CAIR bit provides a global clear function, forcing the entire contents
 * of the INT to be cleared, disabling all DMA interrupt requests. If the NOP
 * bit is set, the command is ignored. This allows you to write multiple-byte
 * registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CINT register
 */
/*@{*/
#define DMA_RD_CINT(base)        (DMA_CINT_REG(base))
#define DMA_WR_CINT(base, value) (DMA_CINT_REG(base) = (value))
#define DMA_RMW_CINT(base, mask, value) (DMA_WR_CINT(base, (DMA_RD_CINT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CINT bitfields
 */

/*!
 * @name Register DMA_CINT, field CINT[3:0] (WORZ)
 *
 * Clears the corresponding bit in INT
 */
/*@{*/
/*! @brief Set the CINT field to a new value. */
#define DMA_WR_CINT_CINT(base, value) (DMA_RMW_CINT(base, DMA_CINT_CINT_MASK, DMA_CINT_CINT(value)))
#define DMA_BWR_CINT_CINT(base, value) (DMA_WR_CINT_CINT(base, value))
/*@}*/

/*!
 * @name Register DMA_CINT, field CAIR[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the INT bit specified in the CINT field
 * - 1 - Clear all bits in INT
 */
/*@{*/
/*! @brief Set the CAIR field to a new value. */
#define DMA_WR_CINT_CAIR(base, value) (DMA_RMW_CINT(base, DMA_CINT_CAIR_MASK, DMA_CINT_CAIR(value)))
#define DMA_BWR_CINT_CAIR(base, value) (BITBAND_ACCESS8(&DMA_CINT_REG(base), DMA_CINT_CAIR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CINT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CINT_NOP(base, value) (DMA_RMW_CINT(base, DMA_CINT_NOP_MASK, DMA_CINT_NOP(value)))
#define DMA_BWR_CINT_NOP(base, value) (BITBAND_ACCESS8(&DMA_CINT_REG(base), DMA_CINT_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_INT - Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_INT - Interrupt Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The INT register provides a bit map for the 16 channels signaling the
 * presence of an interrupt request for each channel. Depending on the appropriate bit
 * setting in the transfer-control descriptors, the eDMA engine generates an
 * interrupt on data transfer completion. The outputs of this register are directly
 * routed to the interrupt controller (INTC). During the interrupt-service routine
 * associated with any given channel, it is the software's responsibility to
 * clear the appropriate bit, negating the interrupt request. Typically, a write to
 * the CINT register in the interrupt service routine is used for this purpose.
 * The state of any given channel's interrupt request is directly affected by
 * writes to this register; it is also affected by writes to the CINT register. On
 * writes to INT, a 1 in any bit position clears the corresponding channel's
 * interrupt request. A zero in any bit position has no affect on the corresponding
 * channel's current interrupt status. The CINT register is provided so the interrupt
 * request for a single channel can easily be cleared without the need to
 * perform a read-modify-write sequence to the INT register.
 */
/*!
 * @name Constants and macros for entire DMA_INT register
 */
/*@{*/
#define DMA_RD_INT(base)         (DMA_INT_REG(base))
#define DMA_WR_INT(base, value)  (DMA_INT_REG(base) = (value))
#define DMA_RMW_INT(base, mask, value) (DMA_WR_INT(base, (DMA_RD_INT(base) & ~(mask)) | (value)))
#define DMA_SET_INT(base, value) (DMA_WR_INT(base, DMA_RD_INT(base) |  (value)))
#define DMA_CLR_INT(base, value) (DMA_WR_INT(base, DMA_RD_INT(base) & ~(value)))
#define DMA_TOG_INT(base, value) (DMA_WR_INT(base, DMA_RD_INT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_INT bitfields
 */

/*!
 * @name Register DMA_INT, field INT0[0] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT0 field. */
#define DMA_RD_INT_INT0(base) ((DMA_INT_REG(base) & DMA_INT_INT0_MASK) >> DMA_INT_INT0_SHIFT)
#define DMA_BRD_INT_INT0(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT0_SHIFT))

/*! @brief Set the INT0 field to a new value. */
#define DMA_WR_INT_INT0(base, value) (DMA_RMW_INT(base, (DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK), DMA_INT_INT0(value)))
#define DMA_BWR_INT_INT0(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT1[1] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT1 field. */
#define DMA_RD_INT_INT1(base) ((DMA_INT_REG(base) & DMA_INT_INT1_MASK) >> DMA_INT_INT1_SHIFT)
#define DMA_BRD_INT_INT1(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT1_SHIFT))

/*! @brief Set the INT1 field to a new value. */
#define DMA_WR_INT_INT1(base, value) (DMA_RMW_INT(base, (DMA_INT_INT1_MASK | DMA_INT_INT0_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK), DMA_INT_INT1(value)))
#define DMA_BWR_INT_INT1(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT2[2] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT2 field. */
#define DMA_RD_INT_INT2(base) ((DMA_INT_REG(base) & DMA_INT_INT2_MASK) >> DMA_INT_INT2_SHIFT)
#define DMA_BRD_INT_INT2(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT2_SHIFT))

/*! @brief Set the INT2 field to a new value. */
#define DMA_WR_INT_INT2(base, value) (DMA_RMW_INT(base, (DMA_INT_INT2_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT3_MASK), DMA_INT_INT2(value)))
#define DMA_BWR_INT_INT2(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT3[3] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT3 field. */
#define DMA_RD_INT_INT3(base) ((DMA_INT_REG(base) & DMA_INT_INT3_MASK) >> DMA_INT_INT3_SHIFT)
#define DMA_BRD_INT_INT3(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT3_SHIFT))

/*! @brief Set the INT3 field to a new value. */
#define DMA_WR_INT_INT3(base, value) (DMA_RMW_INT(base, (DMA_INT_INT3_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK), DMA_INT_INT3(value)))
#define DMA_BWR_INT_INT3(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_ERR - Error Register
 ******************************************************************************/

/*!
 * @brief DMA_ERR - Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERR provides a bit map for the 16 channels, signaling the presence of an
 * error for each channel. The eDMA engine signals the occurrence of an error
 * condition by setting the appropriate bit in this register. The outputs of this
 * register are enabled by the contents of the EEI, and then routed to the
 * interrupt controller. During the execution of the interrupt-service routine associated
 * with any DMA errors, it is software's responsibility to clear the appropriate
 * bit, negating the error-interrupt request. Typically, a write to the CERR in
 * the interrupt-service routine is used for this purpose. The normal DMA channel
 * completion indicators (setting the transfer control descriptor DONE flag and
 * the possible assertion of an interrupt request) are not affected when an error
 * is detected. The contents of this register can also be polled because a
 * non-zero value indicates the presence of a channel error regardless of the state of
 * the EEI. The state of any given channel's error indicators is affected by
 * writes to this register; it is also affected by writes to the CERR. On writes to
 * the ERR, a one in any bit position clears the corresponding channel's error
 * status. A zero in any bit position has no affect on the corresponding channel's
 * current error status. The CERR is provided so the error indicator for a single
 * channel can easily be cleared.
 */
/*!
 * @name Constants and macros for entire DMA_ERR register
 */
/*@{*/
#define DMA_RD_ERR(base)         (DMA_ERR_REG(base))
#define DMA_WR_ERR(base, value)  (DMA_ERR_REG(base) = (value))
#define DMA_RMW_ERR(base, mask, value) (DMA_WR_ERR(base, (DMA_RD_ERR(base) & ~(mask)) | (value)))
#define DMA_SET_ERR(base, value) (DMA_WR_ERR(base, DMA_RD_ERR(base) |  (value)))
#define DMA_CLR_ERR(base, value) (DMA_WR_ERR(base, DMA_RD_ERR(base) & ~(value)))
#define DMA_TOG_ERR(base, value) (DMA_WR_ERR(base, DMA_RD_ERR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERR bitfields
 */

/*!
 * @name Register DMA_ERR, field ERR0[0] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR0 field. */
#define DMA_RD_ERR_ERR0(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR0_MASK) >> DMA_ERR_ERR0_SHIFT)
#define DMA_BRD_ERR_ERR0(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR0_SHIFT))

/*! @brief Set the ERR0 field to a new value. */
#define DMA_WR_ERR_ERR0(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK), DMA_ERR_ERR0(value)))
#define DMA_BWR_ERR_ERR0(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR1[1] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR1 field. */
#define DMA_RD_ERR_ERR1(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR1_MASK) >> DMA_ERR_ERR1_SHIFT)
#define DMA_BRD_ERR_ERR1(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR1_SHIFT))

/*! @brief Set the ERR1 field to a new value. */
#define DMA_WR_ERR_ERR1(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR1_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK), DMA_ERR_ERR1(value)))
#define DMA_BWR_ERR_ERR1(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR2[2] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR2 field. */
#define DMA_RD_ERR_ERR2(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR2_MASK) >> DMA_ERR_ERR2_SHIFT)
#define DMA_BRD_ERR_ERR2(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR2_SHIFT))

/*! @brief Set the ERR2 field to a new value. */
#define DMA_WR_ERR_ERR2(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR2_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR3_MASK), DMA_ERR_ERR2(value)))
#define DMA_BWR_ERR_ERR2(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR3[3] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR3 field. */
#define DMA_RD_ERR_ERR3(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR3_MASK) >> DMA_ERR_ERR3_SHIFT)
#define DMA_BRD_ERR_ERR3(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR3_SHIFT))

/*! @brief Set the ERR3 field to a new value. */
#define DMA_WR_ERR_ERR3(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR3_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK), DMA_ERR_ERR3(value)))
#define DMA_BWR_ERR_ERR3(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_HRS - Hardware Request Status Register
 ******************************************************************************/

/*!
 * @brief DMA_HRS - Hardware Request Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The HRS provides a bit map for the DMA channels, signaling the presence of a
 * hardware request for each channel. The hardware request status bits reflect
 * the current state of the register and qualified (via the ERQ fields) DMA request
 * signals as seen by the DMA's arbitration logic. This view into the hardware
 * request signals may be used for debug purposes. These bits reflect the state of
 * the request as seen by the arbitration logic. Therefore, this status is
 * affected by the ERQ bits.
 */
/*!
 * @name Constants and macros for entire DMA_HRS register
 */
/*@{*/
#define DMA_RD_HRS(base)         (DMA_HRS_REG(base))
#define DMA_WR_HRS(base, value)  (DMA_HRS_REG(base) = (value))
#define DMA_RMW_HRS(base, mask, value) (DMA_WR_HRS(base, (DMA_RD_HRS(base) & ~(mask)) | (value)))
#define DMA_SET_HRS(base, value) (DMA_WR_HRS(base, DMA_RD_HRS(base) |  (value)))
#define DMA_CLR_HRS(base, value) (DMA_WR_HRS(base, DMA_RD_HRS(base) & ~(value)))
#define DMA_TOG_HRS(base, value) (DMA_WR_HRS(base, DMA_RD_HRS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_HRS bitfields
 */

/*!
 * @name Register DMA_HRS, field HRS0[0] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS0 field. */
#define DMA_RD_HRS_HRS0(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS0_MASK) >> DMA_HRS_HRS0_SHIFT)
#define DMA_BRD_HRS_HRS0(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS0_SHIFT))

/*! @brief Set the HRS0 field to a new value. */
#define DMA_WR_HRS_HRS0(base, value) (DMA_RMW_HRS(base, DMA_HRS_HRS0_MASK, DMA_HRS_HRS0(value)))
#define DMA_BWR_HRS_HRS0(base, value) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS1[1] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS1 field. */
#define DMA_RD_HRS_HRS1(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS1_MASK) >> DMA_HRS_HRS1_SHIFT)
#define DMA_BRD_HRS_HRS1(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS1_SHIFT))

/*! @brief Set the HRS1 field to a new value. */
#define DMA_WR_HRS_HRS1(base, value) (DMA_RMW_HRS(base, DMA_HRS_HRS1_MASK, DMA_HRS_HRS1(value)))
#define DMA_BWR_HRS_HRS1(base, value) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS2[2] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS2 field. */
#define DMA_RD_HRS_HRS2(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS2_MASK) >> DMA_HRS_HRS2_SHIFT)
#define DMA_BRD_HRS_HRS2(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS2_SHIFT))

/*! @brief Set the HRS2 field to a new value. */
#define DMA_WR_HRS_HRS2(base, value) (DMA_RMW_HRS(base, DMA_HRS_HRS2_MASK, DMA_HRS_HRS2(value)))
#define DMA_BWR_HRS_HRS2(base, value) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS3[3] (RW)
 *
 * Values:
 * - 0 - A hardware service request for the corresponding channel is not present
 * - 1 - A hardware service request for the corresponding channel is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS3 field. */
#define DMA_RD_HRS_HRS3(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS3_MASK) >> DMA_HRS_HRS3_SHIFT)
#define DMA_BRD_HRS_HRS3(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS3_SHIFT))

/*! @brief Set the HRS3 field to a new value. */
#define DMA_WR_HRS_HRS3(base, value) (DMA_RMW_HRS(base, DMA_HRS_HRS3_MASK, DMA_HRS_HRS3(value)))
#define DMA_BWR_HRS_HRS3(base, value) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI3 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI3 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When the fixed-priority channel arbitration mode is enabled (CR[ERCA] = 0),
 * the contents of these registers define the unique priorities associated with
 * each channel. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values. Otherwise, a
 * configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI3 register
 */
/*@{*/
#define DMA_RD_DCHPRI3(base)     (DMA_DCHPRI3_REG(base))
#define DMA_WR_DCHPRI3(base, value) (DMA_DCHPRI3_REG(base) = (value))
#define DMA_RMW_DCHPRI3(base, mask, value) (DMA_WR_DCHPRI3(base, (DMA_RD_DCHPRI3(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI3(base, value) (DMA_WR_DCHPRI3(base, DMA_RD_DCHPRI3(base) |  (value)))
#define DMA_CLR_DCHPRI3(base, value) (DMA_WR_DCHPRI3(base, DMA_RD_DCHPRI3(base) & ~(value)))
#define DMA_TOG_DCHPRI3(base, value) (DMA_WR_DCHPRI3(base, DMA_RD_DCHPRI3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI3 bitfields
 */

/*!
 * @name Register DMA_DCHPRI3, field CHPRI[3:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_CHPRI field. */
#define DMA_RD_DCHPRI3_CHPRI(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_CHPRI_MASK) >> DMA_DCHPRI3_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI3_CHPRI(base) (DMA_RD_DCHPRI3_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI3_CHPRI(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_CHPRI_MASK, DMA_DCHPRI3_CHPRI(value)))
#define DMA_BWR_DCHPRI3_CHPRI(base, value) (DMA_WR_DCHPRI3_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_DPA field. */
#define DMA_RD_DCHPRI3_DPA(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_DPA_MASK) >> DMA_DCHPRI3_DPA_SHIFT)
#define DMA_BRD_DCHPRI3_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI3_DPA(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_DPA_MASK, DMA_DCHPRI3_DPA(value)))
#define DMA_BWR_DCHPRI3_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_ECP field. */
#define DMA_RD_DCHPRI3_ECP(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_ECP_MASK) >> DMA_DCHPRI3_ECP_SHIFT)
#define DMA_BRD_DCHPRI3_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI3_ECP(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_ECP_MASK, DMA_DCHPRI3_ECP(value)))
#define DMA_BWR_DCHPRI3_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI2 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI2 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When the fixed-priority channel arbitration mode is enabled (CR[ERCA] = 0),
 * the contents of these registers define the unique priorities associated with
 * each channel. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values. Otherwise, a
 * configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI2 register
 */
/*@{*/
#define DMA_RD_DCHPRI2(base)     (DMA_DCHPRI2_REG(base))
#define DMA_WR_DCHPRI2(base, value) (DMA_DCHPRI2_REG(base) = (value))
#define DMA_RMW_DCHPRI2(base, mask, value) (DMA_WR_DCHPRI2(base, (DMA_RD_DCHPRI2(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI2(base, value) (DMA_WR_DCHPRI2(base, DMA_RD_DCHPRI2(base) |  (value)))
#define DMA_CLR_DCHPRI2(base, value) (DMA_WR_DCHPRI2(base, DMA_RD_DCHPRI2(base) & ~(value)))
#define DMA_TOG_DCHPRI2(base, value) (DMA_WR_DCHPRI2(base, DMA_RD_DCHPRI2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI2 bitfields
 */

/*!
 * @name Register DMA_DCHPRI2, field CHPRI[3:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_CHPRI field. */
#define DMA_RD_DCHPRI2_CHPRI(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_CHPRI_MASK) >> DMA_DCHPRI2_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI2_CHPRI(base) (DMA_RD_DCHPRI2_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI2_CHPRI(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_CHPRI_MASK, DMA_DCHPRI2_CHPRI(value)))
#define DMA_BWR_DCHPRI2_CHPRI(base, value) (DMA_WR_DCHPRI2_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_DPA field. */
#define DMA_RD_DCHPRI2_DPA(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_DPA_MASK) >> DMA_DCHPRI2_DPA_SHIFT)
#define DMA_BRD_DCHPRI2_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI2_DPA(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_DPA_MASK, DMA_DCHPRI2_DPA(value)))
#define DMA_BWR_DCHPRI2_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_ECP field. */
#define DMA_RD_DCHPRI2_ECP(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_ECP_MASK) >> DMA_DCHPRI2_ECP_SHIFT)
#define DMA_BRD_DCHPRI2_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI2_ECP(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_ECP_MASK, DMA_DCHPRI2_ECP(value)))
#define DMA_BWR_DCHPRI2_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI1 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI1 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When the fixed-priority channel arbitration mode is enabled (CR[ERCA] = 0),
 * the contents of these registers define the unique priorities associated with
 * each channel. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values. Otherwise, a
 * configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI1 register
 */
/*@{*/
#define DMA_RD_DCHPRI1(base)     (DMA_DCHPRI1_REG(base))
#define DMA_WR_DCHPRI1(base, value) (DMA_DCHPRI1_REG(base) = (value))
#define DMA_RMW_DCHPRI1(base, mask, value) (DMA_WR_DCHPRI1(base, (DMA_RD_DCHPRI1(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI1(base, value) (DMA_WR_DCHPRI1(base, DMA_RD_DCHPRI1(base) |  (value)))
#define DMA_CLR_DCHPRI1(base, value) (DMA_WR_DCHPRI1(base, DMA_RD_DCHPRI1(base) & ~(value)))
#define DMA_TOG_DCHPRI1(base, value) (DMA_WR_DCHPRI1(base, DMA_RD_DCHPRI1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI1 bitfields
 */

/*!
 * @name Register DMA_DCHPRI1, field CHPRI[3:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_CHPRI field. */
#define DMA_RD_DCHPRI1_CHPRI(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_CHPRI_MASK) >> DMA_DCHPRI1_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI1_CHPRI(base) (DMA_RD_DCHPRI1_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI1_CHPRI(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_CHPRI_MASK, DMA_DCHPRI1_CHPRI(value)))
#define DMA_BWR_DCHPRI1_CHPRI(base, value) (DMA_WR_DCHPRI1_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_DPA field. */
#define DMA_RD_DCHPRI1_DPA(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_DPA_MASK) >> DMA_DCHPRI1_DPA_SHIFT)
#define DMA_BRD_DCHPRI1_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI1_DPA(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_DPA_MASK, DMA_DCHPRI1_DPA(value)))
#define DMA_BWR_DCHPRI1_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_ECP field. */
#define DMA_RD_DCHPRI1_ECP(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_ECP_MASK) >> DMA_DCHPRI1_ECP_SHIFT)
#define DMA_BRD_DCHPRI1_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI1_ECP(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_ECP_MASK, DMA_DCHPRI1_ECP(value)))
#define DMA_BWR_DCHPRI1_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI0 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI0 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When the fixed-priority channel arbitration mode is enabled (CR[ERCA] = 0),
 * the contents of these registers define the unique priorities associated with
 * each channel. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values. Otherwise, a
 * configuration error is reported. The range of the priority value is limited to the
 * values of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI0 register
 */
/*@{*/
#define DMA_RD_DCHPRI0(base)     (DMA_DCHPRI0_REG(base))
#define DMA_WR_DCHPRI0(base, value) (DMA_DCHPRI0_REG(base) = (value))
#define DMA_RMW_DCHPRI0(base, mask, value) (DMA_WR_DCHPRI0(base, (DMA_RD_DCHPRI0(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI0(base, value) (DMA_WR_DCHPRI0(base, DMA_RD_DCHPRI0(base) |  (value)))
#define DMA_CLR_DCHPRI0(base, value) (DMA_WR_DCHPRI0(base, DMA_RD_DCHPRI0(base) & ~(value)))
#define DMA_TOG_DCHPRI0(base, value) (DMA_WR_DCHPRI0(base, DMA_RD_DCHPRI0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI0 bitfields
 */

/*!
 * @name Register DMA_DCHPRI0, field CHPRI[3:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_CHPRI field. */
#define DMA_RD_DCHPRI0_CHPRI(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI0_CHPRI(base) (DMA_RD_DCHPRI0_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI0_CHPRI(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_CHPRI_MASK, DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRI0_CHPRI(base, value) (DMA_WR_DCHPRI0_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_DPA field. */
#define DMA_RD_DCHPRI0_DPA(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRI0_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI0_DPA(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_DPA_MASK, DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRI0_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_ECP field. */
#define DMA_RD_DCHPRI0_ECP(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRI0_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI0_ECP(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_ECP_MASK, DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRI0_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SADDR register
 */
/*@{*/
#define DMA_RD_SADDR(base, index) (DMA_SADDR_REG(base, index))
#define DMA_WR_SADDR(base, index, value) (DMA_SADDR_REG(base, index) = (value))
#define DMA_RMW_SADDR(base, index, mask, value) (DMA_WR_SADDR(base, index, (DMA_RD_SADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_SADDR(base, index, value) (DMA_WR_SADDR(base, index, DMA_RD_SADDR(base, index) |  (value)))
#define DMA_CLR_SADDR(base, index, value) (DMA_WR_SADDR(base, index, DMA_RD_SADDR(base, index) & ~(value)))
#define DMA_TOG_SADDR(base, index, value) (DMA_WR_SADDR(base, index, DMA_RD_SADDR(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_SOFF register
 */
/*@{*/
#define DMA_RD_SOFF(base, index) (DMA_SOFF_REG(base, index))
#define DMA_WR_SOFF(base, index, value) (DMA_SOFF_REG(base, index) = (value))
#define DMA_RMW_SOFF(base, index, mask, value) (DMA_WR_SOFF(base, index, (DMA_RD_SOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_SOFF(base, index, value) (DMA_WR_SOFF(base, index, DMA_RD_SOFF(base, index) |  (value)))
#define DMA_CLR_SOFF(base, index, value) (DMA_WR_SOFF(base, index, DMA_RD_SOFF(base, index) & ~(value)))
#define DMA_TOG_SOFF(base, index, value) (DMA_WR_SOFF(base, index, DMA_RD_SOFF(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_ATTR register
 */
/*@{*/
#define DMA_RD_ATTR(base, index) (DMA_ATTR_REG(base, index))
#define DMA_WR_ATTR(base, index, value) (DMA_ATTR_REG(base, index) = (value))
#define DMA_RMW_ATTR(base, index, mask, value) (DMA_WR_ATTR(base, index, (DMA_RD_ATTR(base, index) & ~(mask)) | (value)))
#define DMA_SET_ATTR(base, index, value) (DMA_WR_ATTR(base, index, DMA_RD_ATTR(base, index) |  (value)))
#define DMA_CLR_ATTR(base, index, value) (DMA_WR_ATTR(base, index, DMA_RD_ATTR(base, index) & ~(value)))
#define DMA_TOG_ATTR(base, index, value) (DMA_WR_ATTR(base, index, DMA_RD_ATTR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ATTR bitfields
 */

/*!
 * @name Register DMA_ATTR, field DSIZE[2:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DSIZE field. */
#define DMA_RD_ATTR_DSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DSIZE_MASK) >> DMA_ATTR_DSIZE_SHIFT)
#define DMA_BRD_ATTR_DSIZE(base, index) (DMA_RD_ATTR_DSIZE(base, index))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_ATTR_DSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DSIZE_MASK, DMA_ATTR_DSIZE(value)))
#define DMA_BWR_ATTR_DSIZE(base, index, value) (DMA_WR_ATTR_DSIZE(base, index, value))
/*@}*/

/*!
 * @name Register DMA_ATTR, field DMOD[7:3] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DMOD field. */
#define DMA_RD_ATTR_DMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DMOD_MASK) >> DMA_ATTR_DMOD_SHIFT)
#define DMA_BRD_ATTR_DMOD(base, index) (DMA_RD_ATTR_DMOD(base, index))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_ATTR_DMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DMOD_MASK, DMA_ATTR_DMOD(value)))
#define DMA_BWR_ATTR_DMOD(base, index, value) (DMA_WR_ATTR_DMOD(base, index, value))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SSIZE[10:8] (RW)
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SSIZE field. */
#define DMA_RD_ATTR_SSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SSIZE_MASK) >> DMA_ATTR_SSIZE_SHIFT)
#define DMA_BRD_ATTR_SSIZE(base, index) (DMA_RD_ATTR_SSIZE(base, index))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_ATTR_SSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SSIZE_MASK, DMA_ATTR_SSIZE(value)))
#define DMA_BWR_ATTR_SSIZE(base, index, value) (DMA_WR_ATTR_SSIZE(base, index, value))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SMOD field. */
#define DMA_RD_ATTR_SMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SMOD_MASK) >> DMA_ATTR_SMOD_SHIFT)
#define DMA_BRD_ATTR_SMOD(base, index) (DMA_RD_ATTR_SMOD(base, index))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_ATTR_SMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SMOD_MASK, DMA_ATTR_SMOD(value)))
#define DMA_BWR_ATTR_SMOD(base, index, value) (DMA_WR_ATTR_SMOD(base, index, value))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCD word 2 is defined as follows if: Minor loop mapping is enabled (CR[EMLM]
 * = 1) and Minor loop offset enabled (SMLOE or DMLOE = 1) If minor loop mapping
 * is enabled and SMLOE and DMLOE are cleared then refer to the
 * TCD_NBYTES_MLOFFNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFYES(base, index) (DMA_NBYTES_MLOFFYES_REG(base, index))
#define DMA_WR_NBYTES_MLOFFYES(base, index, value) (DMA_NBYTES_MLOFFYES_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFYES(base, index, mask, value) (DMA_WR_NBYTES_MLOFFYES(base, index, (DMA_RD_NBYTES_MLOFFYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFYES(base, index, value) (DMA_WR_NBYTES_MLOFFYES(base, index, DMA_RD_NBYTES_MLOFFYES(base, index) |  (value)))
#define DMA_CLR_NBYTES_MLOFFYES(base, index, value) (DMA_WR_NBYTES_MLOFFYES(base, index, DMA_RD_NBYTES_MLOFFYES(base, index) & ~(value)))
#define DMA_TOG_NBYTES_MLOFFYES(base, index, value) (DMA_WR_NBYTES_MLOFFYES(base, index, DMA_RD_NBYTES_MLOFFYES(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFYES_NBYTES(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_NBYTES(base, index) (DMA_RD_NBYTES_MLOFFYES_NBYTES(base, index))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_NBYTES_MASK, DMA_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFYES_NBYTES(base, index, value) (DMA_WR_NBYTES_MLOFFYES_NBYTES(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_MLOFF(base, index) (DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_MLOFF_MASK, DMA_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_DMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_DMLOE(base, index) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_DMLOE_MASK, DMA_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_DMLOE(base, index, value) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_SMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_SMLOE(base, index) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_SMLOE_MASK, DMA_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_SMLOE(base, index, value) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCD word 2 is defined as follows if: Minor loop mapping is enabled (CR[EMLM]
 * = 1) and SMLOE = 0 and DMLOE = 0 If minor loop mapping is enabled and SMLOE or
 * DMLOE is set then refer to the TCD_NBYTES_MLOFFYES register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFNO(base, index) (DMA_NBYTES_MLOFFNO_REG(base, index))
#define DMA_WR_NBYTES_MLOFFNO(base, index, value) (DMA_NBYTES_MLOFFNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFNO(base, index, mask, value) (DMA_WR_NBYTES_MLOFFNO(base, index, (DMA_RD_NBYTES_MLOFFNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFNO(base, index, value) (DMA_WR_NBYTES_MLOFFNO(base, index, DMA_RD_NBYTES_MLOFFNO(base, index) |  (value)))
#define DMA_CLR_NBYTES_MLOFFNO(base, index, value) (DMA_WR_NBYTES_MLOFFNO(base, index, DMA_RD_NBYTES_MLOFFNO(base, index) & ~(value)))
#define DMA_TOG_NBYTES_MLOFFNO(base, index, value) (DMA_WR_NBYTES_MLOFFNO(base, index, DMA_RD_NBYTES_MLOFFNO(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_NBYTES(base, index) (DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_NBYTES_MASK, DMA_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_DMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_DMLOE(base, index) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_DMLOE_MASK, DMA_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_DMLOE(base, index, value) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_SMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_SMLOE(base, index) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_SMLOE_MASK, DMA_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_SMLOE(base, index, value) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCD word 2's register definition depends on the status of minor loop mapping.
 * If minor loop mapping is disabled (CR[EMLM] = 0), TCD word 2 is defined as
 * follows. If minor loop mapping is enabled, see the TCD_NBYTES_MLOFFNO and
 * TCD_NBYTES_MLOFFYES register descriptions for TCD word 2's register definition.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLNO(base, index) (DMA_NBYTES_MLNO_REG(base, index))
#define DMA_WR_NBYTES_MLNO(base, index, value) (DMA_NBYTES_MLNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLNO(base, index, mask, value) (DMA_WR_NBYTES_MLNO(base, index, (DMA_RD_NBYTES_MLNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLNO(base, index, value) (DMA_WR_NBYTES_MLNO(base, index, DMA_RD_NBYTES_MLNO(base, index) |  (value)))
#define DMA_CLR_NBYTES_MLNO(base, index, value) (DMA_WR_NBYTES_MLNO(base, index, DMA_RD_NBYTES_MLNO(base, index) & ~(value)))
#define DMA_TOG_NBYTES_MLNO(base, index, value) (DMA_WR_NBYTES_MLNO(base, index, DMA_RD_NBYTES_MLNO(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SLAST register
 */
/*@{*/
#define DMA_RD_SLAST(base, index) (DMA_SLAST_REG(base, index))
#define DMA_WR_SLAST(base, index, value) (DMA_SLAST_REG(base, index) = (value))
#define DMA_RMW_SLAST(base, index, mask, value) (DMA_WR_SLAST(base, index, (DMA_RD_SLAST(base, index) & ~(mask)) | (value)))
#define DMA_SET_SLAST(base, index, value) (DMA_WR_SLAST(base, index, DMA_RD_SLAST(base, index) |  (value)))
#define DMA_CLR_SLAST(base, index, value) (DMA_WR_SLAST(base, index, DMA_RD_SLAST(base, index) & ~(value)))
#define DMA_TOG_SLAST(base, index, value) (DMA_WR_SLAST(base, index, DMA_RD_SLAST(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DADDR register
 */
/*@{*/
#define DMA_RD_DADDR(base, index) (DMA_DADDR_REG(base, index))
#define DMA_WR_DADDR(base, index, value) (DMA_DADDR_REG(base, index) = (value))
#define DMA_RMW_DADDR(base, index, mask, value) (DMA_WR_DADDR(base, index, (DMA_RD_DADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DADDR(base, index, value) (DMA_WR_DADDR(base, index, DMA_RD_DADDR(base, index) |  (value)))
#define DMA_CLR_DADDR(base, index, value) (DMA_WR_DADDR(base, index, DMA_RD_DADDR(base, index) & ~(value)))
#define DMA_TOG_DADDR(base, index, value) (DMA_WR_DADDR(base, index, DMA_RD_DADDR(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_DOFF register
 */
/*@{*/
#define DMA_RD_DOFF(base, index) (DMA_DOFF_REG(base, index))
#define DMA_WR_DOFF(base, index, value) (DMA_DOFF_REG(base, index) = (value))
#define DMA_RMW_DOFF(base, index, mask, value) (DMA_WR_DOFF(base, index, (DMA_RD_DOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_DOFF(base, index, value) (DMA_WR_DOFF(base, index, DMA_RD_DOFF(base, index) |  (value)))
#define DMA_CLR_DOFF(base, index, value) (DMA_WR_DOFF(base, index, DMA_RD_DOFF(base, index) & ~(value)))
#define DMA_TOG_DOFF(base, index, value) (DMA_WR_DOFF(base, index, DMA_RD_DOFF(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_CITER_ELINKNO(base, index) (DMA_CITER_ELINKNO_REG(base, index))
#define DMA_WR_CITER_ELINKNO(base, index, value) (DMA_CITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKNO(base, index, mask, value) (DMA_WR_CITER_ELINKNO(base, index, (DMA_RD_CITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKNO(base, index, value) (DMA_WR_CITER_ELINKNO(base, index, DMA_RD_CITER_ELINKNO(base, index) |  (value)))
#define DMA_CLR_CITER_ELINKNO(base, index, value) (DMA_WR_CITER_ELINKNO(base, index, DMA_RD_CITER_ELINKNO(base, index) & ~(value)))
#define DMA_TOG_CITER_ELINKNO(base, index, value) (DMA_WR_CITER_ELINKNO(base, index, DMA_RD_CITER_ELINKNO(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKNO, field CITER[14:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_CITER field. */
#define DMA_RD_CITER_ELINKNO_CITER(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_CITER_MASK) >> DMA_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKNO_CITER(base, index) (DMA_RD_CITER_ELINKNO_CITER(base, index))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKNO_CITER(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_CITER_MASK, DMA_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_CITER_ELINKNO_CITER(base, index, value) (DMA_WR_CITER_ELINKNO_CITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_ELINK field. */
#define DMA_RD_CITER_ELINKNO_ELINK(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_ELINK_MASK) >> DMA_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKNO_ELINK(base, index) (BITBAND_ACCESS16(&DMA_CITER_ELINKNO_REG(base, index), DMA_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_ELINK_MASK, DMA_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_CITER_ELINKNO_ELINK(base, index, value) (BITBAND_ACCESS16(&DMA_CITER_ELINKNO_REG(base, index), DMA_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_CITER_ELINKYES(base, index) (DMA_CITER_ELINKYES_REG(base, index))
#define DMA_WR_CITER_ELINKYES(base, index, value) (DMA_CITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKYES(base, index, mask, value) (DMA_WR_CITER_ELINKYES(base, index, (DMA_RD_CITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKYES(base, index, value) (DMA_WR_CITER_ELINKYES(base, index, DMA_RD_CITER_ELINKYES(base, index) |  (value)))
#define DMA_CLR_CITER_ELINKYES(base, index, value) (DMA_WR_CITER_ELINKYES(base, index, DMA_RD_CITER_ELINKYES(base, index) & ~(value)))
#define DMA_TOG_CITER_ELINKYES(base, index, value) (DMA_WR_CITER_ELINKYES(base, index, DMA_RD_CITER_ELINKYES(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKYES, field CITER[8:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_CITER field. */
#define DMA_RD_CITER_ELINKYES_CITER(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_CITER_MASK) >> DMA_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKYES_CITER(base, index) (DMA_RD_CITER_ELINKYES_CITER(base, index))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKYES_CITER(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_CITER_MASK, DMA_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_CITER_ELINKYES_CITER(base, index, value) (DMA_WR_CITER_ELINKYES_CITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field LINKCH[12:9] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_CITER_ELINKYES_LINKCH(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_LINKCH_MASK) >> DMA_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_CITER_ELINKYES_LINKCH(base, index) (DMA_RD_CITER_ELINKYES_LINKCH(base, index))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_CITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_LINKCH_MASK, DMA_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_CITER_ELINKYES_LINKCH(base, index, value) (DMA_WR_CITER_ELINKYES_LINKCH(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_ELINK field. */
#define DMA_RD_CITER_ELINKYES_ELINK(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_ELINK_MASK) >> DMA_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKYES_ELINK(base, index) (BITBAND_ACCESS16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_ELINK_MASK, DMA_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_CITER_ELINKYES_ELINK(base, index, value) (BITBAND_ACCESS16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DLAST_SGA register
 */
/*@{*/
#define DMA_RD_DLAST_SGA(base, index) (DMA_DLAST_SGA_REG(base, index))
#define DMA_WR_DLAST_SGA(base, index, value) (DMA_DLAST_SGA_REG(base, index) = (value))
#define DMA_RMW_DLAST_SGA(base, index, mask, value) (DMA_WR_DLAST_SGA(base, index, (DMA_RD_DLAST_SGA(base, index) & ~(mask)) | (value)))
#define DMA_SET_DLAST_SGA(base, index, value) (DMA_WR_DLAST_SGA(base, index, DMA_RD_DLAST_SGA(base, index) |  (value)))
#define DMA_CLR_DLAST_SGA(base, index, value) (DMA_WR_DLAST_SGA(base, index, DMA_RD_DLAST_SGA(base, index) & ~(value)))
#define DMA_TOG_DLAST_SGA(base, index, value) (DMA_WR_DLAST_SGA(base, index, DMA_RD_DLAST_SGA(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_CSR register
 */
/*@{*/
#define DMA_RD_CSR(base, index)  (DMA_CSR_REG(base, index))
#define DMA_WR_CSR(base, index, value) (DMA_CSR_REG(base, index) = (value))
#define DMA_RMW_CSR(base, index, mask, value) (DMA_WR_CSR(base, index, (DMA_RD_CSR(base, index) & ~(mask)) | (value)))
#define DMA_SET_CSR(base, index, value) (DMA_WR_CSR(base, index, DMA_RD_CSR(base, index) |  (value)))
#define DMA_CLR_CSR(base, index, value) (DMA_WR_CSR(base, index, DMA_RD_CSR(base, index) & ~(value)))
#define DMA_TOG_CSR(base, index, value) (DMA_WR_CSR(base, index, DMA_RD_CSR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CSR bitfields
 */

/*!
 * @name Register DMA_CSR, field START[0] (RW)
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service
 *     request
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_START field. */
#define DMA_RD_CSR_START(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_START_MASK) >> DMA_CSR_START_SHIFT)
#define DMA_BRD_CSR_START(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_CSR_START(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_START_MASK, DMA_CSR_START(value)))
#define DMA_BWR_CSR_START(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTMAJOR[1] (RW)
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTMAJOR field. */
#define DMA_RD_CSR_INTMAJOR(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTMAJOR_MASK) >> DMA_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_CSR_INTMAJOR(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_CSR_INTMAJOR(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTMAJOR_MASK, DMA_CSR_INTMAJOR(value)))
#define DMA_BWR_CSR_INTMAJOR(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTHALF[2] (RW)
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTHALF field. */
#define DMA_RD_CSR_INTHALF(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTHALF_MASK) >> DMA_CSR_INTHALF_SHIFT)
#define DMA_BRD_CSR_INTHALF(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_CSR_INTHALF(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTHALF_MASK, DMA_CSR_INTHALF(value)))
#define DMA_BWR_CSR_INTHALF(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field DREQ[3] (RW)
 *
 * Values:
 * - 0 - The channel's ERQ bit is not affected
 * - 1 - The channel's ERQ bit is cleared when the major loop is complete
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DREQ field. */
#define DMA_RD_CSR_DREQ(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DREQ_MASK) >> DMA_CSR_DREQ_SHIFT)
#define DMA_BRD_CSR_DREQ(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_CSR_DREQ(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DREQ_MASK, DMA_CSR_DREQ(value)))
#define DMA_BWR_CSR_DREQ(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field ESG[4] (RW)
 *
 * Values:
 * - 0 - The current channel's TCD is normal format.
 * - 1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into this
 *     channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ESG field. */
#define DMA_RD_CSR_ESG(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ESG_MASK) >> DMA_CSR_ESG_SHIFT)
#define DMA_BRD_CSR_ESG(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_CSR_ESG(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_ESG_MASK, DMA_CSR_ESG(value)))
#define DMA_BWR_CSR_ESG(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORELINK[5] (RW)
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORELINK field. */
#define DMA_RD_CSR_MAJORELINK(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORELINK_MASK) >> DMA_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_CSR_MAJORELINK(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_CSR_MAJORELINK(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORELINK_MASK, DMA_CSR_MAJORELINK(value)))
#define DMA_BWR_CSR_MAJORELINK(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field ACTIVE[6] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ACTIVE field. */
#define DMA_RD_CSR_ACTIVE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ACTIVE_MASK) >> DMA_CSR_ACTIVE_SHIFT)
#define DMA_BRD_CSR_ACTIVE(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_CSR_ACTIVE(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_ACTIVE_MASK, DMA_CSR_ACTIVE(value)))
#define DMA_BWR_CSR_ACTIVE(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field DONE[7] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DONE field. */
#define DMA_RD_CSR_DONE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DONE_MASK) >> DMA_CSR_DONE_SHIFT)
#define DMA_BRD_CSR_DONE(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_CSR_DONE(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DONE_MASK, DMA_CSR_DONE(value)))
#define DMA_BWR_CSR_DONE(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORLINKCH[11:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORLINKCH field. */
#define DMA_RD_CSR_MAJORLINKCH(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORLINKCH_MASK) >> DMA_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_CSR_MAJORLINKCH(base, index) (DMA_RD_CSR_MAJORLINKCH(base, index))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_CSR_MAJORLINKCH(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORLINKCH_MASK, DMA_CSR_MAJORLINKCH(value)))
#define DMA_BWR_CSR_MAJORLINKCH(base, index, value) (DMA_WR_CSR_MAJORLINKCH(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CSR, field BWC[15:14] (RW)
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_BWC field. */
#define DMA_RD_CSR_BWC(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_BWC_MASK) >> DMA_CSR_BWC_SHIFT)
#define DMA_BRD_CSR_BWC(base, index) (DMA_RD_CSR_BWC(base, index))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_CSR_BWC(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_BWC_MASK, DMA_CSR_BWC(value)))
#define DMA_BWR_CSR_BWC(base, index, value) (DMA_WR_CSR_BWC(base, index, value))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_BITER_ELINKNO(base, index) (DMA_BITER_ELINKNO_REG(base, index))
#define DMA_WR_BITER_ELINKNO(base, index, value) (DMA_BITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKNO(base, index, mask, value) (DMA_WR_BITER_ELINKNO(base, index, (DMA_RD_BITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKNO(base, index, value) (DMA_WR_BITER_ELINKNO(base, index, DMA_RD_BITER_ELINKNO(base, index) |  (value)))
#define DMA_CLR_BITER_ELINKNO(base, index, value) (DMA_WR_BITER_ELINKNO(base, index, DMA_RD_BITER_ELINKNO(base, index) & ~(value)))
#define DMA_TOG_BITER_ELINKNO(base, index, value) (DMA_WR_BITER_ELINKNO(base, index, DMA_RD_BITER_ELINKNO(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKNO, field BITER[14:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_BITER field. */
#define DMA_RD_BITER_ELINKNO_BITER(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_BITER_MASK) >> DMA_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKNO_BITER(base, index) (DMA_RD_BITER_ELINKNO_BITER(base, index))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKNO_BITER(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_BITER_MASK, DMA_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_BITER_ELINKNO_BITER(base, index, value) (DMA_WR_BITER_ELINKNO_BITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_ELINK field. */
#define DMA_RD_BITER_ELINKNO_ELINK(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_ELINK_MASK) >> DMA_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKNO_ELINK(base, index) (BITBAND_ACCESS16(&DMA_BITER_ELINKNO_REG(base, index), DMA_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_ELINK_MASK, DMA_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_BITER_ELINKNO_ELINK(base, index, value) (BITBAND_ACCESS16(&DMA_BITER_ELINKNO_REG(base, index), DMA_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_BITER_ELINKYES(base, index) (DMA_BITER_ELINKYES_REG(base, index))
#define DMA_WR_BITER_ELINKYES(base, index, value) (DMA_BITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKYES(base, index, mask, value) (DMA_WR_BITER_ELINKYES(base, index, (DMA_RD_BITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKYES(base, index, value) (DMA_WR_BITER_ELINKYES(base, index, DMA_RD_BITER_ELINKYES(base, index) |  (value)))
#define DMA_CLR_BITER_ELINKYES(base, index, value) (DMA_WR_BITER_ELINKYES(base, index, DMA_RD_BITER_ELINKYES(base, index) & ~(value)))
#define DMA_TOG_BITER_ELINKYES(base, index, value) (DMA_WR_BITER_ELINKYES(base, index, DMA_RD_BITER_ELINKYES(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKYES, field BITER[8:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_BITER field. */
#define DMA_RD_BITER_ELINKYES_BITER(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_BITER_MASK) >> DMA_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKYES_BITER(base, index) (DMA_RD_BITER_ELINKYES_BITER(base, index))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKYES_BITER(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_BITER_MASK, DMA_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_BITER_ELINKYES_BITER(base, index, value) (DMA_WR_BITER_ELINKYES_BITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field LINKCH[12:9] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_BITER_ELINKYES_LINKCH(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_LINKCH_MASK) >> DMA_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_BITER_ELINKYES_LINKCH(base, index) (DMA_RD_BITER_ELINKYES_LINKCH(base, index))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_BITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_LINKCH_MASK, DMA_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_BITER_ELINKYES_LINKCH(base, index, value) (DMA_WR_BITER_ELINKYES_LINKCH(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_ELINK field. */
#define DMA_RD_BITER_ELINKYES_ELINK(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_ELINK_MASK) >> DMA_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKYES_ELINK(base, index) (BITBAND_ACCESS16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_ELINK_MASK, DMA_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_BITER_ELINKYES_ELINK(base, index, value) (BITBAND_ACCESS16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/* Register macros for indexed access to DMA channel priority registers */
/*
 * Constants and macros for entire DMA_DCHPRIn register
 */
#define DMA_DCHPRIn_INDEX(channel)          (((channel) & ~0x03U) | (3 - ((channel) & 0x03U)))
#define DMA_DCHPRIn_REG(base, index)        (((volatile uint8_t *)&DMA_DCHPRI3_REG(base))[DMA_DCHPRIn_INDEX(index)])
#define DMA_RD_DCHPRIn(base, index)         (DMA_DCHPRIn_REG((base), (index)))
#define DMA_WR_DCHPRIn(base, index, value)  (DMA_DCHPRIn_REG((base), (index)) = (value))
#define DMA_SET_DCHPRIn(base, index, value) (DMA_WR_DCHPRIn((base), (index), DMA_RD_DCHPRIn((base), (index)) |  (value)))
#define DMA_CLR_DCHPRIn(base, index, value) (DMA_WR_DCHPRIn((base), (index), DMA_RD_DCHPRIn((base), (index)) & ~(value)))
#define DMA_TOG_DCHPRIn(base, index, value) (DMA_WR_DCHPRIn((base), (index), DMA_RD_DCHPRIn((base), (index)) ^  (value)))

/*
 * Register DMA_DCHPRIn, bit field CHPRI
 */
/* Read current value of the CHPRI bit field. */
#define DMA_RD_DCHPRIn_CHPRI(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRIn_CHPRI(base, index) (DMA_RD_DCHPRIn_CHPRI((base), (index)))

/* Set the CHPRI bit field to a new value. */
#define DMA_WR_DCHPRIn_CHPRI(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_CHPRI_MASK) | DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRIn_CHPRI(base, index, value) (DMA_WR_DCHPRIn_CHPRI((base), (index), (value)))

/*
 * Register DMA_DCHPRIn, bit field DPA
 */
/* Read current value of the DPA bit field. */
#define DMA_RD_DCHPRIn_DPA(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRIn_DPA(base, index) (BITBAND_ACCESS8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_DPA_SHIFT))

/* Set the DPA bit field to a new value. */
#define DMA_WR_DCHPRIn_DPA(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_DPA_MASK) | DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRIn_DPA(base, index, value) (BITBAND_ACCESS8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_DPA_SHIFT) = (value))

/*
 * Register DMA_DCHPRIn, bit field ECP
 */
/* Read current value of the ECP bit field. */
#define DMA_RD_DCHPRIn_ECP(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRIn_ECP(base, index) (BITBAND_ACCESS8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_ECP_SHIFT))

/* Set the ECP bit field to a new value. */
#define DMA_WR_DCHPRIn_ECP(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_ECP_MASK) | DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRIn_ECP(base, index, value) (BITBAND_ACCESS8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_ECP_SHIFT) = (value))

/*
 * MK20D5 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - DMAMUX_CHCFG - Channel Configuration Register
 */

#define DMAMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the DMAMUX module. */
#define DMAMUX_IDX (0U) /*!< Instance number for DMAMUX. */

/*******************************************************************************
 * DMAMUX_CHCFG - Channel Configuration Register
 ******************************************************************************/

/*!
 * @brief DMAMUX_CHCFG - Channel Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same Source value will result in
 * unpredictable behavior. Before changing the trigger or source settings a DMA
 * channel must be disabled via the CHCFGn[ENBL] bit.
 */
/*!
 * @name Constants and macros for entire DMAMUX_CHCFG register
 */
/*@{*/
#define DMAMUX_RD_CHCFG(base, index) (DMAMUX_CHCFG_REG(base, index))
#define DMAMUX_WR_CHCFG(base, index, value) (DMAMUX_CHCFG_REG(base, index) = (value))
#define DMAMUX_RMW_CHCFG(base, index, mask, value) (DMAMUX_WR_CHCFG(base, index, (DMAMUX_RD_CHCFG(base, index) & ~(mask)) | (value)))
#define DMAMUX_SET_CHCFG(base, index, value) (DMAMUX_WR_CHCFG(base, index, DMAMUX_RD_CHCFG(base, index) |  (value)))
#define DMAMUX_CLR_CHCFG(base, index, value) (DMAMUX_WR_CHCFG(base, index, DMAMUX_RD_CHCFG(base, index) & ~(value)))
#define DMAMUX_TOG_CHCFG(base, index, value) (DMAMUX_WR_CHCFG(base, index, DMAMUX_RD_CHCFG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFG bitfields
 */

/*!
 * @name Register DMAMUX_CHCFG, field SOURCE[5:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_SOURCE field. */
#define DMAMUX_RD_CHCFG_SOURCE(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_SOURCE_MASK) >> DMAMUX_CHCFG_SOURCE_SHIFT)
#define DMAMUX_BRD_CHCFG_SOURCE(base, index) (DMAMUX_RD_CHCFG_SOURCE(base, index))

/*! @brief Set the SOURCE field to a new value. */
#define DMAMUX_WR_CHCFG_SOURCE(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_SOURCE_MASK, DMAMUX_CHCFG_SOURCE(value)))
#define DMAMUX_BWR_CHCFG_SOURCE(base, index, value) (DMAMUX_WR_CHCFG_SOURCE(base, index, value))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field TRIG[6] (RW)
 *
 * Values:
 * - 0 - Triggering is disabled. If triggering is disabled, and the ENBL bit is
 *     set, the DMA Channel will simply route the specified source to the DMA
 *     channel. (normal mode)
 * - 1 - Triggering is enabled. If triggering is enabled, and the ENBL bit is
 *     set, the DMAMUX is in periodic trigger mode.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_TRIG field. */
#define DMAMUX_RD_CHCFG_TRIG(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_TRIG_MASK) >> DMAMUX_CHCFG_TRIG_SHIFT)
#define DMAMUX_BRD_CHCFG_TRIG(base, index) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT))

/*! @brief Set the TRIG field to a new value. */
#define DMAMUX_WR_CHCFG_TRIG(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_TRIG_MASK, DMAMUX_CHCFG_TRIG(value)))
#define DMAMUX_BWR_CHCFG_TRIG(base, index, value) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field ENBL[7] (RW)
 *
 * Values:
 * - 0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMA Mux. The DMA has separate channel enables/disables, which
 *     should be used to disable or re-configure a DMA channel.
 * - 1 - DMA channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_ENBL field. */
#define DMAMUX_RD_CHCFG_ENBL(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_ENBL_MASK) >> DMAMUX_CHCFG_ENBL_SHIFT)
#define DMAMUX_BRD_CHCFG_ENBL(base, index) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT))

/*! @brief Set the ENBL field to a new value. */
#define DMAMUX_WR_CHCFG_ENBL(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_ENBL_MASK, DMAMUX_CHCFG_ENBL(value)))
#define DMAMUX_BWR_CHCFG_ENBL(base, index, value) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT) = (value))
/*@}*/

/*
 * MK20D5 EWM
 *
 * External Watchdog Monitor
 *
 * Registers defined in this header file:
 * - EWM_CTRL - Control Register
 * - EWM_SERV - Service Register
 * - EWM_CMPL - Compare Low Register
 * - EWM_CMPH - Compare High Register
 */

#define EWM_INSTANCE_COUNT (1U) /*!< Number of instances of the EWM module. */
#define EWM_IDX (0U) /*!< Instance number for EWM. */

/*******************************************************************************
 * EWM_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief EWM_CTRL - Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CTRL register is cleared by any reset. INEN, ASSIN and EWMEN bits can be
 * written once after a CPU reset. Modifying these bits more than once, generates
 * a bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CTRL register
 */
/*@{*/
#define EWM_RD_CTRL(base)        (EWM_CTRL_REG(base))
#define EWM_WR_CTRL(base, value) (EWM_CTRL_REG(base) = (value))
#define EWM_RMW_CTRL(base, mask, value) (EWM_WR_CTRL(base, (EWM_RD_CTRL(base) & ~(mask)) | (value)))
#define EWM_SET_CTRL(base, value) (EWM_WR_CTRL(base, EWM_RD_CTRL(base) |  (value)))
#define EWM_CLR_CTRL(base, value) (EWM_WR_CTRL(base, EWM_RD_CTRL(base) & ~(value)))
#define EWM_TOG_CTRL(base, value) (EWM_WR_CTRL(base, EWM_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual EWM_CTRL bitfields
 */

/*!
 * @name Register EWM_CTRL, field EWMEN[0] (RW)
 *
 * This bit when set, enables the EWM module. This resets the EWM counter to
 * zero and deasserts the EWM_out signal. Clearing EWMEN bit disables the EWM, and
 * therefore it cannot be enabled until a reset occurs, due to the write-once
 * nature of this bit.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_EWMEN field. */
#define EWM_RD_CTRL_EWMEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_EWMEN_MASK) >> EWM_CTRL_EWMEN_SHIFT)
#define EWM_BRD_CTRL_EWMEN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_EWMEN_SHIFT))

/*! @brief Set the EWMEN field to a new value. */
#define EWM_WR_CTRL_EWMEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_EWMEN_MASK, EWM_CTRL_EWMEN(value)))
#define EWM_BWR_CTRL_EWMEN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_EWMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register EWM_CTRL, field ASSIN[1] (RW)
 *
 * Default assert state of the EWM_in signal is logic zero. Setting ASSIN bit
 * inverts the assert state to a logic one.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_ASSIN field. */
#define EWM_RD_CTRL_ASSIN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_ASSIN_MASK) >> EWM_CTRL_ASSIN_SHIFT)
#define EWM_BRD_CTRL_ASSIN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_ASSIN_SHIFT))

/*! @brief Set the ASSIN field to a new value. */
#define EWM_WR_CTRL_ASSIN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_ASSIN_MASK, EWM_CTRL_ASSIN(value)))
#define EWM_BWR_CTRL_ASSIN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_ASSIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INEN[2] (RW)
 *
 * This bit when set, enables the EWM_in port.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INEN field. */
#define EWM_RD_CTRL_INEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INEN_MASK) >> EWM_CTRL_INEN_SHIFT)
#define EWM_BRD_CTRL_INEN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INEN_SHIFT))

/*! @brief Set the INEN field to a new value. */
#define EWM_WR_CTRL_INEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INEN_MASK, EWM_CTRL_INEN(value)))
#define EWM_BWR_CTRL_INEN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INTEN[3] (RW)
 *
 * This bit when set and EWM_out is asserted, an interrupt request is generated.
 * To de-assert interrupt request, user should clear this bit by writing 0.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INTEN field. */
#define EWM_RD_CTRL_INTEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INTEN_MASK) >> EWM_CTRL_INTEN_SHIFT)
#define EWM_BRD_CTRL_INTEN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INTEN_SHIFT))

/*! @brief Set the INTEN field to a new value. */
#define EWM_WR_CTRL_INTEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INTEN_MASK, EWM_CTRL_INTEN(value)))
#define EWM_BWR_CTRL_INTEN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INTEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * EWM_SERV - Service Register
 ******************************************************************************/

/*!
 * @brief EWM_SERV - Service Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SERV register provides the interface from the CPU to the EWM module. It
 * is write-only and reads of this register return zero.
 */
/*!
 * @name Constants and macros for entire EWM_SERV register
 */
/*@{*/
#define EWM_RD_SERV(base)        (EWM_SERV_REG(base))
#define EWM_WR_SERV(base, value) (EWM_SERV_REG(base) = (value))
#define EWM_RMW_SERV(base, mask, value) (EWM_WR_SERV(base, (EWM_RD_SERV(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPL - Compare Low Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPL - Compare Low Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CMPL register is reset to zero after a CPU reset. This provides no
 * minimum time for the CPU to service the EWM counter. This register can be written
 * only once after a CPU reset. Writing this register more than once generates a
 * bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CMPL register
 */
/*@{*/
#define EWM_RD_CMPL(base)        (EWM_CMPL_REG(base))
#define EWM_WR_CMPL(base, value) (EWM_CMPL_REG(base) = (value))
#define EWM_RMW_CMPL(base, mask, value) (EWM_WR_CMPL(base, (EWM_RD_CMPL(base) & ~(mask)) | (value)))
#define EWM_SET_CMPL(base, value) (EWM_WR_CMPL(base, EWM_RD_CMPL(base) |  (value)))
#define EWM_CLR_CMPL(base, value) (EWM_WR_CMPL(base, EWM_RD_CMPL(base) & ~(value)))
#define EWM_TOG_CMPL(base, value) (EWM_WR_CMPL(base, EWM_RD_CMPL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPH - Compare High Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPH - Compare High Register (RW)
 *
 * Reset value: 0xFFU
 *
 * The CMPH register is reset to 0xFF after a CPU reset. This provides a maximum
 * of 256 clocks time, for the CPU to service the EWM counter. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. The valid values for CMPH are up to 0xFE
 * because the EWM counter never expires when CMPH = 0xFF. The expiration happens only
 * if EWM counter is greater than CMPH.
 */
/*!
 * @name Constants and macros for entire EWM_CMPH register
 */
/*@{*/
#define EWM_RD_CMPH(base)        (EWM_CMPH_REG(base))
#define EWM_WR_CMPH(base, value) (EWM_CMPH_REG(base) = (value))
#define EWM_RMW_CMPH(base, mask, value) (EWM_WR_CMPH(base, (EWM_RD_CMPH(base) & ~(mask)) | (value)))
#define EWM_SET_CMPH(base, value) (EWM_WR_CMPH(base, EWM_RD_CMPH(base) |  (value)))
#define EWM_CLR_CMPH(base, value) (EWM_WR_CMPH(base, EWM_RD_CMPH(base) & ~(value)))
#define EWM_TOG_CMPH(base, value) (EWM_WR_CMPH(base, EWM_RD_CMPH(base) ^  (value)))
/*@}*/

/*
 * MK20D5 FMC
 *
 * Flash Memory Controller
 *
 * Registers defined in this header file:
 * - FMC_PFAPR - Flash Access Protection Register
 * - FMC_PFB0CR - Flash Control Register
 * - FMC_TAGVD - Cache Tag Storage
 * - FMC_DATAW0S - Cache Data Storage
 * - FMC_DATAW1S - Cache Data Storage
 * - FMC_DATAW2S - Cache Data Storage
 * - FMC_DATAW3S - Cache Data Storage
 */

#define FMC_INSTANCE_COUNT (1U) /*!< Number of instances of the FMC module. */
#define FMC_IDX (0U) /*!< Instance number for FMC. */

/*******************************************************************************
 * FMC_PFAPR - Flash Access Protection Register
 ******************************************************************************/

/*!
 * @brief FMC_PFAPR - Flash Access Protection Register (RW)
 *
 * Reset value: 0x00F8003FU
 */
/*!
 * @name Constants and macros for entire FMC_PFAPR register
 */
/*@{*/
#define FMC_RD_PFAPR(base)       (FMC_PFAPR_REG(base))
#define FMC_WR_PFAPR(base, value) (FMC_PFAPR_REG(base) = (value))
#define FMC_RMW_PFAPR(base, mask, value) (FMC_WR_PFAPR(base, (FMC_RD_PFAPR(base) & ~(mask)) | (value)))
#define FMC_SET_PFAPR(base, value) (FMC_WR_PFAPR(base, FMC_RD_PFAPR(base) |  (value)))
#define FMC_CLR_PFAPR(base, value) (FMC_WR_PFAPR(base, FMC_RD_PFAPR(base) & ~(value)))
#define FMC_TOG_PFAPR(base, value) (FMC_WR_PFAPR(base, FMC_RD_PFAPR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFAPR bitfields
 */

/*!
 * @name Register FMC_PFAPR, field M0AP[1:0] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M0AP field. */
#define FMC_RD_PFAPR_M0AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M0AP_MASK) >> FMC_PFAPR_M0AP_SHIFT)
#define FMC_BRD_PFAPR_M0AP(base) (FMC_RD_PFAPR_M0AP(base))

/*! @brief Set the M0AP field to a new value. */
#define FMC_WR_PFAPR_M0AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M0AP_MASK, FMC_PFAPR_M0AP(value)))
#define FMC_BWR_PFAPR_M0AP(base, value) (FMC_WR_PFAPR_M0AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M1AP[3:2] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M1AP field. */
#define FMC_RD_PFAPR_M1AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M1AP_MASK) >> FMC_PFAPR_M1AP_SHIFT)
#define FMC_BRD_PFAPR_M1AP(base) (FMC_RD_PFAPR_M1AP(base))

/*! @brief Set the M1AP field to a new value. */
#define FMC_WR_PFAPR_M1AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M1AP_MASK, FMC_PFAPR_M1AP(value)))
#define FMC_BWR_PFAPR_M1AP(base, value) (FMC_WR_PFAPR_M1AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M2AP[5:4] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M2AP field. */
#define FMC_RD_PFAPR_M2AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M2AP_MASK) >> FMC_PFAPR_M2AP_SHIFT)
#define FMC_BRD_PFAPR_M2AP(base) (FMC_RD_PFAPR_M2AP(base))

/*! @brief Set the M2AP field to a new value. */
#define FMC_WR_PFAPR_M2AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M2AP_MASK, FMC_PFAPR_M2AP(value)))
#define FMC_BWR_PFAPR_M2AP(base, value) (FMC_WR_PFAPR_M2AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M3AP[7:6] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M3AP field. */
#define FMC_RD_PFAPR_M3AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M3AP_MASK) >> FMC_PFAPR_M3AP_SHIFT)
#define FMC_BRD_PFAPR_M3AP(base) (FMC_RD_PFAPR_M3AP(base))

/*! @brief Set the M3AP field to a new value. */
#define FMC_WR_PFAPR_M3AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M3AP_MASK, FMC_PFAPR_M3AP(value)))
#define FMC_BWR_PFAPR_M3AP(base, value) (FMC_WR_PFAPR_M3AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M0PFD[16] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M0PFD field. */
#define FMC_RD_PFAPR_M0PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M0PFD_MASK) >> FMC_PFAPR_M0PFD_SHIFT)
#define FMC_BRD_PFAPR_M0PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M0PFD_SHIFT))

/*! @brief Set the M0PFD field to a new value. */
#define FMC_WR_PFAPR_M0PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M0PFD_MASK, FMC_PFAPR_M0PFD(value)))
#define FMC_BWR_PFAPR_M0PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M0PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M1PFD[17] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M1PFD field. */
#define FMC_RD_PFAPR_M1PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M1PFD_MASK) >> FMC_PFAPR_M1PFD_SHIFT)
#define FMC_BRD_PFAPR_M1PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M1PFD_SHIFT))

/*! @brief Set the M1PFD field to a new value. */
#define FMC_WR_PFAPR_M1PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M1PFD_MASK, FMC_PFAPR_M1PFD(value)))
#define FMC_BWR_PFAPR_M1PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M1PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M2PFD[18] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M2PFD field. */
#define FMC_RD_PFAPR_M2PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M2PFD_MASK) >> FMC_PFAPR_M2PFD_SHIFT)
#define FMC_BRD_PFAPR_M2PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M2PFD_SHIFT))

/*! @brief Set the M2PFD field to a new value. */
#define FMC_WR_PFAPR_M2PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M2PFD_MASK, FMC_PFAPR_M2PFD(value)))
#define FMC_BWR_PFAPR_M2PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M2PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M3PFD[19] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M3PFD field. */
#define FMC_RD_PFAPR_M3PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M3PFD_MASK) >> FMC_PFAPR_M3PFD_SHIFT)
#define FMC_BRD_PFAPR_M3PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M3PFD_SHIFT))

/*! @brief Set the M3PFD field to a new value. */
#define FMC_WR_PFAPR_M3PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M3PFD_MASK, FMC_PFAPR_M3PFD(value)))
#define FMC_BWR_PFAPR_M3PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M3PFD_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FMC_PFB0CR - Flash Control Register
 ******************************************************************************/

/*!
 * @brief FMC_PFB0CR - Flash Control Register (RW)
 *
 * Reset value: 0x3000001FU
 */
/*!
 * @name Constants and macros for entire FMC_PFB0CR register
 */
/*@{*/
#define FMC_RD_PFB0CR(base)      (FMC_PFB0CR_REG(base))
#define FMC_WR_PFB0CR(base, value) (FMC_PFB0CR_REG(base) = (value))
#define FMC_RMW_PFB0CR(base, mask, value) (FMC_WR_PFB0CR(base, (FMC_RD_PFB0CR(base) & ~(mask)) | (value)))
#define FMC_SET_PFB0CR(base, value) (FMC_WR_PFB0CR(base, FMC_RD_PFB0CR(base) |  (value)))
#define FMC_CLR_PFB0CR(base, value) (FMC_WR_PFB0CR(base, FMC_RD_PFB0CR(base) & ~(value)))
#define FMC_TOG_PFB0CR(base, value) (FMC_WR_PFB0CR(base, FMC_RD_PFB0CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFB0CR bitfields
 */

/*!
 * @name Register FMC_PFB0CR, field B0SEBE[0] (RW)
 *
 * This bit controls whether the single entry page buffer is enabled in response
 * to flash read accesses. A high-to-low transition of this enable forces the
 * page buffer to be invalidated.
 *
 * Values:
 * - 0 - Single entry buffer is disabled.
 * - 1 - Single entry buffer is enabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0SEBE field. */
#define FMC_RD_PFB0CR_B0SEBE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0SEBE_MASK) >> FMC_PFB0CR_B0SEBE_SHIFT)
#define FMC_BRD_PFB0CR_B0SEBE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0SEBE_SHIFT))

/*! @brief Set the B0SEBE field to a new value. */
#define FMC_WR_PFB0CR_B0SEBE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0SEBE_MASK, FMC_PFB0CR_B0SEBE(value)))
#define FMC_BWR_PFB0CR_B0SEBE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0SEBE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0IPE[1] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to instruction fetches.
 *
 * Values:
 * - 0 - Do not prefetch in response to instruction fetches.
 * - 1 - Enable prefetches in response to instruction fetches.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0IPE field. */
#define FMC_RD_PFB0CR_B0IPE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0IPE_MASK) >> FMC_PFB0CR_B0IPE_SHIFT)
#define FMC_BRD_PFB0CR_B0IPE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0IPE_SHIFT))

/*! @brief Set the B0IPE field to a new value. */
#define FMC_WR_PFB0CR_B0IPE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0IPE_MASK, FMC_PFB0CR_B0IPE(value)))
#define FMC_BWR_PFB0CR_B0IPE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0IPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0DPE[2] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to data references.
 *
 * Values:
 * - 0 - Do not prefetch in response to data references.
 * - 1 - Enable prefetches in response to data references.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0DPE field. */
#define FMC_RD_PFB0CR_B0DPE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0DPE_MASK) >> FMC_PFB0CR_B0DPE_SHIFT)
#define FMC_BRD_PFB0CR_B0DPE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0DPE_SHIFT))

/*! @brief Set the B0DPE field to a new value. */
#define FMC_WR_PFB0CR_B0DPE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0DPE_MASK, FMC_PFB0CR_B0DPE(value)))
#define FMC_BWR_PFB0CR_B0DPE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0DPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0ICE[3] (RW)
 *
 * This bit controls whether instruction fetches are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache instruction fetches.
 * - 1 - Cache instruction fetches.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0ICE field. */
#define FMC_RD_PFB0CR_B0ICE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0ICE_MASK) >> FMC_PFB0CR_B0ICE_SHIFT)
#define FMC_BRD_PFB0CR_B0ICE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0ICE_SHIFT))

/*! @brief Set the B0ICE field to a new value. */
#define FMC_WR_PFB0CR_B0ICE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0ICE_MASK, FMC_PFB0CR_B0ICE(value)))
#define FMC_BWR_PFB0CR_B0ICE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0ICE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0DCE[4] (RW)
 *
 * This bit controls whether data references are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache data references.
 * - 1 - Cache data references.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0DCE field. */
#define FMC_RD_PFB0CR_B0DCE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0DCE_MASK) >> FMC_PFB0CR_B0DCE_SHIFT)
#define FMC_BRD_PFB0CR_B0DCE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0DCE_SHIFT))

/*! @brief Set the B0DCE field to a new value. */
#define FMC_WR_PFB0CR_B0DCE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0DCE_MASK, FMC_PFB0CR_B0DCE(value)))
#define FMC_BWR_PFB0CR_B0DCE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0DCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field CRC[7:5] (RW)
 *
 * This 3-bit field defines the replacement algorithm for accesses that are
 * cached.
 *
 * Values:
 * - 000 - LRU replacement algorithm per set across all four ways
 * - 001 - Reserved
 * - 010 - Independent LRU with ways [0-1] for ifetches, [2-3] for data
 * - 011 - Independent LRU with ways [0-2] for ifetches, [3] for data
 * - 1xx - Reserved
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_CRC field. */
#define FMC_RD_PFB0CR_CRC(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_CRC_MASK) >> FMC_PFB0CR_CRC_SHIFT)
#define FMC_BRD_PFB0CR_CRC(base) (FMC_RD_PFB0CR_CRC(base))

/*! @brief Set the CRC field to a new value. */
#define FMC_WR_PFB0CR_CRC(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_CRC_MASK, FMC_PFB0CR_CRC(value)))
#define FMC_BWR_PFB0CR_CRC(base, value) (FMC_WR_PFB0CR_CRC(base, value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0MW[18:17] (RO)
 *
 * This read-only field defines the width of the memory.
 *
 * Values:
 * - 00 - 32 bits
 * - 01 - 64 bits
 * - 1x - Reserved
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0MW field. */
#define FMC_RD_PFB0CR_B0MW(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0MW_MASK) >> FMC_PFB0CR_B0MW_SHIFT)
#define FMC_BRD_PFB0CR_B0MW(base) (FMC_RD_PFB0CR_B0MW(base))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field S_B_INV[19] (WORZ)
 *
 * This bit determines if the FMC's prefetch speculation buffer and the single
 * entry page buffer are to be invalidated (cleared). When this bit is written,
 * the speculation buffer and single entry buffer are immediately cleared. This bit
 * always reads as zero.
 *
 * Values:
 * - 0 - Speculation buffer and single entry buffer are not affected.
 * - 1 - Invalidate (clear) speculation buffer and single entry buffer.
 */
/*@{*/
/*! @brief Set the S_B_INV field to a new value. */
#define FMC_WR_PFB0CR_S_B_INV(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_S_B_INV_MASK, FMC_PFB0CR_S_B_INV(value)))
#define FMC_BWR_PFB0CR_S_B_INV(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_S_B_INV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field CINV_WAY[23:20] (WORZ)
 *
 * These bits determine if the given cache way is to be invalidated (cleared).
 * When a bit within this field is written, the corresponding cache way is
 * immediately invalidated: the way's tag, data, and valid contents are cleared. This
 * field always reads as zero. Cache invalidation takes precedence over locking.
 * The cache is invalidated by system reset. System software is required to
 * maintain memory coherency when any segment of the flash memory is programmed or
 * erased. Accordingly, cache invalidations must occur after a programming or erase
 * event is completed and before the new memory image is accessed. The bit setting
 * definitions are for each bit in the field.
 *
 * Values:
 * - 0 - No cache way invalidation for the corresponding cache
 * - 1 - Invalidate cache way for the corresponding cache: clear the tag, data,
 *     and vld bits of ways selected
 */
/*@{*/
/*! @brief Set the CINV_WAY field to a new value. */
#define FMC_WR_PFB0CR_CINV_WAY(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_CINV_WAY_MASK, FMC_PFB0CR_CINV_WAY(value)))
#define FMC_BWR_PFB0CR_CINV_WAY(base, value) (FMC_WR_PFB0CR_CINV_WAY(base, value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field CLCK_WAY[27:24] (RW)
 *
 * These bits determine if the given cache way is locked such that its contents
 * will not be displaced by future misses. The bit setting definitions are for
 * each bit in the field.
 *
 * Values:
 * - 0 - Cache way is unlocked and may be displaced
 * - 1 - Cache way is locked and its contents are not displaced
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_CLCK_WAY field. */
#define FMC_RD_PFB0CR_CLCK_WAY(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_CLCK_WAY_MASK) >> FMC_PFB0CR_CLCK_WAY_SHIFT)
#define FMC_BRD_PFB0CR_CLCK_WAY(base) (FMC_RD_PFB0CR_CLCK_WAY(base))

/*! @brief Set the CLCK_WAY field to a new value. */
#define FMC_WR_PFB0CR_CLCK_WAY(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_CLCK_WAY_MASK, FMC_PFB0CR_CLCK_WAY(value)))
#define FMC_BWR_PFB0CR_CLCK_WAY(base, value) (FMC_WR_PFB0CR_CLCK_WAY(base, value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0RWSC[31:28] (RO)
 *
 * This read-only field defines the number of wait states required to access the
 * flash memory. The relationship between the read access time of the flash
 * array (expressed in system clock cycles) and RWSC is defined as: Access time of
 * flash array [system clocks] = RWSC + 1 The FMC automatically calculates this
 * value based on the ratio of the system clock speed to the flash clock speed. For
 * example, when this ratio is 4:1, the field's value is 3h.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0RWSC field. */
#define FMC_RD_PFB0CR_B0RWSC(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0RWSC_MASK) >> FMC_PFB0CR_B0RWSC_SHIFT)
#define FMC_BRD_PFB0CR_B0RWSC(base) (FMC_RD_PFB0CR_B0RWSC(base))
/*@}*/

/*******************************************************************************
 * FMC_TAGVD - Cache Tag Storage
 ******************************************************************************/

/*!
 * @brief FMC_TAGVD - Cache Tag Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The 32-entry cache is a 4-way, set-associative cache with 2 sets. The ways
 * are numbered 0-3 and the sets are numbered 0-1. In TAGVDWxSy, x denotes the way,
 * and y denotes the set. This section represents tag/vld information for the 2
 * sets (n=0-1) in way 0.
 */
/*!
 * @name Constants and macros for entire FMC_TAGVD register
 */
/*@{*/
#define FMC_RD_TAGVD(base, index, index2) (FMC_TAGVD_REG(base, index, index2))
#define FMC_WR_TAGVD(base, index, index2, value) (FMC_TAGVD_REG(base, index, index2) = (value))
#define FMC_RMW_TAGVD(base, index, index2, mask, value) (FMC_WR_TAGVD(base, index, index2, (FMC_RD_TAGVD(base, index, index2) & ~(mask)) | (value)))
#define FMC_SET_TAGVD(base, index, index2, value) (FMC_WR_TAGVD(base, index, index2, FMC_RD_TAGVD(base, index, index2) |  (value)))
#define FMC_CLR_TAGVD(base, index, index2, value) (FMC_WR_TAGVD(base, index, index2, FMC_RD_TAGVD(base, index, index2) & ~(value)))
#define FMC_TOG_TAGVD(base, index, index2, value) (FMC_WR_TAGVD(base, index, index2, FMC_RD_TAGVD(base, index, index2) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_TAGVD bitfields
 */

/*!
 * @name Register FMC_TAGVD, field valid[0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVD_valid field. */
#define FMC_RD_TAGVD_valid(base, index, index2) ((FMC_TAGVD_REG(base, index, index2) & FMC_TAGVD_valid_MASK) >> FMC_TAGVD_valid_SHIFT)
#define FMC_BRD_TAGVD_valid(base, index, index2) (BITBAND_ACCESS32(&FMC_TAGVD_REG(base, index, index2), FMC_TAGVD_valid_SHIFT))

/*! @brief Set the valid field to a new value. */
#define FMC_WR_TAGVD_valid(base, index, index2, value) (FMC_RMW_TAGVD(base, index, index2, FMC_TAGVD_valid_MASK, FMC_TAGVD_valid(value)))
#define FMC_BWR_TAGVD_valid(base, index, index2, value) (BITBAND_ACCESS32(&FMC_TAGVD_REG(base, index, index2), FMC_TAGVD_valid_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_TAGVD, field tag[18:6] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVD_tag field. */
#define FMC_RD_TAGVD_tag(base, index, index2) ((FMC_TAGVD_REG(base, index, index2) & FMC_TAGVD_tag_MASK) >> FMC_TAGVD_tag_SHIFT)
#define FMC_BRD_TAGVD_tag(base, index, index2) (FMC_RD_TAGVD_tag(base, index, index2))

/*! @brief Set the tag field to a new value. */
#define FMC_WR_TAGVD_tag(base, index, index2, value) (FMC_RMW_TAGVD(base, index, index2, FMC_TAGVD_tag_MASK, FMC_TAGVD_tag(value)))
#define FMC_BWR_TAGVD_tag(base, index, index2, value) (FMC_WR_TAGVD_tag(base, index, index2, value))
/*@}*/

/*******************************************************************************
 * FMC_DATAW0S - Cache Data Storage
 ******************************************************************************/

/*!
 * @brief FMC_DATAW0S - Cache Data Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of eight 32-bit entries is a 4-way, set-associative cache with 2
 * sets. The ways are numbered 0-3 and the sets are numbered 0-1. In DATAWxSy, x
 * denotes the way, and y denotes the set. This section represents data for bits
 * [31:0] of sets 0-1 in way 0.
 */
/*!
 * @name Constants and macros for entire FMC_DATAW0S register
 */
/*@{*/
#define FMC_RD_DATAW0S(base, index) (FMC_DATAW0S_REG(base, index))
#define FMC_WR_DATAW0S(base, index, value) (FMC_DATAW0S_REG(base, index) = (value))
#define FMC_RMW_DATAW0S(base, index, mask, value) (FMC_WR_DATAW0S(base, index, (FMC_RD_DATAW0S(base, index) & ~(mask)) | (value)))
#define FMC_SET_DATAW0S(base, index, value) (FMC_WR_DATAW0S(base, index, FMC_RD_DATAW0S(base, index) |  (value)))
#define FMC_CLR_DATAW0S(base, index, value) (FMC_WR_DATAW0S(base, index, FMC_RD_DATAW0S(base, index) & ~(value)))
#define FMC_TOG_DATAW0S(base, index, value) (FMC_WR_DATAW0S(base, index, FMC_RD_DATAW0S(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FMC_DATAW1S - Cache Data Storage
 ******************************************************************************/

/*!
 * @brief FMC_DATAW1S - Cache Data Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of eight 32-bit entries is a 4-way, set-associative cache with 2
 * sets. The ways are numbered 0-3 and the sets are numbered 0-1. In DATAWxSy, x
 * denotes the way, and y denotes the set. This section represents data for bits
 * [31:0] of sets 0-1 in way 1.
 */
/*!
 * @name Constants and macros for entire FMC_DATAW1S register
 */
/*@{*/
#define FMC_RD_DATAW1S(base, index) (FMC_DATAW1S_REG(base, index))
#define FMC_WR_DATAW1S(base, index, value) (FMC_DATAW1S_REG(base, index) = (value))
#define FMC_RMW_DATAW1S(base, index, mask, value) (FMC_WR_DATAW1S(base, index, (FMC_RD_DATAW1S(base, index) & ~(mask)) | (value)))
#define FMC_SET_DATAW1S(base, index, value) (FMC_WR_DATAW1S(base, index, FMC_RD_DATAW1S(base, index) |  (value)))
#define FMC_CLR_DATAW1S(base, index, value) (FMC_WR_DATAW1S(base, index, FMC_RD_DATAW1S(base, index) & ~(value)))
#define FMC_TOG_DATAW1S(base, index, value) (FMC_WR_DATAW1S(base, index, FMC_RD_DATAW1S(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FMC_DATAW2S - Cache Data Storage
 ******************************************************************************/

/*!
 * @brief FMC_DATAW2S - Cache Data Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of eight 32-bit entries is a 4-way, set-associative cache with 2
 * sets. The ways are numbered 0-3 and the sets are numbered 0-1. In DATAWxSy, x
 * denotes the way, and y denotes the set. This section represents data for bits
 * [31:0] of sets 0-1 in way 2.
 */
/*!
 * @name Constants and macros for entire FMC_DATAW2S register
 */
/*@{*/
#define FMC_RD_DATAW2S(base, index) (FMC_DATAW2S_REG(base, index))
#define FMC_WR_DATAW2S(base, index, value) (FMC_DATAW2S_REG(base, index) = (value))
#define FMC_RMW_DATAW2S(base, index, mask, value) (FMC_WR_DATAW2S(base, index, (FMC_RD_DATAW2S(base, index) & ~(mask)) | (value)))
#define FMC_SET_DATAW2S(base, index, value) (FMC_WR_DATAW2S(base, index, FMC_RD_DATAW2S(base, index) |  (value)))
#define FMC_CLR_DATAW2S(base, index, value) (FMC_WR_DATAW2S(base, index, FMC_RD_DATAW2S(base, index) & ~(value)))
#define FMC_TOG_DATAW2S(base, index, value) (FMC_WR_DATAW2S(base, index, FMC_RD_DATAW2S(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FMC_DATAW3S - Cache Data Storage
 ******************************************************************************/

/*!
 * @brief FMC_DATAW3S - Cache Data Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of eight 32-bit entries is a 4-way, set-associative cache with 2
 * sets. The ways are numbered 0-3 and the sets are numbered 0-1. In DATAWxSy, x
 * denotes the way, and y denotes the set. This section represents data for bits
 * [31:0] of sets 0-1 in way 3.
 */
/*!
 * @name Constants and macros for entire FMC_DATAW3S register
 */
/*@{*/
#define FMC_RD_DATAW3S(base, index) (FMC_DATAW3S_REG(base, index))
#define FMC_WR_DATAW3S(base, index, value) (FMC_DATAW3S_REG(base, index) = (value))
#define FMC_RMW_DATAW3S(base, index, mask, value) (FMC_WR_DATAW3S(base, index, (FMC_RD_DATAW3S(base, index) & ~(mask)) | (value)))
#define FMC_SET_DATAW3S(base, index, value) (FMC_WR_DATAW3S(base, index, FMC_RD_DATAW3S(base, index) |  (value)))
#define FMC_CLR_DATAW3S(base, index, value) (FMC_WR_DATAW3S(base, index, FMC_RD_DATAW3S(base, index) & ~(value)))
#define FMC_TOG_DATAW3S(base, index, value) (FMC_WR_DATAW3S(base, index, FMC_RD_DATAW3S(base, index) ^  (value)))
/*@}*/

/*
 * MK20D5 FTFL
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - FTFL_FSTAT - Flash Status Register
 * - FTFL_FCNFG - Flash Configuration Register
 * - FTFL_FSEC - Flash Security Register
 * - FTFL_FOPT - Flash Option Register
 * - FTFL_FCCOB3 - Flash Common Command Object Registers
 * - FTFL_FCCOB2 - Flash Common Command Object Registers
 * - FTFL_FCCOB1 - Flash Common Command Object Registers
 * - FTFL_FCCOB0 - Flash Common Command Object Registers
 * - FTFL_FCCOB7 - Flash Common Command Object Registers
 * - FTFL_FCCOB6 - Flash Common Command Object Registers
 * - FTFL_FCCOB5 - Flash Common Command Object Registers
 * - FTFL_FCCOB4 - Flash Common Command Object Registers
 * - FTFL_FCCOBB - Flash Common Command Object Registers
 * - FTFL_FCCOBA - Flash Common Command Object Registers
 * - FTFL_FCCOB9 - Flash Common Command Object Registers
 * - FTFL_FCCOB8 - Flash Common Command Object Registers
 * - FTFL_FPROT3 - Program Flash Protection Registers
 * - FTFL_FPROT2 - Program Flash Protection Registers
 * - FTFL_FPROT1 - Program Flash Protection Registers
 * - FTFL_FPROT0 - Program Flash Protection Registers
 * - FTFL_FEPROT - EEPROM Protection Register
 * - FTFL_FDPROT - Data Flash Protection Register
 */

#define FTFL_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFL module. */
#define FTFL_IDX (0U) /*!< Instance number for FTFL. */

/*******************************************************************************
 * FTFL_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief FTFL_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the FTFL module. The
 * CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The MGSTAT0
 * bit is read only. The unassigned bits read 0 and are not writable. When set, the
 * Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in this
 * register prevent the launch of any more commands until the flag is cleared (by
 * writing a one to it).
 */
/*!
 * @name Constants and macros for entire FTFL_FSTAT register
 */
/*@{*/
#define FTFL_RD_FSTAT(base)      (FTFL_FSTAT_REG(base))
#define FTFL_WR_FSTAT(base, value) (FTFL_FSTAT_REG(base) = (value))
#define FTFL_RMW_FSTAT(base, mask, value) (FTFL_WR_FSTAT(base, (FTFL_RD_FSTAT(base) & ~(mask)) | (value)))
#define FTFL_SET_FSTAT(base, value) (FTFL_WR_FSTAT(base, FTFL_RD_FSTAT(base) |  (value)))
#define FTFL_CLR_FSTAT(base, value) (FTFL_WR_FSTAT(base, FTFL_RD_FSTAT(base) & ~(value)))
#define FTFL_TOG_FSTAT(base, value) (FTFL_WR_FSTAT(base, FTFL_RD_FSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTFL_FSTAT bitfields
 */

/*!
 * @name Register FTFL_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of an
 * FTFL command or during the flash reset sequence. As a status flag, this bit
 * cannot (and need not) be cleared by the user like the other error flags in this
 * register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the previous
 * result is discarded and any previous error is cleared.
 */
/*@{*/
/*! @brief Read current value of the FTFL_FSTAT_MGSTAT0 field. */
#define FTFL_RD_FSTAT_MGSTAT0(base) ((FTFL_FSTAT_REG(base) & FTFL_FSTAT_MGSTAT0_MASK) >> FTFL_FSTAT_MGSTAT0_SHIFT)
#define FTFL_BRD_FSTAT_MGSTAT0(base) (BITBAND_ACCESS8(&FTFL_FSTAT_REG(base), FTFL_FSTAT_MGSTAT0_SHIFT))
/*@}*/

/*!
 * @name Register FTFL_FSTAT, field FPVIOL[4] (W1C)
 *
 * The FPVIOL error bit indicates an attempt was made to program or erase an
 * address in a protected area of program flash or data flash memory during a
 * command write sequence or a write was attempted to a protected area of the FlexRAM
 * while enabled for EEPROM . While FPVIOL is set, the CCIF flag cannot be cleared
 * to launch a command. The FPVIOL bit is cleared by writing a 1 to it. Writing
 * a 0 to the FPVIOL bit has no effect.
 *
 * Values:
 * - 0 - No protection violation detected
 * - 1 - Protection violation detected
 */
/*@{*/
/*! @brief Read current value of the FTFL_FSTAT_FPVIOL field. */
#define FTFL_RD_FSTAT_FPVIOL(base) ((FTFL_FSTAT_REG(base) & FTFL_FSTAT_FPVIOL_MASK) >> FTFL_FSTAT_FPVIOL_SHIFT)
#define FTFL_BRD_FSTAT_FPVIOL(base) (BITBAND_ACCESS8(&FTFL_FSTAT_REG(base), FTFL_FSTAT_FPVIOL_SHIFT))

/*! @brief Set the FPVIOL field to a new value. */
#define FTFL_WR_FSTAT_FPVIOL(base, value) (FTFL_RMW_FSTAT(base, (FTFL_FSTAT_FPVIOL_MASK | FTFL_FSTAT_ACCERR_MASK | FTFL_FSTAT_RDCOLERR_MASK | FTFL_FSTAT_CCIF_MASK), FTFL_FSTAT_FPVIOL(value)))
#define FTFL_BWR_FSTAT_FPVIOL(base, value) (BITBAND_ACCESS8(&FTFL_FSTAT_REG(base), FTFL_FSTAT_FPVIOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFL_FSTAT, field ACCERR[5] (W1C)
 *
 * The ACCERR error bit indicates an illegal access has occurred to an FTFL
 * resource caused by a violation of the command write sequence or issuing an illegal
 * FTFL command. While ACCERR is set, the CCIF flag cannot be cleared to launch
 * a command. The ACCERR bit is cleared by writing a 1 to it. Writing a 0 to the
 * ACCERR bit has no effect.
 *
 * Values:
 * - 0 - No access error detected
 * - 1 - Access error detected
 */
/*@{*/
/*! @brief Read current value of the FTFL_FSTAT_ACCERR field. */
#define FTFL_RD_FSTAT_ACCERR(base) ((FTFL_FSTAT_REG(base) & FTFL_FSTAT_ACCERR_MASK) >> FTFL_FSTAT_ACCERR_SHIFT)
#define FTFL_BRD_FSTAT_ACCERR(base) (BITBAND_ACCESS8(&FTFL_FSTAT_REG(base), FTFL_FSTAT_ACCERR_SHIFT))

/*! @brief Set the ACCERR field to a new value. */
#define FTFL_WR_FSTAT_ACCERR(base, value) (FTFL_RMW_FSTAT(base, (FTFL_FSTAT_ACCERR_MASK | FTFL_FSTAT_FPVIOL_MASK | FTFL_FSTAT_RDCOLERR_MASK | FTFL_FSTAT_CCIF_MASK), FTFL_FSTAT_ACCERR(value)))
#define FTFL_BWR_FSTAT_ACCERR(base, value) (BITBAND_ACCESS8(&FTFL_FSTAT_REG(base), FTFL_FSTAT_ACCERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFL_FSTAT, field RDCOLERR[6] (W1C)
 *
 * The RDCOLERR error bit indicates that the MCU attempted a read from an FTFL
 * resource that was being manipulated by an FTFL command (CCIF=0). Any
 * simultaneous access is detected as a collision error by the block arbitration logic. The
 * read data in this case cannot be guaranteed. The RDCOLERR bit is cleared by
 * writing a 1 to it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0 - No collision error detected
 * - 1 - Collision error detected
 */
/*@{*/
/*! @brief Read current value of the FTFL_FSTAT_RDCOLERR field. */
#define FTFL_RD_FSTAT_RDCOLERR(base) ((FTFL_FSTAT_REG(base) & FTFL_FSTAT_RDCOLERR_MASK) >> FTFL_FSTAT_RDCOLERR_SHIFT)
#define FTFL_BRD_FSTAT_RDCOLERR(base) (BITBAND_ACCESS8(&FTFL_FSTAT_REG(base), FTFL_FSTAT_RDCOLERR_SHIFT))

/*! @brief Set the RDCOLERR field to a new value. */
#define FTFL_WR_FSTAT_RDCOLERR(base, value) (FTFL_RMW_FSTAT(base, (FTFL_FSTAT_RDCOLERR_MASK | FTFL_FSTAT_FPVIOL_MASK | FTFL_FSTAT_ACCERR_MASK | FTFL_FSTAT_CCIF_MASK), FTFL_FSTAT_RDCOLERR(value)))
#define FTFL_BWR_FSTAT_RDCOLERR(base, value) (BITBAND_ACCESS8(&FTFL_FSTAT_REG(base), FTFL_FSTAT_RDCOLERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFL_FSTAT, field CCIF[7] (W1C)
 *
 * The CCIF flag indicates that a FTFL command or EEPROM file system operation
 * has completed. The CCIF flag is cleared by writing a 1 to CCIF to launch a
 * command, and CCIF stays low until command completion or command violation. The
 * CCIF flag is also cleared by a successful write to FlexRAM while enabled for EEE,
 * and CCIF stays low until the EEPROM file system has created the associated
 * EEPROM data record. The CCIF bit is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0 - FTFL command or EEPROM file system operation in progress
 * - 1 - FTFL command or EEPROM file system operation has completed
 */
/*@{*/
/*! @brief Read current value of the FTFL_FSTAT_CCIF field. */
#define FTFL_RD_FSTAT_CCIF(base) ((FTFL_FSTAT_REG(base) & FTFL_FSTAT_CCIF_MASK) >> FTFL_FSTAT_CCIF_SHIFT)
#define FTFL_BRD_FSTAT_CCIF(base) (BITBAND_ACCESS8(&FTFL_FSTAT_REG(base), FTFL_FSTAT_CCIF_SHIFT))

/*! @brief Set the CCIF field to a new value. */
#define FTFL_WR_FSTAT_CCIF(base, value) (FTFL_RMW_FSTAT(base, (FTFL_FSTAT_CCIF_MASK | FTFL_FSTAT_FPVIOL_MASK | FTFL_FSTAT_ACCERR_MASK | FTFL_FSTAT_RDCOLERR_MASK), FTFL_FSTAT_CCIF(value)))
#define FTFL_BWR_FSTAT_CCIF(base, value) (BITBAND_ACCESS8(&FTFL_FSTAT_REG(base), FTFL_FSTAT_CCIF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTFL_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief FTFL_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * FTFL module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. RAMRDY , and EEERDY are read-only status bits . The unassigned bits read as
 * noted and are not writable. The reset values for the RAMRDY , and EEERDY bits
 * are determined during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFL_FCNFG register
 */
/*@{*/
#define FTFL_RD_FCNFG(base)      (FTFL_FCNFG_REG(base))
#define FTFL_WR_FCNFG(base, value) (FTFL_FCNFG_REG(base) = (value))
#define FTFL_RMW_FCNFG(base, mask, value) (FTFL_WR_FCNFG(base, (FTFL_RD_FCNFG(base) & ~(mask)) | (value)))
#define FTFL_SET_FCNFG(base, value) (FTFL_WR_FCNFG(base, FTFL_RD_FCNFG(base) |  (value)))
#define FTFL_CLR_FCNFG(base, value) (FTFL_WR_FCNFG(base, FTFL_RD_FCNFG(base) & ~(value)))
#define FTFL_TOG_FCNFG(base, value) (FTFL_WR_FCNFG(base, FTFL_RD_FCNFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTFL_FCNFG bitfields
 */

/*!
 * @name Register FTFL_FCNFG, field EEERDY[0] (RO)
 *
 * This flag indicates if the EEPROM backup data has been copied to the FlexRAM
 * and is therefore available for read access.
 *
 * Values:
 * - 0 - FlexRAM is not available for EEPROM operation.
 * - 1 - FlexRAM is available for EEPROM operations where: reads from the
 *     FlexRAM return data previously written to the FlexRAM in EEPROM mode and writes
 *     to the FlexRAM clear EEERDY and launch an EEPROM operation to store the
 *     written data in the FlexRAM and EEPROM backup.
 */
/*@{*/
/*! @brief Read current value of the FTFL_FCNFG_EEERDY field. */
#define FTFL_RD_FCNFG_EEERDY(base) ((FTFL_FCNFG_REG(base) & FTFL_FCNFG_EEERDY_MASK) >> FTFL_FCNFG_EEERDY_SHIFT)
#define FTFL_BRD_FCNFG_EEERDY(base) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_EEERDY_SHIFT))
/*@}*/

/*!
 * @name Register FTFL_FCNFG, field RAMRDY[1] (RO)
 *
 * This flag indicates the current status of the FlexRAM . The state of the
 * RAMRDY flag is normally controlled by the Set FlexRAM Function command. During the
 * reset sequence, the RAMRDY flag is cleared if the FlexNVM block is
 * partitioned for EEPROM and is set if the FlexNVM block is not partitioned for EEPROM.
 * The RAMRDY flag is cleared if the Program Partition command is run to partition
 * the FlexNVM block for EEPROM. The RAMRDY flag sets after completion of the
 * Erase All Blocks command or execution of the erase-all operation triggered
 * external to the FTFL .
 *
 * Values:
 * - 0 - FlexRAM is not available for traditional RAM access.
 * - 1 - FlexRAM is available as traditional RAM only; writes to the FlexRAM do
 *     not trigger EEPROM operations.
 */
/*@{*/
/*! @brief Read current value of the FTFL_FCNFG_RAMRDY field. */
#define FTFL_RD_FCNFG_RAMRDY(base) ((FTFL_FCNFG_REG(base) & FTFL_FCNFG_RAMRDY_MASK) >> FTFL_FCNFG_RAMRDY_SHIFT)
#define FTFL_BRD_FCNFG_RAMRDY(base) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_RAMRDY_SHIFT))
/*@}*/

/*!
 * @name Register FTFL_FCNFG, field PFLSH[2] (RO)
 *
 * Values:
 * - 0 - FTFL configured for FlexMemory that supports data flash and/or EEPROM
 * - 1 - Reserved
 */
/*@{*/
/*! @brief Read current value of the FTFL_FCNFG_PFLSH field. */
#define FTFL_RD_FCNFG_PFLSH(base) ((FTFL_FCNFG_REG(base) & FTFL_FCNFG_PFLSH_MASK) >> FTFL_FCNFG_PFLSH_SHIFT)
#define FTFL_BRD_FCNFG_PFLSH(base) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_PFLSH_SHIFT))
/*@}*/

/*!
 * @name Register FTFL_FCNFG, field ERSSUSP[4] (RW)
 *
 * The ERSSUSP bit allows the user to suspend (interrupt) the Erase Flash Sector
 * command while it is executing.
 *
 * Values:
 * - 0 - No suspend requested
 * - 1 - Suspend the current Erase Flash Sector command execution.
 */
/*@{*/
/*! @brief Read current value of the FTFL_FCNFG_ERSSUSP field. */
#define FTFL_RD_FCNFG_ERSSUSP(base) ((FTFL_FCNFG_REG(base) & FTFL_FCNFG_ERSSUSP_MASK) >> FTFL_FCNFG_ERSSUSP_SHIFT)
#define FTFL_BRD_FCNFG_ERSSUSP(base) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_ERSSUSP_SHIFT))

/*! @brief Set the ERSSUSP field to a new value. */
#define FTFL_WR_FCNFG_ERSSUSP(base, value) (FTFL_RMW_FCNFG(base, FTFL_FCNFG_ERSSUSP_MASK, FTFL_FCNFG_ERSSUSP(value)))
#define FTFL_BWR_FCNFG_ERSSUSP(base, value) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_ERSSUSP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFL_FCNFG, field ERSAREQ[5] (RO)
 *
 * This bit issues a request to the memory controller to execute the Erase All
 * Blocks command and release security. ERSAREQ is not directly writable but is
 * under indirect user control. Refer to the device's Chip Configuration details on
 * how to request this command. The ERSAREQ bit sets when an erase all request
 * is triggered external to the FTFL and CCIF is set (no command is currently
 * being executed). ERSAREQ is cleared by the FTFL when the operation completes.
 *
 * Values:
 * - 0 - No request or request complete
 * - 1 - Request to: run the Erase All Blocks command, verify the erased state,
 *     program the security byte in the Flash Configuration Field to the unsecure
 *     state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state.
 */
/*@{*/
/*! @brief Read current value of the FTFL_FCNFG_ERSAREQ field. */
#define FTFL_RD_FCNFG_ERSAREQ(base) ((FTFL_FCNFG_REG(base) & FTFL_FCNFG_ERSAREQ_MASK) >> FTFL_FCNFG_ERSAREQ_SHIFT)
#define FTFL_BRD_FCNFG_ERSAREQ(base) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_ERSAREQ_SHIFT))
/*@}*/

/*!
 * @name Register FTFL_FCNFG, field RDCOLLIE[6] (RW)
 *
 * The RDCOLLIE bit controls interrupt generation when an FTFL read collision
 * error occurs.
 *
 * Values:
 * - 0 - Read collision error interrupt disabled
 * - 1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever an FTFL read collision error is detected (see the description
 *     of FSTAT[RDCOLERR]).
 */
/*@{*/
/*! @brief Read current value of the FTFL_FCNFG_RDCOLLIE field. */
#define FTFL_RD_FCNFG_RDCOLLIE(base) ((FTFL_FCNFG_REG(base) & FTFL_FCNFG_RDCOLLIE_MASK) >> FTFL_FCNFG_RDCOLLIE_SHIFT)
#define FTFL_BRD_FCNFG_RDCOLLIE(base) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_RDCOLLIE_SHIFT))

/*! @brief Set the RDCOLLIE field to a new value. */
#define FTFL_WR_FCNFG_RDCOLLIE(base, value) (FTFL_RMW_FCNFG(base, FTFL_FCNFG_RDCOLLIE_MASK, FTFL_FCNFG_RDCOLLIE(value)))
#define FTFL_BWR_FCNFG_RDCOLLIE(base, value) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_RDCOLLIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFL_FCNFG, field CCIE[7] (RW)
 *
 * The CCIE bit controls interrupt generation when an FTFL command completes.
 *
 * Values:
 * - 0 - Command complete interrupt disabled
 * - 1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
/*! @brief Read current value of the FTFL_FCNFG_CCIE field. */
#define FTFL_RD_FCNFG_CCIE(base) ((FTFL_FCNFG_REG(base) & FTFL_FCNFG_CCIE_MASK) >> FTFL_FCNFG_CCIE_SHIFT)
#define FTFL_BRD_FCNFG_CCIE(base) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_CCIE_SHIFT))

/*! @brief Set the CCIE field to a new value. */
#define FTFL_WR_FCNFG_CCIE(base, value) (FTFL_RMW_FCNFG(base, FTFL_FCNFG_CCIE_MASK, FTFL_FCNFG_CCIE(value)))
#define FTFL_BWR_FCNFG_CCIE(base, value) (BITBAND_ACCESS8(&FTFL_FCNFG_REG(base), FTFL_FCNFG_CCIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTFL_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief FTFL_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and FTFL module. During the reset sequence, the register is loaded with the
 * contents of the flash security byte in the Flash Configuration Field located
 * in program flash memory. The Flash basis for the values is signified by X in
 * the reset value.
 */
/*!
 * @name Constants and macros for entire FTFL_FSEC register
 */
/*@{*/
#define FTFL_RD_FSEC(base)       (FTFL_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual FTFL_FSEC bitfields
 */

/*!
 * @name Register FTFL_FSEC, field SEC[1:0] (RO)
 *
 * These bits define the security state of the MCU. In the secure state, the MCU
 * limits access to FTFL module resources. The limitations are defined per
 * device and are detailed in the Chip Configuration details. If the FTFL module is
 * unsecured using backdoor key access, the SEC bits are forced to 10b.
 *
 * Values:
 * - 00 - MCU security status is secure
 * - 01 - MCU security status is secure
 * - 10 - MCU security status is unsecure (The standard shipping condition of
 *     the FTFL is unsecure.)
 * - 11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the FTFL_FSEC_SEC field. */
#define FTFL_RD_FSEC_SEC(base) ((FTFL_FSEC_REG(base) & FTFL_FSEC_SEC_MASK) >> FTFL_FSEC_SEC_SHIFT)
#define FTFL_BRD_FSEC_SEC(base) (FTFL_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register FTFL_FSEC, field FSLACC[3:2] (RO)
 *
 * These bits enable or disable access to the flash memory contents during
 * returned part failure analysis at Freescale. When SEC is secure and FSLACC is
 * denied, access to the program flash contents is denied and any failure analysis
 * performed by Freescale factory test must begin with a full erase to unsecure the
 * part. When access is granted (SEC is unsecure, or SEC is secure and FSLACC is
 * granted), Freescale factory testing has visibility of the current flash
 * contents. The state of the FSLACC bits is only relevant when the SEC bits are set to
 * secure. When the SEC field is set to unsecure, the FSLACC setting does not
 * matter.
 *
 * Values:
 * - 00 - Freescale factory access granted
 * - 01 - Freescale factory access denied
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the FTFL_FSEC_FSLACC field. */
#define FTFL_RD_FSEC_FSLACC(base) ((FTFL_FSEC_REG(base) & FTFL_FSEC_FSLACC_MASK) >> FTFL_FSEC_FSLACC_SHIFT)
#define FTFL_BRD_FSEC_FSLACC(base) (FTFL_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register FTFL_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the FTFL module. The state of
 * the MEEN bits is only relevant when the SEC bits are set to secure outside of
 * NVM Normal Mode. When the SEC field is set to unsecure, the MEEN setting does
 * not matter.
 *
 * Values:
 * - 00 - Mass erase is enabled
 * - 01 - Mass erase is enabled
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the FTFL_FSEC_MEEN field. */
#define FTFL_RD_FSEC_MEEN(base) ((FTFL_FSEC_REG(base) & FTFL_FSEC_MEEN_MASK) >> FTFL_FSEC_MEEN_SHIFT)
#define FTFL_BRD_FSEC_MEEN(base) (FTFL_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register FTFL_FSEC, field KEYEN[7:6] (RO)
 *
 * These bits enable and disable backdoor key access to the FTFL module.
 *
 * Values:
 * - 00 - Backdoor key access disabled
 * - 01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the FTFL_FSEC_KEYEN field. */
#define FTFL_RD_FSEC_KEYEN(base) ((FTFL_FSEC_REG(base) & FTFL_FSEC_KEYEN_MASK) >> FTFL_FSEC_KEYEN_SHIFT)
#define FTFL_BRD_FSEC_KEYEN(base) (FTFL_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * FTFL_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief FTFL_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only . During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFL_FOPT register
 */
/*@{*/
#define FTFL_RD_FOPT(base)       (FTFL_FOPT_REG(base))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB3 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB3 register
 */
/*@{*/
#define FTFL_RD_FCCOB3(base)     (FTFL_FCCOB3_REG(base))
#define FTFL_WR_FCCOB3(base, value) (FTFL_FCCOB3_REG(base) = (value))
#define FTFL_RMW_FCCOB3(base, mask, value) (FTFL_WR_FCCOB3(base, (FTFL_RD_FCCOB3(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB3(base, value) (FTFL_WR_FCCOB3(base, FTFL_RD_FCCOB3(base) |  (value)))
#define FTFL_CLR_FCCOB3(base, value) (FTFL_WR_FCCOB3(base, FTFL_RD_FCCOB3(base) & ~(value)))
#define FTFL_TOG_FCCOB3(base, value) (FTFL_WR_FCCOB3(base, FTFL_RD_FCCOB3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB2 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB2 register
 */
/*@{*/
#define FTFL_RD_FCCOB2(base)     (FTFL_FCCOB2_REG(base))
#define FTFL_WR_FCCOB2(base, value) (FTFL_FCCOB2_REG(base) = (value))
#define FTFL_RMW_FCCOB2(base, mask, value) (FTFL_WR_FCCOB2(base, (FTFL_RD_FCCOB2(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB2(base, value) (FTFL_WR_FCCOB2(base, FTFL_RD_FCCOB2(base) |  (value)))
#define FTFL_CLR_FCCOB2(base, value) (FTFL_WR_FCCOB2(base, FTFL_RD_FCCOB2(base) & ~(value)))
#define FTFL_TOG_FCCOB2(base, value) (FTFL_WR_FCCOB2(base, FTFL_RD_FCCOB2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB1 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB1 register
 */
/*@{*/
#define FTFL_RD_FCCOB1(base)     (FTFL_FCCOB1_REG(base))
#define FTFL_WR_FCCOB1(base, value) (FTFL_FCCOB1_REG(base) = (value))
#define FTFL_RMW_FCCOB1(base, mask, value) (FTFL_WR_FCCOB1(base, (FTFL_RD_FCCOB1(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB1(base, value) (FTFL_WR_FCCOB1(base, FTFL_RD_FCCOB1(base) |  (value)))
#define FTFL_CLR_FCCOB1(base, value) (FTFL_WR_FCCOB1(base, FTFL_RD_FCCOB1(base) & ~(value)))
#define FTFL_TOG_FCCOB1(base, value) (FTFL_WR_FCCOB1(base, FTFL_RD_FCCOB1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB0 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB0 register
 */
/*@{*/
#define FTFL_RD_FCCOB0(base)     (FTFL_FCCOB0_REG(base))
#define FTFL_WR_FCCOB0(base, value) (FTFL_FCCOB0_REG(base) = (value))
#define FTFL_RMW_FCCOB0(base, mask, value) (FTFL_WR_FCCOB0(base, (FTFL_RD_FCCOB0(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB0(base, value) (FTFL_WR_FCCOB0(base, FTFL_RD_FCCOB0(base) |  (value)))
#define FTFL_CLR_FCCOB0(base, value) (FTFL_WR_FCCOB0(base, FTFL_RD_FCCOB0(base) & ~(value)))
#define FTFL_TOG_FCCOB0(base, value) (FTFL_WR_FCCOB0(base, FTFL_RD_FCCOB0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB7 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB7 register
 */
/*@{*/
#define FTFL_RD_FCCOB7(base)     (FTFL_FCCOB7_REG(base))
#define FTFL_WR_FCCOB7(base, value) (FTFL_FCCOB7_REG(base) = (value))
#define FTFL_RMW_FCCOB7(base, mask, value) (FTFL_WR_FCCOB7(base, (FTFL_RD_FCCOB7(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB7(base, value) (FTFL_WR_FCCOB7(base, FTFL_RD_FCCOB7(base) |  (value)))
#define FTFL_CLR_FCCOB7(base, value) (FTFL_WR_FCCOB7(base, FTFL_RD_FCCOB7(base) & ~(value)))
#define FTFL_TOG_FCCOB7(base, value) (FTFL_WR_FCCOB7(base, FTFL_RD_FCCOB7(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB6 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB6 register
 */
/*@{*/
#define FTFL_RD_FCCOB6(base)     (FTFL_FCCOB6_REG(base))
#define FTFL_WR_FCCOB6(base, value) (FTFL_FCCOB6_REG(base) = (value))
#define FTFL_RMW_FCCOB6(base, mask, value) (FTFL_WR_FCCOB6(base, (FTFL_RD_FCCOB6(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB6(base, value) (FTFL_WR_FCCOB6(base, FTFL_RD_FCCOB6(base) |  (value)))
#define FTFL_CLR_FCCOB6(base, value) (FTFL_WR_FCCOB6(base, FTFL_RD_FCCOB6(base) & ~(value)))
#define FTFL_TOG_FCCOB6(base, value) (FTFL_WR_FCCOB6(base, FTFL_RD_FCCOB6(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB5 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB5 register
 */
/*@{*/
#define FTFL_RD_FCCOB5(base)     (FTFL_FCCOB5_REG(base))
#define FTFL_WR_FCCOB5(base, value) (FTFL_FCCOB5_REG(base) = (value))
#define FTFL_RMW_FCCOB5(base, mask, value) (FTFL_WR_FCCOB5(base, (FTFL_RD_FCCOB5(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB5(base, value) (FTFL_WR_FCCOB5(base, FTFL_RD_FCCOB5(base) |  (value)))
#define FTFL_CLR_FCCOB5(base, value) (FTFL_WR_FCCOB5(base, FTFL_RD_FCCOB5(base) & ~(value)))
#define FTFL_TOG_FCCOB5(base, value) (FTFL_WR_FCCOB5(base, FTFL_RD_FCCOB5(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB4 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB4 register
 */
/*@{*/
#define FTFL_RD_FCCOB4(base)     (FTFL_FCCOB4_REG(base))
#define FTFL_WR_FCCOB4(base, value) (FTFL_FCCOB4_REG(base) = (value))
#define FTFL_RMW_FCCOB4(base, mask, value) (FTFL_WR_FCCOB4(base, (FTFL_RD_FCCOB4(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB4(base, value) (FTFL_WR_FCCOB4(base, FTFL_RD_FCCOB4(base) |  (value)))
#define FTFL_CLR_FCCOB4(base, value) (FTFL_WR_FCCOB4(base, FTFL_RD_FCCOB4(base) & ~(value)))
#define FTFL_TOG_FCCOB4(base, value) (FTFL_WR_FCCOB4(base, FTFL_RD_FCCOB4(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOBB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOBB register
 */
/*@{*/
#define FTFL_RD_FCCOBB(base)     (FTFL_FCCOBB_REG(base))
#define FTFL_WR_FCCOBB(base, value) (FTFL_FCCOBB_REG(base) = (value))
#define FTFL_RMW_FCCOBB(base, mask, value) (FTFL_WR_FCCOBB(base, (FTFL_RD_FCCOBB(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOBB(base, value) (FTFL_WR_FCCOBB(base, FTFL_RD_FCCOBB(base) |  (value)))
#define FTFL_CLR_FCCOBB(base, value) (FTFL_WR_FCCOBB(base, FTFL_RD_FCCOBB(base) & ~(value)))
#define FTFL_TOG_FCCOBB(base, value) (FTFL_WR_FCCOBB(base, FTFL_RD_FCCOBB(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOBA - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOBA register
 */
/*@{*/
#define FTFL_RD_FCCOBA(base)     (FTFL_FCCOBA_REG(base))
#define FTFL_WR_FCCOBA(base, value) (FTFL_FCCOBA_REG(base) = (value))
#define FTFL_RMW_FCCOBA(base, mask, value) (FTFL_WR_FCCOBA(base, (FTFL_RD_FCCOBA(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOBA(base, value) (FTFL_WR_FCCOBA(base, FTFL_RD_FCCOBA(base) |  (value)))
#define FTFL_CLR_FCCOBA(base, value) (FTFL_WR_FCCOBA(base, FTFL_RD_FCCOBA(base) & ~(value)))
#define FTFL_TOG_FCCOBA(base, value) (FTFL_WR_FCCOBA(base, FTFL_RD_FCCOBA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB9 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB9 register
 */
/*@{*/
#define FTFL_RD_FCCOB9(base)     (FTFL_FCCOB9_REG(base))
#define FTFL_WR_FCCOB9(base, value) (FTFL_FCCOB9_REG(base) = (value))
#define FTFL_RMW_FCCOB9(base, mask, value) (FTFL_WR_FCCOB9(base, (FTFL_RD_FCCOB9(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB9(base, value) (FTFL_WR_FCCOB9(base, FTFL_RD_FCCOB9(base) |  (value)))
#define FTFL_CLR_FCCOB9(base, value) (FTFL_WR_FCCOB9(base, FTFL_RD_FCCOB9(base) & ~(value)))
#define FTFL_TOG_FCCOB9(base, value) (FTFL_WR_FCCOB9(base, FTFL_RD_FCCOB9(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FCCOB8 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFL_FCCOB8 register
 */
/*@{*/
#define FTFL_RD_FCCOB8(base)     (FTFL_FCCOB8_REG(base))
#define FTFL_WR_FCCOB8(base, value) (FTFL_FCCOB8_REG(base) = (value))
#define FTFL_RMW_FCCOB8(base, mask, value) (FTFL_WR_FCCOB8(base, (FTFL_RD_FCCOB8(base) & ~(mask)) | (value)))
#define FTFL_SET_FCCOB8(base, value) (FTFL_WR_FCCOB8(base, FTFL_RD_FCCOB8(base) |  (value)))
#define FTFL_CLR_FCCOB8(base, value) (FTFL_WR_FCCOB8(base, FTFL_RD_FCCOB8(base) & ~(value)))
#define FTFL_TOG_FCCOB8(base, value) (FTFL_WR_FCCOB8(base, FTFL_RD_FCCOB8(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FPROT3 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which logical program flash regions are protected
 * from program and erase operations. Protected flash regions cannot have their
 * content changed; that is, these regions cannot be programmed and cannot be
 * erased by any FTFL command. Unprotected regions can be changed by program and
 * erase operations. The four FPROT registers allow 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory. The bitfields are defined
 * in each register as follows: Program flash protection register Program flash
 * protection bits FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3
 * PROT[7:0] During the reset sequence, the FPROT registers are loaded with the
 * contents of the program flash protection bytes in the Flash Configuration Field
 * as indicated in the following table. Program flash protection register Flash
 * Configuration Field offset address FPROT0 0x0008 FPROT1 0x0009 FPROT2 0x000A
 * FPROT3 0x000B To change the program flash protection that is loaded during the
 * reset sequence, unprotect the sector of program flash memory that contains the
 * Flash Configuration Field. Then, reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFL_FPROT3 register
 */
/*@{*/
#define FTFL_RD_FPROT3(base)     (FTFL_FPROT3_REG(base))
#define FTFL_WR_FPROT3(base, value) (FTFL_FPROT3_REG(base) = (value))
#define FTFL_RMW_FPROT3(base, mask, value) (FTFL_WR_FPROT3(base, (FTFL_RD_FPROT3(base) & ~(mask)) | (value)))
#define FTFL_SET_FPROT3(base, value) (FTFL_WR_FPROT3(base, FTFL_RD_FPROT3(base) |  (value)))
#define FTFL_CLR_FPROT3(base, value) (FTFL_WR_FPROT3(base, FTFL_RD_FPROT3(base) & ~(value)))
#define FTFL_TOG_FPROT3(base, value) (FTFL_WR_FPROT3(base, FTFL_RD_FPROT3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FPROT2 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which logical program flash regions are protected
 * from program and erase operations. Protected flash regions cannot have their
 * content changed; that is, these regions cannot be programmed and cannot be
 * erased by any FTFL command. Unprotected regions can be changed by program and
 * erase operations. The four FPROT registers allow 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory. The bitfields are defined
 * in each register as follows: Program flash protection register Program flash
 * protection bits FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3
 * PROT[7:0] During the reset sequence, the FPROT registers are loaded with the
 * contents of the program flash protection bytes in the Flash Configuration Field
 * as indicated in the following table. Program flash protection register Flash
 * Configuration Field offset address FPROT0 0x0008 FPROT1 0x0009 FPROT2 0x000A
 * FPROT3 0x000B To change the program flash protection that is loaded during the
 * reset sequence, unprotect the sector of program flash memory that contains the
 * Flash Configuration Field. Then, reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFL_FPROT2 register
 */
/*@{*/
#define FTFL_RD_FPROT2(base)     (FTFL_FPROT2_REG(base))
#define FTFL_WR_FPROT2(base, value) (FTFL_FPROT2_REG(base) = (value))
#define FTFL_RMW_FPROT2(base, mask, value) (FTFL_WR_FPROT2(base, (FTFL_RD_FPROT2(base) & ~(mask)) | (value)))
#define FTFL_SET_FPROT2(base, value) (FTFL_WR_FPROT2(base, FTFL_RD_FPROT2(base) |  (value)))
#define FTFL_CLR_FPROT2(base, value) (FTFL_WR_FPROT2(base, FTFL_RD_FPROT2(base) & ~(value)))
#define FTFL_TOG_FPROT2(base, value) (FTFL_WR_FPROT2(base, FTFL_RD_FPROT2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FPROT1 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which logical program flash regions are protected
 * from program and erase operations. Protected flash regions cannot have their
 * content changed; that is, these regions cannot be programmed and cannot be
 * erased by any FTFL command. Unprotected regions can be changed by program and
 * erase operations. The four FPROT registers allow 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory. The bitfields are defined
 * in each register as follows: Program flash protection register Program flash
 * protection bits FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3
 * PROT[7:0] During the reset sequence, the FPROT registers are loaded with the
 * contents of the program flash protection bytes in the Flash Configuration Field
 * as indicated in the following table. Program flash protection register Flash
 * Configuration Field offset address FPROT0 0x0008 FPROT1 0x0009 FPROT2 0x000A
 * FPROT3 0x000B To change the program flash protection that is loaded during the
 * reset sequence, unprotect the sector of program flash memory that contains the
 * Flash Configuration Field. Then, reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFL_FPROT1 register
 */
/*@{*/
#define FTFL_RD_FPROT1(base)     (FTFL_FPROT1_REG(base))
#define FTFL_WR_FPROT1(base, value) (FTFL_FPROT1_REG(base) = (value))
#define FTFL_RMW_FPROT1(base, mask, value) (FTFL_WR_FPROT1(base, (FTFL_RD_FPROT1(base) & ~(mask)) | (value)))
#define FTFL_SET_FPROT1(base, value) (FTFL_WR_FPROT1(base, FTFL_RD_FPROT1(base) |  (value)))
#define FTFL_CLR_FPROT1(base, value) (FTFL_WR_FPROT1(base, FTFL_RD_FPROT1(base) & ~(value)))
#define FTFL_TOG_FPROT1(base, value) (FTFL_WR_FPROT1(base, FTFL_RD_FPROT1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FPROT0 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFL_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which logical program flash regions are protected
 * from program and erase operations. Protected flash regions cannot have their
 * content changed; that is, these regions cannot be programmed and cannot be
 * erased by any FTFL command. Unprotected regions can be changed by program and
 * erase operations. The four FPROT registers allow 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory. The bitfields are defined
 * in each register as follows: Program flash protection register Program flash
 * protection bits FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3
 * PROT[7:0] During the reset sequence, the FPROT registers are loaded with the
 * contents of the program flash protection bytes in the Flash Configuration Field
 * as indicated in the following table. Program flash protection register Flash
 * Configuration Field offset address FPROT0 0x0008 FPROT1 0x0009 FPROT2 0x000A
 * FPROT3 0x000B To change the program flash protection that is loaded during the
 * reset sequence, unprotect the sector of program flash memory that contains the
 * Flash Configuration Field. Then, reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFL_FPROT0 register
 */
/*@{*/
#define FTFL_RD_FPROT0(base)     (FTFL_FPROT0_REG(base))
#define FTFL_WR_FPROT0(base, value) (FTFL_FPROT0_REG(base) = (value))
#define FTFL_RMW_FPROT0(base, mask, value) (FTFL_WR_FPROT0(base, (FTFL_RD_FPROT0(base) & ~(mask)) | (value)))
#define FTFL_SET_FPROT0(base, value) (FTFL_WR_FPROT0(base, FTFL_RD_FPROT0(base) |  (value)))
#define FTFL_CLR_FPROT0(base, value) (FTFL_WR_FPROT0(base, FTFL_RD_FPROT0(base) & ~(value)))
#define FTFL_TOG_FPROT0(base, value) (FTFL_WR_FPROT0(base, FTFL_RD_FPROT0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FEPROT - EEPROM Protection Register
 ******************************************************************************/

/*!
 * @brief FTFL_FEPROT - EEPROM Protection Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FEPROT register defines which EEPROM regions of the FlexRAM are protected
 * against program and erase operations. Protected EEPROM regions cannot have
 * their content changed by writing to it. Unprotected regions can be changed by
 * writing to the FlexRAM.
 */
/*!
 * @name Constants and macros for entire FTFL_FEPROT register
 */
/*@{*/
#define FTFL_RD_FEPROT(base)     (FTFL_FEPROT_REG(base))
#define FTFL_WR_FEPROT(base, value) (FTFL_FEPROT_REG(base) = (value))
#define FTFL_RMW_FEPROT(base, mask, value) (FTFL_WR_FEPROT(base, (FTFL_RD_FEPROT(base) & ~(mask)) | (value)))
#define FTFL_SET_FEPROT(base, value) (FTFL_WR_FEPROT(base, FTFL_RD_FEPROT(base) |  (value)))
#define FTFL_CLR_FEPROT(base, value) (FTFL_WR_FEPROT(base, FTFL_RD_FEPROT(base) & ~(value)))
#define FTFL_TOG_FEPROT(base, value) (FTFL_WR_FEPROT(base, FTFL_RD_FEPROT(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFL_FDPROT - Data Flash Protection Register
 ******************************************************************************/

/*!
 * @brief FTFL_FDPROT - Data Flash Protection Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FDPROT register defines which data flash regions are protected against
 * program and erase operations. Protected Flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFL command. Unprotected regions can be changed by both program and erase
 * operations.
 */
/*!
 * @name Constants and macros for entire FTFL_FDPROT register
 */
/*@{*/
#define FTFL_RD_FDPROT(base)     (FTFL_FDPROT_REG(base))
#define FTFL_WR_FDPROT(base, value) (FTFL_FDPROT_REG(base) = (value))
#define FTFL_RMW_FDPROT(base, mask, value) (FTFL_WR_FDPROT(base, (FTFL_RD_FDPROT(base) & ~(mask)) | (value)))
#define FTFL_SET_FDPROT(base, value) (FTFL_WR_FDPROT(base, FTFL_RD_FDPROT(base) |  (value)))
#define FTFL_CLR_FDPROT(base, value) (FTFL_WR_FDPROT(base, FTFL_RD_FDPROT(base) & ~(value)))
#define FTFL_TOG_FDPROT(base, value) (FTFL_WR_FDPROT(base, FTFL_RD_FDPROT(base) ^  (value)))
/*@}*/

/*
 * MK20D5 FTM
 *
 * FlexTimer Module
 *
 * Registers defined in this header file:
 * - FTM_SC - Status and Control
 * - FTM_CNT - Counter
 * - FTM_MOD - Modulo
 * - FTM_CnSC - Channel (n) Status and Control
 * - FTM_CnV - Channel (n) Value
 * - FTM_CNTIN - Counter Initial Value
 * - FTM_STATUS - Capture and Compare Status
 * - FTM_MODE - Features Mode Selection
 * - FTM_SYNC - Synchronization
 * - FTM_OUTINIT - Initial State for Channels Output
 * - FTM_OUTMASK - Output Mask
 * - FTM_COMBINE - Function for Linked Channels
 * - FTM_DEADTIME - Deadtime Insertion Control
 * - FTM_EXTTRIG - FTM External Trigger
 * - FTM_POL - Channels Polarity
 * - FTM_FMS - Fault Mode Status
 * - FTM_FILTER - Input Capture Filter Control
 * - FTM_FLTCTRL - Fault Control
 * - FTM_QDCTRL - Quadrature Decoder Control and Status
 * - FTM_CONF - Configuration
 * - FTM_FLTPOL - FTM Fault Input Polarity
 * - FTM_SYNCONF - Synchronization Configuration
 * - FTM_INVCTRL - FTM Inverting Control
 * - FTM_SWOCTRL - FTM Software Output Control
 * - FTM_PWMLOAD - FTM PWM Load
 */

#define FTM_INSTANCE_COUNT (2U) /*!< Number of instances of the FTM module. */
#define FTM0_IDX (0U) /*!< Instance number for FTM0. */
#define FTM1_IDX (1U) /*!< Instance number for FTM1. */

/*******************************************************************************
 * FTM_SC - Status and Control
 ******************************************************************************/

/*!
 * @brief FTM_SC - Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, FTM configuration, clock source, and prescaler factor. These
 * controls relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire FTM_SC register
 */
/*@{*/
#define FTM_RD_SC(base)          (FTM_SC_REG(base))
#define FTM_WR_SC(base, value)   (FTM_SC_REG(base) = (value))
#define FTM_RMW_SC(base, mask, value) (FTM_WR_SC(base, (FTM_RD_SC(base) & ~(mask)) | (value)))
#define FTM_SET_SC(base, value)  (FTM_WR_SC(base, FTM_RD_SC(base) |  (value)))
#define FTM_CLR_SC(base, value)  (FTM_WR_SC(base, FTM_RD_SC(base) & ~(value)))
#define FTM_TOG_SC(base, value)  (FTM_WR_SC(base, FTM_RD_SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SC bitfields
 */

/*!
 * @name Register FTM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock source selected by CLKS. The
 * new prescaler factor affects the clock source on the next system clock cycle
 * after the new value is updated into the register bits. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 000 - Divide by 1
 * - 001 - Divide by 2
 * - 010 - Divide by 4
 * - 011 - Divide by 8
 * - 100 - Divide by 16
 * - 101 - Divide by 32
 * - 110 - Divide by 64
 * - 111 - Divide by 128
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PS field. */
#define FTM_RD_SC_PS(base)   ((FTM_SC_REG(base) & FTM_SC_PS_MASK) >> FTM_SC_PS_SHIFT)
#define FTM_BRD_SC_PS(base)  (FTM_RD_SC_PS(base))

/*! @brief Set the PS field to a new value. */
#define FTM_WR_SC_PS(base, value) (FTM_RMW_SC(base, FTM_SC_PS_MASK, FTM_SC_PS(value)))
#define FTM_BWR_SC_PS(base, value) (FTM_WR_SC_PS(base, value))
/*@}*/

/*!
 * @name Register FTM_SC, field CLKS[4:3] (RW)
 *
 * Selects one of the three FTM counter clock sources. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 00 - No clock selected (This in effect disables the FTM counter.)
 * - 01 - System clock
 * - 10 - Fixed frequency clock
 * - 11 - External clock
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_CLKS field. */
#define FTM_RD_SC_CLKS(base) ((FTM_SC_REG(base) & FTM_SC_CLKS_MASK) >> FTM_SC_CLKS_SHIFT)
#define FTM_BRD_SC_CLKS(base) (FTM_RD_SC_CLKS(base))

/*! @brief Set the CLKS field to a new value. */
#define FTM_WR_SC_CLKS(base, value) (FTM_RMW_SC(base, FTM_SC_CLKS_MASK, FTM_SC_CLKS(value)))
#define FTM_BWR_SC_CLKS(base, value) (FTM_WR_SC_CLKS(base, value))
/*@}*/

/*!
 * @name Register FTM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the FTM to operate in up-down
 * counting mode. This field is write protected. It can be written only when MODE[WPDIS]
 * = 1.
 *
 * Values:
 * - 0 - FTM counter operates in up counting mode.
 * - 1 - FTM counter operates in up-down counting mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_CPWMS field. */
#define FTM_RD_SC_CPWMS(base) ((FTM_SC_REG(base) & FTM_SC_CPWMS_MASK) >> FTM_SC_CPWMS_SHIFT)
#define FTM_BRD_SC_CPWMS(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_CPWMS_SHIFT))

/*! @brief Set the CPWMS field to a new value. */
#define FTM_WR_SC_CPWMS(base, value) (FTM_RMW_SC(base, FTM_SC_CPWMS_MASK, FTM_SC_CPWMS(value)))
#define FTM_BWR_SC_CPWMS(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_CPWMS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field TOIE[6] (RW)
 *
 * Enables FTM overflow interrupts.
 *
 * Values:
 * - 0 - Disable TOF interrupts. Use software polling.
 * - 1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_TOIE field. */
#define FTM_RD_SC_TOIE(base) ((FTM_SC_REG(base) & FTM_SC_TOIE_MASK) >> FTM_SC_TOIE_SHIFT)
#define FTM_BRD_SC_TOIE(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_TOIE_SHIFT))

/*! @brief Set the TOIE field to a new value. */
#define FTM_WR_SC_TOIE(base, value) (FTM_RMW_SC(base, FTM_SC_TOIE_MASK, FTM_SC_TOIE(value)))
#define FTM_BWR_SC_TOIE(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_TOIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field TOF[7] (ROWZ)
 *
 * Set by hardware when the FTM counter passes the value in the MOD register.
 * The TOF bit is cleared by reading the SC register while TOF is set and then
 * writing a 0 to TOF bit. Writing a 1 to TOF has no effect. If another FTM overflow
 * occurs between the read and write operations, the write operation has no
 * effect; therefore, TOF remains set indicating an overflow has occurred. In this
 * case a TOF interrupt request is not lost due to the clearing sequence for a
 * previous TOF.
 *
 * Values:
 * - 0 - FTM counter has not overflowed.
 * - 1 - FTM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_TOF field. */
#define FTM_RD_SC_TOF(base)  ((FTM_SC_REG(base) & FTM_SC_TOF_MASK) >> FTM_SC_TOF_SHIFT)
#define FTM_BRD_SC_TOF(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_TOF_SHIFT))

/*! @brief Set the TOF field to a new value. */
#define FTM_WR_SC_TOF(base, value) (FTM_RMW_SC(base, FTM_SC_TOF_MASK, FTM_SC_TOF(value)))
#define FTM_BWR_SC_TOF(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_TOF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief FTM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the FTM counter value. Reset clears the CNT
 * register. Writing any value to COUNT updates the counter with its initial value
 * (CNTIN). When BDM is active, the FTM counter is frozen (this is the value that you
 * may read).
 */
/*!
 * @name Constants and macros for entire FTM_CNT register
 */
/*@{*/
#define FTM_RD_CNT(base)         (FTM_CNT_REG(base))
#define FTM_WR_CNT(base, value)  (FTM_CNT_REG(base) = (value))
#define FTM_RMW_CNT(base, mask, value) (FTM_WR_CNT(base, (FTM_RD_CNT(base) & ~(mask)) | (value)))
#define FTM_SET_CNT(base, value) (FTM_WR_CNT(base, FTM_RD_CNT(base) |  (value)))
#define FTM_CLR_CNT(base, value) (FTM_WR_CNT(base, FTM_RD_CNT(base) & ~(value)))
#define FTM_TOG_CNT(base, value) (FTM_WR_CNT(base, FTM_RD_CNT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNT bitfields
 */

/*!
 * @name Register FTM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_CNT_COUNT field. */
#define FTM_RD_CNT_COUNT(base) ((FTM_CNT_REG(base) & FTM_CNT_COUNT_MASK) >> FTM_CNT_COUNT_SHIFT)
#define FTM_BRD_CNT_COUNT(base) (FTM_RD_CNT_COUNT(base))

/*! @brief Set the COUNT field to a new value. */
#define FTM_WR_CNT_COUNT(base, value) (FTM_RMW_CNT(base, FTM_CNT_COUNT_MASK, FTM_CNT_COUNT(value)))
#define FTM_BWR_CNT_COUNT(base, value) (FTM_WR_CNT_COUNT(base, value))
/*@}*/

/*******************************************************************************
 * FTM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief FTM_MOD - Modulo (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Modulo register contains the modulo value for the FTM counter. After the
 * FTM counter reaches the modulo value, the overflow flag (TOF) becomes set at
 * the next clock, and the next value of FTM counter depends on the selected
 * counting method (Counter). Writing to the MOD register latches the value into a
 * buffer. The MOD register is updated with the value of its write buffer according
 * to Registers Updated from Write Buffers. If FTMEN = 0, this write coherency
 * mechanism may be manually reset by writing to the SC register (whether BDM is
 * active or not). It is recommended to initialize the FTM counter (write to CNT)
 * before writing to the MOD register to avoid confusion about when the first
 * counter overflow will occur.
 */
/*!
 * @name Constants and macros for entire FTM_MOD register
 */
/*@{*/
#define FTM_RD_MOD(base)         (FTM_MOD_REG(base))
#define FTM_WR_MOD(base, value)  (FTM_MOD_REG(base) = (value))
#define FTM_RMW_MOD(base, mask, value) (FTM_WR_MOD(base, (FTM_RD_MOD(base) & ~(mask)) | (value)))
#define FTM_SET_MOD(base, value) (FTM_WR_MOD(base, FTM_RD_MOD(base) |  (value)))
#define FTM_CLR_MOD(base, value) (FTM_WR_MOD(base, FTM_RD_MOD(base) & ~(value)))
#define FTM_TOG_MOD(base, value) (FTM_WR_MOD(base, FTM_RD_MOD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_MOD bitfields
 */

/*!
 * @name Register FTM_MOD, field MOD[15:0] (RW)
 *
 * Modulo value
 */
/*@{*/
/*! @brief Read current value of the FTM_MOD_MOD field. */
#define FTM_RD_MOD_MOD(base) ((FTM_MOD_REG(base) & FTM_MOD_MOD_MASK) >> FTM_MOD_MOD_SHIFT)
#define FTM_BRD_MOD_MOD(base) (FTM_RD_MOD_MOD(base))

/*! @brief Set the MOD field to a new value. */
#define FTM_WR_MOD_MOD(base, value) (FTM_RMW_MOD(base, FTM_MOD_MOD_MASK, FTM_MOD_MOD(value)))
#define FTM_BWR_MOD_MOD(base, value) (FTM_WR_MOD_MOD(base, value))
/*@}*/

/*******************************************************************************
 * FTM_CnSC - Channel (n) Status and Control
 ******************************************************************************/

/*!
 * @brief FTM_CnSC - Channel (n) Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. Mode,
 * Edge, and Level Selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 0 None Pin not used for FTM 0 0 0 0 1 Input capture Capture
 * on Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or
 * Falling Edge 1 1 Output compare Toggle Output on match 10 Clear Output on match
 * 11 Set Output on match 1X 10 Edge-aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match,
 * and set on channel (n+1) match) 1 0 0 X0 See the following table
 * (#ModeSel2Table). Dual Edge Capture Mode One-shot capture mode X1 Continuous capture mode
 * Dual Edge Capture Mode - Edge Polarity Selection ELSnB ELSnA Channel Port
 * Enable Detected Edges 0 0 Disabled No edge 0 1 Enabled Rising edge 1 0 Enabled
 * Falling edge 1 1 Enabled Rising and falling edges
 */
/*!
 * @name Constants and macros for entire FTM_CnSC register
 */
/*@{*/
#define FTM_RD_CnSC(base, index) (FTM_CnSC_REG(base, index))
#define FTM_WR_CnSC(base, index, value) (FTM_CnSC_REG(base, index) = (value))
#define FTM_RMW_CnSC(base, index, mask, value) (FTM_WR_CnSC(base, index, (FTM_RD_CnSC(base, index) & ~(mask)) | (value)))
#define FTM_SET_CnSC(base, index, value) (FTM_WR_CnSC(base, index, FTM_RD_CnSC(base, index) |  (value)))
#define FTM_CLR_CnSC(base, index, value) (FTM_WR_CnSC(base, index, FTM_RD_CnSC(base, index) & ~(value)))
#define FTM_TOG_CnSC(base, index, value) (FTM_WR_CnSC(base, index, FTM_RD_CnSC(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CnSC bitfields
 */

/*!
 * @name Register FTM_CnSC, field DMA[0] (RW)
 *
 * Values:
 * - 0 - Disable DMA transfers.
 * - 1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_DMA field. */
#define FTM_RD_CnSC_DMA(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_DMA_MASK) >> FTM_CnSC_DMA_SHIFT)
#define FTM_BRD_CnSC_DMA(base, index) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_CnSC_DMA(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_DMA_MASK, FTM_CnSC_DMA(value)))
#define FTM_BWR_CnSC_DMA(base, index, value) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ELSA[2] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_ELSA field. */
#define FTM_RD_CnSC_ELSA(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_ELSA_MASK) >> FTM_CnSC_ELSA_SHIFT)
#define FTM_BRD_CnSC_ELSA(base, index) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_CnSC_ELSA(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_ELSA_MASK, FTM_CnSC_ELSA(value)))
#define FTM_BWR_CnSC_ELSA(base, index, value) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ELSB[3] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_ELSB field. */
#define FTM_RD_CnSC_ELSB(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_ELSB_MASK) >> FTM_CnSC_ELSB_SHIFT)
#define FTM_BRD_CnSC_ELSB(base, index) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_CnSC_ELSB(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_ELSB_MASK, FTM_CnSC_ELSB(value)))
#define FTM_BWR_CnSC_ELSB(base, index, value) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_CnSC, field MSA[4] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_MSA field. */
#define FTM_RD_CnSC_MSA(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_MSA_MASK) >> FTM_CnSC_MSA_SHIFT)
#define FTM_BRD_CnSC_MSA(base, index) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_CnSC_MSA(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_MSA_MASK, FTM_CnSC_MSA(value)))
#define FTM_BWR_CnSC_MSA(base, index, value) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_CnSC, field MSB[5] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_MSB field. */
#define FTM_RD_CnSC_MSB(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_MSB_MASK) >> FTM_CnSC_MSB_SHIFT)
#define FTM_BRD_CnSC_MSB(base, index) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_CnSC_MSB(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_MSB_MASK, FTM_CnSC_MSB(value)))
#define FTM_BWR_CnSC_MSB(base, index, value) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_CnSC, field CHIE[6] (RW)
 *
 * Values:
 * - 0 - Disable channel interrupts. Use software polling.
 * - 1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_CHIE field. */
#define FTM_RD_CnSC_CHIE(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_CHIE_MASK) >> FTM_CnSC_CHIE_SHIFT)
#define FTM_BRD_CnSC_CHIE(base, index) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_CnSC_CHIE(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_CHIE_MASK, FTM_CnSC_CHIE(value)))
#define FTM_BWR_CnSC_CHIE(base, index, value) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_CnSC, field CHF[7] (ROWZ)
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_CHF field. */
#define FTM_RD_CnSC_CHF(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_CHF_MASK) >> FTM_CnSC_CHF_SHIFT)
#define FTM_BRD_CnSC_CHF(base, index) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_CnSC_CHF(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_CHF_MASK, FTM_CnSC_CHF(value)))
#define FTM_BWR_CnSC_CHF(base, index, value) (BITBAND_ACCESS32(&FTM_CnSC_REG(base, index), FTM_CnSC_CHF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_CnV - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In input capture, capture test, and
 * dual edge capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers Updated from
 * Write Buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register (whether BDM mode is active or not).
 */
/*!
 * @name Constants and macros for entire FTM_CnV register
 */
/*@{*/
#define FTM_RD_CnV(base, index)  (FTM_CnV_REG(base, index))
#define FTM_WR_CnV(base, index, value) (FTM_CnV_REG(base, index) = (value))
#define FTM_RMW_CnV(base, index, mask, value) (FTM_WR_CnV(base, index, (FTM_RD_CnV(base, index) & ~(mask)) | (value)))
#define FTM_SET_CnV(base, index, value) (FTM_WR_CnV(base, index, FTM_RD_CnV(base, index) |  (value)))
#define FTM_CLR_CnV(base, index, value) (FTM_WR_CnV(base, index, FTM_RD_CnV(base, index) & ~(value)))
#define FTM_TOG_CnV(base, index, value) (FTM_WR_CnV(base, index, FTM_RD_CnV(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CnV bitfields
 */

/*!
 * @name Register FTM_CnV, field VAL[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_CnV_VAL field. */
#define FTM_RD_CnV_VAL(base, index) ((FTM_CnV_REG(base, index) & FTM_CnV_VAL_MASK) >> FTM_CnV_VAL_SHIFT)
#define FTM_BRD_CnV_VAL(base, index) (FTM_RD_CnV_VAL(base, index))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_CnV_VAL(base, index, value) (FTM_RMW_CnV(base, index, FTM_CnV_VAL_MASK, FTM_CnV_VAL(value)))
#define FTM_BWR_CnV_VAL(base, index, value) (FTM_WR_CnV_VAL(base, index, value))
/*@}*/

/*******************************************************************************
 * FTM_CNTIN - Counter Initial Value
 ******************************************************************************/

/*!
 * @brief FTM_CNTIN - Counter Initial Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Counter Initial Value register contains the initial value for the FTM
 * counter. Writing to the CNTIN register latches the value into a buffer. The CNTIN
 * register is updated with the value of its write buffer according to Registers
 * Updated from Write Buffers. The first time that the FTM clock is selected
 * (first write to change the CLKS bits to a non-zero value), the FTM counter starts
 * with the value 0x0000. To avoid this behavior, before the first write to
 * select the FTM clock, write the new value to the the CNTIN register and then
 * initialize the FTM counter (write any value to the CNT register).
 */
/*!
 * @name Constants and macros for entire FTM_CNTIN register
 */
/*@{*/
#define FTM_RD_CNTIN(base)       (FTM_CNTIN_REG(base))
#define FTM_WR_CNTIN(base, value) (FTM_CNTIN_REG(base) = (value))
#define FTM_RMW_CNTIN(base, mask, value) (FTM_WR_CNTIN(base, (FTM_RD_CNTIN(base) & ~(mask)) | (value)))
#define FTM_SET_CNTIN(base, value) (FTM_WR_CNTIN(base, FTM_RD_CNTIN(base) |  (value)))
#define FTM_CLR_CNTIN(base, value) (FTM_WR_CNTIN(base, FTM_RD_CNTIN(base) & ~(value)))
#define FTM_TOG_CNTIN(base, value) (FTM_WR_CNTIN(base, FTM_RD_CNTIN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNTIN bitfields
 */

/*!
 * @name Register FTM_CNTIN, field INIT[15:0] (RW)
 *
 * Initial Value of the FTM Counter
 */
/*@{*/
/*! @brief Read current value of the FTM_CNTIN_INIT field. */
#define FTM_RD_CNTIN_INIT(base) ((FTM_CNTIN_REG(base) & FTM_CNTIN_INIT_MASK) >> FTM_CNTIN_INIT_SHIFT)
#define FTM_BRD_CNTIN_INIT(base) (FTM_RD_CNTIN_INIT(base))

/*! @brief Set the INIT field to a new value. */
#define FTM_WR_CNTIN_INIT(base, value) (FTM_RMW_CNTIN(base, FTM_CNTIN_INIT_MASK, FTM_CNTIN_INIT(value)))
#define FTM_BWR_CNTIN_INIT(base, value) (FTM_WR_CNTIN_INIT(base, value))
/*@}*/

/*******************************************************************************
 * FTM_STATUS - Capture and Compare Status
 ******************************************************************************/

/*!
 * @brief FTM_STATUS - Capture and Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag CHnF bit (in CnSC) for
 * each FTM channel for software convenience. Each CHnF bit in STATUS is a
 * mirror of CHnF bit in CnSC. All CHnF bits can be checked using only one read of
 * STATUS. All CHnF bits can be cleared by reading STATUS followed by writing 0x00
 * to STATUS. Hardware sets the individual channel flags when an event occurs on
 * the channel. CHF is cleared by reading STATUS while CHnF is set and then
 * writing a 0 to the CHF bit. Writing a 1 to CHF has no effect. If another event
 * occurs between the read and write operations, the write operation has no effect;
 * therefore, CHF remains set indicating an event has occurred. In this case a CHF
 * interrupt request is not lost due to the clearing sequence for a previous CHF.
 * The STATUS register should be used only combine mode.
 */
/*!
 * @name Constants and macros for entire FTM_STATUS register
 */
/*@{*/
#define FTM_RD_STATUS(base)      (FTM_STATUS_REG(base))
#define FTM_WR_STATUS(base, value) (FTM_STATUS_REG(base) = (value))
#define FTM_RMW_STATUS(base, mask, value) (FTM_WR_STATUS(base, (FTM_RD_STATUS(base) & ~(mask)) | (value)))
#define FTM_SET_STATUS(base, value) (FTM_WR_STATUS(base, FTM_RD_STATUS(base) |  (value)))
#define FTM_CLR_STATUS(base, value) (FTM_WR_STATUS(base, FTM_RD_STATUS(base) & ~(value)))
#define FTM_TOG_STATUS(base, value) (FTM_WR_STATUS(base, FTM_RD_STATUS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_STATUS bitfields
 */

/*!
 * @name Register FTM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH0F field. */
#define FTM_RD_STATUS_CH0F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH0F_MASK) >> FTM_STATUS_CH0F_SHIFT)
#define FTM_BRD_STATUS_CH0F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH0F_SHIFT))

/*! @brief Set the CH0F field to a new value. */
#define FTM_WR_STATUS_CH0F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH0F(value)))
#define FTM_BWR_STATUS_CH0F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH0F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH1F field. */
#define FTM_RD_STATUS_CH1F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH1F_MASK) >> FTM_STATUS_CH1F_SHIFT)
#define FTM_BRD_STATUS_CH1F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH1F_SHIFT))

/*! @brief Set the CH1F field to a new value. */
#define FTM_WR_STATUS_CH1F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH1F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH1F(value)))
#define FTM_BWR_STATUS_CH1F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH1F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH2F field. */
#define FTM_RD_STATUS_CH2F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH2F_MASK) >> FTM_STATUS_CH2F_SHIFT)
#define FTM_BRD_STATUS_CH2F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH2F_SHIFT))

/*! @brief Set the CH2F field to a new value. */
#define FTM_WR_STATUS_CH2F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH2F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH2F(value)))
#define FTM_BWR_STATUS_CH2F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH2F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH3F field. */
#define FTM_RD_STATUS_CH3F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH3F_MASK) >> FTM_STATUS_CH3F_SHIFT)
#define FTM_BRD_STATUS_CH3F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH3F_SHIFT))

/*! @brief Set the CH3F field to a new value. */
#define FTM_WR_STATUS_CH3F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH3F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH3F(value)))
#define FTM_BWR_STATUS_CH3F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH3F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH4F[4] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH4F field. */
#define FTM_RD_STATUS_CH4F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH4F_MASK) >> FTM_STATUS_CH4F_SHIFT)
#define FTM_BRD_STATUS_CH4F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH4F_SHIFT))

/*! @brief Set the CH4F field to a new value. */
#define FTM_WR_STATUS_CH4F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH4F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH4F(value)))
#define FTM_BWR_STATUS_CH4F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH4F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH5F[5] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH5F field. */
#define FTM_RD_STATUS_CH5F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH5F_MASK) >> FTM_STATUS_CH5F_SHIFT)
#define FTM_BRD_STATUS_CH5F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH5F_SHIFT))

/*! @brief Set the CH5F field to a new value. */
#define FTM_WR_STATUS_CH5F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH5F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH5F(value)))
#define FTM_BWR_STATUS_CH5F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH5F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH6F[6] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH6F field. */
#define FTM_RD_STATUS_CH6F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH6F_MASK) >> FTM_STATUS_CH6F_SHIFT)
#define FTM_BRD_STATUS_CH6F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH6F_SHIFT))

/*! @brief Set the CH6F field to a new value. */
#define FTM_WR_STATUS_CH6F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH6F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH6F(value)))
#define FTM_BWR_STATUS_CH6F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH6F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH7F[7] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH7F field. */
#define FTM_RD_STATUS_CH7F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH7F_MASK) >> FTM_STATUS_CH7F_SHIFT)
#define FTM_BRD_STATUS_CH7F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH7F_SHIFT))

/*! @brief Set the CH7F field to a new value. */
#define FTM_WR_STATUS_CH7F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH7F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK), FTM_STATUS_CH7F(value)))
#define FTM_BWR_STATUS_CH7F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH7F_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_MODE - Features Mode Selection
 ******************************************************************************/

/*!
 * @brief FTM_MODE - Features Mode Selection (RW)
 *
 * Reset value: 0x00000004U
 *
 * This register contains the control bits used to configure the fault interrupt
 * and fault control, capture test mode, PWM synchronization, write protection,
 * channel output initialization, and enable the enhanced features of the FTM.
 * These controls relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire FTM_MODE register
 */
/*@{*/
#define FTM_RD_MODE(base)        (FTM_MODE_REG(base))
#define FTM_WR_MODE(base, value) (FTM_MODE_REG(base) = (value))
#define FTM_RMW_MODE(base, mask, value) (FTM_WR_MODE(base, (FTM_RD_MODE(base) & ~(mask)) | (value)))
#define FTM_SET_MODE(base, value) (FTM_WR_MODE(base, FTM_RD_MODE(base) |  (value)))
#define FTM_CLR_MODE(base, value) (FTM_WR_MODE(base, FTM_RD_MODE(base) & ~(value)))
#define FTM_TOG_MODE(base, value) (FTM_WR_MODE(base, FTM_RD_MODE(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_MODE bitfields
 */

/*!
 * @name Register FTM_MODE, field FTMEN[0] (RW)
 *
 * This field is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Only the TPM-compatible registers (first set of registers) can be used
 *     without any restriction. Do not use the FTM-specific registers.
 * - 1 - All registers including the FTM-specific registers (second set of
 *     registers) are available for use with no restrictions.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FTMEN field. */
#define FTM_RD_MODE_FTMEN(base) ((FTM_MODE_REG(base) & FTM_MODE_FTMEN_MASK) >> FTM_MODE_FTMEN_SHIFT)
#define FTM_BRD_MODE_FTMEN(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_FTMEN_SHIFT))

/*! @brief Set the FTMEN field to a new value. */
#define FTM_WR_MODE_FTMEN(base, value) (FTM_RMW_MODE(base, FTM_MODE_FTMEN_MASK, FTM_MODE_FTMEN(value)))
#define FTM_BWR_MODE_FTMEN(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_FTMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field INIT[1] (RW)
 *
 * When a 1 is written to INIT bit the channels output is initialized according
 * to the state of their corresponding bit in the OUTINIT register. Writing a 0
 * to INIT bit has no effect. The INIT bit is always read as 0.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_INIT field. */
#define FTM_RD_MODE_INIT(base) ((FTM_MODE_REG(base) & FTM_MODE_INIT_MASK) >> FTM_MODE_INIT_SHIFT)
#define FTM_BRD_MODE_INIT(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_INIT_SHIFT))

/*! @brief Set the INIT field to a new value. */
#define FTM_WR_MODE_INIT(base, value) (FTM_RMW_MODE(base, FTM_MODE_INIT_MASK, FTM_MODE_INIT(value)))
#define FTM_BWR_MODE_INIT(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_INIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field WPDIS[2] (RW)
 *
 * When write protection is enabled (WPDIS = 0), write protected bits can not be
 * written. When write protection is disabled (WPDIS = 1), write protected bits
 * can be written. The WPDIS bit is the negation of the WPEN bit. WPDIS is
 * cleared when 1 is written to WPEN. WPDIS is set when WPEN bit is read as a 1 and
 * then 1 is written to WPDIS. Writing 0 to WPDIS has no effect.
 *
 * Values:
 * - 0 - Write protection is enabled.
 * - 1 - Write protection is disabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_WPDIS field. */
#define FTM_RD_MODE_WPDIS(base) ((FTM_MODE_REG(base) & FTM_MODE_WPDIS_MASK) >> FTM_MODE_WPDIS_SHIFT)
#define FTM_BRD_MODE_WPDIS(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_WPDIS_SHIFT))

/*! @brief Set the WPDIS field to a new value. */
#define FTM_WR_MODE_WPDIS(base, value) (FTM_RMW_MODE(base, FTM_MODE_WPDIS_MASK, FTM_MODE_WPDIS(value)))
#define FTM_BWR_MODE_WPDIS(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_WPDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field PWMSYNC[3] (RW)
 *
 * Selects which triggers can be used by MOD, CnV, OUTMASK, and FTM counter
 * synchronization (PWM Synchronization). The PWMSYNC bit configures the
 * synchronization when SYNCMODE is zero.
 *
 * Values:
 * - 0 - No restrictions. Software and hardware triggers can be used by MOD,
 *     CnV, OUTMASK, and FTM counter synchronization.
 * - 1 - Software trigger can only be used by MOD and CnV synchronization, and
 *     hardware triggers can only be used by OUTMASK and FTM counter
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_PWMSYNC field. */
#define FTM_RD_MODE_PWMSYNC(base) ((FTM_MODE_REG(base) & FTM_MODE_PWMSYNC_MASK) >> FTM_MODE_PWMSYNC_SHIFT)
#define FTM_BRD_MODE_PWMSYNC(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_PWMSYNC_SHIFT))

/*! @brief Set the PWMSYNC field to a new value. */
#define FTM_WR_MODE_PWMSYNC(base, value) (FTM_RMW_MODE(base, FTM_MODE_PWMSYNC_MASK, FTM_MODE_PWMSYNC(value)))
#define FTM_BWR_MODE_PWMSYNC(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_PWMSYNC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field CAPTEST[4] (RW)
 *
 * Enables the capture test mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Capture test mode is disabled.
 * - 1 - Capture test mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_CAPTEST field. */
#define FTM_RD_MODE_CAPTEST(base) ((FTM_MODE_REG(base) & FTM_MODE_CAPTEST_MASK) >> FTM_MODE_CAPTEST_SHIFT)
#define FTM_BRD_MODE_CAPTEST(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_CAPTEST_SHIFT))

/*! @brief Set the CAPTEST field to a new value. */
#define FTM_WR_MODE_CAPTEST(base, value) (FTM_RMW_MODE(base, FTM_MODE_CAPTEST_MASK, FTM_MODE_CAPTEST(value)))
#define FTM_BWR_MODE_CAPTEST(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_CAPTEST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTM[6:5] (RW)
 *
 * Defines the FTM fault control mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 00 - Fault control is disabled for all channels.
 * - 01 - Fault control is enabled for even channels only (channels 0, 2, 4, and
 *     6), and the selected mode is the manual fault clearing.
 * - 10 - Fault control is enabled for all channels, and the selected mode is
 *     the manual fault clearing.
 * - 11 - Fault control is enabled for all channels, and the selected mode is
 *     the automatic fault clearing.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FAULTM field. */
#define FTM_RD_MODE_FAULTM(base) ((FTM_MODE_REG(base) & FTM_MODE_FAULTM_MASK) >> FTM_MODE_FAULTM_SHIFT)
#define FTM_BRD_MODE_FAULTM(base) (FTM_RD_MODE_FAULTM(base))

/*! @brief Set the FAULTM field to a new value. */
#define FTM_WR_MODE_FAULTM(base, value) (FTM_RMW_MODE(base, FTM_MODE_FAULTM_MASK, FTM_MODE_FAULTM(value)))
#define FTM_BWR_MODE_FAULTM(base, value) (FTM_WR_MODE_FAULTM(base, value))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTIE[7] (RW)
 *
 * Enables the generation of an interrupt when a fault is detected by FTM and
 * the FTM fault control is enabled.
 *
 * Values:
 * - 0 - Fault control interrupt is disabled.
 * - 1 - Fault control interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FAULTIE field. */
#define FTM_RD_MODE_FAULTIE(base) ((FTM_MODE_REG(base) & FTM_MODE_FAULTIE_MASK) >> FTM_MODE_FAULTIE_SHIFT)
#define FTM_BRD_MODE_FAULTIE(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_FAULTIE_SHIFT))

/*! @brief Set the FAULTIE field to a new value. */
#define FTM_WR_MODE_FAULTIE(base, value) (FTM_RMW_MODE(base, FTM_MODE_FAULTIE_MASK, FTM_MODE_FAULTIE(value)))
#define FTM_BWR_MODE_FAULTIE(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_FAULTIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_SYNC - Synchronization
 ******************************************************************************/

/*!
 * @brief FTM_SYNC - Synchronization (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the PWM synchronization. A synchronization event can
 * perform the synchronized update of MOD, CV, and OUTMASK registers with the
 * value of their write buffer and the FTM counter initialization. The software
 * trigger (SWSYNC bit) and hardware triggers (TRIG0, TRIG1, and TRIG2 bits) have a
 * potential conflict if used together when SYNCMODE = 0. It is recommended using
 * only hardware or software triggers but not both at the same time, otherwise
 * unpredictable behavior is likely to happen. The selection of the loading point
 * (CNTMAX and CNTMIN bits) is intended to provide the update of MOD, CNTIN, and
 * CnV registers across all enabled channels simultaneously. The use of the
 * loading point selection together with SYNCMODE = 0 and hardware trigger selection
 * (TRIG0, TRIG1, or TRIG2 bits) is likely to result in unpredictable behavior.
 * The synchronization event selection also depends on the PWMSYNC (MODE register)
 * and SYNCMODE (SYNCONF register) bits. See PWM Synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_SYNC register
 */
/*@{*/
#define FTM_RD_SYNC(base)        (FTM_SYNC_REG(base))
#define FTM_WR_SYNC(base, value) (FTM_SYNC_REG(base) = (value))
#define FTM_RMW_SYNC(base, mask, value) (FTM_WR_SYNC(base, (FTM_RD_SYNC(base) & ~(mask)) | (value)))
#define FTM_SET_SYNC(base, value) (FTM_WR_SYNC(base, FTM_RD_SYNC(base) |  (value)))
#define FTM_CLR_SYNC(base, value) (FTM_WR_SYNC(base, FTM_RD_SYNC(base) & ~(value)))
#define FTM_TOG_SYNC(base, value) (FTM_WR_SYNC(base, FTM_RD_SYNC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNC bitfields
 */

/*!
 * @name Register FTM_SYNC, field CNTMIN[0] (RW)
 *
 * Selects the minimum loading point to PWM synchronization (Boundary Cycle and
 * Loading Points). If CNTMIN is one, the selected loading point is when the FTM
 * counter reaches its minimum value (CNTIN register).
 *
 * Values:
 * - 0 - The minimum loading point is disabled.
 * - 1 - The minimum loading point is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_CNTMIN field. */
#define FTM_RD_SYNC_CNTMIN(base) ((FTM_SYNC_REG(base) & FTM_SYNC_CNTMIN_MASK) >> FTM_SYNC_CNTMIN_SHIFT)
#define FTM_BRD_SYNC_CNTMIN(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMIN_SHIFT))

/*! @brief Set the CNTMIN field to a new value. */
#define FTM_WR_SYNC_CNTMIN(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_CNTMIN_MASK, FTM_SYNC_CNTMIN(value)))
#define FTM_BWR_SYNC_CNTMIN(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field CNTMAX[1] (RW)
 *
 * Selects the maximum loading point to PWM synchronization (Boundary Cycle and
 * Loading Points). If CNTMAX is one, the selected loading point is when the FTM
 * counter reaches its maximum value (MOD register).
 *
 * Values:
 * - 0 - The maximum loading point is disabled.
 * - 1 - The maximum loading point is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_CNTMAX field. */
#define FTM_RD_SYNC_CNTMAX(base) ((FTM_SYNC_REG(base) & FTM_SYNC_CNTMAX_MASK) >> FTM_SYNC_CNTMAX_SHIFT)
#define FTM_BRD_SYNC_CNTMAX(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMAX_SHIFT))

/*! @brief Set the CNTMAX field to a new value. */
#define FTM_WR_SYNC_CNTMAX(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_CNTMAX_MASK, FTM_SYNC_CNTMAX(value)))
#define FTM_BWR_SYNC_CNTMAX(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMAX_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field REINIT[2] (RW)
 *
 * Determines if the FTM counter is reinitialized when the selected trigger for
 * the synchronization is detected. The REINIT bit configures the synchronization
 * when SYNCMODE is zero.
 *
 * Values:
 * - 0 - FTM counter continues to count normally.
 * - 1 - FTM counter is updated with its initial value when the selected trigger
 *     is detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_REINIT field. */
#define FTM_RD_SYNC_REINIT(base) ((FTM_SYNC_REG(base) & FTM_SYNC_REINIT_MASK) >> FTM_SYNC_REINIT_SHIFT)
#define FTM_BRD_SYNC_REINIT(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_REINIT_SHIFT))

/*! @brief Set the REINIT field to a new value. */
#define FTM_WR_SYNC_REINIT(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_REINIT_MASK, FTM_SYNC_REINIT(value)))
#define FTM_BWR_SYNC_REINIT(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_REINIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SYNCHOM[3] (RW)
 *
 * Selects when the OUTMASK register is updated with the value of its buffer.
 *
 * Values:
 * - 0 - OUTMASK register is updated with the value of its buffer in all rising
 *     edges of the system clock.
 * - 1 - OUTMASK register is updated with the value of its buffer only by the
 *     PWM synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_SYNCHOM field. */
#define FTM_RD_SYNC_SYNCHOM(base) ((FTM_SYNC_REG(base) & FTM_SYNC_SYNCHOM_MASK) >> FTM_SYNC_SYNCHOM_SHIFT)
#define FTM_BRD_SYNC_SYNCHOM(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_SYNCHOM_SHIFT))

/*! @brief Set the SYNCHOM field to a new value. */
#define FTM_WR_SYNC_SYNCHOM(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_SYNCHOM_MASK, FTM_SYNC_SYNCHOM(value)))
#define FTM_BWR_SYNC_SYNCHOM(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_SYNCHOM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG0[4] (RW)
 *
 * Enables hardware trigger 0 to the PWM synchronization. Hardware trigger 0
 * happens when a rising edge is detected at the trigger 0 input signal.
 *
 * Values:
 * - 0 - Trigger is disabled.
 * - 1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG0 field. */
#define FTM_RD_SYNC_TRIG0(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG0_MASK) >> FTM_SYNC_TRIG0_SHIFT)
#define FTM_BRD_SYNC_TRIG0(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG0_SHIFT))

/*! @brief Set the TRIG0 field to a new value. */
#define FTM_WR_SYNC_TRIG0(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG0_MASK, FTM_SYNC_TRIG0(value)))
#define FTM_BWR_SYNC_TRIG0(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG1[5] (RW)
 *
 * Enables hardware trigger 1 to the PWM synchronization. Hardware trigger 1
 * happens when a rising edge is detected at the trigger 1 input signal.
 *
 * Values:
 * - 0 - Trigger is disabled.
 * - 1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG1 field. */
#define FTM_RD_SYNC_TRIG1(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG1_MASK) >> FTM_SYNC_TRIG1_SHIFT)
#define FTM_BRD_SYNC_TRIG1(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG1_SHIFT))

/*! @brief Set the TRIG1 field to a new value. */
#define FTM_WR_SYNC_TRIG1(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG1_MASK, FTM_SYNC_TRIG1(value)))
#define FTM_BWR_SYNC_TRIG1(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG2[6] (RW)
 *
 * Enables hardware trigger 2 to the PWM synchronization. Hardware trigger 2
 * happens when a rising edge is detected at the trigger 2 input signal.
 *
 * Values:
 * - 0 - Trigger is disabled.
 * - 1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG2 field. */
#define FTM_RD_SYNC_TRIG2(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG2_MASK) >> FTM_SYNC_TRIG2_SHIFT)
#define FTM_BRD_SYNC_TRIG2(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG2_SHIFT))

/*! @brief Set the TRIG2 field to a new value. */
#define FTM_WR_SYNC_TRIG2(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG2_MASK, FTM_SYNC_TRIG2(value)))
#define FTM_BWR_SYNC_TRIG2(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SWSYNC[7] (RW)
 *
 * Selects the software trigger as the PWM synchronization trigger. The software
 * trigger happens when a 1 is written to SWSYNC bit.
 *
 * Values:
 * - 0 - Software trigger is not selected.
 * - 1 - Software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_SWSYNC field. */
#define FTM_RD_SYNC_SWSYNC(base) ((FTM_SYNC_REG(base) & FTM_SYNC_SWSYNC_MASK) >> FTM_SYNC_SWSYNC_SHIFT)
#define FTM_BRD_SYNC_SWSYNC(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_SWSYNC_SHIFT))

/*! @brief Set the SWSYNC field to a new value. */
#define FTM_WR_SYNC_SWSYNC(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_SWSYNC_MASK, FTM_SYNC_SWSYNC(value)))
#define FTM_BWR_SYNC_SWSYNC(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_SWSYNC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_OUTINIT - Initial State for Channels Output
 ******************************************************************************/

/*!
 * @brief FTM_OUTINIT - Initial State for Channels Output (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FTM_OUTINIT register
 */
/*@{*/
#define FTM_RD_OUTINIT(base)     (FTM_OUTINIT_REG(base))
#define FTM_WR_OUTINIT(base, value) (FTM_OUTINIT_REG(base) = (value))
#define FTM_RMW_OUTINIT(base, mask, value) (FTM_WR_OUTINIT(base, (FTM_RD_OUTINIT(base) & ~(mask)) | (value)))
#define FTM_SET_OUTINIT(base, value) (FTM_WR_OUTINIT(base, FTM_RD_OUTINIT(base) |  (value)))
#define FTM_CLR_OUTINIT(base, value) (FTM_WR_OUTINIT(base, FTM_RD_OUTINIT(base) & ~(value)))
#define FTM_TOG_OUTINIT(base, value) (FTM_WR_OUTINIT(base, FTM_RD_OUTINIT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTINIT bitfields
 */

/*!
 * @name Register FTM_OUTINIT, field CH0OI[0] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH0OI field. */
#define FTM_RD_OUTINIT_CH0OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH0OI_MASK) >> FTM_OUTINIT_CH0OI_SHIFT)
#define FTM_BRD_OUTINIT_CH0OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH0OI_SHIFT))

/*! @brief Set the CH0OI field to a new value. */
#define FTM_WR_OUTINIT_CH0OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH0OI_MASK, FTM_OUTINIT_CH0OI(value)))
#define FTM_BWR_OUTINIT_CH0OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH0OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH1OI[1] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH1OI field. */
#define FTM_RD_OUTINIT_CH1OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH1OI_MASK) >> FTM_OUTINIT_CH1OI_SHIFT)
#define FTM_BRD_OUTINIT_CH1OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH1OI_SHIFT))

/*! @brief Set the CH1OI field to a new value. */
#define FTM_WR_OUTINIT_CH1OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH1OI_MASK, FTM_OUTINIT_CH1OI(value)))
#define FTM_BWR_OUTINIT_CH1OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH1OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH2OI[2] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH2OI field. */
#define FTM_RD_OUTINIT_CH2OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH2OI_MASK) >> FTM_OUTINIT_CH2OI_SHIFT)
#define FTM_BRD_OUTINIT_CH2OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH2OI_SHIFT))

/*! @brief Set the CH2OI field to a new value. */
#define FTM_WR_OUTINIT_CH2OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH2OI_MASK, FTM_OUTINIT_CH2OI(value)))
#define FTM_BWR_OUTINIT_CH2OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH2OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH3OI[3] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH3OI field. */
#define FTM_RD_OUTINIT_CH3OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH3OI_MASK) >> FTM_OUTINIT_CH3OI_SHIFT)
#define FTM_BRD_OUTINIT_CH3OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH3OI_SHIFT))

/*! @brief Set the CH3OI field to a new value. */
#define FTM_WR_OUTINIT_CH3OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH3OI_MASK, FTM_OUTINIT_CH3OI(value)))
#define FTM_BWR_OUTINIT_CH3OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH3OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH4OI[4] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH4OI field. */
#define FTM_RD_OUTINIT_CH4OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH4OI_MASK) >> FTM_OUTINIT_CH4OI_SHIFT)
#define FTM_BRD_OUTINIT_CH4OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH4OI_SHIFT))

/*! @brief Set the CH4OI field to a new value. */
#define FTM_WR_OUTINIT_CH4OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH4OI_MASK, FTM_OUTINIT_CH4OI(value)))
#define FTM_BWR_OUTINIT_CH4OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH4OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH5OI[5] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH5OI field. */
#define FTM_RD_OUTINIT_CH5OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH5OI_MASK) >> FTM_OUTINIT_CH5OI_SHIFT)
#define FTM_BRD_OUTINIT_CH5OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH5OI_SHIFT))

/*! @brief Set the CH5OI field to a new value. */
#define FTM_WR_OUTINIT_CH5OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH5OI_MASK, FTM_OUTINIT_CH5OI(value)))
#define FTM_BWR_OUTINIT_CH5OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH5OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH6OI[6] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH6OI field. */
#define FTM_RD_OUTINIT_CH6OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH6OI_MASK) >> FTM_OUTINIT_CH6OI_SHIFT)
#define FTM_BRD_OUTINIT_CH6OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH6OI_SHIFT))

/*! @brief Set the CH6OI field to a new value. */
#define FTM_WR_OUTINIT_CH6OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH6OI_MASK, FTM_OUTINIT_CH6OI(value)))
#define FTM_BWR_OUTINIT_CH6OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH6OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH7OI[7] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH7OI field. */
#define FTM_RD_OUTINIT_CH7OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH7OI_MASK) >> FTM_OUTINIT_CH7OI_SHIFT)
#define FTM_BRD_OUTINIT_CH7OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH7OI_SHIFT))

/*! @brief Set the CH7OI field to a new value. */
#define FTM_WR_OUTINIT_CH7OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH7OI_MASK, FTM_OUTINIT_CH7OI(value)))
#define FTM_BWR_OUTINIT_CH7OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH7OI_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_OUTMASK - Output Mask
 ******************************************************************************/

/*!
 * @brief FTM_OUTMASK - Output Mask (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register provides a mask for each FTM channel. The mask of a channel
 * determines if its output responds (that is, it is masked or not) when a match
 * occurs. This feature is used for BLDC control where the PWM signal is presented
 * to an electric motor at specific times to provide electronic commutation. Any
 * write to the OUTMASK register, stores the value in its write buffer. The
 * register is updated with the value of its write buffer according to PWM
 * Synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_OUTMASK register
 */
/*@{*/
#define FTM_RD_OUTMASK(base)     (FTM_OUTMASK_REG(base))
#define FTM_WR_OUTMASK(base, value) (FTM_OUTMASK_REG(base) = (value))
#define FTM_RMW_OUTMASK(base, mask, value) (FTM_WR_OUTMASK(base, (FTM_RD_OUTMASK(base) & ~(mask)) | (value)))
#define FTM_SET_OUTMASK(base, value) (FTM_WR_OUTMASK(base, FTM_RD_OUTMASK(base) |  (value)))
#define FTM_CLR_OUTMASK(base, value) (FTM_WR_OUTMASK(base, FTM_RD_OUTMASK(base) & ~(value)))
#define FTM_TOG_OUTMASK(base, value) (FTM_WR_OUTMASK(base, FTM_RD_OUTMASK(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTMASK bitfields
 */

/*!
 * @name Register FTM_OUTMASK, field CH0OM[0] (RW)
 *
 * Defines if the channel output is masked (forced to its inactive state) or
 * unmasked (it continues to operate normally).
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH0OM field. */
#define FTM_RD_OUTMASK_CH0OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH0OM_MASK) >> FTM_OUTMASK_CH0OM_SHIFT)
#define FTM_BRD_OUTMASK_CH0OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH0OM_SHIFT))

/*! @brief Set the CH0OM field to a new value. */
#define FTM_WR_OUTMASK_CH0OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH0OM_MASK, FTM_OUTMASK_CH0OM(value)))
#define FTM_BWR_OUTMASK_CH0OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH0OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH1OM[1] (RW)
 *
 * Defines if the channel output is masked (forced to its inactive state) or
 * unmasked (it continues to operate normally).
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH1OM field. */
#define FTM_RD_OUTMASK_CH1OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH1OM_MASK) >> FTM_OUTMASK_CH1OM_SHIFT)
#define FTM_BRD_OUTMASK_CH1OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH1OM_SHIFT))

/*! @brief Set the CH1OM field to a new value. */
#define FTM_WR_OUTMASK_CH1OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH1OM_MASK, FTM_OUTMASK_CH1OM(value)))
#define FTM_BWR_OUTMASK_CH1OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH1OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH2OM[2] (RW)
 *
 * Defines if the channel output is masked (forced to its inactive state) or
 * unmasked (it continues to operate normally).
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH2OM field. */
#define FTM_RD_OUTMASK_CH2OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH2OM_MASK) >> FTM_OUTMASK_CH2OM_SHIFT)
#define FTM_BRD_OUTMASK_CH2OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH2OM_SHIFT))

/*! @brief Set the CH2OM field to a new value. */
#define FTM_WR_OUTMASK_CH2OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH2OM_MASK, FTM_OUTMASK_CH2OM(value)))
#define FTM_BWR_OUTMASK_CH2OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH2OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH3OM[3] (RW)
 *
 * Defines if the channel output is masked (forced to its inactive state) or
 * unmasked (it continues to operate normally).
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH3OM field. */
#define FTM_RD_OUTMASK_CH3OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH3OM_MASK) >> FTM_OUTMASK_CH3OM_SHIFT)
#define FTM_BRD_OUTMASK_CH3OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH3OM_SHIFT))

/*! @brief Set the CH3OM field to a new value. */
#define FTM_WR_OUTMASK_CH3OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH3OM_MASK, FTM_OUTMASK_CH3OM(value)))
#define FTM_BWR_OUTMASK_CH3OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH3OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH4OM[4] (RW)
 *
 * Defines if the channel output is masked (forced to its inactive state) or
 * unmasked (it continues to operate normally).
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH4OM field. */
#define FTM_RD_OUTMASK_CH4OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH4OM_MASK) >> FTM_OUTMASK_CH4OM_SHIFT)
#define FTM_BRD_OUTMASK_CH4OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH4OM_SHIFT))

/*! @brief Set the CH4OM field to a new value. */
#define FTM_WR_OUTMASK_CH4OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH4OM_MASK, FTM_OUTMASK_CH4OM(value)))
#define FTM_BWR_OUTMASK_CH4OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH4OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH5OM[5] (RW)
 *
 * Defines if the channel output is masked (forced to its inactive state) or
 * unmasked (it continues to operate normally).
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH5OM field. */
#define FTM_RD_OUTMASK_CH5OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH5OM_MASK) >> FTM_OUTMASK_CH5OM_SHIFT)
#define FTM_BRD_OUTMASK_CH5OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH5OM_SHIFT))

/*! @brief Set the CH5OM field to a new value. */
#define FTM_WR_OUTMASK_CH5OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH5OM_MASK, FTM_OUTMASK_CH5OM(value)))
#define FTM_BWR_OUTMASK_CH5OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH5OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH6OM[6] (RW)
 *
 * Defines if the channel output is masked (forced to its inactive state) or
 * unmasked (it continues to operate normally).
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH6OM field. */
#define FTM_RD_OUTMASK_CH6OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH6OM_MASK) >> FTM_OUTMASK_CH6OM_SHIFT)
#define FTM_BRD_OUTMASK_CH6OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH6OM_SHIFT))

/*! @brief Set the CH6OM field to a new value. */
#define FTM_WR_OUTMASK_CH6OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH6OM_MASK, FTM_OUTMASK_CH6OM(value)))
#define FTM_BWR_OUTMASK_CH6OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH6OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH7OM[7] (RW)
 *
 * Defines if the channel output is masked (forced to its inactive state) or
 * unmasked (it continues to operate normally).
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH7OM field. */
#define FTM_RD_OUTMASK_CH7OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH7OM_MASK) >> FTM_OUTMASK_CH7OM_SHIFT)
#define FTM_BRD_OUTMASK_CH7OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH7OM_SHIFT))

/*! @brief Set the CH7OM field to a new value. */
#define FTM_WR_OUTMASK_CH7OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH7OM_MASK, FTM_OUTMASK_CH7OM(value)))
#define FTM_BWR_OUTMASK_CH7OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH7OM_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_COMBINE - Function for Linked Channels
 ******************************************************************************/

/*!
 * @brief FTM_COMBINE - Function for Linked Channels (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the control bits used to configure the fault control,
 * synchronization, deadtime insertion, dual edge capture mode, complementary,
 * and combine mode for each pair of channels (n) and (n+1), where n equals 0, 2,
 * 4, and 6.
 */
/*!
 * @name Constants and macros for entire FTM_COMBINE register
 */
/*@{*/
#define FTM_RD_COMBINE(base)     (FTM_COMBINE_REG(base))
#define FTM_WR_COMBINE(base, value) (FTM_COMBINE_REG(base) = (value))
#define FTM_RMW_COMBINE(base, mask, value) (FTM_WR_COMBINE(base, (FTM_RD_COMBINE(base) & ~(mask)) | (value)))
#define FTM_SET_COMBINE(base, value) (FTM_WR_COMBINE(base, FTM_RD_COMBINE(base) |  (value)))
#define FTM_CLR_COMBINE(base, value) (FTM_WR_COMBINE(base, FTM_RD_COMBINE(base) & ~(value)))
#define FTM_TOG_COMBINE(base, value) (FTM_WR_COMBINE(base, FTM_RD_COMBINE(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_COMBINE bitfields
 */

/*!
 * @name Register FTM_COMBINE, field COMBINE0[0] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE0 field. */
#define FTM_RD_COMBINE_COMBINE0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE0_MASK) >> FTM_COMBINE_COMBINE0_SHIFT)
#define FTM_BRD_COMBINE_COMBINE0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE0_SHIFT))

/*! @brief Set the COMBINE0 field to a new value. */
#define FTM_WR_COMBINE_COMBINE0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE0_MASK, FTM_COMBINE_COMBINE0(value)))
#define FTM_BWR_COMBINE_COMBINE0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP0[1] (RW)
 *
 * Enables complementary mode for the combined channels. In complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP0 field. */
#define FTM_RD_COMBINE_COMP0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP0_MASK) >> FTM_COMBINE_COMP0_SHIFT)
#define FTM_BRD_COMBINE_COMP0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP0_SHIFT))

/*! @brief Set the COMP0 field to a new value. */
#define FTM_WR_COMBINE_COMP0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP0_MASK, FTM_COMBINE_COMP0(value)))
#define FTM_BWR_COMBINE_COMP0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN0[2] (RW)
 *
 * Enables the dual edge capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * dual edge capture mode according to #ModeSel1Table. This field applies only
 * when FTMEN = 1. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The dual edge capture mode in this pair of channels is disabled.
 * - 1 - The dual edge capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN0 field. */
#define FTM_RD_COMBINE_DECAPEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN0_MASK) >> FTM_COMBINE_DECAPEN0_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN0_SHIFT))

/*! @brief Set the DECAPEN0 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN0_MASK, FTM_COMBINE_DECAPEN0(value)))
#define FTM_BWR_COMBINE_DECAPEN0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP0[3] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when FTMEN = 1 and DECAPEN = 1. DECAP bit is cleared automatically by
 * hardware if dual edge capture - one-shot mode is selected and when the capture
 * of channel (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP0 field. */
#define FTM_RD_COMBINE_DECAP0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP0_MASK) >> FTM_COMBINE_DECAP0_SHIFT)
#define FTM_BRD_COMBINE_DECAP0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP0_SHIFT))

/*! @brief Set the DECAP0 field to a new value. */
#define FTM_WR_COMBINE_DECAP0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP0_MASK, FTM_COMBINE_DECAP0(value)))
#define FTM_BWR_COMBINE_DECAP0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN0[4] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN0 field. */
#define FTM_RD_COMBINE_DTEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN0_MASK) >> FTM_COMBINE_DTEN0_SHIFT)
#define FTM_BRD_COMBINE_DTEN0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN0_SHIFT))

/*! @brief Set the DTEN0 field to a new value. */
#define FTM_WR_COMBINE_DTEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN0_MASK, FTM_COMBINE_DTEN0(value)))
#define FTM_BWR_COMBINE_DTEN0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN0[5] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN0 field. */
#define FTM_RD_COMBINE_SYNCEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN0_MASK) >> FTM_COMBINE_SYNCEN0_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN0_SHIFT))

/*! @brief Set the SYNCEN0 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN0_MASK, FTM_COMBINE_SYNCEN0(value)))
#define FTM_BWR_COMBINE_SYNCEN0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN0[6] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN0 field. */
#define FTM_RD_COMBINE_FAULTEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN0_MASK) >> FTM_COMBINE_FAULTEN0_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN0_SHIFT))

/*! @brief Set the FAULTEN0 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN0_MASK, FTM_COMBINE_FAULTEN0(value)))
#define FTM_BWR_COMBINE_FAULTEN0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE1[8] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE1 field. */
#define FTM_RD_COMBINE_COMBINE1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE1_MASK) >> FTM_COMBINE_COMBINE1_SHIFT)
#define FTM_BRD_COMBINE_COMBINE1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE1_SHIFT))

/*! @brief Set the COMBINE1 field to a new value. */
#define FTM_WR_COMBINE_COMBINE1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE1_MASK, FTM_COMBINE_COMBINE1(value)))
#define FTM_BWR_COMBINE_COMBINE1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP1[9] (RW)
 *
 * Enables complementary mode for the combined channels. In complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP1 field. */
#define FTM_RD_COMBINE_COMP1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP1_MASK) >> FTM_COMBINE_COMP1_SHIFT)
#define FTM_BRD_COMBINE_COMP1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP1_SHIFT))

/*! @brief Set the COMP1 field to a new value. */
#define FTM_WR_COMBINE_COMP1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP1_MASK, FTM_COMBINE_COMP1(value)))
#define FTM_BWR_COMBINE_COMP1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN1[10] (RW)
 *
 * Enables the dual edge capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * dual edge capture mode according to #ModeSel1Table. This field applies only
 * when FTMEN = 1. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The dual edge capture mode in this pair of channels is disabled.
 * - 1 - The dual edge capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN1 field. */
#define FTM_RD_COMBINE_DECAPEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN1_MASK) >> FTM_COMBINE_DECAPEN1_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN1_SHIFT))

/*! @brief Set the DECAPEN1 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN1_MASK, FTM_COMBINE_DECAPEN1(value)))
#define FTM_BWR_COMBINE_DECAPEN1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP1[11] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when FTMEN = 1 and DECAPEN = 1. DECAP bit is cleared automatically by
 * hardware if dual edge capture - one-shot mode is selected and when the capture
 * of channel (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP1 field. */
#define FTM_RD_COMBINE_DECAP1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP1_MASK) >> FTM_COMBINE_DECAP1_SHIFT)
#define FTM_BRD_COMBINE_DECAP1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP1_SHIFT))

/*! @brief Set the DECAP1 field to a new value. */
#define FTM_WR_COMBINE_DECAP1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP1_MASK, FTM_COMBINE_DECAP1(value)))
#define FTM_BWR_COMBINE_DECAP1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN1[12] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN1 field. */
#define FTM_RD_COMBINE_DTEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN1_MASK) >> FTM_COMBINE_DTEN1_SHIFT)
#define FTM_BRD_COMBINE_DTEN1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN1_SHIFT))

/*! @brief Set the DTEN1 field to a new value. */
#define FTM_WR_COMBINE_DTEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN1_MASK, FTM_COMBINE_DTEN1(value)))
#define FTM_BWR_COMBINE_DTEN1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN1[13] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN1 field. */
#define FTM_RD_COMBINE_SYNCEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN1_MASK) >> FTM_COMBINE_SYNCEN1_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN1_SHIFT))

/*! @brief Set the SYNCEN1 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN1_MASK, FTM_COMBINE_SYNCEN1(value)))
#define FTM_BWR_COMBINE_SYNCEN1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN1[14] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN1 field. */
#define FTM_RD_COMBINE_FAULTEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN1_MASK) >> FTM_COMBINE_FAULTEN1_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN1_SHIFT))

/*! @brief Set the FAULTEN1 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN1_MASK, FTM_COMBINE_FAULTEN1(value)))
#define FTM_BWR_COMBINE_FAULTEN1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE2[16] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE2 field. */
#define FTM_RD_COMBINE_COMBINE2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE2_MASK) >> FTM_COMBINE_COMBINE2_SHIFT)
#define FTM_BRD_COMBINE_COMBINE2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE2_SHIFT))

/*! @brief Set the COMBINE2 field to a new value. */
#define FTM_WR_COMBINE_COMBINE2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE2_MASK, FTM_COMBINE_COMBINE2(value)))
#define FTM_BWR_COMBINE_COMBINE2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP2[17] (RW)
 *
 * Enables complementary mode for the combined channels. In complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP2 field. */
#define FTM_RD_COMBINE_COMP2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP2_MASK) >> FTM_COMBINE_COMP2_SHIFT)
#define FTM_BRD_COMBINE_COMP2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP2_SHIFT))

/*! @brief Set the COMP2 field to a new value. */
#define FTM_WR_COMBINE_COMP2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP2_MASK, FTM_COMBINE_COMP2(value)))
#define FTM_BWR_COMBINE_COMP2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN2[18] (RW)
 *
 * Enables the dual edge capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * dual edge capture mode according to #ModeSel1Table. This field applies only
 * when FTMEN = 1. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The dual edge capture mode in this pair of channels is disabled.
 * - 1 - The dual edge capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN2 field. */
#define FTM_RD_COMBINE_DECAPEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN2_MASK) >> FTM_COMBINE_DECAPEN2_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN2_SHIFT))

/*! @brief Set the DECAPEN2 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN2_MASK, FTM_COMBINE_DECAPEN2(value)))
#define FTM_BWR_COMBINE_DECAPEN2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP2[19] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when FTMEN = 1 and DECAPEN = 1. DECAP bit is cleared automatically by
 * hardware if dual edge capture - one-shot mode is selected and when the capture
 * of channel (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP2 field. */
#define FTM_RD_COMBINE_DECAP2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP2_MASK) >> FTM_COMBINE_DECAP2_SHIFT)
#define FTM_BRD_COMBINE_DECAP2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP2_SHIFT))

/*! @brief Set the DECAP2 field to a new value. */
#define FTM_WR_COMBINE_DECAP2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP2_MASK, FTM_COMBINE_DECAP2(value)))
#define FTM_BWR_COMBINE_DECAP2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN2[20] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN2 field. */
#define FTM_RD_COMBINE_DTEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN2_MASK) >> FTM_COMBINE_DTEN2_SHIFT)
#define FTM_BRD_COMBINE_DTEN2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN2_SHIFT))

/*! @brief Set the DTEN2 field to a new value. */
#define FTM_WR_COMBINE_DTEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN2_MASK, FTM_COMBINE_DTEN2(value)))
#define FTM_BWR_COMBINE_DTEN2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN2[21] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN2 field. */
#define FTM_RD_COMBINE_SYNCEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN2_MASK) >> FTM_COMBINE_SYNCEN2_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN2_SHIFT))

/*! @brief Set the SYNCEN2 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN2_MASK, FTM_COMBINE_SYNCEN2(value)))
#define FTM_BWR_COMBINE_SYNCEN2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN2[22] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN2 field. */
#define FTM_RD_COMBINE_FAULTEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN2_MASK) >> FTM_COMBINE_FAULTEN2_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN2_SHIFT))

/*! @brief Set the FAULTEN2 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN2_MASK, FTM_COMBINE_FAULTEN2(value)))
#define FTM_BWR_COMBINE_FAULTEN2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE3[24] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE3 field. */
#define FTM_RD_COMBINE_COMBINE3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE3_MASK) >> FTM_COMBINE_COMBINE3_SHIFT)
#define FTM_BRD_COMBINE_COMBINE3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE3_SHIFT))

/*! @brief Set the COMBINE3 field to a new value. */
#define FTM_WR_COMBINE_COMBINE3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE3_MASK, FTM_COMBINE_COMBINE3(value)))
#define FTM_BWR_COMBINE_COMBINE3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP3[25] (RW)
 *
 * Enables complementary mode for the combined channels. In complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP3 field. */
#define FTM_RD_COMBINE_COMP3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP3_MASK) >> FTM_COMBINE_COMP3_SHIFT)
#define FTM_BRD_COMBINE_COMP3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP3_SHIFT))

/*! @brief Set the COMP3 field to a new value. */
#define FTM_WR_COMBINE_COMP3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP3_MASK, FTM_COMBINE_COMP3(value)))
#define FTM_BWR_COMBINE_COMP3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN3[26] (RW)
 *
 * Enables the dual edge capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * dual edge capture mode according to #ModeSel1Table. This field applies only
 * when FTMEN = 1. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The dual edge capture mode in this pair of channels is disabled.
 * - 1 - The dual edge capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN3 field. */
#define FTM_RD_COMBINE_DECAPEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN3_MASK) >> FTM_COMBINE_DECAPEN3_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN3_SHIFT))

/*! @brief Set the DECAPEN3 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN3_MASK, FTM_COMBINE_DECAPEN3(value)))
#define FTM_BWR_COMBINE_DECAPEN3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP3[27] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when FTMEN = 1 and DECAPEN = 1. DECAP bit is cleared automatically by
 * hardware if dual edge capture - one-shot mode is selected and when the capture
 * of channel (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP3 field. */
#define FTM_RD_COMBINE_DECAP3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP3_MASK) >> FTM_COMBINE_DECAP3_SHIFT)
#define FTM_BRD_COMBINE_DECAP3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP3_SHIFT))

/*! @brief Set the DECAP3 field to a new value. */
#define FTM_WR_COMBINE_DECAP3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP3_MASK, FTM_COMBINE_DECAP3(value)))
#define FTM_BWR_COMBINE_DECAP3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN3[28] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN3 field. */
#define FTM_RD_COMBINE_DTEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN3_MASK) >> FTM_COMBINE_DTEN3_SHIFT)
#define FTM_BRD_COMBINE_DTEN3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN3_SHIFT))

/*! @brief Set the DTEN3 field to a new value. */
#define FTM_WR_COMBINE_DTEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN3_MASK, FTM_COMBINE_DTEN3(value)))
#define FTM_BWR_COMBINE_DTEN3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN3[29] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN3 field. */
#define FTM_RD_COMBINE_SYNCEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN3_MASK) >> FTM_COMBINE_SYNCEN3_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN3_SHIFT))

/*! @brief Set the SYNCEN3 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN3_MASK, FTM_COMBINE_SYNCEN3(value)))
#define FTM_BWR_COMBINE_SYNCEN3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN3[30] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN3 field. */
#define FTM_RD_COMBINE_FAULTEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN3_MASK) >> FTM_COMBINE_FAULTEN3_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN3_SHIFT))

/*! @brief Set the FAULTEN3 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN3_MASK, FTM_COMBINE_FAULTEN3(value)))
#define FTM_BWR_COMBINE_FAULTEN3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_DEADTIME - Deadtime Insertion Control
 ******************************************************************************/

/*!
 * @brief FTM_DEADTIME - Deadtime Insertion Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the deadtime prescaler factor and deadtime value. All
 * FTM channels use this clock prescaler and this deadtime value for the deadtime
 * insertion.
 */
/*!
 * @name Constants and macros for entire FTM_DEADTIME register
 */
/*@{*/
#define FTM_RD_DEADTIME(base)    (FTM_DEADTIME_REG(base))
#define FTM_WR_DEADTIME(base, value) (FTM_DEADTIME_REG(base) = (value))
#define FTM_RMW_DEADTIME(base, mask, value) (FTM_WR_DEADTIME(base, (FTM_RD_DEADTIME(base) & ~(mask)) | (value)))
#define FTM_SET_DEADTIME(base, value) (FTM_WR_DEADTIME(base, FTM_RD_DEADTIME(base) |  (value)))
#define FTM_CLR_DEADTIME(base, value) (FTM_WR_DEADTIME(base, FTM_RD_DEADTIME(base) & ~(value)))
#define FTM_TOG_DEADTIME(base, value) (FTM_WR_DEADTIME(base, FTM_RD_DEADTIME(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_DEADTIME bitfields
 */

/*!
 * @name Register FTM_DEADTIME, field DTVAL[5:0] (RW)
 *
 * Selects the deadtime insertion value for the deadtime counter. The deadtime
 * counter is clocked by a scaled version of the system clock. See the description
 * of DTPS. Deadtime insert value = (DTPS * DTVAL). DTVAL selects the number of
 * deadtime counts inserted as follows: When DTVAL is 0, no counts are inserted.
 * When DTVAL is 1, 1 count is inserted. When DTVAL is 2, 2 counts are inserted.
 * This pattern continues up to a possible 63 counts. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_DEADTIME_DTVAL field. */
#define FTM_RD_DEADTIME_DTVAL(base) ((FTM_DEADTIME_REG(base) & FTM_DEADTIME_DTVAL_MASK) >> FTM_DEADTIME_DTVAL_SHIFT)
#define FTM_BRD_DEADTIME_DTVAL(base) (FTM_RD_DEADTIME_DTVAL(base))

/*! @brief Set the DTVAL field to a new value. */
#define FTM_WR_DEADTIME_DTVAL(base, value) (FTM_RMW_DEADTIME(base, FTM_DEADTIME_DTVAL_MASK, FTM_DEADTIME_DTVAL(value)))
#define FTM_BWR_DEADTIME_DTVAL(base, value) (FTM_WR_DEADTIME_DTVAL(base, value))
/*@}*/

/*!
 * @name Register FTM_DEADTIME, field DTPS[7:6] (RW)
 *
 * Selects the division factor of the system clock. This prescaled clock is used
 * by the deadtime counter. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0x - Divide the system clock by 1.
 * - 10 - Divide the system clock by 4.
 * - 11 - Divide the system clock by 16.
 */
/*@{*/
/*! @brief Read current value of the FTM_DEADTIME_DTPS field. */
#define FTM_RD_DEADTIME_DTPS(base) ((FTM_DEADTIME_REG(base) & FTM_DEADTIME_DTPS_MASK) >> FTM_DEADTIME_DTPS_SHIFT)
#define FTM_BRD_DEADTIME_DTPS(base) (FTM_RD_DEADTIME_DTPS(base))

/*! @brief Set the DTPS field to a new value. */
#define FTM_WR_DEADTIME_DTPS(base, value) (FTM_RMW_DEADTIME(base, FTM_DEADTIME_DTPS_MASK, FTM_DEADTIME_DTPS(value)))
#define FTM_BWR_DEADTIME_DTPS(base, value) (FTM_WR_DEADTIME_DTPS(base, value))
/*@}*/

/*******************************************************************************
 * FTM_EXTTRIG - FTM External Trigger
 ******************************************************************************/

/*!
 * @brief FTM_EXTTRIG - FTM External Trigger (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates when a channel trigger was generated, enables the
 * generation of a trigger when the FTM counter is equal to its initial value, and
 * selects which channels are used in the generation of the channel triggers.
 * Several channels can be selected to generate multiple triggers in one PWM period.
 * Channels 6 and 7 are not used to generate channel triggers.
 */
/*!
 * @name Constants and macros for entire FTM_EXTTRIG register
 */
/*@{*/
#define FTM_RD_EXTTRIG(base)     (FTM_EXTTRIG_REG(base))
#define FTM_WR_EXTTRIG(base, value) (FTM_EXTTRIG_REG(base) = (value))
#define FTM_RMW_EXTTRIG(base, mask, value) (FTM_WR_EXTTRIG(base, (FTM_RD_EXTTRIG(base) & ~(mask)) | (value)))
#define FTM_SET_EXTTRIG(base, value) (FTM_WR_EXTTRIG(base, FTM_RD_EXTTRIG(base) |  (value)))
#define FTM_CLR_EXTTRIG(base, value) (FTM_WR_EXTTRIG(base, FTM_RD_EXTTRIG(base) & ~(value)))
#define FTM_TOG_EXTTRIG(base, value) (FTM_WR_EXTTRIG(base, FTM_RD_EXTTRIG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_EXTTRIG bitfields
 */

/*!
 * @name Register FTM_EXTTRIG, field CH2TRIG[0] (RW)
 *
 * Enable the generation of the channel trigger when the FTM counter is equal to
 * the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH2TRIG field. */
#define FTM_RD_EXTTRIG_CH2TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH2TRIG_MASK) >> FTM_EXTTRIG_CH2TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH2TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH2TRIG_SHIFT))

/*! @brief Set the CH2TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH2TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH2TRIG_MASK, FTM_EXTTRIG_CH2TRIG(value)))
#define FTM_BWR_EXTTRIG_CH2TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH2TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH3TRIG[1] (RW)
 *
 * Enable the generation of the channel trigger when the FTM counter is equal to
 * the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH3TRIG field. */
#define FTM_RD_EXTTRIG_CH3TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH3TRIG_MASK) >> FTM_EXTTRIG_CH3TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH3TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH3TRIG_SHIFT))

/*! @brief Set the CH3TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH3TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH3TRIG_MASK, FTM_EXTTRIG_CH3TRIG(value)))
#define FTM_BWR_EXTTRIG_CH3TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH3TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH4TRIG[2] (RW)
 *
 * Enable the generation of the channel trigger when the FTM counter is equal to
 * the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH4TRIG field. */
#define FTM_RD_EXTTRIG_CH4TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH4TRIG_MASK) >> FTM_EXTTRIG_CH4TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH4TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH4TRIG_SHIFT))

/*! @brief Set the CH4TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH4TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH4TRIG_MASK, FTM_EXTTRIG_CH4TRIG(value)))
#define FTM_BWR_EXTTRIG_CH4TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH4TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH5TRIG[3] (RW)
 *
 * Enable the generation of the channel trigger when the FTM counter is equal to
 * the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH5TRIG field. */
#define FTM_RD_EXTTRIG_CH5TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH5TRIG_MASK) >> FTM_EXTTRIG_CH5TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH5TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH5TRIG_SHIFT))

/*! @brief Set the CH5TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH5TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH5TRIG_MASK, FTM_EXTTRIG_CH5TRIG(value)))
#define FTM_BWR_EXTTRIG_CH5TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH5TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH0TRIG[4] (RW)
 *
 * Enable the generation of the channel trigger when the FTM counter is equal to
 * the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH0TRIG field. */
#define FTM_RD_EXTTRIG_CH0TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH0TRIG_MASK) >> FTM_EXTTRIG_CH0TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH0TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH0TRIG_SHIFT))

/*! @brief Set the CH0TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH0TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH0TRIG_MASK, FTM_EXTTRIG_CH0TRIG(value)))
#define FTM_BWR_EXTTRIG_CH0TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH0TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH1TRIG[5] (RW)
 *
 * Enable the generation of the channel trigger when the FTM counter is equal to
 * the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH1TRIG field. */
#define FTM_RD_EXTTRIG_CH1TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH1TRIG_MASK) >> FTM_EXTTRIG_CH1TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH1TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH1TRIG_SHIFT))

/*! @brief Set the CH1TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH1TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH1TRIG_MASK, FTM_EXTTRIG_CH1TRIG(value)))
#define FTM_BWR_EXTTRIG_CH1TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH1TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field INITTRIGEN[6] (RW)
 *
 * Enables the generation of the trigger when the FTM counter is equal to the
 * CNTIN register.
 *
 * Values:
 * - 0 - The generation of initialization trigger is disabled.
 * - 1 - The generation of initialization trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_INITTRIGEN field. */
#define FTM_RD_EXTTRIG_INITTRIGEN(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_INITTRIGEN_MASK) >> FTM_EXTTRIG_INITTRIGEN_SHIFT)
#define FTM_BRD_EXTTRIG_INITTRIGEN(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_INITTRIGEN_SHIFT))

/*! @brief Set the INITTRIGEN field to a new value. */
#define FTM_WR_EXTTRIG_INITTRIGEN(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_INITTRIGEN_MASK, FTM_EXTTRIG_INITTRIGEN(value)))
#define FTM_BWR_EXTTRIG_INITTRIGEN(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_INITTRIGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field TRIGF[7] (RW)
 *
 * Set by hardware when a channel trigger is generated. Clear TRIGF by reading
 * EXTTRIG while TRIGF is set and then writing a 0 to TRIGF. Writing a 1 to TRIGF
 * has no effect. If another channel trigger is generated before the clearing
 * sequence is completed, the sequence is reset so TRIGF remains set after the clear
 * sequence is completed for the earlier TRIGF.
 *
 * Values:
 * - 0 - No channel trigger was generated.
 * - 1 - A channel trigger was generated.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_TRIGF field. */
#define FTM_RD_EXTTRIG_TRIGF(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_TRIGF_MASK) >> FTM_EXTTRIG_TRIGF_SHIFT)
#define FTM_BRD_EXTTRIG_TRIGF(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_TRIGF_SHIFT))

/*! @brief Set the TRIGF field to a new value. */
#define FTM_WR_EXTTRIG_TRIGF(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_TRIGF_MASK, FTM_EXTTRIG_TRIGF(value)))
#define FTM_BWR_EXTTRIG_TRIGF(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_TRIGF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_POL - Channels Polarity
 ******************************************************************************/

/*!
 * @brief FTM_POL - Channels Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the output polarity of the FTM channels. The safe value
 * that is driven in a channel output when the fault control is enabled and a
 * fault condition is detected is the inactive state of the channel. That is, the
 * safe value of a channel is the value of its POL bit.
 */
/*!
 * @name Constants and macros for entire FTM_POL register
 */
/*@{*/
#define FTM_RD_POL(base)         (FTM_POL_REG(base))
#define FTM_WR_POL(base, value)  (FTM_POL_REG(base) = (value))
#define FTM_RMW_POL(base, mask, value) (FTM_WR_POL(base, (FTM_RD_POL(base) & ~(mask)) | (value)))
#define FTM_SET_POL(base, value) (FTM_WR_POL(base, FTM_RD_POL(base) |  (value)))
#define FTM_CLR_POL(base, value) (FTM_WR_POL(base, FTM_RD_POL(base) & ~(value)))
#define FTM_TOG_POL(base, value) (FTM_WR_POL(base, FTM_RD_POL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_POL bitfields
 */

/*!
 * @name Register FTM_POL, field POL0[0] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL0 field. */
#define FTM_RD_POL_POL0(base) ((FTM_POL_REG(base) & FTM_POL_POL0_MASK) >> FTM_POL_POL0_SHIFT)
#define FTM_BRD_POL_POL0(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL0_SHIFT))

/*! @brief Set the POL0 field to a new value. */
#define FTM_WR_POL_POL0(base, value) (FTM_RMW_POL(base, FTM_POL_POL0_MASK, FTM_POL_POL0(value)))
#define FTM_BWR_POL_POL0(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL1[1] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL1 field. */
#define FTM_RD_POL_POL1(base) ((FTM_POL_REG(base) & FTM_POL_POL1_MASK) >> FTM_POL_POL1_SHIFT)
#define FTM_BRD_POL_POL1(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL1_SHIFT))

/*! @brief Set the POL1 field to a new value. */
#define FTM_WR_POL_POL1(base, value) (FTM_RMW_POL(base, FTM_POL_POL1_MASK, FTM_POL_POL1(value)))
#define FTM_BWR_POL_POL1(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL2[2] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL2 field. */
#define FTM_RD_POL_POL2(base) ((FTM_POL_REG(base) & FTM_POL_POL2_MASK) >> FTM_POL_POL2_SHIFT)
#define FTM_BRD_POL_POL2(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL2_SHIFT))

/*! @brief Set the POL2 field to a new value. */
#define FTM_WR_POL_POL2(base, value) (FTM_RMW_POL(base, FTM_POL_POL2_MASK, FTM_POL_POL2(value)))
#define FTM_BWR_POL_POL2(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL3[3] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL3 field. */
#define FTM_RD_POL_POL3(base) ((FTM_POL_REG(base) & FTM_POL_POL3_MASK) >> FTM_POL_POL3_SHIFT)
#define FTM_BRD_POL_POL3(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL3_SHIFT))

/*! @brief Set the POL3 field to a new value. */
#define FTM_WR_POL_POL3(base, value) (FTM_RMW_POL(base, FTM_POL_POL3_MASK, FTM_POL_POL3(value)))
#define FTM_BWR_POL_POL3(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL4[4] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL4 field. */
#define FTM_RD_POL_POL4(base) ((FTM_POL_REG(base) & FTM_POL_POL4_MASK) >> FTM_POL_POL4_SHIFT)
#define FTM_BRD_POL_POL4(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL4_SHIFT))

/*! @brief Set the POL4 field to a new value. */
#define FTM_WR_POL_POL4(base, value) (FTM_RMW_POL(base, FTM_POL_POL4_MASK, FTM_POL_POL4(value)))
#define FTM_BWR_POL_POL4(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL5[5] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL5 field. */
#define FTM_RD_POL_POL5(base) ((FTM_POL_REG(base) & FTM_POL_POL5_MASK) >> FTM_POL_POL5_SHIFT)
#define FTM_BRD_POL_POL5(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL5_SHIFT))

/*! @brief Set the POL5 field to a new value. */
#define FTM_WR_POL_POL5(base, value) (FTM_RMW_POL(base, FTM_POL_POL5_MASK, FTM_POL_POL5(value)))
#define FTM_BWR_POL_POL5(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL6[6] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL6 field. */
#define FTM_RD_POL_POL6(base) ((FTM_POL_REG(base) & FTM_POL_POL6_MASK) >> FTM_POL_POL6_SHIFT)
#define FTM_BRD_POL_POL6(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL6_SHIFT))

/*! @brief Set the POL6 field to a new value. */
#define FTM_WR_POL_POL6(base, value) (FTM_RMW_POL(base, FTM_POL_POL6_MASK, FTM_POL_POL6(value)))
#define FTM_BWR_POL_POL6(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL7[7] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL7 field. */
#define FTM_RD_POL_POL7(base) ((FTM_POL_REG(base) & FTM_POL_POL7_MASK) >> FTM_POL_POL7_SHIFT)
#define FTM_BRD_POL_POL7(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL7_SHIFT))

/*! @brief Set the POL7 field to a new value. */
#define FTM_WR_POL_POL7(base, value) (FTM_RMW_POL(base, FTM_POL_POL7_MASK, FTM_POL_POL7(value)))
#define FTM_BWR_POL_POL7(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL7_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_FMS - Fault Mode Status
 ******************************************************************************/

/*!
 * @brief FTM_FMS - Fault Mode Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the fault detection flags, write protection enable
 * bit, and the logic OR of the enabled fault inputs.
 */
/*!
 * @name Constants and macros for entire FTM_FMS register
 */
/*@{*/
#define FTM_RD_FMS(base)         (FTM_FMS_REG(base))
#define FTM_WR_FMS(base, value)  (FTM_FMS_REG(base) = (value))
#define FTM_RMW_FMS(base, mask, value) (FTM_WR_FMS(base, (FTM_RD_FMS(base) & ~(mask)) | (value)))
#define FTM_SET_FMS(base, value) (FTM_WR_FMS(base, FTM_RD_FMS(base) |  (value)))
#define FTM_CLR_FMS(base, value) (FTM_WR_FMS(base, FTM_RD_FMS(base) & ~(value)))
#define FTM_TOG_FMS(base, value) (FTM_WR_FMS(base, FTM_RD_FMS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FMS bitfields
 */

/*!
 * @name Register FTM_FMS, field FAULTF0[0] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF0
 * by reading the FMS register while FAULTF0 is set and then writing a 0 to
 * FAULTF0 while there is no existing fault condition at the the corresponding fault
 * input. Writing a 1 to FAULTF0 has no effect. FAULTF0 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the
 * corresponding fault input before the clearing sequence is completed, the sequence is
 * reset so FAULTF0 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF0 field. */
#define FTM_RD_FMS_FAULTF0(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF0_MASK) >> FTM_FMS_FAULTF0_SHIFT)
#define FTM_BRD_FMS_FAULTF0(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF0_SHIFT))

/*! @brief Set the FAULTF0 field to a new value. */
#define FTM_WR_FMS_FAULTF0(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF0_MASK, FTM_FMS_FAULTF0(value)))
#define FTM_BWR_FMS_FAULTF0(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF1[1] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF1
 * by reading the FMS register while FAULTF1 is set and then writing a 0 to
 * FAULTF1 while there is no existing fault condition at the the corresponding fault
 * input. Writing a 1 to FAULTF1 has no effect. FAULTF1 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the
 * corresponding fault input before the clearing sequence is completed, the sequence is
 * reset so FAULTF1 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF1 field. */
#define FTM_RD_FMS_FAULTF1(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF1_MASK) >> FTM_FMS_FAULTF1_SHIFT)
#define FTM_BRD_FMS_FAULTF1(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF1_SHIFT))

/*! @brief Set the FAULTF1 field to a new value. */
#define FTM_WR_FMS_FAULTF1(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF1_MASK, FTM_FMS_FAULTF1(value)))
#define FTM_BWR_FMS_FAULTF1(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF2[2] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF2
 * by reading the FMS register while FAULTF2 is set and then writing a 0 to
 * FAULTF2 while there is no existing fault condition at the the corresponding fault
 * input. Writing a 1 to FAULTF2 has no effect. FAULTF2 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the
 * corresponding fault input before the clearing sequence is completed, the sequence is
 * reset so FAULTF2 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF2 field. */
#define FTM_RD_FMS_FAULTF2(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF2_MASK) >> FTM_FMS_FAULTF2_SHIFT)
#define FTM_BRD_FMS_FAULTF2(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF2_SHIFT))

/*! @brief Set the FAULTF2 field to a new value. */
#define FTM_WR_FMS_FAULTF2(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF2_MASK, FTM_FMS_FAULTF2(value)))
#define FTM_BWR_FMS_FAULTF2(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF3[3] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF3
 * by reading the FMS register while FAULTF3 is set and then writing a 0 to
 * FAULTF3 while there is no existing fault condition at the the corresponding fault
 * input. Writing a 1 to FAULTF3 has no effect. FAULTF3 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the
 * corresponding fault input before the clearing sequence is completed, the sequence is
 * reset so FAULTF3 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF3 field. */
#define FTM_RD_FMS_FAULTF3(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF3_MASK) >> FTM_FMS_FAULTF3_SHIFT)
#define FTM_BRD_FMS_FAULTF3(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF3_SHIFT))

/*! @brief Set the FAULTF3 field to a new value. */
#define FTM_WR_FMS_FAULTF3(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF3_MASK, FTM_FMS_FAULTF3(value)))
#define FTM_BWR_FMS_FAULTF3(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTIN[5] (RO)
 *
 * Represents the logic OR of the enabled fault inputs after their filter (if
 * their filter is enabled) when fault control is enabled.
 *
 * Values:
 * - 0 - The logic OR of the enabled fault inputs is 0.
 * - 1 - The logic OR of the enabled fault inputs is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTIN field. */
#define FTM_RD_FMS_FAULTIN(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTIN_MASK) >> FTM_FMS_FAULTIN_SHIFT)
#define FTM_BRD_FMS_FAULTIN(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTIN_SHIFT))
/*@}*/

/*!
 * @name Register FTM_FMS, field WPEN[6] (RW)
 *
 * The WPEN bit is the negation of the WPDIS bit. WPEN is set when 1 is written
 * to it. WPEN is cleared when WPEN bit is read as a 1 and then 1 is written to
 * WPDIS. Writing 0 to WPEN has no effect.
 *
 * Values:
 * - 0 - Write protection is disabled. Write protected bits can be written.
 * - 1 - Write protection is enabled. Write protected bits cannot be written.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_WPEN field. */
#define FTM_RD_FMS_WPEN(base) ((FTM_FMS_REG(base) & FTM_FMS_WPEN_MASK) >> FTM_FMS_WPEN_SHIFT)
#define FTM_BRD_FMS_WPEN(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_WPEN_SHIFT))

/*! @brief Set the WPEN field to a new value. */
#define FTM_WR_FMS_WPEN(base, value) (FTM_RMW_FMS(base, FTM_FMS_WPEN_MASK, FTM_FMS_WPEN(value)))
#define FTM_BWR_FMS_WPEN(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_WPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF[7] (ROWZ)
 *
 * Represents the logic OR of the individual FAULTFj bits (where j = 3, 2, 1,
 * 0). Clear FAULTF by reading the FMS register while FAULTF is set and then
 * writing a 0 to FAULTF while there is no existing fault condition at the enabled
 * fault inputs. Writing a 1 to FAULTF has no effect. If another fault condition is
 * detected in an enabled fault input before the clearing sequence is completed,
 * the sequence is reset so FAULTF remains set after the clearing sequence is
 * completed for the earlier fault condition. FAULTF is also cleared when FAULTFj
 * bits are cleared individually.
 *
 * Values:
 * - 0 - No fault condition was detected.
 * - 1 - A fault condition was detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF field. */
#define FTM_RD_FMS_FAULTF(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF_MASK) >> FTM_FMS_FAULTF_SHIFT)
#define FTM_BRD_FMS_FAULTF(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF_SHIFT))

/*! @brief Set the FAULTF field to a new value. */
#define FTM_WR_FMS_FAULTF(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF(value)))
#define FTM_BWR_FMS_FAULTF(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_FILTER - Input Capture Filter Control
 ******************************************************************************/

/*!
 * @brief FTM_FILTER - Input Capture Filter Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the inputs of channels. Channels
 * 4, 5, 6 and 7 do not have an input filter. Writing to the FILTER register has
 * immediate effect and must be done only when the channels 0, 1, 2, and 3 are not
 * in input modes. Failure to do this could result in a missing valid signal.
 */
/*!
 * @name Constants and macros for entire FTM_FILTER register
 */
/*@{*/
#define FTM_RD_FILTER(base)      (FTM_FILTER_REG(base))
#define FTM_WR_FILTER(base, value) (FTM_FILTER_REG(base) = (value))
#define FTM_RMW_FILTER(base, mask, value) (FTM_WR_FILTER(base, (FTM_RD_FILTER(base) & ~(mask)) | (value)))
#define FTM_SET_FILTER(base, value) (FTM_WR_FILTER(base, FTM_RD_FILTER(base) |  (value)))
#define FTM_CLR_FILTER(base, value) (FTM_WR_FILTER(base, FTM_RD_FILTER(base) & ~(value)))
#define FTM_TOG_FILTER(base, value) (FTM_WR_FILTER(base, FTM_RD_FILTER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FILTER bitfields
 */

/*!
 * @name Register FTM_FILTER, field CH0FVAL[3:0] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH0FVAL field. */
#define FTM_RD_FILTER_CH0FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH0FVAL_MASK) >> FTM_FILTER_CH0FVAL_SHIFT)
#define FTM_BRD_FILTER_CH0FVAL(base) (FTM_RD_FILTER_CH0FVAL(base))

/*! @brief Set the CH0FVAL field to a new value. */
#define FTM_WR_FILTER_CH0FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH0FVAL_MASK, FTM_FILTER_CH0FVAL(value)))
#define FTM_BWR_FILTER_CH0FVAL(base, value) (FTM_WR_FILTER_CH0FVAL(base, value))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH1FVAL[7:4] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH1FVAL field. */
#define FTM_RD_FILTER_CH1FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH1FVAL_MASK) >> FTM_FILTER_CH1FVAL_SHIFT)
#define FTM_BRD_FILTER_CH1FVAL(base) (FTM_RD_FILTER_CH1FVAL(base))

/*! @brief Set the CH1FVAL field to a new value. */
#define FTM_WR_FILTER_CH1FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH1FVAL_MASK, FTM_FILTER_CH1FVAL(value)))
#define FTM_BWR_FILTER_CH1FVAL(base, value) (FTM_WR_FILTER_CH1FVAL(base, value))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH2FVAL[11:8] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH2FVAL field. */
#define FTM_RD_FILTER_CH2FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH2FVAL_MASK) >> FTM_FILTER_CH2FVAL_SHIFT)
#define FTM_BRD_FILTER_CH2FVAL(base) (FTM_RD_FILTER_CH2FVAL(base))

/*! @brief Set the CH2FVAL field to a new value. */
#define FTM_WR_FILTER_CH2FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH2FVAL_MASK, FTM_FILTER_CH2FVAL(value)))
#define FTM_BWR_FILTER_CH2FVAL(base, value) (FTM_WR_FILTER_CH2FVAL(base, value))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH3FVAL[15:12] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH3FVAL field. */
#define FTM_RD_FILTER_CH3FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH3FVAL_MASK) >> FTM_FILTER_CH3FVAL_SHIFT)
#define FTM_BRD_FILTER_CH3FVAL(base) (FTM_RD_FILTER_CH3FVAL(base))

/*! @brief Set the CH3FVAL field to a new value. */
#define FTM_WR_FILTER_CH3FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH3FVAL_MASK, FTM_FILTER_CH3FVAL(value)))
#define FTM_BWR_FILTER_CH3FVAL(base, value) (FTM_WR_FILTER_CH3FVAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_FLTCTRL - Fault Control
 ******************************************************************************/

/*!
 * @brief FTM_FLTCTRL - Fault Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the fault inputs, enables the
 * fault inputs and the fault inputs filter.
 */
/*!
 * @name Constants and macros for entire FTM_FLTCTRL register
 */
/*@{*/
#define FTM_RD_FLTCTRL(base)     (FTM_FLTCTRL_REG(base))
#define FTM_WR_FLTCTRL(base, value) (FTM_FLTCTRL_REG(base) = (value))
#define FTM_RMW_FLTCTRL(base, mask, value) (FTM_WR_FLTCTRL(base, (FTM_RD_FLTCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_FLTCTRL(base, value) (FTM_WR_FLTCTRL(base, FTM_RD_FLTCTRL(base) |  (value)))
#define FTM_CLR_FLTCTRL(base, value) (FTM_WR_FLTCTRL(base, FTM_RD_FLTCTRL(base) & ~(value)))
#define FTM_TOG_FLTCTRL(base, value) (FTM_WR_FLTCTRL(base, FTM_RD_FLTCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTCTRL bitfields
 */

/*!
 * @name Register FTM_FLTCTRL, field FAULT0EN[0] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT0EN field. */
#define FTM_RD_FLTCTRL_FAULT0EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT0EN_MASK) >> FTM_FLTCTRL_FAULT0EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT0EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT0EN_SHIFT))

/*! @brief Set the FAULT0EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT0EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT0EN_MASK, FTM_FLTCTRL_FAULT0EN(value)))
#define FTM_BWR_FLTCTRL_FAULT0EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT0EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT1EN[1] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT1EN field. */
#define FTM_RD_FLTCTRL_FAULT1EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT1EN_MASK) >> FTM_FLTCTRL_FAULT1EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT1EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT1EN_SHIFT))

/*! @brief Set the FAULT1EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT1EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT1EN_MASK, FTM_FLTCTRL_FAULT1EN(value)))
#define FTM_BWR_FLTCTRL_FAULT1EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT1EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT2EN[2] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT2EN field. */
#define FTM_RD_FLTCTRL_FAULT2EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT2EN_MASK) >> FTM_FLTCTRL_FAULT2EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT2EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT2EN_SHIFT))

/*! @brief Set the FAULT2EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT2EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT2EN_MASK, FTM_FLTCTRL_FAULT2EN(value)))
#define FTM_BWR_FLTCTRL_FAULT2EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT2EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT3EN[3] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT3EN field. */
#define FTM_RD_FLTCTRL_FAULT3EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT3EN_MASK) >> FTM_FLTCTRL_FAULT3EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT3EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT3EN_SHIFT))

/*! @brief Set the FAULT3EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT3EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT3EN_MASK, FTM_FLTCTRL_FAULT3EN(value)))
#define FTM_BWR_FLTCTRL_FAULT3EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT3EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR0EN[4] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR0EN field. */
#define FTM_RD_FLTCTRL_FFLTR0EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR0EN_MASK) >> FTM_FLTCTRL_FFLTR0EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR0EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR0EN_SHIFT))

/*! @brief Set the FFLTR0EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR0EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR0EN_MASK, FTM_FLTCTRL_FFLTR0EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR0EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR0EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR1EN[5] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR1EN field. */
#define FTM_RD_FLTCTRL_FFLTR1EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR1EN_MASK) >> FTM_FLTCTRL_FFLTR1EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR1EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR1EN_SHIFT))

/*! @brief Set the FFLTR1EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR1EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR1EN_MASK, FTM_FLTCTRL_FFLTR1EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR1EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR1EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR2EN[6] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR2EN field. */
#define FTM_RD_FLTCTRL_FFLTR2EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR2EN_MASK) >> FTM_FLTCTRL_FFLTR2EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR2EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR2EN_SHIFT))

/*! @brief Set the FFLTR2EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR2EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR2EN_MASK, FTM_FLTCTRL_FFLTR2EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR2EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR2EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR3EN[7] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR3EN field. */
#define FTM_RD_FLTCTRL_FFLTR3EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR3EN_MASK) >> FTM_FLTCTRL_FFLTR3EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR3EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR3EN_SHIFT))

/*! @brief Set the FFLTR3EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR3EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR3EN_MASK, FTM_FLTCTRL_FFLTR3EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR3EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR3EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFVAL[11:8] (RW)
 *
 * Selects the filter value for the fault inputs. The fault filter is disabled
 * when the value is zero. Writing to this field has immediate effect and must be
 * done only when the fault control or all fault inputs are disabled. Failure to
 * do this could result in a missing fault detection.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFVAL field. */
#define FTM_RD_FLTCTRL_FFVAL(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFVAL_MASK) >> FTM_FLTCTRL_FFVAL_SHIFT)
#define FTM_BRD_FLTCTRL_FFVAL(base) (FTM_RD_FLTCTRL_FFVAL(base))

/*! @brief Set the FFVAL field to a new value. */
#define FTM_WR_FLTCTRL_FFVAL(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFVAL_MASK, FTM_FLTCTRL_FFVAL(value)))
#define FTM_BWR_FLTCTRL_FFVAL(base, value) (FTM_WR_FLTCTRL_FFVAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_QDCTRL - Quadrature Decoder Control and Status
 ******************************************************************************/

/*!
 * @brief FTM_QDCTRL - Quadrature Decoder Control and Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has the control and status bits for the quadrature decoder mode.
 */
/*!
 * @name Constants and macros for entire FTM_QDCTRL register
 */
/*@{*/
#define FTM_RD_QDCTRL(base)      (FTM_QDCTRL_REG(base))
#define FTM_WR_QDCTRL(base, value) (FTM_QDCTRL_REG(base) = (value))
#define FTM_RMW_QDCTRL(base, mask, value) (FTM_WR_QDCTRL(base, (FTM_RD_QDCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_QDCTRL(base, value) (FTM_WR_QDCTRL(base, FTM_RD_QDCTRL(base) |  (value)))
#define FTM_CLR_QDCTRL(base, value) (FTM_WR_QDCTRL(base, FTM_RD_QDCTRL(base) & ~(value)))
#define FTM_TOG_QDCTRL(base, value) (FTM_WR_QDCTRL(base, FTM_RD_QDCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_QDCTRL bitfields
 */

/*!
 * @name Register FTM_QDCTRL, field QUADEN[0] (RW)
 *
 * Enables the quadrature decoder mode. In this mode, the phase A and B input
 * signals control the FTM counter direction. The quadrature decoder mode has
 * precedence over the other modes. (See #ModeSel1Table.) This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Quadrature decoder mode is disabled.
 * - 1 - Quadrature decoder mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADEN field. */
#define FTM_RD_QDCTRL_QUADEN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADEN_MASK) >> FTM_QDCTRL_QUADEN_SHIFT)
#define FTM_BRD_QDCTRL_QUADEN(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADEN_SHIFT))

/*! @brief Set the QUADEN field to a new value. */
#define FTM_WR_QDCTRL_QUADEN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_QUADEN_MASK, FTM_QDCTRL_QUADEN(value)))
#define FTM_BWR_QDCTRL_QUADEN(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field TOFDIR[1] (RO)
 *
 * Indicates if the TOF bit was set on the top or the bottom of counting.
 *
 * Values:
 * - 0 - TOF bit was set on the bottom of counting. There was an FTM counter
 *     decrement and FTM counter changes from its minimum value (CNTIN register) to
 *     its maximum value (MOD register).
 * - 1 - TOF bit was set on the top of counting. There was an FTM counter
 *     increment and FTM counter changes from its maximum value (MOD register) to its
 *     minimum value (CNTIN register).
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_TOFDIR field. */
#define FTM_RD_QDCTRL_TOFDIR(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_TOFDIR_MASK) >> FTM_QDCTRL_TOFDIR_SHIFT)
#define FTM_BRD_QDCTRL_TOFDIR(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_TOFDIR_SHIFT))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADIR[2] (RO)
 *
 * Indicates the counting direction.
 *
 * Values:
 * - 0 - Counting direction is decreasing (FTM counter decrement).
 * - 1 - Counting direction is increasing (FTM counter increment).
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADIR field. */
#define FTM_RD_QDCTRL_QUADIR(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADIR_MASK) >> FTM_QDCTRL_QUADIR_SHIFT)
#define FTM_BRD_QDCTRL_QUADIR(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADIR_SHIFT))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADMODE[3] (RW)
 *
 * Selects the encoding mode used in the quadrature decoder mode.
 *
 * Values:
 * - 0 - Phase A and phase B encoding mode.
 * - 1 - Count and direction encoding mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADMODE field. */
#define FTM_RD_QDCTRL_QUADMODE(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADMODE_MASK) >> FTM_QDCTRL_QUADMODE_SHIFT)
#define FTM_BRD_QDCTRL_QUADMODE(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADMODE_SHIFT))

/*! @brief Set the QUADMODE field to a new value. */
#define FTM_WR_QDCTRL_QUADMODE(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_QUADMODE_MASK, FTM_QDCTRL_QUADMODE(value)))
#define FTM_BWR_QDCTRL_QUADMODE(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBPOL[4] (RW)
 *
 * Selects the polarity for the quadrature decoder phase B input.
 *
 * Values:
 * - 0 - Normal polarity. Phase B input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 1 - Inverted polarity. Phase B input signal is inverted before identifying
 *     the rising and falling edges of this signal.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHBPOL field. */
#define FTM_RD_QDCTRL_PHBPOL(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHBPOL_MASK) >> FTM_QDCTRL_PHBPOL_SHIFT)
#define FTM_BRD_QDCTRL_PHBPOL(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBPOL_SHIFT))

/*! @brief Set the PHBPOL field to a new value. */
#define FTM_WR_QDCTRL_PHBPOL(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHBPOL_MASK, FTM_QDCTRL_PHBPOL(value)))
#define FTM_BWR_QDCTRL_PHBPOL(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAPOL[5] (RW)
 *
 * Selects the polarity for the quadrature decoder phase A input.
 *
 * Values:
 * - 0 - Normal polarity. Phase A input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 1 - Inverted polarity. Phase A input signal is inverted before identifying
 *     the rising and falling edges of this signal.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHAPOL field. */
#define FTM_RD_QDCTRL_PHAPOL(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHAPOL_MASK) >> FTM_QDCTRL_PHAPOL_SHIFT)
#define FTM_BRD_QDCTRL_PHAPOL(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAPOL_SHIFT))

/*! @brief Set the PHAPOL field to a new value. */
#define FTM_WR_QDCTRL_PHAPOL(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHAPOL_MASK, FTM_QDCTRL_PHAPOL(value)))
#define FTM_BWR_QDCTRL_PHAPOL(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBFLTREN[6] (RW)
 *
 * Enables the filter for the quadrature decoder phase B input. The filter value
 * for the phase B input is defined by the CH1FVAL field of FILTER. The phase B
 * filter is also disabled when CH1FVAL is zero.
 *
 * Values:
 * - 0 - Phase B input filter is disabled.
 * - 1 - Phase B input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHBFLTREN field. */
#define FTM_RD_QDCTRL_PHBFLTREN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHBFLTREN_MASK) >> FTM_QDCTRL_PHBFLTREN_SHIFT)
#define FTM_BRD_QDCTRL_PHBFLTREN(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBFLTREN_SHIFT))

/*! @brief Set the PHBFLTREN field to a new value. */
#define FTM_WR_QDCTRL_PHBFLTREN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHBFLTREN_MASK, FTM_QDCTRL_PHBFLTREN(value)))
#define FTM_BWR_QDCTRL_PHBFLTREN(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBFLTREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAFLTREN[7] (RW)
 *
 * Enables the filter for the quadrature decoder phase A input. The filter value
 * for the phase A input is defined by the CH0FVAL field of FILTER. The phase A
 * filter is also disabled when CH0FVAL is zero.
 *
 * Values:
 * - 0 - Phase A input filter is disabled.
 * - 1 - Phase A input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHAFLTREN field. */
#define FTM_RD_QDCTRL_PHAFLTREN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHAFLTREN_MASK) >> FTM_QDCTRL_PHAFLTREN_SHIFT)
#define FTM_BRD_QDCTRL_PHAFLTREN(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAFLTREN_SHIFT))

/*! @brief Set the PHAFLTREN field to a new value. */
#define FTM_WR_QDCTRL_PHAFLTREN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHAFLTREN_MASK, FTM_QDCTRL_PHAFLTREN(value)))
#define FTM_BWR_QDCTRL_PHAFLTREN(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAFLTREN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief FTM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the number of times that the FTM counter overflow
 * should occur before the TOF bit to be set, the FTM behavior in BDM modes, the use
 * of an external global time base, and the global time base signal generation.
 */
/*!
 * @name Constants and macros for entire FTM_CONF register
 */
/*@{*/
#define FTM_RD_CONF(base)        (FTM_CONF_REG(base))
#define FTM_WR_CONF(base, value) (FTM_CONF_REG(base) = (value))
#define FTM_RMW_CONF(base, mask, value) (FTM_WR_CONF(base, (FTM_RD_CONF(base) & ~(mask)) | (value)))
#define FTM_SET_CONF(base, value) (FTM_WR_CONF(base, FTM_RD_CONF(base) |  (value)))
#define FTM_CLR_CONF(base, value) (FTM_WR_CONF(base, FTM_RD_CONF(base) & ~(value)))
#define FTM_TOG_CONF(base, value) (FTM_WR_CONF(base, FTM_RD_CONF(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CONF bitfields
 */

/*!
 * @name Register FTM_CONF, field NUMTOF[4:0] (RW)
 *
 * Selects the ratio between the number of counter overflows to the number of
 * times the TOF bit is set. NUMTOF = 0: The TOF bit is set for each counter
 * overflow. NUMTOF = 1: The TOF bit is set for the first counter overflow but not for
 * the next overflow. NUMTOF = 2: The TOF bit is set for the first counter
 * overflow but not for the next 2 overflows. NUMTOF = 3: The TOF bit is set for the
 * first counter overflow but not for the next 3 overflows. This pattern continues
 * up to a maximum of 31.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_NUMTOF field. */
#define FTM_RD_CONF_NUMTOF(base) ((FTM_CONF_REG(base) & FTM_CONF_NUMTOF_MASK) >> FTM_CONF_NUMTOF_SHIFT)
#define FTM_BRD_CONF_NUMTOF(base) (FTM_RD_CONF_NUMTOF(base))

/*! @brief Set the NUMTOF field to a new value. */
#define FTM_WR_CONF_NUMTOF(base, value) (FTM_RMW_CONF(base, FTM_CONF_NUMTOF_MASK, FTM_CONF_NUMTOF(value)))
#define FTM_BWR_CONF_NUMTOF(base, value) (FTM_WR_CONF_NUMTOF(base, value))
/*@}*/

/*!
 * @name Register FTM_CONF, field BDMMODE[7:6] (RW)
 *
 * Selects the FTM behavior in BDM mode. See BDM Mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_BDMMODE field. */
#define FTM_RD_CONF_BDMMODE(base) ((FTM_CONF_REG(base) & FTM_CONF_BDMMODE_MASK) >> FTM_CONF_BDMMODE_SHIFT)
#define FTM_BRD_CONF_BDMMODE(base) (FTM_RD_CONF_BDMMODE(base))

/*! @brief Set the BDMMODE field to a new value. */
#define FTM_WR_CONF_BDMMODE(base, value) (FTM_RMW_CONF(base, FTM_CONF_BDMMODE_MASK, FTM_CONF_BDMMODE(value)))
#define FTM_BWR_CONF_BDMMODE(base, value) (FTM_WR_CONF_BDMMODE(base, value))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the FTM to use an external global time base signal that is
 * generated by another FTM.
 *
 * Values:
 * - 0 - Use of an external global time base is disabled.
 * - 1 - Use of an external global time base is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_GTBEEN field. */
#define FTM_RD_CONF_GTBEEN(base) ((FTM_CONF_REG(base) & FTM_CONF_GTBEEN_MASK) >> FTM_CONF_GTBEEN_SHIFT)
#define FTM_BRD_CONF_GTBEEN(base) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_GTBEEN_SHIFT))

/*! @brief Set the GTBEEN field to a new value. */
#define FTM_WR_CONF_GTBEEN(base, value) (FTM_RMW_CONF(base, FTM_CONF_GTBEEN_MASK, FTM_CONF_GTBEEN(value)))
#define FTM_BWR_CONF_GTBEEN(base, value) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_GTBEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEOUT[10] (RW)
 *
 * Enables the global time base signal generation to other FTMs.
 *
 * Values:
 * - 0 - A global time base signal generation is disabled.
 * - 1 - A global time base signal generation is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_GTBEOUT field. */
#define FTM_RD_CONF_GTBEOUT(base) ((FTM_CONF_REG(base) & FTM_CONF_GTBEOUT_MASK) >> FTM_CONF_GTBEOUT_SHIFT)
#define FTM_BRD_CONF_GTBEOUT(base) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_GTBEOUT_SHIFT))

/*! @brief Set the GTBEOUT field to a new value. */
#define FTM_WR_CONF_GTBEOUT(base, value) (FTM_RMW_CONF(base, FTM_CONF_GTBEOUT_MASK, FTM_CONF_GTBEOUT(value)))
#define FTM_BWR_CONF_GTBEOUT(base, value) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_GTBEOUT_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_FLTPOL - FTM Fault Input Polarity
 ******************************************************************************/

/*!
 * @brief FTM_FLTPOL - FTM Fault Input Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the fault inputs polarity.
 */
/*!
 * @name Constants and macros for entire FTM_FLTPOL register
 */
/*@{*/
#define FTM_RD_FLTPOL(base)      (FTM_FLTPOL_REG(base))
#define FTM_WR_FLTPOL(base, value) (FTM_FLTPOL_REG(base) = (value))
#define FTM_RMW_FLTPOL(base, mask, value) (FTM_WR_FLTPOL(base, (FTM_RD_FLTPOL(base) & ~(mask)) | (value)))
#define FTM_SET_FLTPOL(base, value) (FTM_WR_FLTPOL(base, FTM_RD_FLTPOL(base) |  (value)))
#define FTM_CLR_FLTPOL(base, value) (FTM_WR_FLTPOL(base, FTM_RD_FLTPOL(base) & ~(value)))
#define FTM_TOG_FLTPOL(base, value) (FTM_WR_FLTPOL(base, FTM_RD_FLTPOL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTPOL bitfields
 */

/*!
 * @name Register FTM_FLTPOL, field FLT0POL[0] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A one at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A zero at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT0POL field. */
#define FTM_RD_FLTPOL_FLT0POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT0POL_MASK) >> FTM_FLTPOL_FLT0POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT0POL(base) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT0POL_SHIFT))

/*! @brief Set the FLT0POL field to a new value. */
#define FTM_WR_FLTPOL_FLT0POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT0POL_MASK, FTM_FLTPOL_FLT0POL(value)))
#define FTM_BWR_FLTPOL_FLT0POL(base, value) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT0POL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT1POL[1] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A one at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A zero at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT1POL field. */
#define FTM_RD_FLTPOL_FLT1POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT1POL_MASK) >> FTM_FLTPOL_FLT1POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT1POL(base) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT1POL_SHIFT))

/*! @brief Set the FLT1POL field to a new value. */
#define FTM_WR_FLTPOL_FLT1POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT1POL_MASK, FTM_FLTPOL_FLT1POL(value)))
#define FTM_BWR_FLTPOL_FLT1POL(base, value) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT1POL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT2POL[2] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A one at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A zero at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT2POL field. */
#define FTM_RD_FLTPOL_FLT2POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT2POL_MASK) >> FTM_FLTPOL_FLT2POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT2POL(base) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT2POL_SHIFT))

/*! @brief Set the FLT2POL field to a new value. */
#define FTM_WR_FLTPOL_FLT2POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT2POL_MASK, FTM_FLTPOL_FLT2POL(value)))
#define FTM_BWR_FLTPOL_FLT2POL(base, value) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT2POL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT3POL[3] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A one at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A zero at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT3POL field. */
#define FTM_RD_FLTPOL_FLT3POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT3POL_MASK) >> FTM_FLTPOL_FLT3POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT3POL(base) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT3POL_SHIFT))

/*! @brief Set the FLT3POL field to a new value. */
#define FTM_WR_FLTPOL_FLT3POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT3POL_MASK, FTM_FLTPOL_FLT3POL(value)))
#define FTM_BWR_FLTPOL_FLT3POL(base, value) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT3POL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_SYNCONF - Synchronization Configuration
 ******************************************************************************/

/*!
 * @brief FTM_SYNCONF - Synchronization Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the PWM synchronization configuration, SWOCTRL, INVCTRL
 * and CNTIN registers synchronization, if FTM clears the TRIGj bit (where j =
 * 0, 1, 2) when the hardware trigger j is detected.
 */
/*!
 * @name Constants and macros for entire FTM_SYNCONF register
 */
/*@{*/
#define FTM_RD_SYNCONF(base)     (FTM_SYNCONF_REG(base))
#define FTM_WR_SYNCONF(base, value) (FTM_SYNCONF_REG(base) = (value))
#define FTM_RMW_SYNCONF(base, mask, value) (FTM_WR_SYNCONF(base, (FTM_RD_SYNCONF(base) & ~(mask)) | (value)))
#define FTM_SET_SYNCONF(base, value) (FTM_WR_SYNCONF(base, FTM_RD_SYNCONF(base) |  (value)))
#define FTM_CLR_SYNCONF(base, value) (FTM_WR_SYNCONF(base, FTM_RD_SYNCONF(base) & ~(value)))
#define FTM_TOG_SYNCONF(base, value) (FTM_WR_SYNCONF(base, FTM_RD_SYNCONF(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNCONF bitfields
 */

/*!
 * @name Register FTM_SYNCONF, field HWTRIGMODE[0] (RW)
 *
 * Values:
 * - 0 - FTM clears the TRIGj bit when the hardware trigger j is detected.
 * - 1 - FTM does not clear the TRIGj bit when the hardware trigger j is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWTRIGMODE field. */
#define FTM_RD_SYNCONF_HWTRIGMODE(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWTRIGMODE_MASK) >> FTM_SYNCONF_HWTRIGMODE_SHIFT)
#define FTM_BRD_SYNCONF_HWTRIGMODE(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWTRIGMODE_SHIFT))

/*! @brief Set the HWTRIGMODE field to a new value. */
#define FTM_WR_SYNCONF_HWTRIGMODE(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWTRIGMODE_MASK, FTM_SYNCONF_HWTRIGMODE(value)))
#define FTM_BWR_SYNCONF_HWTRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWTRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field CNTINC[2] (RW)
 *
 * Values:
 * - 0 - CNTIN register is updated with its buffer value at all rising edges of
 *     system clock.
 * - 1 - CNTIN register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_CNTINC field. */
#define FTM_RD_SYNCONF_CNTINC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_CNTINC_MASK) >> FTM_SYNCONF_CNTINC_SHIFT)
#define FTM_BRD_SYNCONF_CNTINC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_CNTINC_SHIFT))

/*! @brief Set the CNTINC field to a new value. */
#define FTM_WR_SYNCONF_CNTINC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_CNTINC_MASK, FTM_SYNCONF_CNTINC(value)))
#define FTM_BWR_SYNCONF_CNTINC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_CNTINC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field INVC[4] (RW)
 *
 * Values:
 * - 0 - INVCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 1 - INVCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_INVC field. */
#define FTM_RD_SYNCONF_INVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_INVC_MASK) >> FTM_SYNCONF_INVC_SHIFT)
#define FTM_BRD_SYNCONF_INVC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_INVC_SHIFT))

/*! @brief Set the INVC field to a new value. */
#define FTM_WR_SYNCONF_INVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_INVC_MASK, FTM_SYNCONF_INVC(value)))
#define FTM_BWR_SYNCONF_INVC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_INVC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOC[5] (RW)
 *
 * Values:
 * - 0 - SWOCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 1 - SWOCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWOC field. */
#define FTM_RD_SYNCONF_SWOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWOC_MASK) >> FTM_SYNCONF_SWOC_SHIFT)
#define FTM_BRD_SYNCONF_SWOC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOC_SHIFT))

/*! @brief Set the SWOC field to a new value. */
#define FTM_WR_SYNCONF_SWOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWOC_MASK, FTM_SYNCONF_SWOC(value)))
#define FTM_BWR_SYNCONF_SWOC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SYNCMODE[7] (RW)
 *
 * Selects the PWM synchronization mode.
 *
 * Values:
 * - 0 - Legacy PWM synchronization is selected.
 * - 1 - Enhanced PWM synchronization is selected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SYNCMODE field. */
#define FTM_RD_SYNCONF_SYNCMODE(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SYNCMODE_MASK) >> FTM_SYNCONF_SYNCMODE_SHIFT)
#define FTM_BRD_SYNCONF_SYNCMODE(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SYNCMODE_SHIFT))

/*! @brief Set the SYNCMODE field to a new value. */
#define FTM_WR_SYNCONF_SYNCMODE(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SYNCMODE_MASK, FTM_SYNCONF_SYNCMODE(value)))
#define FTM_BWR_SYNCONF_SYNCMODE(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SYNCMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWRSTCNT[8] (RW)
 *
 * FTM counter synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the FTM counter synchronization.
 * - 1 - The software trigger activates the FTM counter synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWRSTCNT field. */
#define FTM_RD_SYNCONF_SWRSTCNT(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWRSTCNT_MASK) >> FTM_SYNCONF_SWRSTCNT_SHIFT)
#define FTM_BRD_SYNCONF_SWRSTCNT(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWRSTCNT_SHIFT))

/*! @brief Set the SWRSTCNT field to a new value. */
#define FTM_WR_SYNCONF_SWRSTCNT(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWRSTCNT_MASK, FTM_SYNCONF_SWRSTCNT(value)))
#define FTM_BWR_SYNCONF_SWRSTCNT(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWRSTCNT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWWRBUF[9] (RW)
 *
 * MOD, CNTIN, and CV registers synchronization is activated by the software
 * trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate MOD, CNTIN, and CV registers
 *     synchronization.
 * - 1 - The software trigger activates MOD, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWWRBUF field. */
#define FTM_RD_SYNCONF_SWWRBUF(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWWRBUF_MASK) >> FTM_SYNCONF_SWWRBUF_SHIFT)
#define FTM_BRD_SYNCONF_SWWRBUF(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWWRBUF_SHIFT))

/*! @brief Set the SWWRBUF field to a new value. */
#define FTM_WR_SYNCONF_SWWRBUF(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWWRBUF_MASK, FTM_SYNCONF_SWWRBUF(value)))
#define FTM_BWR_SYNCONF_SWWRBUF(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWWRBUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOM[10] (RW)
 *
 * Output mask synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the OUTMASK register
 *     synchronization.
 * - 1 - The software trigger activates the OUTMASK register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWOM field. */
#define FTM_RD_SYNCONF_SWOM(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWOM_MASK) >> FTM_SYNCONF_SWOM_SHIFT)
#define FTM_BRD_SYNCONF_SWOM(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOM_SHIFT))

/*! @brief Set the SWOM field to a new value. */
#define FTM_WR_SYNCONF_SWOM(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWOM_MASK, FTM_SYNCONF_SWOM(value)))
#define FTM_BWR_SYNCONF_SWOM(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWINVC[11] (RW)
 *
 * Inverting control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the INVCTRL register
 *     synchronization.
 * - 1 - The software trigger activates the INVCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWINVC field. */
#define FTM_RD_SYNCONF_SWINVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWINVC_MASK) >> FTM_SYNCONF_SWINVC_SHIFT)
#define FTM_BRD_SYNCONF_SWINVC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWINVC_SHIFT))

/*! @brief Set the SWINVC field to a new value. */
#define FTM_WR_SYNCONF_SWINVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWINVC_MASK, FTM_SYNCONF_SWINVC(value)))
#define FTM_BWR_SYNCONF_SWINVC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWINVC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWSOC[12] (RW)
 *
 * Software output control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 1 - The software trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWSOC field. */
#define FTM_RD_SYNCONF_SWSOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWSOC_MASK) >> FTM_SYNCONF_SWSOC_SHIFT)
#define FTM_BRD_SYNCONF_SWSOC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWSOC_SHIFT))

/*! @brief Set the SWSOC field to a new value. */
#define FTM_WR_SYNCONF_SWSOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWSOC_MASK, FTM_SYNCONF_SWSOC(value)))
#define FTM_BWR_SYNCONF_SWSOC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWSOC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWRSTCNT[16] (RW)
 *
 * FTM counter synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the FTM counter synchronization.
 * - 1 - A hardware trigger activates the FTM counter synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWRSTCNT field. */
#define FTM_RD_SYNCONF_HWRSTCNT(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWRSTCNT_MASK) >> FTM_SYNCONF_HWRSTCNT_SHIFT)
#define FTM_BRD_SYNCONF_HWRSTCNT(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWRSTCNT_SHIFT))

/*! @brief Set the HWRSTCNT field to a new value. */
#define FTM_WR_SYNCONF_HWRSTCNT(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWRSTCNT_MASK, FTM_SYNCONF_HWRSTCNT(value)))
#define FTM_BWR_SYNCONF_HWRSTCNT(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWRSTCNT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWWRBUF[17] (RW)
 *
 * MOD, CNTIN, and CV registers synchronization is activated by a hardware
 * trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate MOD, CNTIN, and CV registers
 *     synchronization.
 * - 1 - A hardware trigger activates MOD, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWWRBUF field. */
#define FTM_RD_SYNCONF_HWWRBUF(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWWRBUF_MASK) >> FTM_SYNCONF_HWWRBUF_SHIFT)
#define FTM_BRD_SYNCONF_HWWRBUF(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWWRBUF_SHIFT))

/*! @brief Set the HWWRBUF field to a new value. */
#define FTM_WR_SYNCONF_HWWRBUF(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWWRBUF_MASK, FTM_SYNCONF_HWWRBUF(value)))
#define FTM_BWR_SYNCONF_HWWRBUF(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWWRBUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWOM[18] (RW)
 *
 * Output mask synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the OUTMASK register
 *     synchronization.
 * - 1 - A hardware trigger activates the OUTMASK register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWOM field. */
#define FTM_RD_SYNCONF_HWOM(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWOM_MASK) >> FTM_SYNCONF_HWOM_SHIFT)
#define FTM_BRD_SYNCONF_HWOM(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWOM_SHIFT))

/*! @brief Set the HWOM field to a new value. */
#define FTM_WR_SYNCONF_HWOM(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWOM_MASK, FTM_SYNCONF_HWOM(value)))
#define FTM_BWR_SYNCONF_HWOM(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWOM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWINVC[19] (RW)
 *
 * Inverting control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the INVCTRL register
 *     synchronization.
 * - 1 - A hardware trigger activates the INVCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWINVC field. */
#define FTM_RD_SYNCONF_HWINVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWINVC_MASK) >> FTM_SYNCONF_HWINVC_SHIFT)
#define FTM_BRD_SYNCONF_HWINVC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWINVC_SHIFT))

/*! @brief Set the HWINVC field to a new value. */
#define FTM_WR_SYNCONF_HWINVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWINVC_MASK, FTM_SYNCONF_HWINVC(value)))
#define FTM_BWR_SYNCONF_HWINVC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWINVC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWSOC[20] (RW)
 *
 * Software output control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 1 - A hardware trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWSOC field. */
#define FTM_RD_SYNCONF_HWSOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWSOC_MASK) >> FTM_SYNCONF_HWSOC_SHIFT)
#define FTM_BRD_SYNCONF_HWSOC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWSOC_SHIFT))

/*! @brief Set the HWSOC field to a new value. */
#define FTM_WR_SYNCONF_HWSOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWSOC_MASK, FTM_SYNCONF_HWSOC(value)))
#define FTM_BWR_SYNCONF_HWSOC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWSOC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_INVCTRL - FTM Inverting Control
 ******************************************************************************/

/*!
 * @brief FTM_INVCTRL - FTM Inverting Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls controls when the channel (n) output becomes the
 * channel (n+1) output, and channel (n+1) output becomes the channel (n) output. Each
 * INVmEN bit enables the inverting operation for the corresponding pair
 * channels m. This register has a write buffer. The INVmEN bit is updated by the
 * INVCTRL register synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_INVCTRL register
 */
/*@{*/
#define FTM_RD_INVCTRL(base)     (FTM_INVCTRL_REG(base))
#define FTM_WR_INVCTRL(base, value) (FTM_INVCTRL_REG(base) = (value))
#define FTM_RMW_INVCTRL(base, mask, value) (FTM_WR_INVCTRL(base, (FTM_RD_INVCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_INVCTRL(base, value) (FTM_WR_INVCTRL(base, FTM_RD_INVCTRL(base) |  (value)))
#define FTM_CLR_INVCTRL(base, value) (FTM_WR_INVCTRL(base, FTM_RD_INVCTRL(base) & ~(value)))
#define FTM_TOG_INVCTRL(base, value) (FTM_WR_INVCTRL(base, FTM_RD_INVCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_INVCTRL bitfields
 */

/*!
 * @name Register FTM_INVCTRL, field INV0EN[0] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV0EN field. */
#define FTM_RD_INVCTRL_INV0EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV0EN_MASK) >> FTM_INVCTRL_INV0EN_SHIFT)
#define FTM_BRD_INVCTRL_INV0EN(base) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV0EN_SHIFT))

/*! @brief Set the INV0EN field to a new value. */
#define FTM_WR_INVCTRL_INV0EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV0EN_MASK, FTM_INVCTRL_INV0EN(value)))
#define FTM_BWR_INVCTRL_INV0EN(base, value) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV0EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV1EN[1] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV1EN field. */
#define FTM_RD_INVCTRL_INV1EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV1EN_MASK) >> FTM_INVCTRL_INV1EN_SHIFT)
#define FTM_BRD_INVCTRL_INV1EN(base) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV1EN_SHIFT))

/*! @brief Set the INV1EN field to a new value. */
#define FTM_WR_INVCTRL_INV1EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV1EN_MASK, FTM_INVCTRL_INV1EN(value)))
#define FTM_BWR_INVCTRL_INV1EN(base, value) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV1EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV2EN[2] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV2EN field. */
#define FTM_RD_INVCTRL_INV2EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV2EN_MASK) >> FTM_INVCTRL_INV2EN_SHIFT)
#define FTM_BRD_INVCTRL_INV2EN(base) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV2EN_SHIFT))

/*! @brief Set the INV2EN field to a new value. */
#define FTM_WR_INVCTRL_INV2EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV2EN_MASK, FTM_INVCTRL_INV2EN(value)))
#define FTM_BWR_INVCTRL_INV2EN(base, value) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV2EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV3EN[3] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV3EN field. */
#define FTM_RD_INVCTRL_INV3EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV3EN_MASK) >> FTM_INVCTRL_INV3EN_SHIFT)
#define FTM_BRD_INVCTRL_INV3EN(base) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV3EN_SHIFT))

/*! @brief Set the INV3EN field to a new value. */
#define FTM_WR_INVCTRL_INV3EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV3EN_MASK, FTM_INVCTRL_INV3EN(value)))
#define FTM_BWR_INVCTRL_INV3EN(base, value) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV3EN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_SWOCTRL - FTM Software Output Control
 ******************************************************************************/

/*!
 * @brief FTM_SWOCTRL - FTM Software Output Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register enables software control of channel (n) output and defines the
 * value forced to the channel (n) output: The CHnOC bits enable the control of
 * the corresponding channel (n) output by software. The CHnOCV bits select the
 * value that is forced at the corresponding channel (n) output. This register has
 * a write buffer. The fields are updated by the SWOCTRL register synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_SWOCTRL register
 */
/*@{*/
#define FTM_RD_SWOCTRL(base)     (FTM_SWOCTRL_REG(base))
#define FTM_WR_SWOCTRL(base, value) (FTM_SWOCTRL_REG(base) = (value))
#define FTM_RMW_SWOCTRL(base, mask, value) (FTM_WR_SWOCTRL(base, (FTM_RD_SWOCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_SWOCTRL(base, value) (FTM_WR_SWOCTRL(base, FTM_RD_SWOCTRL(base) |  (value)))
#define FTM_CLR_SWOCTRL(base, value) (FTM_WR_SWOCTRL(base, FTM_RD_SWOCTRL(base) & ~(value)))
#define FTM_TOG_SWOCTRL(base, value) (FTM_WR_SWOCTRL(base, FTM_RD_SWOCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SWOCTRL bitfields
 */

/*!
 * @name Register FTM_SWOCTRL, field CH0OC[0] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH0OC field. */
#define FTM_RD_SWOCTRL_CH0OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH0OC_MASK) >> FTM_SWOCTRL_CH0OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH0OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OC_SHIFT))

/*! @brief Set the CH0OC field to a new value. */
#define FTM_WR_SWOCTRL_CH0OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH0OC_MASK, FTM_SWOCTRL_CH0OC(value)))
#define FTM_BWR_SWOCTRL_CH0OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OC[1] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH1OC field. */
#define FTM_RD_SWOCTRL_CH1OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH1OC_MASK) >> FTM_SWOCTRL_CH1OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH1OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OC_SHIFT))

/*! @brief Set the CH1OC field to a new value. */
#define FTM_WR_SWOCTRL_CH1OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH1OC_MASK, FTM_SWOCTRL_CH1OC(value)))
#define FTM_BWR_SWOCTRL_CH1OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OC[2] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH2OC field. */
#define FTM_RD_SWOCTRL_CH2OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH2OC_MASK) >> FTM_SWOCTRL_CH2OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH2OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OC_SHIFT))

/*! @brief Set the CH2OC field to a new value. */
#define FTM_WR_SWOCTRL_CH2OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH2OC_MASK, FTM_SWOCTRL_CH2OC(value)))
#define FTM_BWR_SWOCTRL_CH2OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OC[3] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH3OC field. */
#define FTM_RD_SWOCTRL_CH3OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH3OC_MASK) >> FTM_SWOCTRL_CH3OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH3OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OC_SHIFT))

/*! @brief Set the CH3OC field to a new value. */
#define FTM_WR_SWOCTRL_CH3OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH3OC_MASK, FTM_SWOCTRL_CH3OC(value)))
#define FTM_BWR_SWOCTRL_CH3OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OC[4] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH4OC field. */
#define FTM_RD_SWOCTRL_CH4OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH4OC_MASK) >> FTM_SWOCTRL_CH4OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH4OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OC_SHIFT))

/*! @brief Set the CH4OC field to a new value. */
#define FTM_WR_SWOCTRL_CH4OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH4OC_MASK, FTM_SWOCTRL_CH4OC(value)))
#define FTM_BWR_SWOCTRL_CH4OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OC[5] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH5OC field. */
#define FTM_RD_SWOCTRL_CH5OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH5OC_MASK) >> FTM_SWOCTRL_CH5OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH5OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OC_SHIFT))

/*! @brief Set the CH5OC field to a new value. */
#define FTM_WR_SWOCTRL_CH5OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH5OC_MASK, FTM_SWOCTRL_CH5OC(value)))
#define FTM_BWR_SWOCTRL_CH5OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OC[6] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH6OC field. */
#define FTM_RD_SWOCTRL_CH6OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH6OC_MASK) >> FTM_SWOCTRL_CH6OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH6OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OC_SHIFT))

/*! @brief Set the CH6OC field to a new value. */
#define FTM_WR_SWOCTRL_CH6OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH6OC_MASK, FTM_SWOCTRL_CH6OC(value)))
#define FTM_BWR_SWOCTRL_CH6OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OC[7] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH7OC field. */
#define FTM_RD_SWOCTRL_CH7OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH7OC_MASK) >> FTM_SWOCTRL_CH7OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH7OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OC_SHIFT))

/*! @brief Set the CH7OC field to a new value. */
#define FTM_WR_SWOCTRL_CH7OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH7OC_MASK, FTM_SWOCTRL_CH7OC(value)))
#define FTM_BWR_SWOCTRL_CH7OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH0OCV[8] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH0OCV field. */
#define FTM_RD_SWOCTRL_CH0OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH0OCV_MASK) >> FTM_SWOCTRL_CH0OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH0OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OCV_SHIFT))

/*! @brief Set the CH0OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH0OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH0OCV_MASK, FTM_SWOCTRL_CH0OCV(value)))
#define FTM_BWR_SWOCTRL_CH0OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OCV[9] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH1OCV field. */
#define FTM_RD_SWOCTRL_CH1OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH1OCV_MASK) >> FTM_SWOCTRL_CH1OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH1OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OCV_SHIFT))

/*! @brief Set the CH1OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH1OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH1OCV_MASK, FTM_SWOCTRL_CH1OCV(value)))
#define FTM_BWR_SWOCTRL_CH1OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OCV[10] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH2OCV field. */
#define FTM_RD_SWOCTRL_CH2OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH2OCV_MASK) >> FTM_SWOCTRL_CH2OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH2OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OCV_SHIFT))

/*! @brief Set the CH2OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH2OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH2OCV_MASK, FTM_SWOCTRL_CH2OCV(value)))
#define FTM_BWR_SWOCTRL_CH2OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OCV[11] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH3OCV field. */
#define FTM_RD_SWOCTRL_CH3OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH3OCV_MASK) >> FTM_SWOCTRL_CH3OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH3OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OCV_SHIFT))

/*! @brief Set the CH3OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH3OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH3OCV_MASK, FTM_SWOCTRL_CH3OCV(value)))
#define FTM_BWR_SWOCTRL_CH3OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OCV[12] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH4OCV field. */
#define FTM_RD_SWOCTRL_CH4OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH4OCV_MASK) >> FTM_SWOCTRL_CH4OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH4OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OCV_SHIFT))

/*! @brief Set the CH4OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH4OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH4OCV_MASK, FTM_SWOCTRL_CH4OCV(value)))
#define FTM_BWR_SWOCTRL_CH4OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OCV[13] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH5OCV field. */
#define FTM_RD_SWOCTRL_CH5OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH5OCV_MASK) >> FTM_SWOCTRL_CH5OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH5OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OCV_SHIFT))

/*! @brief Set the CH5OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH5OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH5OCV_MASK, FTM_SWOCTRL_CH5OCV(value)))
#define FTM_BWR_SWOCTRL_CH5OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OCV[14] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH6OCV field. */
#define FTM_RD_SWOCTRL_CH6OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH6OCV_MASK) >> FTM_SWOCTRL_CH6OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH6OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OCV_SHIFT))

/*! @brief Set the CH6OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH6OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH6OCV_MASK, FTM_SWOCTRL_CH6OCV(value)))
#define FTM_BWR_SWOCTRL_CH6OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OCV[15] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH7OCV field. */
#define FTM_RD_SWOCTRL_CH7OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH7OCV_MASK) >> FTM_SWOCTRL_CH7OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH7OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OCV_SHIFT))

/*! @brief Set the CH7OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH7OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH7OCV_MASK, FTM_SWOCTRL_CH7OCV(value)))
#define FTM_BWR_SWOCTRL_CH7OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OCV_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_PWMLOAD - FTM PWM Load
 ******************************************************************************/

/*!
 * @brief FTM_PWMLOAD - FTM PWM Load (RW)
 *
 * Reset value: 0x00000000U
 *
 * Enables the loading of the MOD, CNTIN, C(n)V, and C(n+1)V registers with the
 * values of their write buffers when the FTM counter changes from the MOD
 * register value to its next value or when a channel (j) match occurs. A match occurs
 * for the channel (j) when FTM counter = C(j)V.
 */
/*!
 * @name Constants and macros for entire FTM_PWMLOAD register
 */
/*@{*/
#define FTM_RD_PWMLOAD(base)     (FTM_PWMLOAD_REG(base))
#define FTM_WR_PWMLOAD(base, value) (FTM_PWMLOAD_REG(base) = (value))
#define FTM_RMW_PWMLOAD(base, mask, value) (FTM_WR_PWMLOAD(base, (FTM_RD_PWMLOAD(base) & ~(mask)) | (value)))
#define FTM_SET_PWMLOAD(base, value) (FTM_WR_PWMLOAD(base, FTM_RD_PWMLOAD(base) |  (value)))
#define FTM_CLR_PWMLOAD(base, value) (FTM_WR_PWMLOAD(base, FTM_RD_PWMLOAD(base) & ~(value)))
#define FTM_TOG_PWMLOAD(base, value) (FTM_WR_PWMLOAD(base, FTM_RD_PWMLOAD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_PWMLOAD bitfields
 */

/*!
 * @name Register FTM_PWMLOAD, field CH0SEL[0] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH0SEL field. */
#define FTM_RD_PWMLOAD_CH0SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH0SEL_MASK) >> FTM_PWMLOAD_CH0SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH0SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH0SEL_SHIFT))

/*! @brief Set the CH0SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH0SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH0SEL_MASK, FTM_PWMLOAD_CH0SEL(value)))
#define FTM_BWR_PWMLOAD_CH0SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH0SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH1SEL[1] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH1SEL field. */
#define FTM_RD_PWMLOAD_CH1SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH1SEL_MASK) >> FTM_PWMLOAD_CH1SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH1SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH1SEL_SHIFT))

/*! @brief Set the CH1SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH1SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH1SEL_MASK, FTM_PWMLOAD_CH1SEL(value)))
#define FTM_BWR_PWMLOAD_CH1SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH1SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH2SEL[2] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH2SEL field. */
#define FTM_RD_PWMLOAD_CH2SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH2SEL_MASK) >> FTM_PWMLOAD_CH2SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH2SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH2SEL_SHIFT))

/*! @brief Set the CH2SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH2SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH2SEL_MASK, FTM_PWMLOAD_CH2SEL(value)))
#define FTM_BWR_PWMLOAD_CH2SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH2SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH3SEL[3] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH3SEL field. */
#define FTM_RD_PWMLOAD_CH3SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH3SEL_MASK) >> FTM_PWMLOAD_CH3SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH3SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH3SEL_SHIFT))

/*! @brief Set the CH3SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH3SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH3SEL_MASK, FTM_PWMLOAD_CH3SEL(value)))
#define FTM_BWR_PWMLOAD_CH3SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH3SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH4SEL[4] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH4SEL field. */
#define FTM_RD_PWMLOAD_CH4SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH4SEL_MASK) >> FTM_PWMLOAD_CH4SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH4SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH4SEL_SHIFT))

/*! @brief Set the CH4SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH4SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH4SEL_MASK, FTM_PWMLOAD_CH4SEL(value)))
#define FTM_BWR_PWMLOAD_CH4SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH4SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH5SEL[5] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH5SEL field. */
#define FTM_RD_PWMLOAD_CH5SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH5SEL_MASK) >> FTM_PWMLOAD_CH5SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH5SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH5SEL_SHIFT))

/*! @brief Set the CH5SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH5SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH5SEL_MASK, FTM_PWMLOAD_CH5SEL(value)))
#define FTM_BWR_PWMLOAD_CH5SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH5SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH6SEL[6] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH6SEL field. */
#define FTM_RD_PWMLOAD_CH6SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH6SEL_MASK) >> FTM_PWMLOAD_CH6SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH6SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH6SEL_SHIFT))

/*! @brief Set the CH6SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH6SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH6SEL_MASK, FTM_PWMLOAD_CH6SEL(value)))
#define FTM_BWR_PWMLOAD_CH6SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH6SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH7SEL[7] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH7SEL field. */
#define FTM_RD_PWMLOAD_CH7SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH7SEL_MASK) >> FTM_PWMLOAD_CH7SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH7SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH7SEL_SHIFT))

/*! @brief Set the CH7SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH7SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH7SEL_MASK, FTM_PWMLOAD_CH7SEL(value)))
#define FTM_BWR_PWMLOAD_CH7SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH7SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field LDOK[9] (RW)
 *
 * Enables the loading of the MOD, CNTIN, and CV registers with the values of
 * their write buffers.
 *
 * Values:
 * - 0 - Loading updated values is disabled.
 * - 1 - Loading updated values is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_LDOK field. */
#define FTM_RD_PWMLOAD_LDOK(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_LDOK_MASK) >> FTM_PWMLOAD_LDOK_SHIFT)
#define FTM_BRD_PWMLOAD_LDOK(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_LDOK_SHIFT))

/*! @brief Set the LDOK field to a new value. */
#define FTM_WR_PWMLOAD_LDOK(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_LDOK_MASK, FTM_PWMLOAD_LDOK(value)))
#define FTM_BWR_PWMLOAD_LDOK(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_LDOK_SHIFT) = (value))
/*@}*/

/*
 * MK20D5 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - GPIO_PDOR - Port Data Output Register
 * - GPIO_PSOR - Port Set Output Register
 * - GPIO_PCOR - Port Clear Output Register
 * - GPIO_PTOR - Port Toggle Output Register
 * - GPIO_PDIR - Port Data Input Register
 * - GPIO_PDDR - Port Data Direction Register
 */

#define GPIO_INSTANCE_COUNT (5U) /*!< Number of instances of the GPIO module. */
#define GPIOA_IDX (0U) /*!< Instance number for GPIOA. */
#define GPIOB_IDX (1U) /*!< Instance number for GPIOB. */
#define GPIOC_IDX (2U) /*!< Instance number for GPIOC. */
#define GPIOD_IDX (3U) /*!< Instance number for GPIOD. */
#define GPIOE_IDX (4U) /*!< Instance number for GPIOE. */

/*******************************************************************************
 * GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define GPIO_RD_PDOR(base)       (GPIO_PDOR_REG(base))
#define GPIO_WR_PDOR(base, value) (GPIO_PDOR_REG(base) = (value))
#define GPIO_RMW_PDOR(base, mask, value) (GPIO_WR_PDOR(base, (GPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) |  (value)))
#define GPIO_CLR_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) & ~(value)))
#define GPIO_TOG_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define GPIO_RD_PSOR(base)       (GPIO_PSOR_REG(base))
#define GPIO_WR_PSOR(base, value) (GPIO_PSOR_REG(base) = (value))
#define GPIO_RMW_PSOR(base, mask, value) (GPIO_WR_PSOR(base, (GPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define GPIO_RD_PCOR(base)       (GPIO_PCOR_REG(base))
#define GPIO_WR_PCOR(base, value) (GPIO_PCOR_REG(base) = (value))
#define GPIO_RMW_PCOR(base, mask, value) (GPIO_WR_PCOR(base, (GPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define GPIO_RD_PTOR(base)       (GPIO_PTOR_REG(base))
#define GPIO_WR_PTOR(base, value) (GPIO_PTOR_REG(base) = (value))
#define GPIO_RMW_PTOR(base, mask, value) (GPIO_WR_PTOR(base, (GPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define GPIO_RD_PDIR(base)       (GPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define GPIO_RD_PDDR(base)       (GPIO_PDDR_REG(base))
#define GPIO_WR_PDDR(base, value) (GPIO_PDDR_REG(base) = (value))
#define GPIO_RMW_PDDR(base, mask, value) (GPIO_WR_PDDR(base, (GPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) |  (value)))
#define GPIO_CLR_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) & ~(value)))
#define GPIO_TOG_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) ^  (value)))
/*@}*/

/*
 * MK20D5 I2C
 *
 * Inter-Integrated Circuit
 *
 * Registers defined in this header file:
 * - I2C_A1 - I2C Address Register 1
 * - I2C_F - I2C Frequency Divider register
 * - I2C_C1 - I2C Control Register 1
 * - I2C_S - I2C Status Register
 * - I2C_D - I2C Data I/O register
 * - I2C_C2 - I2C Control Register 2
 * - I2C_FLT - I2C Programmable Input Glitch Filter register
 * - I2C_RA - I2C Range Address register
 * - I2C_SMB - I2C SMBus Control and Status register
 * - I2C_A2 - I2C Address Register 2
 * - I2C_SLTH - I2C SCL Low Timeout Register High
 * - I2C_SLTL - I2C SCL Low Timeout Register Low
 */

#define I2C_INSTANCE_COUNT (1U) /*!< Number of instances of the I2C module. */
#define I2C0_IDX (0U) /*!< Instance number for I2C0. */

/*******************************************************************************
 * I2C_A1 - I2C Address Register 1
 ******************************************************************************/

/*!
 * @brief I2C_A1 - I2C Address Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the slave address to be used by the I2C module.
 */
/*!
 * @name Constants and macros for entire I2C_A1 register
 */
/*@{*/
#define I2C_RD_A1(base)          (I2C_A1_REG(base))
#define I2C_WR_A1(base, value)   (I2C_A1_REG(base) = (value))
#define I2C_RMW_A1(base, mask, value) (I2C_WR_A1(base, (I2C_RD_A1(base) & ~(mask)) | (value)))
#define I2C_SET_A1(base, value)  (I2C_WR_A1(base, I2C_RD_A1(base) |  (value)))
#define I2C_CLR_A1(base, value)  (I2C_WR_A1(base, I2C_RD_A1(base) & ~(value)))
#define I2C_TOG_A1(base, value)  (I2C_WR_A1(base, I2C_RD_A1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A1 bitfields
 */

/*!
 * @name Register I2C_A1, field AD[7:1] (RW)
 *
 * Contains the primary slave address used by the I2C module when it is
 * addressed as a slave. This field is used in the 7-bit address scheme and the lower
 * seven bits in the 10-bit address scheme.
 */
/*@{*/
/*! @brief Read current value of the I2C_A1_AD field. */
#define I2C_RD_A1_AD(base)   ((I2C_A1_REG(base) & I2C_A1_AD_MASK) >> I2C_A1_AD_SHIFT)
#define I2C_BRD_A1_AD(base)  (I2C_RD_A1_AD(base))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_A1_AD(base, value) (I2C_RMW_A1(base, I2C_A1_AD_MASK, I2C_A1_AD(value)))
#define I2C_BWR_A1_AD(base, value) (I2C_WR_A1_AD(base, value))
/*@}*/

/*******************************************************************************
 * I2C_F - I2C Frequency Divider register
 ******************************************************************************/

/*!
 * @brief I2C_F - I2C Frequency Divider register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_F register
 */
/*@{*/
#define I2C_RD_F(base)           (I2C_F_REG(base))
#define I2C_WR_F(base, value)    (I2C_F_REG(base) = (value))
#define I2C_RMW_F(base, mask, value) (I2C_WR_F(base, (I2C_RD_F(base) & ~(mask)) | (value)))
#define I2C_SET_F(base, value)   (I2C_WR_F(base, I2C_RD_F(base) |  (value)))
#define I2C_CLR_F(base, value)   (I2C_WR_F(base, I2C_RD_F(base) & ~(value)))
#define I2C_TOG_F(base, value)   (I2C_WR_F(base, I2C_RD_F(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2C_F bitfields
 */

/*!
 * @name Register I2C_F, field ICR[5:0] (RW)
 *
 * Prescales the bus clock for bit rate selection. This field and the MULT field
 * determine the I2C baud rate, the SDA hold time, the SCL start hold time, and
 * the SCL stop hold time. For a list of values corresponding to each ICR
 * setting, see I2C Divider and Hold Values. The SCL divider multiplied by multiplier
 * factor (mul) determines the I2C baud rate. I2C baud rate = bus speed (Hz)/(mul *
 * SCL divider) The SDA hold time is the delay from the falling edge of SCL (I2C
 * clock) to the changing of SDA (I2C data). SDA hold time = bus period (s) *
 * mul * SDA hold value The SCL start hold time is the delay from the falling edge
 * of SDA (I2C data) while SCL is high (start condition) to the falling edge of
 * SCL (I2C clock). SCL start hold time = bus period (s) * mul * SCL start hold
 * value The SCL stop hold time is the delay from the rising edge of SCL (I2C
 * clock) to the rising edge of SDA (I2C data) while SCL is high (stop condition). SCL
 * stop hold time = bus period (s) * mul * SCL stop hold value
 */
/*@{*/
/*! @brief Read current value of the I2C_F_ICR field. */
#define I2C_RD_F_ICR(base)   ((I2C_F_REG(base) & I2C_F_ICR_MASK) >> I2C_F_ICR_SHIFT)
#define I2C_BRD_F_ICR(base)  (I2C_RD_F_ICR(base))

/*! @brief Set the ICR field to a new value. */
#define I2C_WR_F_ICR(base, value) (I2C_RMW_F(base, I2C_F_ICR_MASK, I2C_F_ICR(value)))
#define I2C_BWR_F_ICR(base, value) (I2C_WR_F_ICR(base, value))
/*@}*/

/*!
 * @name Register I2C_F, field MULT[7:6] (RW)
 *
 * The MULT bits define the multiplier factor mul. This factor is used along
 * with the SCL divider to generate the I2C baud rate.
 *
 * Values:
 * - 00 - mul = 1
 * - 01 - mul = 2
 * - 10 - mul = 4
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the I2C_F_MULT field. */
#define I2C_RD_F_MULT(base)  ((I2C_F_REG(base) & I2C_F_MULT_MASK) >> I2C_F_MULT_SHIFT)
#define I2C_BRD_F_MULT(base) (I2C_RD_F_MULT(base))

/*! @brief Set the MULT field to a new value. */
#define I2C_WR_F_MULT(base, value) (I2C_RMW_F(base, I2C_F_MULT_MASK, I2C_F_MULT(value)))
#define I2C_BWR_F_MULT(base, value) (I2C_WR_F_MULT(base, value))
/*@}*/

/*******************************************************************************
 * I2C_C1 - I2C Control Register 1
 ******************************************************************************/

/*!
 * @brief I2C_C1 - I2C Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C1 register
 */
/*@{*/
#define I2C_RD_C1(base)          (I2C_C1_REG(base))
#define I2C_WR_C1(base, value)   (I2C_C1_REG(base) = (value))
#define I2C_RMW_C1(base, mask, value) (I2C_WR_C1(base, (I2C_RD_C1(base) & ~(mask)) | (value)))
#define I2C_SET_C1(base, value)  (I2C_WR_C1(base, I2C_RD_C1(base) |  (value)))
#define I2C_CLR_C1(base, value)  (I2C_WR_C1(base, I2C_RD_C1(base) & ~(value)))
#define I2C_TOG_C1(base, value)  (I2C_WR_C1(base, I2C_RD_C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C1 bitfields
 */

/*!
 * @name Register I2C_C1, field DMAEN[0] (RW)
 *
 * The DMAEN bit enables or disables the DMA function.
 *
 * Values:
 * - 0 - All DMA signalling disabled.
 * - 1 - DMA transfer is enabled and the following conditions trigger the DMA
 *     request: While FACK = 0, a data byte is received, either address or data is
 *     transmitted. (ACK/NACK automatic) While FACK = 0, the first byte received
 *     matches the A1 register or is general call address. If any address
 *     matching occurs, IAAS and TCF are set. If the direction of transfer is known from
 *     master to slave, then it is not required to check the SRW. With this
 *     assumption, DMA can also be used in this case. In other cases, if the master
 *     reads data from the slave, then it is required to rewrite the C1 register
 *     operation. With this assumption, DMA cannot be used. When FACK = 1, an
 *     address or a data byte is transmitted.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_DMAEN field. */
#define I2C_RD_C1_DMAEN(base) ((I2C_C1_REG(base) & I2C_C1_DMAEN_MASK) >> I2C_C1_DMAEN_SHIFT)
#define I2C_BRD_C1_DMAEN(base) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define I2C_WR_C1_DMAEN(base, value) (I2C_RMW_C1(base, I2C_C1_DMAEN_MASK, I2C_C1_DMAEN(value)))
#define I2C_BWR_C1_DMAEN(base, value) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_DMAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C1, field WUEN[1] (RW)
 *
 * The I2C module can wake the MCU from low power mode with no peripheral bus
 * running when slave address matching occurs.
 *
 * Values:
 * - 0 - Normal operation. No interrupt generated when address matching in low
 *     power mode.
 * - 1 - Enables the wakeup function in low power mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_WUEN field. */
#define I2C_RD_C1_WUEN(base) ((I2C_C1_REG(base) & I2C_C1_WUEN_MASK) >> I2C_C1_WUEN_SHIFT)
#define I2C_BRD_C1_WUEN(base) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_WUEN_SHIFT))

/*! @brief Set the WUEN field to a new value. */
#define I2C_WR_C1_WUEN(base, value) (I2C_RMW_C1(base, I2C_C1_WUEN_MASK, I2C_C1_WUEN(value)))
#define I2C_BWR_C1_WUEN(base, value) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_WUEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C1, field RSTA[2] (WORZ)
 *
 * Writing a one to this bit generates a repeated START condition provided it is
 * the current master. This bit will always be read as zero. Attempting a repeat
 * at the wrong time results in loss of arbitration.
 */
/*@{*/
/*! @brief Set the RSTA field to a new value. */
#define I2C_WR_C1_RSTA(base, value) (I2C_RMW_C1(base, I2C_C1_RSTA_MASK, I2C_C1_RSTA(value)))
#define I2C_BWR_C1_RSTA(base, value) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_RSTA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C1, field TXAK[3] (RW)
 *
 * Specifies the value driven onto the SDA during data acknowledge cycles for
 * both master and slave receivers. The value of the FACK bit affects NACK/ACK
 * generation.
 *
 * Values:
 * - 0 - An acknowledge signal is sent to the bus on the following (if FACK is
 *     cleared) or current (if FACK is set) receiving byte.
 * - 1 - No acknowledge signal is sent to the bus on the following (if FACK is
 *     cleared) or current (if FACK is set) receiving data byte.SCL is held low
 *     until TXAK is written.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TXAK field. */
#define I2C_RD_C1_TXAK(base) ((I2C_C1_REG(base) & I2C_C1_TXAK_MASK) >> I2C_C1_TXAK_SHIFT)
#define I2C_BRD_C1_TXAK(base) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_TXAK_SHIFT))

/*! @brief Set the TXAK field to a new value. */
#define I2C_WR_C1_TXAK(base, value) (I2C_RMW_C1(base, I2C_C1_TXAK_MASK, I2C_C1_TXAK(value)))
#define I2C_BWR_C1_TXAK(base, value) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_TXAK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C1, field TX[4] (RW)
 *
 * Selects the direction of master and slave transfers. In master mode this bit
 * must be set according to the type of transfer required. Therefore, for address
 * cycles, this bit is always set. When addressed as a slave this bit must be
 * set by software according to the SRW bit in the status register.
 *
 * Values:
 * - 0 - Receive
 * - 1 - Transmit
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TX field. */
#define I2C_RD_C1_TX(base)   ((I2C_C1_REG(base) & I2C_C1_TX_MASK) >> I2C_C1_TX_SHIFT)
#define I2C_BRD_C1_TX(base)  (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_TX_SHIFT))

/*! @brief Set the TX field to a new value. */
#define I2C_WR_C1_TX(base, value) (I2C_RMW_C1(base, I2C_C1_TX_MASK, I2C_C1_TX(value)))
#define I2C_BWR_C1_TX(base, value) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_TX_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C1, field MST[5] (RW)
 *
 * When the MST bit is changed from a 0 to a 1, a START signal is generated on
 * the bus and master mode is selected. When this bit changes from a 1 to a 0, a
 * STOP signal is generated and the mode of operation changes from master to slave.
 *
 * Values:
 * - 0 - Slave mode
 * - 1 - Master mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_MST field. */
#define I2C_RD_C1_MST(base)  ((I2C_C1_REG(base) & I2C_C1_MST_MASK) >> I2C_C1_MST_SHIFT)
#define I2C_BRD_C1_MST(base) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_MST_SHIFT))

/*! @brief Set the MST field to a new value. */
#define I2C_WR_C1_MST(base, value) (I2C_RMW_C1(base, I2C_C1_MST_MASK, I2C_C1_MST(value)))
#define I2C_BWR_C1_MST(base, value) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_MST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C1, field IICIE[6] (RW)
 *
 * Enables I2C interrupt requests.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICIE field. */
#define I2C_RD_C1_IICIE(base) ((I2C_C1_REG(base) & I2C_C1_IICIE_MASK) >> I2C_C1_IICIE_SHIFT)
#define I2C_BRD_C1_IICIE(base) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_IICIE_SHIFT))

/*! @brief Set the IICIE field to a new value. */
#define I2C_WR_C1_IICIE(base, value) (I2C_RMW_C1(base, I2C_C1_IICIE_MASK, I2C_C1_IICIE(value)))
#define I2C_BWR_C1_IICIE(base, value) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_IICIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C1, field IICEN[7] (RW)
 *
 * Enables I2C module operation.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICEN field. */
#define I2C_RD_C1_IICEN(base) ((I2C_C1_REG(base) & I2C_C1_IICEN_MASK) >> I2C_C1_IICEN_SHIFT)
#define I2C_BRD_C1_IICEN(base) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_IICEN_SHIFT))

/*! @brief Set the IICEN field to a new value. */
#define I2C_WR_C1_IICEN(base, value) (I2C_RMW_C1(base, I2C_C1_IICEN_MASK, I2C_C1_IICEN(value)))
#define I2C_BWR_C1_IICEN(base, value) (BITBAND_ACCESS8(&I2C_C1_REG(base), I2C_C1_IICEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2C_S - I2C Status Register
 ******************************************************************************/

/*!
 * @brief I2C_S - I2C Status Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire I2C_S register
 */
/*@{*/
#define I2C_RD_S(base)           (I2C_S_REG(base))
#define I2C_WR_S(base, value)    (I2C_S_REG(base) = (value))
#define I2C_RMW_S(base, mask, value) (I2C_WR_S(base, (I2C_RD_S(base) & ~(mask)) | (value)))
#define I2C_SET_S(base, value)   (I2C_WR_S(base, I2C_RD_S(base) |  (value)))
#define I2C_CLR_S(base, value)   (I2C_WR_S(base, I2C_RD_S(base) & ~(value)))
#define I2C_TOG_S(base, value)   (I2C_WR_S(base, I2C_RD_S(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2C_S bitfields
 */

/*!
 * @name Register I2C_S, field RXAK[0] (RO)
 *
 * Values:
 * - 0 - Acknowledge signal was received after the completion of one byte of
 *     data transmission on the bus
 * - 1 - No acknowledge signal detected
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RXAK field. */
#define I2C_RD_S_RXAK(base)  ((I2C_S_REG(base) & I2C_S_RXAK_MASK) >> I2C_S_RXAK_SHIFT)
#define I2C_BRD_S_RXAK(base) (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_RXAK_SHIFT))
/*@}*/

/*!
 * @name Register I2C_S, field IICIF[1] (W1C)
 *
 * This bit sets when an interrupt is pending. This bit must be cleared by
 * software or by writing a 1 to it in the interrupt routine. One of the following
 * events can set this bit: One byte transfer including ACK/NACK bit completes if
 * FACK = 0 One byte transfer excluding ACK/NACK bit completes if FACK = 1. An ACK
 * or NACK is sent on the bus by writing 0 or 1 to TXAK after this bit is set in
 * receive mode Match of slave address to calling address including primary slave
 * address, range slave address , alert response address, second slave address,
 * or general call address. Arbitration lost In SMBus mode, any timeouts except
 * SCL and SDA high timeouts
 *
 * Values:
 * - 0 - No interrupt pending
 * - 1 - Interrupt pending
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IICIF field. */
#define I2C_RD_S_IICIF(base) ((I2C_S_REG(base) & I2C_S_IICIF_MASK) >> I2C_S_IICIF_SHIFT)
#define I2C_BRD_S_IICIF(base) (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_IICIF_SHIFT))

/*! @brief Set the IICIF field to a new value. */
#define I2C_WR_S_IICIF(base, value) (I2C_RMW_S(base, (I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IICIF(value)))
#define I2C_BWR_S_IICIF(base, value) (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_IICIF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_S, field SRW[2] (RO)
 *
 * When addressed as a slave, SRW indicates the value of the R/W command bit of
 * the calling address sent to the master.
 *
 * Values:
 * - 0 - Slave receive, master writing to slave
 * - 1 - Slave transmit, master reading from slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_SRW field. */
#define I2C_RD_S_SRW(base)   ((I2C_S_REG(base) & I2C_S_SRW_MASK) >> I2C_S_SRW_SHIFT)
#define I2C_BRD_S_SRW(base)  (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_SRW_SHIFT))
/*@}*/

/*!
 * @name Register I2C_S, field RAM[3] (RW)
 *
 * This bit is set by any of the following conditions: Any nonzero calling
 * address is received that matches the address in the RA register. The RMEN bit is
 * set and the calling address is within the range of values of the A1 and RA
 * registers. Writing the C1 register with any value clears this bit.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RAM field. */
#define I2C_RD_S_RAM(base)   ((I2C_S_REG(base) & I2C_S_RAM_MASK) >> I2C_S_RAM_SHIFT)
#define I2C_BRD_S_RAM(base)  (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_RAM_SHIFT))

/*! @brief Set the RAM field to a new value. */
#define I2C_WR_S_RAM(base, value) (I2C_RMW_S(base, (I2C_S_RAM_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_RAM(value)))
#define I2C_BWR_S_RAM(base, value) (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_RAM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_S, field ARBL[4] (W1C)
 *
 * This bit is set by hardware when the arbitration procedure is lost. The ARBL
 * bit must be cleared by software, by writing a one to it.
 *
 * Values:
 * - 0 - Standard bus operation.
 * - 1 - Loss of arbitration.
 */
/*@{*/
/*! @brief Read current value of the I2C_S_ARBL field. */
#define I2C_RD_S_ARBL(base)  ((I2C_S_REG(base) & I2C_S_ARBL_MASK) >> I2C_S_ARBL_SHIFT)
#define I2C_BRD_S_ARBL(base) (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_ARBL_SHIFT))

/*! @brief Set the ARBL field to a new value. */
#define I2C_WR_S_ARBL(base, value) (I2C_RMW_S(base, (I2C_S_ARBL_MASK | I2C_S_IICIF_MASK), I2C_S_ARBL(value)))
#define I2C_BWR_S_ARBL(base, value) (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_ARBL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_S, field BUSY[5] (RO)
 *
 * Indicates the status of the bus regardless of slave or master mode. This bit
 * is set when a START signal is detected and cleared when a STOP signal is
 * detected.
 *
 * Values:
 * - 0 - Bus is idle
 * - 1 - Bus is busy
 */
/*@{*/
/*! @brief Read current value of the I2C_S_BUSY field. */
#define I2C_RD_S_BUSY(base)  ((I2C_S_REG(base) & I2C_S_BUSY_MASK) >> I2C_S_BUSY_SHIFT)
#define I2C_BRD_S_BUSY(base) (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_BUSY_SHIFT))
/*@}*/

/*!
 * @name Register I2C_S, field IAAS[6] (RW)
 *
 * This bit is set by one of the following conditions: The calling address
 * matches the programmed slave primary address in the A1 register or range address in
 * the RA register (which must be set to a nonzero value). GCAEN is set and a
 * general call is received. SIICAEN is set and the calling address matches the
 * second programmed slave address. ALERTEN is set and an SMBus alert response
 * address is received RMEN is set and an address is received that is within the range
 * between the values of the A1 and RA registers. This bit sets before the ACK
 * bit. The CPU must check the SRW bit and set TX/RX accordingly. Writing the C1
 * register with any value clears this bit.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IAAS field. */
#define I2C_RD_S_IAAS(base)  ((I2C_S_REG(base) & I2C_S_IAAS_MASK) >> I2C_S_IAAS_SHIFT)
#define I2C_BRD_S_IAAS(base) (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_IAAS_SHIFT))

/*! @brief Set the IAAS field to a new value. */
#define I2C_WR_S_IAAS(base, value) (I2C_RMW_S(base, (I2C_S_IAAS_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IAAS(value)))
#define I2C_BWR_S_IAAS(base, value) (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_IAAS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_S, field TCF[7] (RO)
 *
 * This bit sets on the completion of a byte and acknowledge bit transfer. This
 * bit is valid only during or immediately following a transfer to or from the
 * I2C module. The TCF bit is cleared by reading the I2C data register in receive
 * mode or by writing to the I2C data register in transmit mode.
 *
 * Values:
 * - 0 - Transfer in progress
 * - 1 - Transfer complete
 */
/*@{*/
/*! @brief Read current value of the I2C_S_TCF field. */
#define I2C_RD_S_TCF(base)   ((I2C_S_REG(base) & I2C_S_TCF_MASK) >> I2C_S_TCF_SHIFT)
#define I2C_BRD_S_TCF(base)  (BITBAND_ACCESS8(&I2C_S_REG(base), I2C_S_TCF_SHIFT))
/*@}*/

/*******************************************************************************
 * I2C_D - I2C Data I/O register
 ******************************************************************************/

/*!
 * @brief I2C_D - I2C Data I/O register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_D register
 */
/*@{*/
#define I2C_RD_D(base)           (I2C_D_REG(base))
#define I2C_WR_D(base, value)    (I2C_D_REG(base) = (value))
#define I2C_RMW_D(base, mask, value) (I2C_WR_D(base, (I2C_RD_D(base) & ~(mask)) | (value)))
#define I2C_SET_D(base, value)   (I2C_WR_D(base, I2C_RD_D(base) |  (value)))
#define I2C_CLR_D(base, value)   (I2C_WR_D(base, I2C_RD_D(base) & ~(value)))
#define I2C_TOG_D(base, value)   (I2C_WR_D(base, I2C_RD_D(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * I2C_C2 - I2C Control Register 2
 ******************************************************************************/

/*!
 * @brief I2C_C2 - I2C Control Register 2 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C2 register
 */
/*@{*/
#define I2C_RD_C2(base)          (I2C_C2_REG(base))
#define I2C_WR_C2(base, value)   (I2C_C2_REG(base) = (value))
#define I2C_RMW_C2(base, mask, value) (I2C_WR_C2(base, (I2C_RD_C2(base) & ~(mask)) | (value)))
#define I2C_SET_C2(base, value)  (I2C_WR_C2(base, I2C_RD_C2(base) |  (value)))
#define I2C_CLR_C2(base, value)  (I2C_WR_C2(base, I2C_RD_C2(base) & ~(value)))
#define I2C_TOG_C2(base, value)  (I2C_WR_C2(base, I2C_RD_C2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C2 bitfields
 */

/*!
 * @name Register I2C_C2, field AD[2:0] (RW)
 *
 * Contains the upper three bits of the slave address in the 10-bit address
 * scheme. This field is valid only when the ADEXT bit is set.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_AD field. */
#define I2C_RD_C2_AD(base)   ((I2C_C2_REG(base) & I2C_C2_AD_MASK) >> I2C_C2_AD_SHIFT)
#define I2C_BRD_C2_AD(base)  (I2C_RD_C2_AD(base))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_C2_AD(base, value) (I2C_RMW_C2(base, I2C_C2_AD_MASK, I2C_C2_AD(value)))
#define I2C_BWR_C2_AD(base, value) (I2C_WR_C2_AD(base, value))
/*@}*/

/*!
 * @name Register I2C_C2, field RMEN[3] (RW)
 *
 * This bit controls slave address matching for addresses between the values of
 * the A1 and RA registers. When this bit is set, a slave address match occurs
 * for any address greater than the value of the A1 register and less than or equal
 * to the value of the RA register.
 *
 * Values:
 * - 0 - Range mode disabled. No address match occurs for an address within the
 *     range of values of the A1 and RA registers.
 * - 1 - Range mode enabled. Address matching occurs when a slave receives an
 *     address within the range of values of the A1 and RA registers.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_RMEN field. */
#define I2C_RD_C2_RMEN(base) ((I2C_C2_REG(base) & I2C_C2_RMEN_MASK) >> I2C_C2_RMEN_SHIFT)
#define I2C_BRD_C2_RMEN(base) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_RMEN_SHIFT))

/*! @brief Set the RMEN field to a new value. */
#define I2C_WR_C2_RMEN(base, value) (I2C_RMW_C2(base, I2C_C2_RMEN_MASK, I2C_C2_RMEN(value)))
#define I2C_BWR_C2_RMEN(base, value) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_RMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C2, field SBRC[4] (RW)
 *
 * Enables independent slave mode baud rate at max frequency. This forces clock
 * stretching on SCL in very fast I2C modes.
 *
 * Values:
 * - 0 - The slave baud rate follows the master baud rate and clock stretching
 *     may occur
 * - 1 - Slave baud rate is independent of the master baud rate
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_SBRC field. */
#define I2C_RD_C2_SBRC(base) ((I2C_C2_REG(base) & I2C_C2_SBRC_MASK) >> I2C_C2_SBRC_SHIFT)
#define I2C_BRD_C2_SBRC(base) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_SBRC_SHIFT))

/*! @brief Set the SBRC field to a new value. */
#define I2C_WR_C2_SBRC(base, value) (I2C_RMW_C2(base, I2C_C2_SBRC_MASK, I2C_C2_SBRC(value)))
#define I2C_BWR_C2_SBRC(base, value) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_SBRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C2, field HDRS[5] (RW)
 *
 * Controls the drive capability of the I2C pads.
 *
 * Values:
 * - 0 - Normal drive mode
 * - 1 - High drive mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_HDRS field. */
#define I2C_RD_C2_HDRS(base) ((I2C_C2_REG(base) & I2C_C2_HDRS_MASK) >> I2C_C2_HDRS_SHIFT)
#define I2C_BRD_C2_HDRS(base) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_HDRS_SHIFT))

/*! @brief Set the HDRS field to a new value. */
#define I2C_WR_C2_HDRS(base, value) (I2C_RMW_C2(base, I2C_C2_HDRS_MASK, I2C_C2_HDRS(value)))
#define I2C_BWR_C2_HDRS(base, value) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_HDRS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C2, field ADEXT[6] (RW)
 *
 * Controls the number of bits used for the slave address.
 *
 * Values:
 * - 0 - 7-bit address scheme
 * - 1 - 10-bit address scheme
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_ADEXT field. */
#define I2C_RD_C2_ADEXT(base) ((I2C_C2_REG(base) & I2C_C2_ADEXT_MASK) >> I2C_C2_ADEXT_SHIFT)
#define I2C_BRD_C2_ADEXT(base) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_ADEXT_SHIFT))

/*! @brief Set the ADEXT field to a new value. */
#define I2C_WR_C2_ADEXT(base, value) (I2C_RMW_C2(base, I2C_C2_ADEXT_MASK, I2C_C2_ADEXT(value)))
#define I2C_BWR_C2_ADEXT(base, value) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_ADEXT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_C2, field GCAEN[7] (RW)
 *
 * Enables general call address.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_GCAEN field. */
#define I2C_RD_C2_GCAEN(base) ((I2C_C2_REG(base) & I2C_C2_GCAEN_MASK) >> I2C_C2_GCAEN_SHIFT)
#define I2C_BRD_C2_GCAEN(base) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_GCAEN_SHIFT))

/*! @brief Set the GCAEN field to a new value. */
#define I2C_WR_C2_GCAEN(base, value) (I2C_RMW_C2(base, I2C_C2_GCAEN_MASK, I2C_C2_GCAEN(value)))
#define I2C_BWR_C2_GCAEN(base, value) (BITBAND_ACCESS8(&I2C_C2_REG(base), I2C_C2_GCAEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2C_FLT - I2C Programmable Input Glitch Filter register
 ******************************************************************************/

/*!
 * @brief I2C_FLT - I2C Programmable Input Glitch Filter register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_FLT register
 */
/*@{*/
#define I2C_RD_FLT(base)         (I2C_FLT_REG(base))
#define I2C_WR_FLT(base, value)  (I2C_FLT_REG(base) = (value))
#define I2C_RMW_FLT(base, mask, value) (I2C_WR_FLT(base, (I2C_RD_FLT(base) & ~(mask)) | (value)))
#define I2C_SET_FLT(base, value) (I2C_WR_FLT(base, I2C_RD_FLT(base) |  (value)))
#define I2C_CLR_FLT(base, value) (I2C_WR_FLT(base, I2C_RD_FLT(base) & ~(value)))
#define I2C_TOG_FLT(base, value) (I2C_WR_FLT(base, I2C_RD_FLT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2C_FLT bitfields
 */

/*!
 * @name Register I2C_FLT, field FLT[4:0] (RW)
 *
 * Controls the width of the glitch, in terms of bus clock cycles, that the
 * filter must absorb. For any glitch whose size is less than or equal to this width
 * setting, the filter does not allow the glitch to pass.
 *
 * Values:
 * - 0 - No filter/bypass
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_FLT field. */
#define I2C_RD_FLT_FLT(base) ((I2C_FLT_REG(base) & I2C_FLT_FLT_MASK) >> I2C_FLT_FLT_SHIFT)
#define I2C_BRD_FLT_FLT(base) (I2C_RD_FLT_FLT(base))

/*! @brief Set the FLT field to a new value. */
#define I2C_WR_FLT_FLT(base, value) (I2C_RMW_FLT(base, I2C_FLT_FLT_MASK, I2C_FLT_FLT(value)))
#define I2C_BWR_FLT_FLT(base, value) (I2C_WR_FLT_FLT(base, value))
/*@}*/

/*******************************************************************************
 * I2C_RA - I2C Range Address register
 ******************************************************************************/

/*!
 * @brief I2C_RA - I2C Range Address register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_RA register
 */
/*@{*/
#define I2C_RD_RA(base)          (I2C_RA_REG(base))
#define I2C_WR_RA(base, value)   (I2C_RA_REG(base) = (value))
#define I2C_RMW_RA(base, mask, value) (I2C_WR_RA(base, (I2C_RD_RA(base) & ~(mask)) | (value)))
#define I2C_SET_RA(base, value)  (I2C_WR_RA(base, I2C_RD_RA(base) |  (value)))
#define I2C_CLR_RA(base, value)  (I2C_WR_RA(base, I2C_RD_RA(base) & ~(value)))
#define I2C_TOG_RA(base, value)  (I2C_WR_RA(base, I2C_RD_RA(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2C_RA bitfields
 */

/*!
 * @name Register I2C_RA, field RAD[7:1] (RW)
 *
 * This field contains the slave address to be used by the I2C module. The field
 * is used in the 7-bit address scheme. Any nonzero write enables this register.
 * This register's use is similar to that of the A1 register, but in addition
 * this register can be considered a maximum boundary in range matching mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_RA_RAD field. */
#define I2C_RD_RA_RAD(base)  ((I2C_RA_REG(base) & I2C_RA_RAD_MASK) >> I2C_RA_RAD_SHIFT)
#define I2C_BRD_RA_RAD(base) (I2C_RD_RA_RAD(base))

/*! @brief Set the RAD field to a new value. */
#define I2C_WR_RA_RAD(base, value) (I2C_RMW_RA(base, I2C_RA_RAD_MASK, I2C_RA_RAD(value)))
#define I2C_BWR_RA_RAD(base, value) (I2C_WR_RA_RAD(base, value))
/*@}*/

/*******************************************************************************
 * I2C_SMB - I2C SMBus Control and Status register
 ******************************************************************************/

/*!
 * @brief I2C_SMB - I2C SMBus Control and Status register (RW)
 *
 * Reset value: 0x00U
 *
 * When the SCL and SDA signals are held high for a length of time greater than
 * the high timeout period, the SHTF1 flag sets. Before reaching this threshold,
 * while the system is detecting how long these signals are being held high, a
 * master assumes that the bus is free. However, the SHTF1 bit rises in the bus
 * transmission process with the idle bus state. When the TCKSEL bit is set, there
 * is no meaning to monitor the SHTF1 bit because the bus speed is too high to
 * match the protocol of SMBus.
 */
/*!
 * @name Constants and macros for entire I2C_SMB register
 */
/*@{*/
#define I2C_RD_SMB(base)         (I2C_SMB_REG(base))
#define I2C_WR_SMB(base, value)  (I2C_SMB_REG(base) = (value))
#define I2C_RMW_SMB(base, mask, value) (I2C_WR_SMB(base, (I2C_RD_SMB(base) & ~(mask)) | (value)))
#define I2C_SET_SMB(base, value) (I2C_WR_SMB(base, I2C_RD_SMB(base) |  (value)))
#define I2C_CLR_SMB(base, value) (I2C_WR_SMB(base, I2C_RD_SMB(base) & ~(value)))
#define I2C_TOG_SMB(base, value) (I2C_WR_SMB(base, I2C_RD_SMB(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2C_SMB bitfields
 */

/*!
 * @name Register I2C_SMB, field SHTF2IE[0] (RW)
 *
 * Enables SCL high and SDA low timeout interrupt.
 *
 * Values:
 * - 0 - SHTF2 interrupt is disabled
 * - 1 - SHTF2 interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2IE field. */
#define I2C_RD_SMB_SHTF2IE(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2IE_MASK) >> I2C_SMB_SHTF2IE_SHIFT)
#define I2C_BRD_SMB_SHTF2IE(base) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_SHTF2IE_SHIFT))

/*! @brief Set the SHTF2IE field to a new value. */
#define I2C_WR_SMB_SHTF2IE(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2IE_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2IE(value)))
#define I2C_BWR_SMB_SHTF2IE(base, value) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_SHTF2IE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF2[1] (W1C)
 *
 * This bit sets when SCL is held high and SDA is held low more than clock *
 * LoValue/512. Software clears this bit by writing a 1 to it.
 *
 * Values:
 * - 0 - No SCL high and SDA low timeout occurs
 * - 1 - SCL high and SDA low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2 field. */
#define I2C_RD_SMB_SHTF2(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2_MASK) >> I2C_SMB_SHTF2_SHIFT)
#define I2C_BRD_SMB_SHTF2(base) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_SHTF2_SHIFT))

/*! @brief Set the SHTF2 field to a new value. */
#define I2C_WR_SMB_SHTF2(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2(value)))
#define I2C_BWR_SMB_SHTF2(base, value) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_SHTF2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF1[2] (RO)
 *
 * This read-only bit sets when SCL and SDA are held high more than clock *
 * LoValue / 512, which indicates the bus is free. This bit is cleared automatically.
 *
 * Values:
 * - 0 - No SCL high and SDA high timeout occurs
 * - 1 - SCL high and SDA high timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF1 field. */
#define I2C_RD_SMB_SHTF1(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF1_MASK) >> I2C_SMB_SHTF1_SHIFT)
#define I2C_BRD_SMB_SHTF1(base) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_SHTF1_SHIFT))
/*@}*/

/*!
 * @name Register I2C_SMB, field SLTF[3] (W1C)
 *
 * This bit is set when the SLT register (consisting of the SLTH and SLTL
 * registers) is loaded with a non-zero value (LoValue) and an SCL low timeout occurs.
 * Software clears this bit by writing a logic 1 to it. The low timeout function
 * is disabled when the SLT register's value is zero.
 *
 * Values:
 * - 0 - No low timeout occurs
 * - 1 - Low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SLTF field. */
#define I2C_RD_SMB_SLTF(base) ((I2C_SMB_REG(base) & I2C_SMB_SLTF_MASK) >> I2C_SMB_SLTF_SHIFT)
#define I2C_BRD_SMB_SLTF(base) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_SLTF_SHIFT))

/*! @brief Set the SLTF field to a new value. */
#define I2C_WR_SMB_SLTF(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SLTF_MASK | I2C_SMB_SHTF2_MASK), I2C_SMB_SLTF(value)))
#define I2C_BWR_SMB_SLTF(base, value) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_SLTF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_SMB, field TCKSEL[4] (RW)
 *
 * Selects the clock source of the timeout counter.
 *
 * Values:
 * - 0 - Timeout counter counts at the frequency of the bus clock / 64
 * - 1 - Timeout counter counts at the frequency of the bus clock
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_TCKSEL field. */
#define I2C_RD_SMB_TCKSEL(base) ((I2C_SMB_REG(base) & I2C_SMB_TCKSEL_MASK) >> I2C_SMB_TCKSEL_SHIFT)
#define I2C_BRD_SMB_TCKSEL(base) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_TCKSEL_SHIFT))

/*! @brief Set the TCKSEL field to a new value. */
#define I2C_WR_SMB_TCKSEL(base, value) (I2C_RMW_SMB(base, (I2C_SMB_TCKSEL_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_TCKSEL(value)))
#define I2C_BWR_SMB_TCKSEL(base, value) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_TCKSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_SMB, field SIICAEN[5] (RW)
 *
 * Enables or disables SMBus device default address.
 *
 * Values:
 * - 0 - I2C address register 2 matching is disabled
 * - 1 - I2C address register 2 matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SIICAEN field. */
#define I2C_RD_SMB_SIICAEN(base) ((I2C_SMB_REG(base) & I2C_SMB_SIICAEN_MASK) >> I2C_SMB_SIICAEN_SHIFT)
#define I2C_BRD_SMB_SIICAEN(base) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_SIICAEN_SHIFT))

/*! @brief Set the SIICAEN field to a new value. */
#define I2C_WR_SMB_SIICAEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SIICAEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SIICAEN(value)))
#define I2C_BWR_SMB_SIICAEN(base, value) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_SIICAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_SMB, field ALERTEN[6] (RW)
 *
 * Enables or disables SMBus alert response address matching. After the host
 * responds to a device that used the alert response address, you must use software
 * to put the device's address on the bus. The alert protocol is described in the
 * SMBus specification.
 *
 * Values:
 * - 0 - SMBus alert response address matching is disabled
 * - 1 - SMBus alert response address matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_ALERTEN field. */
#define I2C_RD_SMB_ALERTEN(base) ((I2C_SMB_REG(base) & I2C_SMB_ALERTEN_MASK) >> I2C_SMB_ALERTEN_SHIFT)
#define I2C_BRD_SMB_ALERTEN(base) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_ALERTEN_SHIFT))

/*! @brief Set the ALERTEN field to a new value. */
#define I2C_WR_SMB_ALERTEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_ALERTEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_ALERTEN(value)))
#define I2C_BWR_SMB_ALERTEN(base, value) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_ALERTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2C_SMB, field FACK[7] (RW)
 *
 * For SMBus packet error checking, the CPU must be able to issue an ACK or NACK
 * according to the result of receiving data byte.
 *
 * Values:
 * - 0 - An ACK or NACK is sent on the following receiving data byte
 * - 1 - Writing 0 to TXAK after receiving a data byte generates an ACK. Writing
 *     1 to TXAK after receiving a data byte generates a NACK.
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_FACK field. */
#define I2C_RD_SMB_FACK(base) ((I2C_SMB_REG(base) & I2C_SMB_FACK_MASK) >> I2C_SMB_FACK_SHIFT)
#define I2C_BRD_SMB_FACK(base) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_FACK_SHIFT))

/*! @brief Set the FACK field to a new value. */
#define I2C_WR_SMB_FACK(base, value) (I2C_RMW_SMB(base, (I2C_SMB_FACK_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_FACK(value)))
#define I2C_BWR_SMB_FACK(base, value) (BITBAND_ACCESS8(&I2C_SMB_REG(base), I2C_SMB_FACK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2C_A2 - I2C Address Register 2
 ******************************************************************************/

/*!
 * @brief I2C_A2 - I2C Address Register 2 (RW)
 *
 * Reset value: 0xC2U
 */
/*!
 * @name Constants and macros for entire I2C_A2 register
 */
/*@{*/
#define I2C_RD_A2(base)          (I2C_A2_REG(base))
#define I2C_WR_A2(base, value)   (I2C_A2_REG(base) = (value))
#define I2C_RMW_A2(base, mask, value) (I2C_WR_A2(base, (I2C_RD_A2(base) & ~(mask)) | (value)))
#define I2C_SET_A2(base, value)  (I2C_WR_A2(base, I2C_RD_A2(base) |  (value)))
#define I2C_CLR_A2(base, value)  (I2C_WR_A2(base, I2C_RD_A2(base) & ~(value)))
#define I2C_TOG_A2(base, value)  (I2C_WR_A2(base, I2C_RD_A2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A2 bitfields
 */

/*!
 * @name Register I2C_A2, field SAD[7:1] (RW)
 *
 * Contains the slave address used by the SMBus. This field is used on the
 * device default address or other related addresses.
 */
/*@{*/
/*! @brief Read current value of the I2C_A2_SAD field. */
#define I2C_RD_A2_SAD(base)  ((I2C_A2_REG(base) & I2C_A2_SAD_MASK) >> I2C_A2_SAD_SHIFT)
#define I2C_BRD_A2_SAD(base) (I2C_RD_A2_SAD(base))

/*! @brief Set the SAD field to a new value. */
#define I2C_WR_A2_SAD(base, value) (I2C_RMW_A2(base, I2C_A2_SAD_MASK, I2C_A2_SAD(value)))
#define I2C_BWR_A2_SAD(base, value) (I2C_WR_A2_SAD(base, value))
/*@}*/

/*******************************************************************************
 * I2C_SLTH - I2C SCL Low Timeout Register High
 ******************************************************************************/

/*!
 * @brief I2C_SLTH - I2C SCL Low Timeout Register High (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTH register
 */
/*@{*/
#define I2C_RD_SLTH(base)        (I2C_SLTH_REG(base))
#define I2C_WR_SLTH(base, value) (I2C_SLTH_REG(base) = (value))
#define I2C_RMW_SLTH(base, mask, value) (I2C_WR_SLTH(base, (I2C_RD_SLTH(base) & ~(mask)) | (value)))
#define I2C_SET_SLTH(base, value) (I2C_WR_SLTH(base, I2C_RD_SLTH(base) |  (value)))
#define I2C_CLR_SLTH(base, value) (I2C_WR_SLTH(base, I2C_RD_SLTH(base) & ~(value)))
#define I2C_TOG_SLTH(base, value) (I2C_WR_SLTH(base, I2C_RD_SLTH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * I2C_SLTL - I2C SCL Low Timeout Register Low
 ******************************************************************************/

/*!
 * @brief I2C_SLTL - I2C SCL Low Timeout Register Low (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTL register
 */
/*@{*/
#define I2C_RD_SLTL(base)        (I2C_SLTL_REG(base))
#define I2C_WR_SLTL(base, value) (I2C_SLTL_REG(base) = (value))
#define I2C_RMW_SLTL(base, mask, value) (I2C_WR_SLTL(base, (I2C_RD_SLTL(base) & ~(mask)) | (value)))
#define I2C_SET_SLTL(base, value) (I2C_WR_SLTL(base, I2C_RD_SLTL(base) |  (value)))
#define I2C_CLR_SLTL(base, value) (I2C_WR_SLTL(base, I2C_RD_SLTL(base) & ~(value)))
#define I2C_TOG_SLTL(base, value) (I2C_WR_SLTL(base, I2C_RD_SLTL(base) ^  (value)))
/*@}*/

/*
 * MK20D5 I2S
 *
 * Inter-IC Sound / Synchronous Audio Interface
 *
 * Registers defined in this header file:
 * - I2S_TCSR - SAI Transmit Control Register
 * - I2S_TCR1 - SAI Transmit Configuration 1 Register
 * - I2S_TCR2 - SAI Transmit Configuration 2 Register
 * - I2S_TCR3 - SAI Transmit Configuration 3 Register
 * - I2S_TCR4 - SAI Transmit Configuration 4 Register
 * - I2S_TCR5 - SAI Transmit Configuration 5 Register
 * - I2S_TDR - SAI Transmit Data Register
 * - I2S_TFR - SAI Transmit FIFO Register
 * - I2S_TMR - SAI Transmit Mask Register
 * - I2S_RCSR - SAI Receive Control Register
 * - I2S_RCR1 - SAI Receive Configuration 1 Register
 * - I2S_RCR2 - SAI Receive Configuration 2 Register
 * - I2S_RCR3 - SAI Receive Configuration 3 Register
 * - I2S_RCR4 - SAI Receive Configuration 4 Register
 * - I2S_RCR5 - SAI Receive Configuration 5 Register
 * - I2S_RDR - SAI Receive Data Register
 * - I2S_RFR - SAI Receive FIFO Register
 * - I2S_RMR - SAI Receive Mask Register
 * - I2S_MCR - SAI MCLK Control Register
 * - I2S_MDR - MCLK Divide Register
 */

#define I2S_INSTANCE_COUNT (1U) /*!< Number of instances of the I2S module. */
#define I2S0_IDX (0U) /*!< Instance number for I2S0. */

/*******************************************************************************
 * I2S_TCSR - SAI Transmit Control Register
 ******************************************************************************/

/*!
 * @brief I2S_TCSR - SAI Transmit Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TCSR register
 */
/*@{*/
#define I2S_RD_TCSR(base)        (I2S_TCSR_REG(base))
#define I2S_WR_TCSR(base, value) (I2S_TCSR_REG(base) = (value))
#define I2S_RMW_TCSR(base, mask, value) (I2S_WR_TCSR(base, (I2S_RD_TCSR(base) & ~(mask)) | (value)))
#define I2S_SET_TCSR(base, value) (I2S_WR_TCSR(base, I2S_RD_TCSR(base) |  (value)))
#define I2S_CLR_TCSR(base, value) (I2S_WR_TCSR(base, I2S_RD_TCSR(base) & ~(value)))
#define I2S_TOG_TCSR(base, value) (I2S_WR_TCSR(base, I2S_RD_TCSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCSR bitfields
 */

/*!
 * @name Register I2S_TCSR, field FRDE[0] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FRDE field. */
#define I2S_RD_TCSR_FRDE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FRDE_MASK) >> I2S_TCSR_FRDE_SHIFT)
#define I2S_BRD_TCSR_FRDE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRDE_SHIFT))

/*! @brief Set the FRDE field to a new value. */
#define I2S_WR_TCSR_FRDE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FRDE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FRDE(value)))
#define I2S_BWR_TCSR_FRDE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FWDE field. */
#define I2S_RD_TCSR_FWDE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FWDE_MASK) >> I2S_TCSR_FWDE_SHIFT)
#define I2S_BRD_TCSR_FWDE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWDE_SHIFT))

/*! @brief Set the FWDE field to a new value. */
#define I2S_WR_TCSR_FWDE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FWDE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FWDE(value)))
#define I2S_BWR_TCSR_FWDE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FRIE[8] (RW)
 *
 * Enables/disables FIFO request interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FRIE field. */
#define I2S_RD_TCSR_FRIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FRIE_MASK) >> I2S_TCSR_FRIE_SHIFT)
#define I2S_BRD_TCSR_FRIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRIE_SHIFT))

/*! @brief Set the FRIE field to a new value. */
#define I2S_WR_TCSR_FRIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FRIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FRIE(value)))
#define I2S_BWR_TCSR_FRIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FWIE field. */
#define I2S_RD_TCSR_FWIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FWIE_MASK) >> I2S_TCSR_FWIE_SHIFT)
#define I2S_BRD_TCSR_FWIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWIE_SHIFT))

/*! @brief Set the FWIE field to a new value. */
#define I2S_WR_TCSR_FWIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FWIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FWIE(value)))
#define I2S_BWR_TCSR_FWIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt,
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FEIE field. */
#define I2S_RD_TCSR_FEIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FEIE_MASK) >> I2S_TCSR_FEIE_SHIFT)
#define I2S_BRD_TCSR_FEIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define I2S_WR_TCSR_FEIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FEIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FEIE(value)))
#define I2S_BWR_TCSR_FEIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_SEIE field. */
#define I2S_RD_TCSR_SEIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_SEIE_MASK) >> I2S_TCSR_SEIE_SHIFT)
#define I2S_BRD_TCSR_SEIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SEIE_SHIFT))

/*! @brief Set the SEIE field to a new value. */
#define I2S_WR_TCSR_SEIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_SEIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_SEIE(value)))
#define I2S_BWR_TCSR_SEIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_WSIE field. */
#define I2S_RD_TCSR_WSIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_WSIE_MASK) >> I2S_TCSR_WSIE_SHIFT)
#define I2S_BRD_TCSR_WSIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_WSIE_SHIFT))

/*! @brief Set the WSIE field to a new value. */
#define I2S_WR_TCSR_WSIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_WSIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_WSIE(value)))
#define I2S_BWR_TCSR_WSIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_WSIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FRF[16] (RO)
 *
 * Indicates that the number of words in an enabled transmit channel FIFO is
 * less than or equal to the transmit FIFO watermark.
 *
 * Values:
 * - 0 - Transmit FIFO watermark not reached.
 * - 1 - Transmit FIFO watermark has been reached.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FRF field. */
#define I2S_RD_TCSR_FRF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FRF_MASK) >> I2S_TCSR_FRF_SHIFT)
#define I2S_BRD_TCSR_FRF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRF_SHIFT))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled transmit FIFO is empty.
 *
 * Values:
 * - 0 - No enabled transmit FIFO is empty.
 * - 1 - Enabled transmit FIFO is empty.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FWF field. */
#define I2S_RD_TCSR_FWF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FWF_MASK) >> I2S_TCSR_FWF_SHIFT)
#define I2S_BRD_TCSR_FWF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWF_SHIFT))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled transmit FIFO has underrun. Write a logic one to
 * this register bit to clear this flag.
 *
 * Values:
 * - 0 - Transmit underrun not detected.
 * - 1 - Transmit underrun detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FEF field. */
#define I2S_RD_TCSR_FEF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FEF_MASK) >> I2S_TCSR_FEF_SHIFT)
#define I2S_BRD_TCSR_FEF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FEF_SHIFT))

/*! @brief Set the FEF field to a new value. */
#define I2S_WR_TCSR_FEF(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FEF(value)))
#define I2S_BWR_TCSR_FEF(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic one to this register bit to clear this flag.
 *
 * Values:
 * - 0 - Sync error not detected.
 * - 1 - Frame sync error detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_SEF field. */
#define I2S_RD_TCSR_SEF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_SEF_MASK) >> I2S_TCSR_SEF_SHIFT)
#define I2S_BRD_TCSR_SEF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SEF_SHIFT))

/*! @brief Set the SEF field to a new value. */
#define I2S_WR_TCSR_SEF(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_SEF_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_SEF(value)))
#define I2S_BWR_TCSR_SEF(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic one to this register bit to clear this flag.
 *
 * Values:
 * - 0 - Start of word not detected.
 * - 1 - Start of word detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_WSF field. */
#define I2S_RD_TCSR_WSF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_WSF_MASK) >> I2S_TCSR_WSF_SHIFT)
#define I2S_BRD_TCSR_WSF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_WSF_SHIFT))

/*! @brief Set the WSF field to a new value. */
#define I2S_WR_TCSR_WSF(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_WSF_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK), I2S_TCSR_WSF(value)))
#define I2S_BWR_TCSR_WSF(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_WSF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SR[24] (RW)
 *
 * When set, resets the internal transmitter logic including the FIFO pointers.
 * Software visible-registers are not affected, except for the status registers.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Software reset.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_SR field. */
#define I2S_RD_TCSR_SR(base) ((I2S_TCSR_REG(base) & I2S_TCSR_SR_MASK) >> I2S_TCSR_SR_SHIFT)
#define I2S_BRD_TCSR_SR(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SR_SHIFT))

/*! @brief Set the SR field to a new value. */
#define I2S_WR_TCSR_SR(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_SR_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_SR(value)))
#define I2S_BWR_TCSR_SR(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this bit will always return zero.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - FIFO reset.
 */
/*@{*/
/*! @brief Set the FR field to a new value. */
#define I2S_WR_TCSR_FR(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FR_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FR(value)))
#define I2S_BWR_TCSR_FR(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field BCE[28] (RW)
 *
 * Enables the transmit bit clock, separately from the transmit enable. This bit
 * is automatically set whenever the transmit enable is set. When software
 * clears this bit, the transmit bit clock remains enabled (and this bit remains set)
 * until the end of the current frame.
 *
 * Values:
 * - 0 - Transmit bit clock is disabled
 * - 1 - Transmit bit clock is enabled
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_BCE field. */
#define I2S_RD_TCSR_BCE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_BCE_MASK) >> I2S_TCSR_BCE_SHIFT)
#define I2S_BRD_TCSR_BCE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_BCE_SHIFT))

/*! @brief Set the BCE field to a new value. */
#define I2S_WR_TCSR_BCE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_BCE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_BCE(value)))
#define I2S_BWR_TCSR_BCE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_BCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field DBGE[29] (RW)
 *
 * Enables/disables transmitter operation in debug mode. The transmit bit clock
 * is not affected by debug mode.
 *
 * Values:
 * - 0 - Transmitter is disabled in debug mode, after completing the current
 *     frame.
 * - 1 - Transmitter is enabled in debug mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_DBGE field. */
#define I2S_RD_TCSR_DBGE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_DBGE_MASK) >> I2S_TCSR_DBGE_SHIFT)
#define I2S_BRD_TCSR_DBGE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_DBGE_SHIFT))

/*! @brief Set the DBGE field to a new value. */
#define I2S_WR_TCSR_DBGE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_DBGE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_DBGE(value)))
#define I2S_BWR_TCSR_DBGE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_DBGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field STOPE[30] (RW)
 *
 * Configures transmitter operation in Stop mode. This bit is ignored and the
 * transmitter is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0 - Transmitter disabled in stop mode.
 * - 1 - Transmitter enabled in stop mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_STOPE field. */
#define I2S_RD_TCSR_STOPE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_STOPE_MASK) >> I2S_TCSR_STOPE_SHIFT)
#define I2S_BRD_TCSR_STOPE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_STOPE_SHIFT))

/*! @brief Set the STOPE field to a new value. */
#define I2S_WR_TCSR_STOPE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_STOPE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_STOPE(value)))
#define I2S_BWR_TCSR_STOPE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_STOPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field TE[31] (RW)
 *
 * Enables/disables the transmitter. When software clears this bit, the
 * transmitter remains enabled (and this bit remains set) until the end of the current
 * frame.
 *
 * Values:
 * - 0 - Transmitter is disabled.
 * - 1 - Transmitter is enabled, or transmitter has been disabled and not end of
 *     frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_TE field. */
#define I2S_RD_TCSR_TE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_TE_MASK) >> I2S_TCSR_TE_SHIFT)
#define I2S_BRD_TCSR_TE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_TE_SHIFT))

/*! @brief Set the TE field to a new value. */
#define I2S_WR_TCSR_TE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_TE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_TE(value)))
#define I2S_BWR_TCSR_TE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_TE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2S_TCR1 - SAI Transmit Configuration 1 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR1 - SAI Transmit Configuration 1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TCR1 register
 */
/*@{*/
#define I2S_RD_TCR1(base)        (I2S_TCR1_REG(base))
#define I2S_WR_TCR1(base, value) (I2S_TCR1_REG(base) = (value))
#define I2S_RMW_TCR1(base, mask, value) (I2S_WR_TCR1(base, (I2S_RD_TCR1(base) & ~(mask)) | (value)))
#define I2S_SET_TCR1(base, value) (I2S_WR_TCR1(base, I2S_RD_TCR1(base) |  (value)))
#define I2S_CLR_TCR1(base, value) (I2S_WR_TCR1(base, I2S_RD_TCR1(base) & ~(value)))
#define I2S_TOG_TCR1(base, value) (I2S_WR_TCR1(base, I2S_RD_TCR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR1 bitfields
 */

/*!
 * @name Register I2S_TCR1, field TFW[2:0] (RW)
 *
 * Configures the watermark level for all enabled transmit channels.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR1_TFW field. */
#define I2S_RD_TCR1_TFW(base) ((I2S_TCR1_REG(base) & I2S_TCR1_TFW_MASK) >> I2S_TCR1_TFW_SHIFT)
#define I2S_BRD_TCR1_TFW(base) (I2S_RD_TCR1_TFW(base))

/*! @brief Set the TFW field to a new value. */
#define I2S_WR_TCR1_TFW(base, value) (I2S_RMW_TCR1(base, I2S_TCR1_TFW_MASK, I2S_TCR1_TFW(value)))
#define I2S_BWR_TCR1_TFW(base, value) (I2S_WR_TCR1_TFW(base, value))
/*@}*/

/*******************************************************************************
 * I2S_TCR2 - SAI Transmit Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR2 - SAI Transmit Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register should not be altered when the transmit enable bit is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR2 register
 */
/*@{*/
#define I2S_RD_TCR2(base)        (I2S_TCR2_REG(base))
#define I2S_WR_TCR2(base, value) (I2S_TCR2_REG(base) = (value))
#define I2S_RMW_TCR2(base, mask, value) (I2S_WR_TCR2(base, (I2S_RD_TCR2(base) & ~(mask)) | (value)))
#define I2S_SET_TCR2(base, value) (I2S_WR_TCR2(base, I2S_RD_TCR2(base) |  (value)))
#define I2S_CLR_TCR2(base, value) (I2S_WR_TCR2(base, I2S_RD_TCR2(base) & ~(value)))
#define I2S_TOG_TCR2(base, value) (I2S_WR_TCR2(base, I2S_RD_TCR2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR2 bitfields
 */

/*!
 * @name Register I2S_TCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_DIV field. */
#define I2S_RD_TCR2_DIV(base) ((I2S_TCR2_REG(base) & I2S_TCR2_DIV_MASK) >> I2S_TCR2_DIV_SHIFT)
#define I2S_BRD_TCR2_DIV(base) (I2S_RD_TCR2_DIV(base))

/*! @brief Set the DIV field to a new value. */
#define I2S_WR_TCR2_DIV(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_DIV_MASK, I2S_TCR2_DIV(value)))
#define I2S_BWR_TCR2_DIV(base, value) (I2S_WR_TCR2_DIV(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is generated externally (slave mode).
 * - 1 - Bit clock is generated internally (master mode).
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCD field. */
#define I2S_RD_TCR2_BCD(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCD_MASK) >> I2S_TCR2_BCD_SHIFT)
#define I2S_BRD_TCR2_BCD(base) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCD_SHIFT))

/*! @brief Set the BCD field to a new value. */
#define I2S_WR_TCR2_BCD(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCD_MASK, I2S_TCR2_BCD(value)))
#define I2S_BWR_TCR2_BCD(base, value) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0 - Bit Clock is active high (drive outputs on rising edge and sample
 *     inputs on falling edge).
 * - 1 - Bit Clock is active low (drive outputs on falling edge and sample
 *     inputs on rising edge).
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCP field. */
#define I2S_RD_TCR2_BCP(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCP_MASK) >> I2S_TCR2_BCP_SHIFT)
#define I2S_BRD_TCR2_BCP(base) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCP_SHIFT))

/*! @brief Set the BCP field to a new value. */
#define I2S_WR_TCR2_BCP(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCP_MASK, I2S_TCR2_BCP(value)))
#define I2S_BWR_TCR2_BCP(base, value) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field MSEL[27:26] (RW)
 *
 * Selects the Audio Master Clock used to generate an internally generated bit
 * clock. This field has no effect when configured for an externally generated bit
 * clock.
 *
 * Values:
 * - 00 - Bus Clock selected.
 * - 01 - Master Clock 1 selected.
 * - 10 - Master Clock 2 selected.
 * - 11 - Master Clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_MSEL field. */
#define I2S_RD_TCR2_MSEL(base) ((I2S_TCR2_REG(base) & I2S_TCR2_MSEL_MASK) >> I2S_TCR2_MSEL_SHIFT)
#define I2S_BRD_TCR2_MSEL(base) (I2S_RD_TCR2_MSEL(base))

/*! @brief Set the MSEL field to a new value. */
#define I2S_WR_TCR2_MSEL(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_MSEL_MASK, I2S_TCR2_MSEL(value)))
#define I2S_BWR_TCR2_MSEL(base, value) (I2S_WR_TCR2_MSEL(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCI[28] (RW)
 *
 * When set in either asynchronous or synchronous mode and using an internally
 * generated bit clock, configures the internal logic to be clocked as if the bit
 * clock was externally generated. This has the effect of decreasing data input
 * setup time, but increasing data output valid time. This bit has no effect when
 * configured for an externally generated bit clock or when synchronous to
 * another SAI peripheral.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Internal logic is clocked by external bit clock.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCI field. */
#define I2S_RD_TCR2_BCI(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCI_MASK) >> I2S_TCR2_BCI_SHIFT)
#define I2S_BRD_TCR2_BCI(base) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCI_SHIFT))

/*! @brief Set the BCI field to a new value. */
#define I2S_WR_TCR2_BCI(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCI_MASK, I2S_TCR2_BCI(value)))
#define I2S_BWR_TCR2_BCI(base, value) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCS[29] (RW)
 *
 * When set in asynchronous mode, the transmitter is clocked by the receiver bit
 * clock. When set in synchronous mode, the transmitter is clocked by the
 * transmitter bit clock, but uses the receiver frame sync. This bit has no effect when
 * synchronous with another SAI peripheral.
 *
 * Values:
 * - 0 - Use the normal bit clock source.
 * - 1 - Swap the bit clock source.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCS field. */
#define I2S_RD_TCR2_BCS(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCS_MASK) >> I2S_TCR2_BCS_SHIFT)
#define I2S_BRD_TCR2_BCS(base) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCS_SHIFT))

/*! @brief Set the BCS field to a new value. */
#define I2S_WR_TCR2_BCS(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCS_MASK, I2S_TCR2_BCS(value)))
#define I2S_BWR_TCR2_BCS(base, value) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the receiver or other SAI
 * peripheral must be configured for asynchronous operation.
 *
 * Values:
 * - 00 - Asynchronous mode.
 * - 01 - Synchronous with receiver.
 * - 10 - Synchronous with another SAI transmitter.
 * - 11 - Synchronous with another SAI receiver.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_SYNC field. */
#define I2S_RD_TCR2_SYNC(base) ((I2S_TCR2_REG(base) & I2S_TCR2_SYNC_MASK) >> I2S_TCR2_SYNC_SHIFT)
#define I2S_BRD_TCR2_SYNC(base) (I2S_RD_TCR2_SYNC(base))

/*! @brief Set the SYNC field to a new value. */
#define I2S_WR_TCR2_SYNC(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_SYNC_MASK, I2S_TCR2_SYNC(value)))
#define I2S_BWR_TCR2_SYNC(base, value) (I2S_WR_TCR2_SYNC(base, value))
/*@}*/

/*******************************************************************************
 * I2S_TCR3 - SAI Transmit Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR3 - SAI Transmit Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register should not be altered when the transmit enable bit is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR3 register
 */
/*@{*/
#define I2S_RD_TCR3(base)        (I2S_TCR3_REG(base))
#define I2S_WR_TCR3(base, value) (I2S_TCR3_REG(base) = (value))
#define I2S_RMW_TCR3(base, mask, value) (I2S_WR_TCR3(base, (I2S_RD_TCR3(base) & ~(mask)) | (value)))
#define I2S_SET_TCR3(base, value) (I2S_WR_TCR3(base, I2S_RD_TCR3(base) |  (value)))
#define I2S_CLR_TCR3(base, value) (I2S_WR_TCR3(base, I2S_RD_TCR3(base) & ~(value)))
#define I2S_TOG_TCR3(base, value) (I2S_WR_TCR3(base, I2S_RD_TCR3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR3 bitfields
 */

/*!
 * @name Register I2S_TCR3, field WDFL[4:0] (RW)
 *
 * Configures which word the start of word flag is set. The value written should
 * be one less than the word number (for example, write zero to configure for
 * the first word in the frame). When configured to a value greater than the Frame
 * Size field, then the start of word flag is never set.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR3_WDFL field. */
#define I2S_RD_TCR3_WDFL(base) ((I2S_TCR3_REG(base) & I2S_TCR3_WDFL_MASK) >> I2S_TCR3_WDFL_SHIFT)
#define I2S_BRD_TCR3_WDFL(base) (I2S_RD_TCR3_WDFL(base))

/*! @brief Set the WDFL field to a new value. */
#define I2S_WR_TCR3_WDFL(base, value) (I2S_RMW_TCR3(base, I2S_TCR3_WDFL_MASK, I2S_TCR3_WDFL(value)))
#define I2S_BWR_TCR3_WDFL(base, value) (I2S_WR_TCR3_WDFL(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR3, field TCE[17:16] (RW)
 *
 * Enables a data channel for a transmit operation. A channel should be enabled
 * before its FIFO is accessed.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR3_TCE field. */
#define I2S_RD_TCR3_TCE(base) ((I2S_TCR3_REG(base) & I2S_TCR3_TCE_MASK) >> I2S_TCR3_TCE_SHIFT)
#define I2S_BRD_TCR3_TCE(base) (I2S_RD_TCR3_TCE(base))

/*! @brief Set the TCE field to a new value. */
#define I2S_WR_TCR3_TCE(base, value) (I2S_RMW_TCR3(base, I2S_TCR3_TCE_MASK, I2S_TCR3_TCE(value)))
#define I2S_BWR_TCR3_TCE(base, value) (I2S_WR_TCR3_TCE(base, value))
/*@}*/

/*******************************************************************************
 * I2S_TCR4 - SAI Transmit Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR4 - SAI Transmit Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register should not be altered when the transmit enable bit is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR4 register
 */
/*@{*/
#define I2S_RD_TCR4(base)        (I2S_TCR4_REG(base))
#define I2S_WR_TCR4(base, value) (I2S_TCR4_REG(base) = (value))
#define I2S_RMW_TCR4(base, mask, value) (I2S_WR_TCR4(base, (I2S_RD_TCR4(base) & ~(mask)) | (value)))
#define I2S_SET_TCR4(base, value) (I2S_WR_TCR4(base, I2S_RD_TCR4(base) |  (value)))
#define I2S_CLR_TCR4(base, value) (I2S_WR_TCR4(base, I2S_RD_TCR4(base) & ~(value)))
#define I2S_TOG_TCR4(base, value) (I2S_WR_TCR4(base, I2S_RD_TCR4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR4 bitfields
 */

/*!
 * @name Register I2S_TCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0 - Frame Sync is generated externally (slave mode).
 * - 1 - Frame Sync is generated internally (master mode).
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FSD field. */
#define I2S_RD_TCR4_FSD(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FSD_MASK) >> I2S_TCR4_FSD_SHIFT)
#define I2S_BRD_TCR4_FSD(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSD_SHIFT))

/*! @brief Set the FSD field to a new value. */
#define I2S_WR_TCR4_FSD(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FSD_MASK, I2S_TCR4_FSD(value)))
#define I2S_BWR_TCR4_FSD(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is active high.
 * - 1 - Frame sync is active low.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FSP field. */
#define I2S_RD_TCR4_FSP(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FSP_MASK) >> I2S_TCR4_FSP_SHIFT)
#define I2S_BRD_TCR4_FSP(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSP_SHIFT))

/*! @brief Set the FSP field to a new value. */
#define I2S_WR_TCR4_FSP(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FSP_MASK, I2S_TCR4_FSP(value)))
#define I2S_BWR_TCR4_FSP(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0 - Frame sync asserts with the first bit of the frame.
 * - 1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FSE field. */
#define I2S_RD_TCR4_FSE(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FSE_MASK) >> I2S_TCR4_FSE_SHIFT)
#define I2S_BRD_TCR4_FSE(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSE_SHIFT))

/*! @brief Set the FSE field to a new value. */
#define I2S_WR_TCR4_FSE(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FSE_MASK, I2S_TCR4_FSE(value)))
#define I2S_BWR_TCR4_FSE(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field MF[4] (RW)
 *
 * Specifies whether the LSB or the MSB is transmitted/received first.
 *
 * Values:
 * - 0 - LBS is transmitted/received first.
 * - 1 - MBS is transmitted/received first.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_MF field. */
#define I2S_RD_TCR4_MF(base) ((I2S_TCR4_REG(base) & I2S_TCR4_MF_MASK) >> I2S_TCR4_MF_SHIFT)
#define I2S_BRD_TCR4_MF(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_MF_SHIFT))

/*! @brief Set the MF field to a new value. */
#define I2S_WR_TCR4_MF(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_MF_MASK, I2S_TCR4_MF(value)))
#define I2S_BWR_TCR4_MF(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_MF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written should be one less than the number of bit clocks (for example, write 0
 * for the frame sync to assert for one bit clock only). The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_SYWD field. */
#define I2S_RD_TCR4_SYWD(base) ((I2S_TCR4_REG(base) & I2S_TCR4_SYWD_MASK) >> I2S_TCR4_SYWD_SHIFT)
#define I2S_BRD_TCR4_SYWD(base) (I2S_RD_TCR4_SYWD(base))

/*! @brief Set the SYWD field to a new value. */
#define I2S_WR_TCR4_SYWD(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_SYWD_MASK, I2S_TCR4_SYWD(value)))
#define I2S_BWR_TCR4_SYWD(base, value) (I2S_WR_TCR4_SYWD(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FRSZ[20:16] (RW)
 *
 * Configures the number of words in each frame. The value written should be one
 * less than the number of words in the frame (for example, write 0 for one word
 * per frame). The maximum supported frame size is 32 words.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FRSZ field. */
#define I2S_RD_TCR4_FRSZ(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FRSZ_MASK) >> I2S_TCR4_FRSZ_SHIFT)
#define I2S_BRD_TCR4_FRSZ(base) (I2S_RD_TCR4_FRSZ(base))

/*! @brief Set the FRSZ field to a new value. */
#define I2S_WR_TCR4_FRSZ(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FRSZ_MASK, I2S_TCR4_FRSZ(value)))
#define I2S_BWR_TCR4_FRSZ(base, value) (I2S_WR_TCR4_FRSZ(base, value))
/*@}*/

/*******************************************************************************
 * I2S_TCR5 - SAI Transmit Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR5 - SAI Transmit Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register should not be altered when the transmit enable bit is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR5 register
 */
/*@{*/
#define I2S_RD_TCR5(base)        (I2S_TCR5_REG(base))
#define I2S_WR_TCR5(base, value) (I2S_TCR5_REG(base) = (value))
#define I2S_RMW_TCR5(base, mask, value) (I2S_WR_TCR5(base, (I2S_RD_TCR5(base) & ~(mask)) | (value)))
#define I2S_SET_TCR5(base, value) (I2S_WR_TCR5(base, I2S_RD_TCR5(base) |  (value)))
#define I2S_CLR_TCR5(base, value) (I2S_WR_TCR5(base, I2S_RD_TCR5(base) & ~(value)))
#define I2S_TOG_TCR5(base, value) (I2S_WR_TCR5(base, I2S_RD_TCR5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR5 bitfields
 */

/*!
 * @name Register I2S_TCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit transmitted for each word in the
 * frame. If configured for MSB First, the index of the next bit transmitted is
 * one less than the current bit transmitted. If configured for LSB First, the
 * index of the next bit transmitted is one more than the current bit transmitted.
 * The value written should be greater than or equal to the word width when
 * configured for MSB First. The value written should be less than or equal to 31-word
 * width when configured for LSB First.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR5_FBT field. */
#define I2S_RD_TCR5_FBT(base) ((I2S_TCR5_REG(base) & I2S_TCR5_FBT_MASK) >> I2S_TCR5_FBT_SHIFT)
#define I2S_BRD_TCR5_FBT(base) (I2S_RD_TCR5_FBT(base))

/*! @brief Set the FBT field to a new value. */
#define I2S_WR_TCR5_FBT(base, value) (I2S_RMW_TCR5(base, I2S_TCR5_FBT_MASK, I2S_TCR5_FBT(value)))
#define I2S_BWR_TCR5_FBT(base, value) (I2S_WR_TCR5_FBT(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written should be one less than the number of bits in the first word. Words of
 * less than 8 bits wide are not supported if there is only one word per frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR5_W0W field. */
#define I2S_RD_TCR5_W0W(base) ((I2S_TCR5_REG(base) & I2S_TCR5_W0W_MASK) >> I2S_TCR5_W0W_SHIFT)
#define I2S_BRD_TCR5_W0W(base) (I2S_RD_TCR5_W0W(base))

/*! @brief Set the W0W field to a new value. */
#define I2S_WR_TCR5_W0W(base, value) (I2S_RMW_TCR5(base, I2S_TCR5_W0W_MASK, I2S_TCR5_W0W(value)))
#define I2S_BWR_TCR5_W0W(base, value) (I2S_WR_TCR5_W0W(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written should be one less than the number of bits per
 * word. This field must be configured greater than or equal to Word 0 Width even
 * when there is only one word in each frame. Words of fewer than 8 bits wide are
 * not supported.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR5_WNW field. */
#define I2S_RD_TCR5_WNW(base) ((I2S_TCR5_REG(base) & I2S_TCR5_WNW_MASK) >> I2S_TCR5_WNW_SHIFT)
#define I2S_BRD_TCR5_WNW(base) (I2S_RD_TCR5_WNW(base))

/*! @brief Set the WNW field to a new value. */
#define I2S_WR_TCR5_WNW(base, value) (I2S_RMW_TCR5(base, I2S_TCR5_WNW_MASK, I2S_TCR5_WNW(value)))
#define I2S_BWR_TCR5_WNW(base, value) (I2S_WR_TCR5_WNW(base, value))
/*@}*/

/*******************************************************************************
 * I2S_TDR - SAI Transmit Data Register
 ******************************************************************************/

/*!
 * @brief I2S_TDR - SAI Transmit Data Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TDR register
 */
/*@{*/
#define I2S_RD_TDR(base, index)  (I2S_TDR_REG(base, index))
#define I2S_WR_TDR(base, index, value) (I2S_TDR_REG(base, index) = (value))
#define I2S_RMW_TDR(base, index, mask, value) (I2S_WR_TDR(base, index, (I2S_RD_TDR(base, index) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * I2S_TFR - SAI Transmit FIFO Register
 ******************************************************************************/

/*!
 * @brief I2S_TFR - SAI Transmit FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The MSB of the read pointer and write pointer is used to distinguish between
 * FIFO full and empty conditions. If the read and write pointers are identical
 * then the FIFO is empty. If the read and write pointers are identical except for
 * the MSB then the FIFO is full.
 */
/*!
 * @name Constants and macros for entire I2S_TFR register
 */
/*@{*/
#define I2S_RD_TFR(base, index)  (I2S_TFR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual I2S_TFR bitfields
 */

/*!
 * @name Register I2S_TFR, field RFP[3:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the I2S_TFR_RFP field. */
#define I2S_RD_TFR_RFP(base, index) ((I2S_TFR_REG(base, index) & I2S_TFR_RFP_MASK) >> I2S_TFR_RFP_SHIFT)
#define I2S_BRD_TFR_RFP(base, index) (I2S_RD_TFR_RFP(base, index))
/*@}*/

/*!
 * @name Register I2S_TFR, field WFP[19:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the I2S_TFR_WFP field. */
#define I2S_RD_TFR_WFP(base, index) ((I2S_TFR_REG(base, index) & I2S_TFR_WFP_MASK) >> I2S_TFR_WFP_SHIFT)
#define I2S_BRD_TFR_WFP(base, index) (I2S_RD_TFR_WFP(base, index))
/*@}*/

/*******************************************************************************
 * I2S_TMR - SAI Transmit Mask Register
 ******************************************************************************/

/*!
 * @brief I2S_TMR - SAI Transmit Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates when the transmit enable bit is
 * first set and then at the end of each frame. This allows the masked words in
 * each frame to change from frame to frame.
 */
/*!
 * @name Constants and macros for entire I2S_TMR register
 */
/*@{*/
#define I2S_RD_TMR(base)         (I2S_TMR_REG(base))
#define I2S_WR_TMR(base, value)  (I2S_TMR_REG(base) = (value))
#define I2S_RMW_TMR(base, mask, value) (I2S_WR_TMR(base, (I2S_RD_TMR(base) & ~(mask)) | (value)))
#define I2S_SET_TMR(base, value) (I2S_WR_TMR(base, I2S_RD_TMR(base) |  (value)))
#define I2S_CLR_TMR(base, value) (I2S_WR_TMR(base, I2S_RD_TMR(base) & ~(value)))
#define I2S_TOG_TMR(base, value) (I2S_WR_TMR(base, I2S_RD_TMR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * I2S_RCSR - SAI Receive Control Register
 ******************************************************************************/

/*!
 * @brief I2S_RCSR - SAI Receive Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_RCSR register
 */
/*@{*/
#define I2S_RD_RCSR(base)        (I2S_RCSR_REG(base))
#define I2S_WR_RCSR(base, value) (I2S_RCSR_REG(base) = (value))
#define I2S_RMW_RCSR(base, mask, value) (I2S_WR_RCSR(base, (I2S_RD_RCSR(base) & ~(mask)) | (value)))
#define I2S_SET_RCSR(base, value) (I2S_WR_RCSR(base, I2S_RD_RCSR(base) |  (value)))
#define I2S_CLR_RCSR(base, value) (I2S_WR_RCSR(base, I2S_RD_RCSR(base) & ~(value)))
#define I2S_TOG_RCSR(base, value) (I2S_WR_RCSR(base, I2S_RD_RCSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCSR bitfields
 */

/*!
 * @name Register I2S_RCSR, field FRDE[0] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FRDE field. */
#define I2S_RD_RCSR_FRDE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FRDE_MASK) >> I2S_RCSR_FRDE_SHIFT)
#define I2S_BRD_RCSR_FRDE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRDE_SHIFT))

/*! @brief Set the FRDE field to a new value. */
#define I2S_WR_RCSR_FRDE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FRDE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FRDE(value)))
#define I2S_BWR_RCSR_FRDE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FWDE field. */
#define I2S_RD_RCSR_FWDE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FWDE_MASK) >> I2S_RCSR_FWDE_SHIFT)
#define I2S_BRD_RCSR_FWDE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWDE_SHIFT))

/*! @brief Set the FWDE field to a new value. */
#define I2S_WR_RCSR_FWDE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FWDE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FWDE(value)))
#define I2S_BWR_RCSR_FWDE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FRIE[8] (RW)
 *
 * Enables/disables FIFO request interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FRIE field. */
#define I2S_RD_RCSR_FRIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FRIE_MASK) >> I2S_RCSR_FRIE_SHIFT)
#define I2S_BRD_RCSR_FRIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRIE_SHIFT))

/*! @brief Set the FRIE field to a new value. */
#define I2S_WR_RCSR_FRIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FRIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FRIE(value)))
#define I2S_BWR_RCSR_FRIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FWIE field. */
#define I2S_RD_RCSR_FWIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FWIE_MASK) >> I2S_RCSR_FWIE_SHIFT)
#define I2S_BRD_RCSR_FWIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWIE_SHIFT))

/*! @brief Set the FWIE field to a new value. */
#define I2S_WR_RCSR_FWIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FWIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FWIE(value)))
#define I2S_BWR_RCSR_FWIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt,
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FEIE field. */
#define I2S_RD_RCSR_FEIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FEIE_MASK) >> I2S_RCSR_FEIE_SHIFT)
#define I2S_BRD_RCSR_FEIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define I2S_WR_RCSR_FEIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FEIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FEIE(value)))
#define I2S_BWR_RCSR_FEIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_SEIE field. */
#define I2S_RD_RCSR_SEIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_SEIE_MASK) >> I2S_RCSR_SEIE_SHIFT)
#define I2S_BRD_RCSR_SEIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SEIE_SHIFT))

/*! @brief Set the SEIE field to a new value. */
#define I2S_WR_RCSR_SEIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_SEIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_SEIE(value)))
#define I2S_BWR_RCSR_SEIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_WSIE field. */
#define I2S_RD_RCSR_WSIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_WSIE_MASK) >> I2S_RCSR_WSIE_SHIFT)
#define I2S_BRD_RCSR_WSIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_WSIE_SHIFT))

/*! @brief Set the WSIE field to a new value. */
#define I2S_WR_RCSR_WSIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_WSIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_WSIE(value)))
#define I2S_BWR_RCSR_WSIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_WSIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FRF[16] (RO)
 *
 * Indicates that the number of words in an enabled receive channel FIFO is
 * greater than the receive FIFO watermark.
 *
 * Values:
 * - 0 - Receive FIFO watermark not reached.
 * - 1 - Receive FIFO watermark has been reached.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FRF field. */
#define I2S_RD_RCSR_FRF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FRF_MASK) >> I2S_RCSR_FRF_SHIFT)
#define I2S_BRD_RCSR_FRF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRF_SHIFT))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled receive FIFO is full.
 *
 * Values:
 * - 0 - No enabled receive FIFO is full.
 * - 1 - Enabled receive FIFO is full.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FWF field. */
#define I2S_RD_RCSR_FWF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FWF_MASK) >> I2S_RCSR_FWF_SHIFT)
#define I2S_BRD_RCSR_FWF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWF_SHIFT))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled receive FIFO has overflowed. Write a logic one to
 * this register bit to clear this flag.
 *
 * Values:
 * - 0 - Receive overflow not detected.
 * - 1 - Receive overflow detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FEF field. */
#define I2S_RD_RCSR_FEF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FEF_MASK) >> I2S_RCSR_FEF_SHIFT)
#define I2S_BRD_RCSR_FEF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FEF_SHIFT))

/*! @brief Set the FEF field to a new value. */
#define I2S_WR_RCSR_FEF(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FEF(value)))
#define I2S_BWR_RCSR_FEF(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic one to this register bit to clear this flag.
 *
 * Values:
 * - 0 - Sync error not detected.
 * - 1 - Frame sync error detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_SEF field. */
#define I2S_RD_RCSR_SEF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_SEF_MASK) >> I2S_RCSR_SEF_SHIFT)
#define I2S_BRD_RCSR_SEF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SEF_SHIFT))

/*! @brief Set the SEF field to a new value. */
#define I2S_WR_RCSR_SEF(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_SEF_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_SEF(value)))
#define I2S_BWR_RCSR_SEF(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic one to this register bit to clear this flag.
 *
 * Values:
 * - 0 - Start of word not detected.
 * - 1 - Start of word detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_WSF field. */
#define I2S_RD_RCSR_WSF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_WSF_MASK) >> I2S_RCSR_WSF_SHIFT)
#define I2S_BRD_RCSR_WSF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_WSF_SHIFT))

/*! @brief Set the WSF field to a new value. */
#define I2S_WR_RCSR_WSF(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_WSF_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK), I2S_RCSR_WSF(value)))
#define I2S_BWR_RCSR_WSF(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_WSF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SR[24] (RW)
 *
 * When set, resets the internal receiver logic including the FIFO pointers.
 * Software visible-registers are not affected, except for the status registers.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Software reset.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_SR field. */
#define I2S_RD_RCSR_SR(base) ((I2S_RCSR_REG(base) & I2S_RCSR_SR_MASK) >> I2S_RCSR_SR_SHIFT)
#define I2S_BRD_RCSR_SR(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SR_SHIFT))

/*! @brief Set the SR field to a new value. */
#define I2S_WR_RCSR_SR(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_SR_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_SR(value)))
#define I2S_BWR_RCSR_SR(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this bit will always return zero.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - FIFO reset.
 */
/*@{*/
/*! @brief Set the FR field to a new value. */
#define I2S_WR_RCSR_FR(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FR_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FR(value)))
#define I2S_BWR_RCSR_FR(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field BCE[28] (RW)
 *
 * Enables the receive bit clock, separately from the receive enable. This bit
 * is automatically set whenever the receive enable is set. When software clears
 * this bit, the receive bit clock remains enabled (and this bit remains set)
 * until the end of the current frame.
 *
 * Values:
 * - 0 - Receive bit clock is disabled
 * - 1 - Receive bit clock is enabled
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_BCE field. */
#define I2S_RD_RCSR_BCE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_BCE_MASK) >> I2S_RCSR_BCE_SHIFT)
#define I2S_BRD_RCSR_BCE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_BCE_SHIFT))

/*! @brief Set the BCE field to a new value. */
#define I2S_WR_RCSR_BCE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_BCE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_BCE(value)))
#define I2S_BWR_RCSR_BCE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_BCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field DBGE[29] (RW)
 *
 * Enables/disables receiver operation in debug mode. The receive bit clock is
 * not affected by debug mode.
 *
 * Values:
 * - 0 - Receiver is disabled in debug mode, after completing the current frame.
 * - 1 - Receiver is enabled in debug mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_DBGE field. */
#define I2S_RD_RCSR_DBGE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_DBGE_MASK) >> I2S_RCSR_DBGE_SHIFT)
#define I2S_BRD_RCSR_DBGE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_DBGE_SHIFT))

/*! @brief Set the DBGE field to a new value. */
#define I2S_WR_RCSR_DBGE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_DBGE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_DBGE(value)))
#define I2S_BWR_RCSR_DBGE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_DBGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field STOPE[30] (RW)
 *
 * Configures receiver operation in Stop mode. This bit is ignored and the
 * receiver is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0 - Receiver disabled in stop mode.
 * - 1 - Receiver enabled in stop mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_STOPE field. */
#define I2S_RD_RCSR_STOPE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_STOPE_MASK) >> I2S_RCSR_STOPE_SHIFT)
#define I2S_BRD_RCSR_STOPE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_STOPE_SHIFT))

/*! @brief Set the STOPE field to a new value. */
#define I2S_WR_RCSR_STOPE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_STOPE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_STOPE(value)))
#define I2S_BWR_RCSR_STOPE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_STOPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field RE[31] (RW)
 *
 * Enables/disables the receiver. When software clears this bit, the receiver
 * remains enabled (and this bit remains set) until the end of the current frame.
 *
 * Values:
 * - 0 - Receiver is disabled.
 * - 1 - Receiver is enabled, or receiver has been disabled and not end of frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_RE field. */
#define I2S_RD_RCSR_RE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_RE_MASK) >> I2S_RCSR_RE_SHIFT)
#define I2S_BRD_RCSR_RE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_RE_SHIFT))

/*! @brief Set the RE field to a new value. */
#define I2S_WR_RCSR_RE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_RE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_RE(value)))
#define I2S_BWR_RCSR_RE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2S_RCR1 - SAI Receive Configuration 1 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR1 - SAI Receive Configuration 1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_RCR1 register
 */
/*@{*/
#define I2S_RD_RCR1(base)        (I2S_RCR1_REG(base))
#define I2S_WR_RCR1(base, value) (I2S_RCR1_REG(base) = (value))
#define I2S_RMW_RCR1(base, mask, value) (I2S_WR_RCR1(base, (I2S_RD_RCR1(base) & ~(mask)) | (value)))
#define I2S_SET_RCR1(base, value) (I2S_WR_RCR1(base, I2S_RD_RCR1(base) |  (value)))
#define I2S_CLR_RCR1(base, value) (I2S_WR_RCR1(base, I2S_RD_RCR1(base) & ~(value)))
#define I2S_TOG_RCR1(base, value) (I2S_WR_RCR1(base, I2S_RD_RCR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR1 bitfields
 */

/*!
 * @name Register I2S_RCR1, field RFW[2:0] (RW)
 *
 * Configures the watermark level for all enabled receiver channels.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR1_RFW field. */
#define I2S_RD_RCR1_RFW(base) ((I2S_RCR1_REG(base) & I2S_RCR1_RFW_MASK) >> I2S_RCR1_RFW_SHIFT)
#define I2S_BRD_RCR1_RFW(base) (I2S_RD_RCR1_RFW(base))

/*! @brief Set the RFW field to a new value. */
#define I2S_WR_RCR1_RFW(base, value) (I2S_RMW_RCR1(base, I2S_RCR1_RFW_MASK, I2S_RCR1_RFW(value)))
#define I2S_BWR_RCR1_RFW(base, value) (I2S_WR_RCR1_RFW(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RCR2 - SAI Receive Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR2 - SAI Receive Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register should not be altered when the receive enable bit is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR2 register
 */
/*@{*/
#define I2S_RD_RCR2(base)        (I2S_RCR2_REG(base))
#define I2S_WR_RCR2(base, value) (I2S_RCR2_REG(base) = (value))
#define I2S_RMW_RCR2(base, mask, value) (I2S_WR_RCR2(base, (I2S_RD_RCR2(base) & ~(mask)) | (value)))
#define I2S_SET_RCR2(base, value) (I2S_WR_RCR2(base, I2S_RD_RCR2(base) |  (value)))
#define I2S_CLR_RCR2(base, value) (I2S_WR_RCR2(base, I2S_RD_RCR2(base) & ~(value)))
#define I2S_TOG_RCR2(base, value) (I2S_WR_RCR2(base, I2S_RD_RCR2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR2 bitfields
 */

/*!
 * @name Register I2S_RCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_DIV field. */
#define I2S_RD_RCR2_DIV(base) ((I2S_RCR2_REG(base) & I2S_RCR2_DIV_MASK) >> I2S_RCR2_DIV_SHIFT)
#define I2S_BRD_RCR2_DIV(base) (I2S_RD_RCR2_DIV(base))

/*! @brief Set the DIV field to a new value. */
#define I2S_WR_RCR2_DIV(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_DIV_MASK, I2S_RCR2_DIV(value)))
#define I2S_BWR_RCR2_DIV(base, value) (I2S_WR_RCR2_DIV(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is generated externally (slave mode).
 * - 1 - Bit clock is generated internally (master mode).
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCD field. */
#define I2S_RD_RCR2_BCD(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCD_MASK) >> I2S_RCR2_BCD_SHIFT)
#define I2S_BRD_RCR2_BCD(base) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCD_SHIFT))

/*! @brief Set the BCD field to a new value. */
#define I2S_WR_RCR2_BCD(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCD_MASK, I2S_RCR2_BCD(value)))
#define I2S_BWR_RCR2_BCD(base, value) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0 - Bit Clock is active high (drive outputs on rising edge and sample
 *     inputs on falling edge).
 * - 1 - Bit Clock is active low (drive outputs on falling edge and sample
 *     inputs on rising edge).
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCP field. */
#define I2S_RD_RCR2_BCP(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCP_MASK) >> I2S_RCR2_BCP_SHIFT)
#define I2S_BRD_RCR2_BCP(base) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCP_SHIFT))

/*! @brief Set the BCP field to a new value. */
#define I2S_WR_RCR2_BCP(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCP_MASK, I2S_RCR2_BCP(value)))
#define I2S_BWR_RCR2_BCP(base, value) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field MSEL[27:26] (RW)
 *
 * Selects the Audio Master Clock used to generate an internally generated bit
 * clock. This field has no effect when configured for an externally generated bit
 * clock.
 *
 * Values:
 * - 00 - Bus Clock selected.
 * - 01 - Master Clock 1 selected.
 * - 10 - Master Clock 2 selected.
 * - 11 - Master Clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_MSEL field. */
#define I2S_RD_RCR2_MSEL(base) ((I2S_RCR2_REG(base) & I2S_RCR2_MSEL_MASK) >> I2S_RCR2_MSEL_SHIFT)
#define I2S_BRD_RCR2_MSEL(base) (I2S_RD_RCR2_MSEL(base))

/*! @brief Set the MSEL field to a new value. */
#define I2S_WR_RCR2_MSEL(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_MSEL_MASK, I2S_RCR2_MSEL(value)))
#define I2S_BWR_RCR2_MSEL(base, value) (I2S_WR_RCR2_MSEL(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCI[28] (RW)
 *
 * When set in either asynchronous or synchronous mode and using an internally
 * generated bit clock, configures the internal logic to be clocked as if the bit
 * clock was externally generated. This has the effect of decreasing data input
 * setup time, but increasing data output valid time. This bit has no effect when
 * configured for an externally generated bit clock or when synchronous to
 * another SAI peripheral.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Internal logic is clocked as if bit clock was externally generated.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCI field. */
#define I2S_RD_RCR2_BCI(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCI_MASK) >> I2S_RCR2_BCI_SHIFT)
#define I2S_BRD_RCR2_BCI(base) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCI_SHIFT))

/*! @brief Set the BCI field to a new value. */
#define I2S_WR_RCR2_BCI(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCI_MASK, I2S_RCR2_BCI(value)))
#define I2S_BWR_RCR2_BCI(base, value) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCS[29] (RW)
 *
 * When set in asynchronous mode, the receiver is clocked by the transmitter bit
 * clock. When set in synchronous mode, the receiver is clocked by the receiver
 * bit clock, but uses the transmitter frame sync. This bit has no effect when
 * synchronous with another SAI peripheral.
 *
 * Values:
 * - 0 - Use the normal bit clock source.
 * - 1 - Swap the bit clock source.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCS field. */
#define I2S_RD_RCR2_BCS(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCS_MASK) >> I2S_RCR2_BCS_SHIFT)
#define I2S_BRD_RCR2_BCS(base) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCS_SHIFT))

/*! @brief Set the BCS field to a new value. */
#define I2S_WR_RCR2_BCS(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCS_MASK, I2S_RCR2_BCS(value)))
#define I2S_BWR_RCR2_BCS(base, value) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the transmitter or other SAI
 * peripheral must be configured for asynchronous operation.
 *
 * Values:
 * - 00 - Asynchronous mode.
 * - 01 - Synchronous with transmitter.
 * - 10 - Synchronous with another SAI receiver.
 * - 11 - Synchronous with another SAI transmitter.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_SYNC field. */
#define I2S_RD_RCR2_SYNC(base) ((I2S_RCR2_REG(base) & I2S_RCR2_SYNC_MASK) >> I2S_RCR2_SYNC_SHIFT)
#define I2S_BRD_RCR2_SYNC(base) (I2S_RD_RCR2_SYNC(base))

/*! @brief Set the SYNC field to a new value. */
#define I2S_WR_RCR2_SYNC(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_SYNC_MASK, I2S_RCR2_SYNC(value)))
#define I2S_BWR_RCR2_SYNC(base, value) (I2S_WR_RCR2_SYNC(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RCR3 - SAI Receive Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR3 - SAI Receive Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register should not be altered when the receive enable bit is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR3 register
 */
/*@{*/
#define I2S_RD_RCR3(base)        (I2S_RCR3_REG(base))
#define I2S_WR_RCR3(base, value) (I2S_RCR3_REG(base) = (value))
#define I2S_RMW_RCR3(base, mask, value) (I2S_WR_RCR3(base, (I2S_RD_RCR3(base) & ~(mask)) | (value)))
#define I2S_SET_RCR3(base, value) (I2S_WR_RCR3(base, I2S_RD_RCR3(base) |  (value)))
#define I2S_CLR_RCR3(base, value) (I2S_WR_RCR3(base, I2S_RD_RCR3(base) & ~(value)))
#define I2S_TOG_RCR3(base, value) (I2S_WR_RCR3(base, I2S_RD_RCR3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR3 bitfields
 */

/*!
 * @name Register I2S_RCR3, field WDFL[4:0] (RW)
 *
 * Configures which word the start of word flag is set. The value written should
 * be one less than the word number (for example, write zero to configure for
 * the first word in the frame). When configured to a value greater than the Frame
 * Size field, then the start of word flag is never set.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR3_WDFL field. */
#define I2S_RD_RCR3_WDFL(base) ((I2S_RCR3_REG(base) & I2S_RCR3_WDFL_MASK) >> I2S_RCR3_WDFL_SHIFT)
#define I2S_BRD_RCR3_WDFL(base) (I2S_RD_RCR3_WDFL(base))

/*! @brief Set the WDFL field to a new value. */
#define I2S_WR_RCR3_WDFL(base, value) (I2S_RMW_RCR3(base, I2S_RCR3_WDFL_MASK, I2S_RCR3_WDFL(value)))
#define I2S_BWR_RCR3_WDFL(base, value) (I2S_WR_RCR3_WDFL(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR3, field RCE[17:16] (RW)
 *
 * Enables a data channel for a receive operation. A channel should be enabled
 * before its FIFO is accessed.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR3_RCE field. */
#define I2S_RD_RCR3_RCE(base) ((I2S_RCR3_REG(base) & I2S_RCR3_RCE_MASK) >> I2S_RCR3_RCE_SHIFT)
#define I2S_BRD_RCR3_RCE(base) (I2S_RD_RCR3_RCE(base))

/*! @brief Set the RCE field to a new value. */
#define I2S_WR_RCR3_RCE(base, value) (I2S_RMW_RCR3(base, I2S_RCR3_RCE_MASK, I2S_RCR3_RCE(value)))
#define I2S_BWR_RCR3_RCE(base, value) (I2S_WR_RCR3_RCE(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RCR4 - SAI Receive Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR4 - SAI Receive Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register should not be altered when the receive enable bit is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR4 register
 */
/*@{*/
#define I2S_RD_RCR4(base)        (I2S_RCR4_REG(base))
#define I2S_WR_RCR4(base, value) (I2S_RCR4_REG(base) = (value))
#define I2S_RMW_RCR4(base, mask, value) (I2S_WR_RCR4(base, (I2S_RD_RCR4(base) & ~(mask)) | (value)))
#define I2S_SET_RCR4(base, value) (I2S_WR_RCR4(base, I2S_RD_RCR4(base) |  (value)))
#define I2S_CLR_RCR4(base, value) (I2S_WR_RCR4(base, I2S_RD_RCR4(base) & ~(value)))
#define I2S_TOG_RCR4(base, value) (I2S_WR_RCR4(base, I2S_RD_RCR4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR4 bitfields
 */

/*!
 * @name Register I2S_RCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0 - Frame Sync is generated externally (slave mode).
 * - 1 - Frame Sync is generated internally (master mode).
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FSD field. */
#define I2S_RD_RCR4_FSD(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FSD_MASK) >> I2S_RCR4_FSD_SHIFT)
#define I2S_BRD_RCR4_FSD(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSD_SHIFT))

/*! @brief Set the FSD field to a new value. */
#define I2S_WR_RCR4_FSD(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FSD_MASK, I2S_RCR4_FSD(value)))
#define I2S_BWR_RCR4_FSD(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is active high.
 * - 1 - Frame sync is active low.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FSP field. */
#define I2S_RD_RCR4_FSP(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FSP_MASK) >> I2S_RCR4_FSP_SHIFT)
#define I2S_BRD_RCR4_FSP(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSP_SHIFT))

/*! @brief Set the FSP field to a new value. */
#define I2S_WR_RCR4_FSP(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FSP_MASK, I2S_RCR4_FSP(value)))
#define I2S_BWR_RCR4_FSP(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0 - Frame sync asserts with the first bit of the frame.
 * - 1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FSE field. */
#define I2S_RD_RCR4_FSE(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FSE_MASK) >> I2S_RCR4_FSE_SHIFT)
#define I2S_BRD_RCR4_FSE(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSE_SHIFT))

/*! @brief Set the FSE field to a new value. */
#define I2S_WR_RCR4_FSE(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FSE_MASK, I2S_RCR4_FSE(value)))
#define I2S_BWR_RCR4_FSE(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field MF[4] (RW)
 *
 * Specifies whether the LSB or the MSB is transmitted/received first.
 *
 * Values:
 * - 0 - LBS is transmitted/received first.
 * - 1 - MBS is transmitted/received first.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_MF field. */
#define I2S_RD_RCR4_MF(base) ((I2S_RCR4_REG(base) & I2S_RCR4_MF_MASK) >> I2S_RCR4_MF_SHIFT)
#define I2S_BRD_RCR4_MF(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_MF_SHIFT))

/*! @brief Set the MF field to a new value. */
#define I2S_WR_RCR4_MF(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_MF_MASK, I2S_RCR4_MF(value)))
#define I2S_BWR_RCR4_MF(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_MF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written should be one less than the number of bit clocks (for example, write 0
 * for the frame sync to assert for one bit clock only). The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_SYWD field. */
#define I2S_RD_RCR4_SYWD(base) ((I2S_RCR4_REG(base) & I2S_RCR4_SYWD_MASK) >> I2S_RCR4_SYWD_SHIFT)
#define I2S_BRD_RCR4_SYWD(base) (I2S_RD_RCR4_SYWD(base))

/*! @brief Set the SYWD field to a new value. */
#define I2S_WR_RCR4_SYWD(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_SYWD_MASK, I2S_RCR4_SYWD(value)))
#define I2S_BWR_RCR4_SYWD(base, value) (I2S_WR_RCR4_SYWD(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FRSZ[20:16] (RW)
 *
 * Configures the number of words in each frame. The value written should be one
 * less than the number of words in the frame (for example, write 0 for one word
 * per frame). The maximum supported frame size is 32 words.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FRSZ field. */
#define I2S_RD_RCR4_FRSZ(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FRSZ_MASK) >> I2S_RCR4_FRSZ_SHIFT)
#define I2S_BRD_RCR4_FRSZ(base) (I2S_RD_RCR4_FRSZ(base))

/*! @brief Set the FRSZ field to a new value. */
#define I2S_WR_RCR4_FRSZ(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FRSZ_MASK, I2S_RCR4_FRSZ(value)))
#define I2S_BWR_RCR4_FRSZ(base, value) (I2S_WR_RCR4_FRSZ(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RCR5 - SAI Receive Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR5 - SAI Receive Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register should not be altered when the receive enable bit is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR5 register
 */
/*@{*/
#define I2S_RD_RCR5(base)        (I2S_RCR5_REG(base))
#define I2S_WR_RCR5(base, value) (I2S_RCR5_REG(base) = (value))
#define I2S_RMW_RCR5(base, mask, value) (I2S_WR_RCR5(base, (I2S_RD_RCR5(base) & ~(mask)) | (value)))
#define I2S_SET_RCR5(base, value) (I2S_WR_RCR5(base, I2S_RD_RCR5(base) |  (value)))
#define I2S_CLR_RCR5(base, value) (I2S_WR_RCR5(base, I2S_RD_RCR5(base) & ~(value)))
#define I2S_TOG_RCR5(base, value) (I2S_WR_RCR5(base, I2S_RD_RCR5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR5 bitfields
 */

/*!
 * @name Register I2S_RCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit received for each word in the
 * frame. If configured for MSB First. The index of the next bit received is one less
 * than the current bit received. If configured for LSB First, the index of the
 * next bit received is one more than the current bit received. The value written
 * should be greater than or equal to the word width when configured for MSB
 * First. The value written should be less than or equal to (31 - word with) when
 * configured for LSB First.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR5_FBT field. */
#define I2S_RD_RCR5_FBT(base) ((I2S_RCR5_REG(base) & I2S_RCR5_FBT_MASK) >> I2S_RCR5_FBT_SHIFT)
#define I2S_BRD_RCR5_FBT(base) (I2S_RD_RCR5_FBT(base))

/*! @brief Set the FBT field to a new value. */
#define I2S_WR_RCR5_FBT(base, value) (I2S_RMW_RCR5(base, I2S_RCR5_FBT_MASK, I2S_RCR5_FBT(value)))
#define I2S_BWR_RCR5_FBT(base, value) (I2S_WR_RCR5_FBT(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written should be one less than the number of bits in the first word. Words of
 * less than 8 bits wide are not supported if there is only one word per frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR5_W0W field. */
#define I2S_RD_RCR5_W0W(base) ((I2S_RCR5_REG(base) & I2S_RCR5_W0W_MASK) >> I2S_RCR5_W0W_SHIFT)
#define I2S_BRD_RCR5_W0W(base) (I2S_RD_RCR5_W0W(base))

/*! @brief Set the W0W field to a new value. */
#define I2S_WR_RCR5_W0W(base, value) (I2S_RMW_RCR5(base, I2S_RCR5_W0W_MASK, I2S_RCR5_W0W(value)))
#define I2S_BWR_RCR5_W0W(base, value) (I2S_WR_RCR5_W0W(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written should be one less than the number of bits per
 * word. This field must be configured greater than or equal to Word 0 Width even
 * when there is only one word in each frame. Words of fewer than 8 bits wide are
 * not supported.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR5_WNW field. */
#define I2S_RD_RCR5_WNW(base) ((I2S_RCR5_REG(base) & I2S_RCR5_WNW_MASK) >> I2S_RCR5_WNW_SHIFT)
#define I2S_BRD_RCR5_WNW(base) (I2S_RD_RCR5_WNW(base))

/*! @brief Set the WNW field to a new value. */
#define I2S_WR_RCR5_WNW(base, value) (I2S_RMW_RCR5(base, I2S_RCR5_WNW_MASK, I2S_RCR5_WNW(value)))
#define I2S_BWR_RCR5_WNW(base, value) (I2S_WR_RCR5_WNW(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RDR - SAI Receive Data Register
 ******************************************************************************/

/*!
 * @brief I2S_RDR - SAI Receive Data Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Reading this register introduces one additional peripheral clock wait state
 * on each read.
 */
/*!
 * @name Constants and macros for entire I2S_RDR register
 */
/*@{*/
#define I2S_RD_RDR(base, index)  (I2S_RDR_REG(base, index))
/*@}*/

/*******************************************************************************
 * I2S_RFR - SAI Receive FIFO Register
 ******************************************************************************/

/*!
 * @brief I2S_RFR - SAI Receive FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The MSB of the read pointer and write pointer is used to distinguish between
 * FIFO full and empty conditions. If the read and write pointers are identical
 * then the FIFO is empty. If the read and write pointers are identical except for
 * the MSB then the FIFO is full.
 */
/*!
 * @name Constants and macros for entire I2S_RFR register
 */
/*@{*/
#define I2S_RD_RFR(base, index)  (I2S_RFR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual I2S_RFR bitfields
 */

/*!
 * @name Register I2S_RFR, field RFP[3:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the I2S_RFR_RFP field. */
#define I2S_RD_RFR_RFP(base, index) ((I2S_RFR_REG(base, index) & I2S_RFR_RFP_MASK) >> I2S_RFR_RFP_SHIFT)
#define I2S_BRD_RFR_RFP(base, index) (I2S_RD_RFR_RFP(base, index))
/*@}*/

/*!
 * @name Register I2S_RFR, field WFP[19:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the I2S_RFR_WFP field. */
#define I2S_RD_RFR_WFP(base, index) ((I2S_RFR_REG(base, index) & I2S_RFR_WFP_MASK) >> I2S_RFR_WFP_SHIFT)
#define I2S_BRD_RFR_WFP(base, index) (I2S_RD_RFR_WFP(base, index))
/*@}*/

/*******************************************************************************
 * I2S_RMR - SAI Receive Mask Register
 ******************************************************************************/

/*!
 * @brief I2S_RMR - SAI Receive Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates when the receive enable bit is
 * first set and then at the end of each frame. This allows the masked words in
 * each frame to change from frame to frame.
 */
/*!
 * @name Constants and macros for entire I2S_RMR register
 */
/*@{*/
#define I2S_RD_RMR(base)         (I2S_RMR_REG(base))
#define I2S_WR_RMR(base, value)  (I2S_RMR_REG(base) = (value))
#define I2S_RMW_RMR(base, mask, value) (I2S_WR_RMR(base, (I2S_RD_RMR(base) & ~(mask)) | (value)))
#define I2S_SET_RMR(base, value) (I2S_WR_RMR(base, I2S_RD_RMR(base) |  (value)))
#define I2S_CLR_RMR(base, value) (I2S_WR_RMR(base, I2S_RD_RMR(base) & ~(value)))
#define I2S_TOG_RMR(base, value) (I2S_WR_RMR(base, I2S_RD_RMR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * I2S_MCR - SAI MCLK Control Register
 ******************************************************************************/

/*!
 * @brief I2S_MCR - SAI MCLK Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCLK Control Register controls the clock source and direction of the
 * Audio Master Clock.
 */
/*!
 * @name Constants and macros for entire I2S_MCR register
 */
/*@{*/
#define I2S_RD_MCR(base)         (I2S_MCR_REG(base))
#define I2S_WR_MCR(base, value)  (I2S_MCR_REG(base) = (value))
#define I2S_RMW_MCR(base, mask, value) (I2S_WR_MCR(base, (I2S_RD_MCR(base) & ~(mask)) | (value)))
#define I2S_SET_MCR(base, value) (I2S_WR_MCR(base, I2S_RD_MCR(base) |  (value)))
#define I2S_CLR_MCR(base, value) (I2S_WR_MCR(base, I2S_RD_MCR(base) & ~(value)))
#define I2S_TOG_MCR(base, value) (I2S_WR_MCR(base, I2S_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_MCR bitfields
 */

/*!
 * @name Register I2S_MCR, field MICS[25:24] (RW)
 *
 * Selects the clock input to the MCLK Divider. This field cannot be changed
 * when the MCLK divider is enabled. See the Chip Configuration details for
 * information about the connections to these inputs.
 *
 * Values:
 * - 00 - MCLK Divider input clock 0 selected.
 * - 01 - MCLK Divider input clock 1 selected.
 * - 10 - MCLK Divider input clock 2 selected.
 * - 11 - MCLK Divider input clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the I2S_MCR_MICS field. */
#define I2S_RD_MCR_MICS(base) ((I2S_MCR_REG(base) & I2S_MCR_MICS_MASK) >> I2S_MCR_MICS_SHIFT)
#define I2S_BRD_MCR_MICS(base) (I2S_RD_MCR_MICS(base))

/*! @brief Set the MICS field to a new value. */
#define I2S_WR_MCR_MICS(base, value) (I2S_RMW_MCR(base, I2S_MCR_MICS_MASK, I2S_MCR_MICS(value)))
#define I2S_BWR_MCR_MICS(base, value) (I2S_WR_MCR_MICS(base, value))
/*@}*/

/*!
 * @name Register I2S_MCR, field MOE[30] (RW)
 *
 * Enables the MCLK Divider and configures the SAI_MCLK pin as an output. When
 * software clears this bit, this bit remains set until the MCLK divider is fully
 * disabled.
 *
 * Values:
 * - 0 - SAI_MCLK pin is configured as an input that bypasses the MCLK Divider.
 * - 1 - SAI_MCLK pin is configured as an output from the MCLK Divider and the
 *     MCLK Divider is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_MCR_MOE field. */
#define I2S_RD_MCR_MOE(base) ((I2S_MCR_REG(base) & I2S_MCR_MOE_MASK) >> I2S_MCR_MOE_SHIFT)
#define I2S_BRD_MCR_MOE(base) (BITBAND_ACCESS32(&I2S_MCR_REG(base), I2S_MCR_MOE_SHIFT))

/*! @brief Set the MOE field to a new value. */
#define I2S_WR_MCR_MOE(base, value) (I2S_RMW_MCR(base, I2S_MCR_MOE_MASK, I2S_MCR_MOE(value)))
#define I2S_BWR_MCR_MOE(base, value) (BITBAND_ACCESS32(&I2S_MCR_REG(base), I2S_MCR_MOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_MCR, field DUF[31] (RO)
 *
 * Provides the status of on-the-fly updates to the MCLK Divider ratio.
 *
 * Values:
 * - 0 - MCLK Divider ratio is not being updated currently.
 * - 1 - MCLK Divider ratio is updating on-the-fly. Furthur updates to the MCLK
 *     Divider ratio are blocked while this flag remains set.
 */
/*@{*/
/*! @brief Read current value of the I2S_MCR_DUF field. */
#define I2S_RD_MCR_DUF(base) ((I2S_MCR_REG(base) & I2S_MCR_DUF_MASK) >> I2S_MCR_DUF_SHIFT)
#define I2S_BRD_MCR_DUF(base) (BITBAND_ACCESS32(&I2S_MCR_REG(base), I2S_MCR_DUF_SHIFT))
/*@}*/

/*******************************************************************************
 * I2S_MDR - MCLK Divide Register
 ******************************************************************************/

/*!
 * @brief I2S_MDR - MCLK Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Configures the MCLK Divide Ratio. Although the MCLK Divide Register can be
 * changed when the MCLK divided clock is enabled, additional writes to the MCLK
 * Divide Register are blocked while the Divider Update Flag is set. Writes to the
 * MCLK Divide Register when the MCLK divided clock is disabled do not set the
 * Divider Update Flag.
 */
/*!
 * @name Constants and macros for entire I2S_MDR register
 */
/*@{*/
#define I2S_RD_MDR(base)         (I2S_MDR_REG(base))
#define I2S_WR_MDR(base, value)  (I2S_MDR_REG(base) = (value))
#define I2S_RMW_MDR(base, mask, value) (I2S_WR_MDR(base, (I2S_RD_MDR(base) & ~(mask)) | (value)))
#define I2S_SET_MDR(base, value) (I2S_WR_MDR(base, I2S_RD_MDR(base) |  (value)))
#define I2S_CLR_MDR(base, value) (I2S_WR_MDR(base, I2S_RD_MDR(base) & ~(value)))
#define I2S_TOG_MDR(base, value) (I2S_WR_MDR(base, I2S_RD_MDR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_MDR bitfields
 */

/*!
 * @name Register I2S_MDR, field DIVIDE[11:0] (RW)
 *
 * The MCLK FRACT must be set equal or less than the MCLK DIVIDE. Sets the MCLK
 * divide ratio such that: MCLK output = MCLK input * ( (FRACT + 1) / (DIVIDE +
 * 1) )
 */
/*@{*/
/*! @brief Read current value of the I2S_MDR_DIVIDE field. */
#define I2S_RD_MDR_DIVIDE(base) ((I2S_MDR_REG(base) & I2S_MDR_DIVIDE_MASK) >> I2S_MDR_DIVIDE_SHIFT)
#define I2S_BRD_MDR_DIVIDE(base) (I2S_RD_MDR_DIVIDE(base))

/*! @brief Set the DIVIDE field to a new value. */
#define I2S_WR_MDR_DIVIDE(base, value) (I2S_RMW_MDR(base, I2S_MDR_DIVIDE_MASK, I2S_MDR_DIVIDE(value)))
#define I2S_BWR_MDR_DIVIDE(base, value) (I2S_WR_MDR_DIVIDE(base, value))
/*@}*/

/*!
 * @name Register I2S_MDR, field FRACT[19:12] (RW)
 *
 * The MCLK FRACT must be set equal or less than the MCLK DIVIDE. Sets the MCLK
 * divide ratio such that: MCLK output = MCLK input * ( (FRACT + 1) / (DIVIDE +
 * 1) )
 */
/*@{*/
/*! @brief Read current value of the I2S_MDR_FRACT field. */
#define I2S_RD_MDR_FRACT(base) ((I2S_MDR_REG(base) & I2S_MDR_FRACT_MASK) >> I2S_MDR_FRACT_SHIFT)
#define I2S_BRD_MDR_FRACT(base) (I2S_RD_MDR_FRACT(base))

/*! @brief Set the FRACT field to a new value. */
#define I2S_WR_MDR_FRACT(base, value) (I2S_RMW_MDR(base, I2S_MDR_FRACT_MASK, I2S_MDR_FRACT(value)))
#define I2S_BWR_MDR_FRACT(base, value) (I2S_WR_MDR_FRACT(base, value))
/*@}*/

/*
 * MK20D5 LLWU
 *
 * Low leakage wakeup unit
 *
 * Registers defined in this header file:
 * - LLWU_PE1 - LLWU Pin Enable 1 Register
 * - LLWU_PE2 - LLWU Pin Enable 2 Register
 * - LLWU_PE3 - LLWU Pin Enable 3 Register
 * - LLWU_PE4 - LLWU Pin Enable 4 Register
 * - LLWU_ME - LLWU Module Enable Register
 * - LLWU_F1 - LLWU Flag 1 Register
 * - LLWU_F2 - LLWU Flag 2 Register
 * - LLWU_F3 - LLWU Flag 3 Register
 * - LLWU_FILT1 - LLWU Pin Filter 1 Register
 * - LLWU_FILT2 - LLWU Pin Filter 2 Register
 * - LLWU_RST - LLWU Reset Enable Register
 */

#define LLWU_INSTANCE_COUNT (1U) /*!< Number of instances of the LLWU module. */
#define LLWU_IDX (0U) /*!< Instance number for LLWU. */

/*******************************************************************************
 * LLWU_PE1 - LLWU Pin Enable 1 Register
 ******************************************************************************/

/*!
 * @brief LLWU_PE1 - LLWU Pin Enable 1 Register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE1 contains the bit field to enable and select the edge detect type for
 * the external wakeup input pins LLWU_P3-LLWU_P0. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the Reset
 * details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE1 register
 */
/*@{*/
#define LLWU_RD_PE1(base)        (LLWU_PE1_REG(base))
#define LLWU_WR_PE1(base, value) (LLWU_PE1_REG(base) = (value))
#define LLWU_RMW_PE1(base, mask, value) (LLWU_WR_PE1(base, (LLWU_RD_PE1(base) & ~(mask)) | (value)))
#define LLWU_SET_PE1(base, value) (LLWU_WR_PE1(base, LLWU_RD_PE1(base) |  (value)))
#define LLWU_CLR_PE1(base, value) (LLWU_WR_PE1(base, LLWU_RD_PE1(base) & ~(value)))
#define LLWU_TOG_PE1(base, value) (LLWU_WR_PE1(base, LLWU_RD_PE1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE1 bitfields
 */

/*!
 * @name Register LLWU_PE1, field WUPE0[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE0 field. */
#define LLWU_RD_PE1_WUPE0(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE0_MASK) >> LLWU_PE1_WUPE0_SHIFT)
#define LLWU_BRD_PE1_WUPE0(base) (LLWU_RD_PE1_WUPE0(base))

/*! @brief Set the WUPE0 field to a new value. */
#define LLWU_WR_PE1_WUPE0(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE0(value)))
#define LLWU_BWR_PE1_WUPE0(base, value) (LLWU_WR_PE1_WUPE0(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE1[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE1 field. */
#define LLWU_RD_PE1_WUPE1(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE1_MASK) >> LLWU_PE1_WUPE1_SHIFT)
#define LLWU_BRD_PE1_WUPE1(base) (LLWU_RD_PE1_WUPE1(base))

/*! @brief Set the WUPE1 field to a new value. */
#define LLWU_WR_PE1_WUPE1(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE1(value)))
#define LLWU_BWR_PE1_WUPE1(base, value) (LLWU_WR_PE1_WUPE1(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE2[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE2 field. */
#define LLWU_RD_PE1_WUPE2(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE2_MASK) >> LLWU_PE1_WUPE2_SHIFT)
#define LLWU_BRD_PE1_WUPE2(base) (LLWU_RD_PE1_WUPE2(base))

/*! @brief Set the WUPE2 field to a new value. */
#define LLWU_WR_PE1_WUPE2(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE2(value)))
#define LLWU_BWR_PE1_WUPE2(base, value) (LLWU_WR_PE1_WUPE2(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE3[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE3 field. */
#define LLWU_RD_PE1_WUPE3(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE3_MASK) >> LLWU_PE1_WUPE3_SHIFT)
#define LLWU_BRD_PE1_WUPE3(base) (LLWU_RD_PE1_WUPE3(base))

/*! @brief Set the WUPE3 field to a new value. */
#define LLWU_WR_PE1_WUPE3(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE3_MASK, LLWU_PE1_WUPE3(value)))
#define LLWU_BWR_PE1_WUPE3(base, value) (LLWU_WR_PE1_WUPE3(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE2 - LLWU Pin Enable 2 Register
 ******************************************************************************/

/*!
 * @brief LLWU_PE2 - LLWU Pin Enable 2 Register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE2 contains the bit field to enable and select the edge detect type for
 * the external wakeup input pins LLWU_P7-LLWU_P4. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the Reset
 * details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE2 register
 */
/*@{*/
#define LLWU_RD_PE2(base)        (LLWU_PE2_REG(base))
#define LLWU_WR_PE2(base, value) (LLWU_PE2_REG(base) = (value))
#define LLWU_RMW_PE2(base, mask, value) (LLWU_WR_PE2(base, (LLWU_RD_PE2(base) & ~(mask)) | (value)))
#define LLWU_SET_PE2(base, value) (LLWU_WR_PE2(base, LLWU_RD_PE2(base) |  (value)))
#define LLWU_CLR_PE2(base, value) (LLWU_WR_PE2(base, LLWU_RD_PE2(base) & ~(value)))
#define LLWU_TOG_PE2(base, value) (LLWU_WR_PE2(base, LLWU_RD_PE2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE2 bitfields
 */

/*!
 * @name Register LLWU_PE2, field WUPE4[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE4 field. */
#define LLWU_RD_PE2_WUPE4(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE4_MASK) >> LLWU_PE2_WUPE4_SHIFT)
#define LLWU_BRD_PE2_WUPE4(base) (LLWU_RD_PE2_WUPE4(base))

/*! @brief Set the WUPE4 field to a new value. */
#define LLWU_WR_PE2_WUPE4(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE4_MASK, LLWU_PE2_WUPE4(value)))
#define LLWU_BWR_PE2_WUPE4(base, value) (LLWU_WR_PE2_WUPE4(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE5[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE5 field. */
#define LLWU_RD_PE2_WUPE5(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE5_MASK) >> LLWU_PE2_WUPE5_SHIFT)
#define LLWU_BRD_PE2_WUPE5(base) (LLWU_RD_PE2_WUPE5(base))

/*! @brief Set the WUPE5 field to a new value. */
#define LLWU_WR_PE2_WUPE5(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE5_MASK, LLWU_PE2_WUPE5(value)))
#define LLWU_BWR_PE2_WUPE5(base, value) (LLWU_WR_PE2_WUPE5(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE6[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE6 field. */
#define LLWU_RD_PE2_WUPE6(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE6_MASK) >> LLWU_PE2_WUPE6_SHIFT)
#define LLWU_BRD_PE2_WUPE6(base) (LLWU_RD_PE2_WUPE6(base))

/*! @brief Set the WUPE6 field to a new value. */
#define LLWU_WR_PE2_WUPE6(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE6_MASK, LLWU_PE2_WUPE6(value)))
#define LLWU_BWR_PE2_WUPE6(base, value) (LLWU_WR_PE2_WUPE6(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE7[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE7 field. */
#define LLWU_RD_PE2_WUPE7(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE7_MASK) >> LLWU_PE2_WUPE7_SHIFT)
#define LLWU_BRD_PE2_WUPE7(base) (LLWU_RD_PE2_WUPE7(base))

/*! @brief Set the WUPE7 field to a new value. */
#define LLWU_WR_PE2_WUPE7(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE7_MASK, LLWU_PE2_WUPE7(value)))
#define LLWU_BWR_PE2_WUPE7(base, value) (LLWU_WR_PE2_WUPE7(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE3 - LLWU Pin Enable 3 Register
 ******************************************************************************/

/*!
 * @brief LLWU_PE3 - LLWU Pin Enable 3 Register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE3 contains the bit field to enable and select the edge detect type for
 * the external wakeup input pins LLWU_P11-LLWU_P8. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * Reset details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE3 register
 */
/*@{*/
#define LLWU_RD_PE3(base)        (LLWU_PE3_REG(base))
#define LLWU_WR_PE3(base, value) (LLWU_PE3_REG(base) = (value))
#define LLWU_RMW_PE3(base, mask, value) (LLWU_WR_PE3(base, (LLWU_RD_PE3(base) & ~(mask)) | (value)))
#define LLWU_SET_PE3(base, value) (LLWU_WR_PE3(base, LLWU_RD_PE3(base) |  (value)))
#define LLWU_CLR_PE3(base, value) (LLWU_WR_PE3(base, LLWU_RD_PE3(base) & ~(value)))
#define LLWU_TOG_PE3(base, value) (LLWU_WR_PE3(base, LLWU_RD_PE3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE3 bitfields
 */

/*!
 * @name Register LLWU_PE3, field WUPE8[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE8 field. */
#define LLWU_RD_PE3_WUPE8(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE8_MASK) >> LLWU_PE3_WUPE8_SHIFT)
#define LLWU_BRD_PE3_WUPE8(base) (LLWU_RD_PE3_WUPE8(base))

/*! @brief Set the WUPE8 field to a new value. */
#define LLWU_WR_PE3_WUPE8(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE8_MASK, LLWU_PE3_WUPE8(value)))
#define LLWU_BWR_PE3_WUPE8(base, value) (LLWU_WR_PE3_WUPE8(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE9[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE9 field. */
#define LLWU_RD_PE3_WUPE9(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE9_MASK) >> LLWU_PE3_WUPE9_SHIFT)
#define LLWU_BRD_PE3_WUPE9(base) (LLWU_RD_PE3_WUPE9(base))

/*! @brief Set the WUPE9 field to a new value. */
#define LLWU_WR_PE3_WUPE9(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE9_MASK, LLWU_PE3_WUPE9(value)))
#define LLWU_BWR_PE3_WUPE9(base, value) (LLWU_WR_PE3_WUPE9(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE10[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE10 field. */
#define LLWU_RD_PE3_WUPE10(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE10_MASK) >> LLWU_PE3_WUPE10_SHIFT)
#define LLWU_BRD_PE3_WUPE10(base) (LLWU_RD_PE3_WUPE10(base))

/*! @brief Set the WUPE10 field to a new value. */
#define LLWU_WR_PE3_WUPE10(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE10_MASK, LLWU_PE3_WUPE10(value)))
#define LLWU_BWR_PE3_WUPE10(base, value) (LLWU_WR_PE3_WUPE10(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE11[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE11 field. */
#define LLWU_RD_PE3_WUPE11(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE11_MASK) >> LLWU_PE3_WUPE11_SHIFT)
#define LLWU_BRD_PE3_WUPE11(base) (LLWU_RD_PE3_WUPE11(base))

/*! @brief Set the WUPE11 field to a new value. */
#define LLWU_WR_PE3_WUPE11(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE11_MASK, LLWU_PE3_WUPE11(value)))
#define LLWU_BWR_PE3_WUPE11(base, value) (LLWU_WR_PE3_WUPE11(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE4 - LLWU Pin Enable 4 Register
 ******************************************************************************/

/*!
 * @brief LLWU_PE4 - LLWU Pin Enable 4 Register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE4 contains the bit field to enable and select the edge detect type for
 * the external wakeup input pins LLWU_P15-LLWU_P12. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * Reset details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE4 register
 */
/*@{*/
#define LLWU_RD_PE4(base)        (LLWU_PE4_REG(base))
#define LLWU_WR_PE4(base, value) (LLWU_PE4_REG(base) = (value))
#define LLWU_RMW_PE4(base, mask, value) (LLWU_WR_PE4(base, (LLWU_RD_PE4(base) & ~(mask)) | (value)))
#define LLWU_SET_PE4(base, value) (LLWU_WR_PE4(base, LLWU_RD_PE4(base) |  (value)))
#define LLWU_CLR_PE4(base, value) (LLWU_WR_PE4(base, LLWU_RD_PE4(base) & ~(value)))
#define LLWU_TOG_PE4(base, value) (LLWU_WR_PE4(base, LLWU_RD_PE4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE4 bitfields
 */

/*!
 * @name Register LLWU_PE4, field WUPE12[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE12 field. */
#define LLWU_RD_PE4_WUPE12(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE12_MASK) >> LLWU_PE4_WUPE12_SHIFT)
#define LLWU_BRD_PE4_WUPE12(base) (LLWU_RD_PE4_WUPE12(base))

/*! @brief Set the WUPE12 field to a new value. */
#define LLWU_WR_PE4_WUPE12(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE12_MASK, LLWU_PE4_WUPE12(value)))
#define LLWU_BWR_PE4_WUPE12(base, value) (LLWU_WR_PE4_WUPE12(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE13[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE13 field. */
#define LLWU_RD_PE4_WUPE13(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE13_MASK) >> LLWU_PE4_WUPE13_SHIFT)
#define LLWU_BRD_PE4_WUPE13(base) (LLWU_RD_PE4_WUPE13(base))

/*! @brief Set the WUPE13 field to a new value. */
#define LLWU_WR_PE4_WUPE13(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE13_MASK, LLWU_PE4_WUPE13(value)))
#define LLWU_BWR_PE4_WUPE13(base, value) (LLWU_WR_PE4_WUPE13(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE14[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE14 field. */
#define LLWU_RD_PE4_WUPE14(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE14_MASK) >> LLWU_PE4_WUPE14_SHIFT)
#define LLWU_BRD_PE4_WUPE14(base) (LLWU_RD_PE4_WUPE14(base))

/*! @brief Set the WUPE14 field to a new value. */
#define LLWU_WR_PE4_WUPE14(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE14_MASK, LLWU_PE4_WUPE14(value)))
#define LLWU_BWR_PE4_WUPE14(base, value) (LLWU_WR_PE4_WUPE14(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE15[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE15 field. */
#define LLWU_RD_PE4_WUPE15(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE15_MASK) >> LLWU_PE4_WUPE15_SHIFT)
#define LLWU_BRD_PE4_WUPE15(base) (LLWU_RD_PE4_WUPE15(base))

/*! @brief Set the WUPE15 field to a new value. */
#define LLWU_WR_PE4_WUPE15(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE15_MASK, LLWU_PE4_WUPE15(value)))
#define LLWU_BWR_PE4_WUPE15(base, value) (LLWU_WR_PE4_WUPE15(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_ME - LLWU Module Enable Register
 ******************************************************************************/

/*!
 * @brief LLWU_ME - LLWU Module Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_ME contains the bits to enable the internal module flag as a wakeup
 * input source for inputs MWUF7-MWUF0. This register is reset on Chip Reset not VLLS
 * and by reset types that trigger Chip Reset not VLLS. It is unaffected by
 * reset types that do not trigger Chip Reset not VLLS. See the Reset details for
 * more information.
 */
/*!
 * @name Constants and macros for entire LLWU_ME register
 */
/*@{*/
#define LLWU_RD_ME(base)         (LLWU_ME_REG(base))
#define LLWU_WR_ME(base, value)  (LLWU_ME_REG(base) = (value))
#define LLWU_RMW_ME(base, mask, value) (LLWU_WR_ME(base, (LLWU_RD_ME(base) & ~(mask)) | (value)))
#define LLWU_SET_ME(base, value) (LLWU_WR_ME(base, LLWU_RD_ME(base) |  (value)))
#define LLWU_CLR_ME(base, value) (LLWU_WR_ME(base, LLWU_RD_ME(base) & ~(value)))
#define LLWU_TOG_ME(base, value) (LLWU_WR_ME(base, LLWU_RD_ME(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_ME bitfields
 */

/*!
 * @name Register LLWU_ME, field WUME0[0] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME0 field. */
#define LLWU_RD_ME_WUME0(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME0_MASK) >> LLWU_ME_WUME0_SHIFT)
#define LLWU_BRD_ME_WUME0(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME0_SHIFT))

/*! @brief Set the WUME0 field to a new value. */
#define LLWU_WR_ME_WUME0(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME0_MASK, LLWU_ME_WUME0(value)))
#define LLWU_BWR_ME_WUME0(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME1[1] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME1 field. */
#define LLWU_RD_ME_WUME1(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME1_MASK) >> LLWU_ME_WUME1_SHIFT)
#define LLWU_BRD_ME_WUME1(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME1_SHIFT))

/*! @brief Set the WUME1 field to a new value. */
#define LLWU_WR_ME_WUME1(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME1_MASK, LLWU_ME_WUME1(value)))
#define LLWU_BWR_ME_WUME1(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME2[2] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME2 field. */
#define LLWU_RD_ME_WUME2(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME2_MASK) >> LLWU_ME_WUME2_SHIFT)
#define LLWU_BRD_ME_WUME2(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME2_SHIFT))

/*! @brief Set the WUME2 field to a new value. */
#define LLWU_WR_ME_WUME2(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME2_MASK, LLWU_ME_WUME2(value)))
#define LLWU_BWR_ME_WUME2(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME3[3] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME3 field. */
#define LLWU_RD_ME_WUME3(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME3_MASK) >> LLWU_ME_WUME3_SHIFT)
#define LLWU_BRD_ME_WUME3(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME3_SHIFT))

/*! @brief Set the WUME3 field to a new value. */
#define LLWU_WR_ME_WUME3(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME3_MASK, LLWU_ME_WUME3(value)))
#define LLWU_BWR_ME_WUME3(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME4[4] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME4 field. */
#define LLWU_RD_ME_WUME4(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME4_MASK) >> LLWU_ME_WUME4_SHIFT)
#define LLWU_BRD_ME_WUME4(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME4_SHIFT))

/*! @brief Set the WUME4 field to a new value. */
#define LLWU_WR_ME_WUME4(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME4_MASK, LLWU_ME_WUME4(value)))
#define LLWU_BWR_ME_WUME4(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME5[5] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME5 field. */
#define LLWU_RD_ME_WUME5(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME5_MASK) >> LLWU_ME_WUME5_SHIFT)
#define LLWU_BRD_ME_WUME5(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME5_SHIFT))

/*! @brief Set the WUME5 field to a new value. */
#define LLWU_WR_ME_WUME5(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME5_MASK, LLWU_ME_WUME5(value)))
#define LLWU_BWR_ME_WUME5(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME6[6] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME6 field. */
#define LLWU_RD_ME_WUME6(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME6_MASK) >> LLWU_ME_WUME6_SHIFT)
#define LLWU_BRD_ME_WUME6(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME6_SHIFT))

/*! @brief Set the WUME6 field to a new value. */
#define LLWU_WR_ME_WUME6(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME6_MASK, LLWU_ME_WUME6(value)))
#define LLWU_BWR_ME_WUME6(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME7[7] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME7 field. */
#define LLWU_RD_ME_WUME7(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME7_MASK) >> LLWU_ME_WUME7_SHIFT)
#define LLWU_BRD_ME_WUME7(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME7_SHIFT))

/*! @brief Set the WUME7 field to a new value. */
#define LLWU_WR_ME_WUME7(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME7_MASK, LLWU_ME_WUME7(value)))
#define LLWU_BWR_ME_WUME7(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME7_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_F1 - LLWU Flag 1 Register
 ******************************************************************************/

/*!
 * @brief LLWU_F1 - LLWU Flag 1 Register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F1 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this will be the source causing the CPU
 * interrupt flow. For VLLS, this will be the source causing the MCU reset flow.
 * The external wakeup flags are read only and clearing a flag is accomplished by
 * a write of a one to the corresponding WUFx bit. The wakeup flag (WUFx) if set
 * will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS.
 * It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the Reset details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_F1 register
 */
/*@{*/
#define LLWU_RD_F1(base)         (LLWU_F1_REG(base))
#define LLWU_WR_F1(base, value)  (LLWU_F1_REG(base) = (value))
#define LLWU_RMW_F1(base, mask, value) (LLWU_WR_F1(base, (LLWU_RD_F1(base) & ~(mask)) | (value)))
#define LLWU_SET_F1(base, value) (LLWU_WR_F1(base, LLWU_RD_F1(base) |  (value)))
#define LLWU_CLR_F1(base, value) (LLWU_WR_F1(base, LLWU_RD_F1(base) & ~(value)))
#define LLWU_TOG_F1(base, value) (LLWU_WR_F1(base, LLWU_RD_F1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F1 bitfields
 */

/*!
 * @name Register LLWU_F1, field WUF0[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF0.
 *
 * Values:
 * - 0 - LLWU_P0 input was not a wakeup source
 * - 1 - LLWU_P0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF0 field. */
#define LLWU_RD_F1_WUF0(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF0_MASK) >> LLWU_F1_WUF0_SHIFT)
#define LLWU_BRD_F1_WUF0(base) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF0_SHIFT))

/*! @brief Set the WUF0 field to a new value. */
#define LLWU_WR_F1_WUF0(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF0(value)))
#define LLWU_BWR_F1_WUF0(base, value) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF1[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF1.
 *
 * Values:
 * - 0 - LLWU_P1 input was not a wakeup source
 * - 1 - LLWU_P1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF1 field. */
#define LLWU_RD_F1_WUF1(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF1_MASK) >> LLWU_F1_WUF1_SHIFT)
#define LLWU_BRD_F1_WUF1(base) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF1_SHIFT))

/*! @brief Set the WUF1 field to a new value. */
#define LLWU_WR_F1_WUF1(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF1_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF1(value)))
#define LLWU_BWR_F1_WUF1(base, value) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF2[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF2.
 *
 * Values:
 * - 0 - LLWU_P2 input was not a wakeup source
 * - 1 - LLWU_P2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF2 field. */
#define LLWU_RD_F1_WUF2(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF2_MASK) >> LLWU_F1_WUF2_SHIFT)
#define LLWU_BRD_F1_WUF2(base) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF2_SHIFT))

/*! @brief Set the WUF2 field to a new value. */
#define LLWU_WR_F1_WUF2(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF2_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF2(value)))
#define LLWU_BWR_F1_WUF2(base, value) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF3[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF3.
 *
 * Values:
 * - 0 - LLWU_P3 input was not a wakeup source
 * - 1 - LLWU_P3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF3 field. */
#define LLWU_RD_F1_WUF3(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF3_MASK) >> LLWU_F1_WUF3_SHIFT)
#define LLWU_BRD_F1_WUF3(base) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF3_SHIFT))

/*! @brief Set the WUF3 field to a new value. */
#define LLWU_WR_F1_WUF3(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF3_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF3(value)))
#define LLWU_BWR_F1_WUF3(base, value) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF4[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF4.
 *
 * Values:
 * - 0 - LLWU_P4 input was not a wakeup source
 * - 1 - LLWU_P4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF4 field. */
#define LLWU_RD_F1_WUF4(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF4_MASK) >> LLWU_F1_WUF4_SHIFT)
#define LLWU_BRD_F1_WUF4(base) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF4_SHIFT))

/*! @brief Set the WUF4 field to a new value. */
#define LLWU_WR_F1_WUF4(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF4_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF4(value)))
#define LLWU_BWR_F1_WUF4(base, value) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF5[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF5.
 *
 * Values:
 * - 0 - LLWU_P5 input was not a wakeup source
 * - 1 - LLWU_P5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF5 field. */
#define LLWU_RD_F1_WUF5(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF5_MASK) >> LLWU_F1_WUF5_SHIFT)
#define LLWU_BRD_F1_WUF5(base) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF5_SHIFT))

/*! @brief Set the WUF5 field to a new value. */
#define LLWU_WR_F1_WUF5(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF5_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF6_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF5(value)))
#define LLWU_BWR_F1_WUF5(base, value) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF6[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF6.
 *
 * Values:
 * - 0 - LLWU_P6 input was not a wakeup source
 * - 1 - LLWU_P6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF6 field. */
#define LLWU_RD_F1_WUF6(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF6_MASK) >> LLWU_F1_WUF6_SHIFT)
#define LLWU_BRD_F1_WUF6(base) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF6_SHIFT))

/*! @brief Set the WUF6 field to a new value. */
#define LLWU_WR_F1_WUF6(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF6_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF7_MASK), LLWU_F1_WUF6(value)))
#define LLWU_BWR_F1_WUF6(base, value) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF7[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF7.
 *
 * Values:
 * - 0 - LLWU_P7 input was not a wakeup source
 * - 1 - LLWU_P7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F1_WUF7 field. */
#define LLWU_RD_F1_WUF7(base) ((LLWU_F1_REG(base) & LLWU_F1_WUF7_MASK) >> LLWU_F1_WUF7_SHIFT)
#define LLWU_BRD_F1_WUF7(base) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF7_SHIFT))

/*! @brief Set the WUF7 field to a new value. */
#define LLWU_WR_F1_WUF7(base, value) (LLWU_RMW_F1(base, (LLWU_F1_WUF7_MASK | LLWU_F1_WUF0_MASK | LLWU_F1_WUF1_MASK | LLWU_F1_WUF2_MASK | LLWU_F1_WUF3_MASK | LLWU_F1_WUF4_MASK | LLWU_F1_WUF5_MASK | LLWU_F1_WUF6_MASK), LLWU_F1_WUF7(value)))
#define LLWU_BWR_F1_WUF7(base, value) (BITBAND_ACCESS8(&LLWU_F1_REG(base), LLWU_F1_WUF7_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_F2 - LLWU Flag 2 Register
 ******************************************************************************/

/*!
 * @brief LLWU_F2 - LLWU Flag 2 Register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F2 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this will be the source causing the CPU
 * interrupt flow. For VLLS, this will be the source causing the MCU reset flow.
 * The external wakeup flags are read only and clearing a flag is accomplished by
 * a write of a one to the corresponding WUFx bit. The wakeup flag (WUFx) if set
 * will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS.
 * It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the Reset details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_F2 register
 */
/*@{*/
#define LLWU_RD_F2(base)         (LLWU_F2_REG(base))
#define LLWU_WR_F2(base, value)  (LLWU_F2_REG(base) = (value))
#define LLWU_RMW_F2(base, mask, value) (LLWU_WR_F2(base, (LLWU_RD_F2(base) & ~(mask)) | (value)))
#define LLWU_SET_F2(base, value) (LLWU_WR_F2(base, LLWU_RD_F2(base) |  (value)))
#define LLWU_CLR_F2(base, value) (LLWU_WR_F2(base, LLWU_RD_F2(base) & ~(value)))
#define LLWU_TOG_F2(base, value) (LLWU_WR_F2(base, LLWU_RD_F2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F2 bitfields
 */

/*!
 * @name Register LLWU_F2, field WUF8[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF8.
 *
 * Values:
 * - 0 - LLWU_P8 input was not a wakeup source
 * - 1 - LLWU_P8 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF8 field. */
#define LLWU_RD_F2_WUF8(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF8_MASK) >> LLWU_F2_WUF8_SHIFT)
#define LLWU_BRD_F2_WUF8(base) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF8_SHIFT))

/*! @brief Set the WUF8 field to a new value. */
#define LLWU_WR_F2_WUF8(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF8(value)))
#define LLWU_BWR_F2_WUF8(base, value) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF9[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF9.
 *
 * Values:
 * - 0 - LLWU_P9 input was not a wakeup source
 * - 1 - LLWU_P9 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF9 field. */
#define LLWU_RD_F2_WUF9(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF9_MASK) >> LLWU_F2_WUF9_SHIFT)
#define LLWU_BRD_F2_WUF9(base) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF9_SHIFT))

/*! @brief Set the WUF9 field to a new value. */
#define LLWU_WR_F2_WUF9(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF9_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF9(value)))
#define LLWU_BWR_F2_WUF9(base, value) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF10[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF10.
 *
 * Values:
 * - 0 - LLWU_P10 input was not a wakeup source
 * - 1 - LLWU_P10 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF10 field. */
#define LLWU_RD_F2_WUF10(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF10_MASK) >> LLWU_F2_WUF10_SHIFT)
#define LLWU_BRD_F2_WUF10(base) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF10_SHIFT))

/*! @brief Set the WUF10 field to a new value. */
#define LLWU_WR_F2_WUF10(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF10_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF10(value)))
#define LLWU_BWR_F2_WUF10(base, value) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF11[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF11.
 *
 * Values:
 * - 0 - LLWU_P11 input was not a wakeup source
 * - 1 - LLWU_P11 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF11 field. */
#define LLWU_RD_F2_WUF11(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF11_MASK) >> LLWU_F2_WUF11_SHIFT)
#define LLWU_BRD_F2_WUF11(base) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF11_SHIFT))

/*! @brief Set the WUF11 field to a new value. */
#define LLWU_WR_F2_WUF11(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF11_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF11(value)))
#define LLWU_BWR_F2_WUF11(base, value) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF12[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF12.
 *
 * Values:
 * - 0 - LLWU_P12 input was not a wakeup source
 * - 1 - LLWU_P12 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF12 field. */
#define LLWU_RD_F2_WUF12(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF12_MASK) >> LLWU_F2_WUF12_SHIFT)
#define LLWU_BRD_F2_WUF12(base) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF12_SHIFT))

/*! @brief Set the WUF12 field to a new value. */
#define LLWU_WR_F2_WUF12(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF12_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF12(value)))
#define LLWU_BWR_F2_WUF12(base, value) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF13[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF13.
 *
 * Values:
 * - 0 - LLWU_P13 input was not a wakeup source
 * - 1 - LLWU_P13 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF13 field. */
#define LLWU_RD_F2_WUF13(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF13_MASK) >> LLWU_F2_WUF13_SHIFT)
#define LLWU_BRD_F2_WUF13(base) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF13_SHIFT))

/*! @brief Set the WUF13 field to a new value. */
#define LLWU_WR_F2_WUF13(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF13_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF14_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF13(value)))
#define LLWU_BWR_F2_WUF13(base, value) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF14[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF14.
 *
 * Values:
 * - 0 - LLWU_P14 input was not a wakeup source
 * - 1 - LLWU_P14 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF14 field. */
#define LLWU_RD_F2_WUF14(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF14_MASK) >> LLWU_F2_WUF14_SHIFT)
#define LLWU_BRD_F2_WUF14(base) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF14_SHIFT))

/*! @brief Set the WUF14 field to a new value. */
#define LLWU_WR_F2_WUF14(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF14_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF15_MASK), LLWU_F2_WUF14(value)))
#define LLWU_BWR_F2_WUF14(base, value) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF15[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF15.
 *
 * Values:
 * - 0 - LLWU_P15 input was not a wakeup source
 * - 1 - LLWU_P15 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F2_WUF15 field. */
#define LLWU_RD_F2_WUF15(base) ((LLWU_F2_REG(base) & LLWU_F2_WUF15_MASK) >> LLWU_F2_WUF15_SHIFT)
#define LLWU_BRD_F2_WUF15(base) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF15_SHIFT))

/*! @brief Set the WUF15 field to a new value. */
#define LLWU_WR_F2_WUF15(base, value) (LLWU_RMW_F2(base, (LLWU_F2_WUF15_MASK | LLWU_F2_WUF8_MASK | LLWU_F2_WUF9_MASK | LLWU_F2_WUF10_MASK | LLWU_F2_WUF11_MASK | LLWU_F2_WUF12_MASK | LLWU_F2_WUF13_MASK | LLWU_F2_WUF14_MASK), LLWU_F2_WUF15(value)))
#define LLWU_BWR_F2_WUF15(base, value) (BITBAND_ACCESS8(&LLWU_F2_REG(base), LLWU_F2_WUF15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_F3 - LLWU Flag 3 Register
 ******************************************************************************/

/*!
 * @brief LLWU_F3 - LLWU Flag 3 Register (RO)
 *
 * Reset value: 0x00U
 *
 * LLWU_F3 contains the wakeup flags indicating which internal wakeup source
 * caused the MCU to exit LLS or VLLS mode. For LLS, this will be the source causing
 * the CPU interrupt flow. For VLLS, this will be the source causing the MCU
 * reset flow. For internal peripherals that are capable of running in a low-leakage
 * power mode, such as RTC or CMP modules, the flag from the associated
 * peripheral is accessible as the MWUFx bit. Clearing of the flag will need to be done
 * in the peripheral instead of writing a one to the MWUFx bit. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS.
 * See the Reset details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_F3 register
 */
/*@{*/
#define LLWU_RD_F3(base)         (LLWU_F3_REG(base))
/*@}*/

/*
 * Constants & macros for individual LLWU_F3 bitfields
 */

/*!
 * @name Register LLWU_F3, field MWUF0[0] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 0 input was not a wakeup source
 * - 1 - Module 0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF0 field. */
#define LLWU_RD_F3_MWUF0(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF0_MASK) >> LLWU_F3_MWUF0_SHIFT)
#define LLWU_BRD_F3_MWUF0(base) (BITBAND_ACCESS8(&LLWU_F3_REG(base), LLWU_F3_MWUF0_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF1[1] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 1 input was not a wakeup source
 * - 1 - Module 1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF1 field. */
#define LLWU_RD_F3_MWUF1(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF1_MASK) >> LLWU_F3_MWUF1_SHIFT)
#define LLWU_BRD_F3_MWUF1(base) (BITBAND_ACCESS8(&LLWU_F3_REG(base), LLWU_F3_MWUF1_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF2[2] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 2 input was not a wakeup source
 * - 1 - Module 2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF2 field. */
#define LLWU_RD_F3_MWUF2(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF2_MASK) >> LLWU_F3_MWUF2_SHIFT)
#define LLWU_BRD_F3_MWUF2(base) (BITBAND_ACCESS8(&LLWU_F3_REG(base), LLWU_F3_MWUF2_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF3[3] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 3 input was not a wakeup source
 * - 1 - Module 3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF3 field. */
#define LLWU_RD_F3_MWUF3(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF3_MASK) >> LLWU_F3_MWUF3_SHIFT)
#define LLWU_BRD_F3_MWUF3(base) (BITBAND_ACCESS8(&LLWU_F3_REG(base), LLWU_F3_MWUF3_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF4[4] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 4 input was not a wakeup source
 * - 1 - Module 4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF4 field. */
#define LLWU_RD_F3_MWUF4(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF4_MASK) >> LLWU_F3_MWUF4_SHIFT)
#define LLWU_BRD_F3_MWUF4(base) (BITBAND_ACCESS8(&LLWU_F3_REG(base), LLWU_F3_MWUF4_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF5[5] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 5 input was not a wakeup source
 * - 1 - Module 5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF5 field. */
#define LLWU_RD_F3_MWUF5(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF5_MASK) >> LLWU_F3_MWUF5_SHIFT)
#define LLWU_BRD_F3_MWUF5(base) (BITBAND_ACCESS8(&LLWU_F3_REG(base), LLWU_F3_MWUF5_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF6[6] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 6 input was not a wakeup source
 * - 1 - Module 6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF6 field. */
#define LLWU_RD_F3_MWUF6(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF6_MASK) >> LLWU_F3_MWUF6_SHIFT)
#define LLWU_BRD_F3_MWUF6(base) (BITBAND_ACCESS8(&LLWU_F3_REG(base), LLWU_F3_MWUF6_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF7[7] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 7 input was not a wakeup source
 * - 1 - Module 7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_F3_MWUF7 field. */
#define LLWU_RD_F3_MWUF7(base) ((LLWU_F3_REG(base) & LLWU_F3_MWUF7_MASK) >> LLWU_F3_MWUF7_SHIFT)
#define LLWU_BRD_F3_MWUF7(base) (BITBAND_ACCESS8(&LLWU_F3_REG(base), LLWU_F3_MWUF7_SHIFT))
/*@}*/

/*******************************************************************************
 * LLWU_FILT1 - LLWU Pin Filter 1 Register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT1 - LLWU Pin Filter 1 Register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT1 is a control and status register that is used to enable/disable
 * the digital filter 1 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the Reset
 * details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT1 register
 */
/*@{*/
#define LLWU_RD_FILT1(base)      (LLWU_FILT1_REG(base))
#define LLWU_WR_FILT1(base, value) (LLWU_FILT1_REG(base) = (value))
#define LLWU_RMW_FILT1(base, mask, value) (LLWU_WR_FILT1(base, (LLWU_RD_FILT1(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT1(base, value) (LLWU_WR_FILT1(base, LLWU_RD_FILT1(base) |  (value)))
#define LLWU_CLR_FILT1(base, value) (LLWU_WR_FILT1(base, LLWU_RD_FILT1(base) & ~(value)))
#define LLWU_TOG_FILT1(base, value) (LLWU_WR_FILT1(base, LLWU_RD_FILT1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT1 bitfields
 */

/*!
 * @name Register LLWU_FILT1, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0000 - Select LLWU_P0 for filter
 * - 1111 - Select LLWU_P15 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTSEL field. */
#define LLWU_RD_FILT1_FILTSEL(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTSEL_MASK) >> LLWU_FILT1_FILTSEL_SHIFT)
#define LLWU_BRD_FILT1_FILTSEL(base) (LLWU_RD_FILT1_FILTSEL(base))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT1_FILTSEL(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTSEL_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTSEL(value)))
#define LLWU_BWR_FILT1_FILTSEL(base, value) (LLWU_WR_FILT1_FILTSEL(base, value))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTE field. */
#define LLWU_RD_FILT1_FILTE(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTE_MASK) >> LLWU_FILT1_FILTE_SHIFT)
#define LLWU_BRD_FILT1_FILTE(base) (LLWU_RD_FILT1_FILTE(base))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT1_FILTE(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTE_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTE(value)))
#define LLWU_BWR_FILT1_FILTE(base, value) (LLWU_WR_FILT1_FILTE(base, value))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 1 was not a wakeup source
 * - 1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTF field. */
#define LLWU_RD_FILT1_FILTF(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTF_MASK) >> LLWU_FILT1_FILTF_SHIFT)
#define LLWU_BRD_FILT1_FILTF(base) (BITBAND_ACCESS8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTF_SHIFT))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT1_FILTF(base, value) (LLWU_RMW_FILT1(base, LLWU_FILT1_FILTF_MASK, LLWU_FILT1_FILTF(value)))
#define LLWU_BWR_FILT1_FILTF(base, value) (BITBAND_ACCESS8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_FILT2 - LLWU Pin Filter 2 Register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT2 - LLWU Pin Filter 2 Register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT2 is a control and status register that is used to enable/disable
 * the digital filter 2 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the Reset
 * details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT2 register
 */
/*@{*/
#define LLWU_RD_FILT2(base)      (LLWU_FILT2_REG(base))
#define LLWU_WR_FILT2(base, value) (LLWU_FILT2_REG(base) = (value))
#define LLWU_RMW_FILT2(base, mask, value) (LLWU_WR_FILT2(base, (LLWU_RD_FILT2(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT2(base, value) (LLWU_WR_FILT2(base, LLWU_RD_FILT2(base) |  (value)))
#define LLWU_CLR_FILT2(base, value) (LLWU_WR_FILT2(base, LLWU_RD_FILT2(base) & ~(value)))
#define LLWU_TOG_FILT2(base, value) (LLWU_WR_FILT2(base, LLWU_RD_FILT2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT2 bitfields
 */

/*!
 * @name Register LLWU_FILT2, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0000 - Select LLWU_P0 for filter
 * - 1111 - Select LLWU_P15 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTSEL field. */
#define LLWU_RD_FILT2_FILTSEL(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTSEL_MASK) >> LLWU_FILT2_FILTSEL_SHIFT)
#define LLWU_BRD_FILT2_FILTSEL(base) (LLWU_RD_FILT2_FILTSEL(base))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT2_FILTSEL(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTSEL_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTSEL(value)))
#define LLWU_BWR_FILT2_FILTSEL(base, value) (LLWU_WR_FILT2_FILTSEL(base, value))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTE field. */
#define LLWU_RD_FILT2_FILTE(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTE_MASK) >> LLWU_FILT2_FILTE_SHIFT)
#define LLWU_BRD_FILT2_FILTE(base) (LLWU_RD_FILT2_FILTE(base))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT2_FILTE(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTE_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTE(value)))
#define LLWU_BWR_FILT2_FILTE(base, value) (LLWU_WR_FILT2_FILTE(base, value))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 2 was not a wakeup source
 * - 1 - Pin Filter 2 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTF field. */
#define LLWU_RD_FILT2_FILTF(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTF_MASK) >> LLWU_FILT2_FILTF_SHIFT)
#define LLWU_BRD_FILT2_FILTF(base) (BITBAND_ACCESS8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTF_SHIFT))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT2_FILTF(base, value) (LLWU_RMW_FILT2(base, LLWU_FILT2_FILTF_MASK, LLWU_FILT2_FILTF(value)))
#define LLWU_BWR_FILT2_FILTF(base, value) (BITBAND_ACCESS8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_RST - LLWU Reset Enable Register
 ******************************************************************************/

/*!
 * @brief LLWU_RST - LLWU Reset Enable Register (RW)
 *
 * Reset value: 0x02U
 *
 * LLWU_RST is a control register that is used to enable/disable the digital
 * filter for the external pin detect and RESET pin. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the Reset
 * details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_RST register
 */
/*@{*/
#define LLWU_RD_RST(base)        (LLWU_RST_REG(base))
#define LLWU_WR_RST(base, value) (LLWU_RST_REG(base) = (value))
#define LLWU_RMW_RST(base, mask, value) (LLWU_WR_RST(base, (LLWU_RD_RST(base) & ~(mask)) | (value)))
#define LLWU_SET_RST(base, value) (LLWU_WR_RST(base, LLWU_RD_RST(base) |  (value)))
#define LLWU_CLR_RST(base, value) (LLWU_WR_RST(base, LLWU_RD_RST(base) & ~(value)))
#define LLWU_TOG_RST(base, value) (LLWU_WR_RST(base, LLWU_RD_RST(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_RST bitfields
 */

/*!
 * @name Register LLWU_RST, field RSTFILT[0] (RW)
 *
 * Enables the digital filter for the RESET pin during LLS, VLLS3, VLLS2 or
 * VLLS1 modes.
 *
 * Values:
 * - 0 - Filter not enabled
 * - 1 - Filter enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_RST_RSTFILT field. */
#define LLWU_RD_RST_RSTFILT(base) ((LLWU_RST_REG(base) & LLWU_RST_RSTFILT_MASK) >> LLWU_RST_RSTFILT_SHIFT)
#define LLWU_BRD_RST_RSTFILT(base) (BITBAND_ACCESS8(&LLWU_RST_REG(base), LLWU_RST_RSTFILT_SHIFT))

/*! @brief Set the RSTFILT field to a new value. */
#define LLWU_WR_RST_RSTFILT(base, value) (LLWU_RMW_RST(base, LLWU_RST_RSTFILT_MASK, LLWU_RST_RSTFILT(value)))
#define LLWU_BWR_RST_RSTFILT(base, value) (BITBAND_ACCESS8(&LLWU_RST_REG(base), LLWU_RST_RSTFILT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_RST, field LLRSTE[1] (RW)
 *
 * This bit must be set to allow the device to be reset while in a low-leakage
 * power mode. On devices where Reset is not a dedicated pin, the RESET pin must
 * also be enabled in the explicit port mux control.
 *
 * Values:
 * - 0 - RESET pin not enabled as a leakage mode exit source
 * - 1 - RESET pin enabled as a low leakage mode exit source
 */
/*@{*/
/*! @brief Read current value of the LLWU_RST_LLRSTE field. */
#define LLWU_RD_RST_LLRSTE(base) ((LLWU_RST_REG(base) & LLWU_RST_LLRSTE_MASK) >> LLWU_RST_LLRSTE_SHIFT)
#define LLWU_BRD_RST_LLRSTE(base) (BITBAND_ACCESS8(&LLWU_RST_REG(base), LLWU_RST_LLRSTE_SHIFT))

/*! @brief Set the LLRSTE field to a new value. */
#define LLWU_WR_RST_LLRSTE(base, value) (LLWU_RMW_RST(base, LLWU_RST_LLRSTE_MASK, LLWU_RST_LLRSTE(value)))
#define LLWU_BWR_RST_LLRSTE(base, value) (BITBAND_ACCESS8(&LLWU_RST_REG(base), LLWU_RST_LLRSTE_SHIFT) = (value))
/*@}*/

/*
 * MK20D5 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - LPTMR_CSR - Low Power Timer Control Status Register
 * - LPTMR_PSR - Low Power Timer Prescale Register
 * - LPTMR_CMR - Low Power Timer Compare Register
 * - LPTMR_CNR - Low Power Timer Counter Register
 */

#define LPTMR_INSTANCE_COUNT (1U) /*!< Number of instances of the LPTMR module. */
#define LPTMR0_IDX (0U) /*!< Instance number for LPTMR0. */

/*******************************************************************************
 * LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define LPTMR_RD_CSR(base)       (LPTMR_CSR_REG(base))
#define LPTMR_WR_CSR(base, value) (LPTMR_CSR_REG(base) = (value))
#define LPTMR_RMW_CSR(base, mask, value) (LPTMR_WR_CSR(base, (LPTMR_RD_CSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CSR(base, value) (LPTMR_WR_CSR(base, LPTMR_RD_CSR(base) |  (value)))
#define LPTMR_CLR_CSR(base, value) (LPTMR_WR_CSR(base, LPTMR_RD_CSR(base) & ~(value)))
#define LPTMR_TOG_CSR(base, value) (LPTMR_WR_CSR(base, LPTMR_RD_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When the Timer Enable bit is clear, it resets the LPTMR internal logic
 * (including the LPTMR Counter Register and Timer Compare Flag). When the Timer Enable
 * bit is set, the LPTMR is enabled. When writing 1 to this bit, bits
 * LPTMR_CSR[5:1] should not be altered.
 *
 * Values:
 * - 0 - LPTMR is disabled and internal logic is reset.
 * - 1 - LPTMR is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define LPTMR_RD_CSR_TEN(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TEN_MASK) >> LPTMR_CSR_TEN_SHIFT)
#define LPTMR_BRD_CSR_TEN(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT))

/*! @brief Set the TEN field to a new value. */
#define LPTMR_WR_CSR_TEN(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TEN_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TEN(value)))
#define LPTMR_BWR_CSR_TEN(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * The Timer Mode Select configures the mode of the LPTMR. The Timer Mode Select
 * should only be altered when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Time Counter mode.
 * - 1 - Pulse Counter mode.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define LPTMR_RD_CSR_TMS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TMS_MASK) >> LPTMR_CSR_TMS_SHIFT)
#define LPTMR_BRD_CSR_TMS(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT))

/*! @brief Set the TMS field to a new value. */
#define LPTMR_WR_CSR_TMS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TMS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TMS(value)))
#define LPTMR_BWR_CSR_TMS(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear the Timer Free Running Counter configures the LPTMR Counter
 * Register to reset whenever the Timer Compare Flag is set. When set, the Timer Free
 * Running Counter configures the LPTMR Counter Register to reset on overflow. The
 * Timer Free Running Counter should only be altered when the LPTMR is disabled.
 *
 * Values:
 * - 0 - LPTMR Counter Register is reset whenever the Timer Compare Flag is set.
 * - 1 - LPTMR Counter Register is reset on overflow.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define LPTMR_RD_CSR_TFC(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TFC_MASK) >> LPTMR_CSR_TFC_SHIFT)
#define LPTMR_BRD_CSR_TFC(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT))

/*! @brief Set the TFC field to a new value. */
#define LPTMR_WR_CSR_TFC(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TFC_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TFC(value)))
#define LPTMR_BWR_CSR_TFC(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * The Timer Pin Polarity configures the polarity of the input source in Pulse
 * Counter mode. The Timer Pin Polarity should only be changed when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0 - Pulse Counter input source is active high, and LPTMR Counter Register
 *     will increment on the rising edge.
 * - 1 - Pulse Counter input source is active low, and LPTMR Counter Register
 *     will increment on the falling edge.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define LPTMR_RD_CSR_TPP(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPP_MASK) >> LPTMR_CSR_TPP_SHIFT)
#define LPTMR_BRD_CSR_TPP(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT))

/*! @brief Set the TPP field to a new value. */
#define LPTMR_WR_CSR_TPP(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPP_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPP(value)))
#define LPTMR_BWR_CSR_TPP(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * The Timer Pin Select configures the input source to be used in Pulse Counter
 * mode. The Timer Pin Select should only be altered when the LPTMR is disabled.
 * The input connections vary by device. See the Chip Configuration details for
 * information on the connections to these inputs.
 *
 * Values:
 * - 00 - Pulse counter input 0 is selected.
 * - 01 - Pulse counter input 1 is selected.
 * - 10 - Pulse counter input 2 is selected.
 * - 11 - Pulse counter input 3 is selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define LPTMR_RD_CSR_TPS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPS_MASK) >> LPTMR_CSR_TPS_SHIFT)
#define LPTMR_BRD_CSR_TPS(base) (LPTMR_RD_CSR_TPS(base))

/*! @brief Set the TPS field to a new value. */
#define LPTMR_WR_CSR_TPS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPS(value)))
#define LPTMR_BWR_CSR_TPS(base, value) (LPTMR_WR_CSR_TPS(base, value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When the Timer Interrupt Enable is set, the LPTMR Interrupt is generated
 * whenever the Timer Compare Flag is also set.
 *
 * Values:
 * - 0 - Timer Interrupt Disabled.
 * - 1 - Timer Interrupt Enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define LPTMR_RD_CSR_TIE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TIE_MASK) >> LPTMR_CSR_TIE_SHIFT)
#define LPTMR_BRD_CSR_TIE(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT))

/*! @brief Set the TIE field to a new value. */
#define LPTMR_WR_CSR_TIE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TIE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TIE(value)))
#define LPTMR_BWR_CSR_TIE(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * The timer compare flag is set when the LPTMR is enabled and the LPTMR Counter
 * Register equals the LPTMR Compare Register and increments. This Timer Compare
 * Flag is cleared when the LPTMR is disabled or a logic one is written to the
 * Timer Compare Flag.
 *
 * Values:
 * - 0 - LPTMR Counter Register has not equaled the LPTMR Compare Register and
 *     incremented
 * - 1 - LPTMR Counter Register has equaled the LPTMR Compare Register and
 *     incremented
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define LPTMR_RD_CSR_TCF(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TCF_MASK) >> LPTMR_CSR_TCF_SHIFT)
#define LPTMR_BRD_CSR_TCF(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT))

/*! @brief Set the TCF field to a new value. */
#define LPTMR_WR_CSR_TCF(base, value) (LPTMR_RMW_CSR(base, LPTMR_CSR_TCF_MASK, LPTMR_CSR_TCF(value)))
#define LPTMR_BWR_CSR_TCF(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define LPTMR_RD_PSR(base)       (LPTMR_PSR_REG(base))
#define LPTMR_WR_PSR(base, value) (LPTMR_PSR_REG(base) = (value))
#define LPTMR_RMW_PSR(base, mask, value) (LPTMR_WR_PSR(base, (LPTMR_RD_PSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_PSR(base, value) (LPTMR_WR_PSR(base, LPTMR_RD_PSR(base) |  (value)))
#define LPTMR_CLR_PSR(base, value) (LPTMR_WR_PSR(base, LPTMR_RD_PSR(base) & ~(value)))
#define LPTMR_TOG_PSR(base, value) (LPTMR_WR_PSR(base, LPTMR_RD_PSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * The Prescaler Clock Select selects the clock to be used by the LPTMR
 * prescaler/glitch filter. The Prescaler Clock Select should only be altered when the
 * LPTMR is disabled. The clock connections vary by device. See the Chip
 * Configuration details for information on the connections to these inputs.
 *
 * Values:
 * - 00 - Prescaler/glitch filter clock 0 selected
 * - 01 - Prescaler/glitch filter clock 1 selected
 * - 10 - Prescaler/glitch filter clock 2 selected
 * - 11 - Prescaler/glitch filter clock 3 selected
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define LPTMR_RD_PSR_PCS(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PCS_MASK) >> LPTMR_PSR_PCS_SHIFT)
#define LPTMR_BRD_PSR_PCS(base) (LPTMR_RD_PSR_PCS(base))

/*! @brief Set the PCS field to a new value. */
#define LPTMR_WR_PSR_PCS(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PCS_MASK, LPTMR_PSR_PCS(value)))
#define LPTMR_BWR_PSR_PCS(base, value) (LPTMR_WR_PSR_PCS(base, value))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When the Prescaler Bypass is set the selected prescaler clock (in Time
 * Counter mode) or selected input source (in Pulse Counter mode) directly clocks the
 * LPTMR Counter Register. When the Prescaler Bypass is clear, the LPTMR Counter
 * Register is clocked by the output of the prescaler/glitch filter. The Prescaler
 * Bypass should only be altered when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Prescaler/Glitch Filter is enabled.
 * - 1 - Prescaler/Glitch Filter is bypassed.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define LPTMR_RD_PSR_PBYP(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PBYP_MASK) >> LPTMR_PSR_PBYP_SHIFT)
#define LPTMR_BRD_PSR_PBYP(base) (BITBAND_ACCESS32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT))

/*! @brief Set the PBYP field to a new value. */
#define LPTMR_WR_PSR_PBYP(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PBYP_MASK, LPTMR_PSR_PBYP(value)))
#define LPTMR_BWR_PSR_PBYP(base, value) (BITBAND_ACCESS32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * The Prescaler Value register field configures the size of the Prescaler (in
 * Time Counter mode) or width of the Glitch Filter (in Pulse Counter mode). The
 * Prescale Value should only be altered when the LPTMR is disabled.
 *
 * Values:
 * - 0000 - Prescaler divides the prescaler clock by 2; Glitch Filter does not
 *     support this configuration.
 * - 0001 - Prescaler divides the prescaler clock by 4; Glitch Filter recognizes
 *     change on input pin after 2 rising clock edges.
 * - 0010 - Prescaler divides the prescaler clock by 8; Glitch Filter recognizes
 *     change on input pin after 4 rising clock edges.
 * - 0011 - Prescaler divides the prescaler clock by 16; Glitch Filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0100 - Prescaler divides the prescaler clock by 32; Glitch Filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0101 - Prescaler divides the prescaler clock by 64; Glitch Filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0110 - Prescaler divides the prescaler clock by 128; Glitch Filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0111 - Prescaler divides the prescaler clock by 256; Glitch Filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 1000 - Prescaler divides the prescaler clock by 512; Glitch Filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 1001 - Prescaler divides the prescaler clock by 1024; Glitch Filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 1010 - Prescaler divides the prescaler clock by 2048; Glitch Filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 1011 - Prescaler divides the prescaler clock by 4096; Glitch Filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 1100 - Prescaler divides the prescaler clock by 8192; Glitch Filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 1101 - Prescaler divides the prescaler clock by 16384; Glitch Filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 1110 - Prescaler divides the prescaler clock by 32768; Glitch Filter
 *     recognizes change on input pin after 16384 rising clock edges.
 * - 1111 - Prescaler divides the prescaler clock by 65536; Glitch Filter
 *     recognizes change on input pin after 32768 rising clock edges.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define LPTMR_RD_PSR_PRESCALE(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PRESCALE_MASK) >> LPTMR_PSR_PRESCALE_SHIFT)
#define LPTMR_BRD_PSR_PRESCALE(base) (LPTMR_RD_PSR_PRESCALE(base))

/*! @brief Set the PRESCALE field to a new value. */
#define LPTMR_WR_PSR_PRESCALE(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PRESCALE_MASK, LPTMR_PSR_PRESCALE(value)))
#define LPTMR_BWR_PSR_PRESCALE(base, value) (LPTMR_WR_PSR_PRESCALE(base, value))
/*@}*/

/*******************************************************************************
 * LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define LPTMR_RD_CMR(base)       (LPTMR_CMR_REG(base))
#define LPTMR_WR_CMR(base, value) (LPTMR_CMR_REG(base) = (value))
#define LPTMR_RMW_CMR(base, mask, value) (LPTMR_WR_CMR(base, (LPTMR_RD_CMR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CMR(base, value) (LPTMR_WR_CMR(base, LPTMR_RD_CMR(base) |  (value)))
#define LPTMR_CLR_CMR(base, value) (LPTMR_WR_CMR(base, LPTMR_RD_CMR(base) & ~(value)))
#define LPTMR_TOG_CMR(base, value) (LPTMR_WR_CMR(base, LPTMR_RD_CMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the LPTMR Counter Register equals the value in
 * the LPTMR Compare Register and increments, the Timer Compare Flag is set and
 * the Hardware Trigger asserts until the next time the LPTMR Counter Register
 * increments. If the LPTMR Compare Register is zero, the Hardware Trigger will
 * remain asserted until the LPTMR is disabled. If the LPTMR is enabled, the LPTMR
 * Compare Register should only be altered when the Timer Compare Flag is set.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define LPTMR_RD_CMR_COMPARE(base) ((LPTMR_CMR_REG(base) & LPTMR_CMR_COMPARE_MASK) >> LPTMR_CMR_COMPARE_SHIFT)
#define LPTMR_BRD_CMR_COMPARE(base) (LPTMR_RD_CMR_COMPARE(base))

/*! @brief Set the COMPARE field to a new value. */
#define LPTMR_WR_CMR_COMPARE(base, value) (LPTMR_RMW_CMR(base, LPTMR_CMR_COMPARE_MASK, LPTMR_CMR_COMPARE(value)))
#define LPTMR_BWR_CMR_COMPARE(base, value) (LPTMR_WR_CMR_COMPARE(base, value))
/*@}*/

/*******************************************************************************
 * LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CNR - Low Power Timer Counter Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define LPTMR_RD_CNR(base)       (LPTMR_CNR_REG(base))
#define LPTMR_WR_CNR(base, value) (LPTMR_CNR_REG(base) = (value))
#define LPTMR_RMW_CNR(base, mask, value) (LPTMR_WR_CNR(base, (LPTMR_RD_CNR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CNR(base, value) (LPTMR_WR_CNR(base, LPTMR_RD_CNR(base) |  (value)))
#define LPTMR_CLR_CNR(base, value) (LPTMR_WR_CNR(base, LPTMR_RD_CNR(base) & ~(value)))
#define LPTMR_TOG_CNR(base, value) (LPTMR_WR_CNR(base, LPTMR_RD_CNR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define LPTMR_RD_CNR_COUNTER(base) ((LPTMR_CNR_REG(base) & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT)
#define LPTMR_BRD_CNR_COUNTER(base) (LPTMR_RD_CNR_COUNTER(base))

/*! @brief Set the COUNTER field to a new value. */
#define LPTMR_WR_CNR_COUNTER(base, value) (LPTMR_RMW_CNR(base, LPTMR_CNR_COUNTER_MASK, LPTMR_CNR_COUNTER(value)))
#define LPTMR_BWR_CNR_COUNTER(base, value) (LPTMR_WR_CNR_COUNTER(base, value))
/*@}*/

/*
 * MK20D5 MCG
 *
 * Multipurpose Clock Generator module
 *
 * Registers defined in this header file:
 * - MCG_C1 - MCG Control 1 Register
 * - MCG_C2 - MCG Control 2 Register
 * - MCG_C3 - MCG Control 3 Register
 * - MCG_C4 - MCG Control 4 Register
 * - MCG_C5 - MCG Control 5 Register
 * - MCG_C6 - MCG Control 6 Register
 * - MCG_S - MCG Status Register
 * - MCG_SC - MCG Status and Control Register
 * - MCG_ATCVH - MCG Auto Trim Compare Value High Register
 * - MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 * - MCG_C7 - MCG Control 7 Register
 * - MCG_C8 - MCG Control 8 Register
 */

#define MCG_INSTANCE_COUNT (1U) /*!< Number of instances of the MCG module. */
#define MCG_IDX (0U) /*!< Instance number for MCG. */

/*******************************************************************************
 * MCG_C1 - MCG Control 1 Register
 ******************************************************************************/

/*!
 * @brief MCG_C1 - MCG Control 1 Register (RW)
 *
 * Reset value: 0x04U
 */
/*!
 * @name Constants and macros for entire MCG_C1 register
 */
/*@{*/
#define MCG_RD_C1(base)          (MCG_C1_REG(base))
#define MCG_WR_C1(base, value)   (MCG_C1_REG(base) = (value))
#define MCG_RMW_C1(base, mask, value) (MCG_WR_C1(base, (MCG_RD_C1(base) & ~(mask)) | (value)))
#define MCG_SET_C1(base, value)  (MCG_WR_C1(base, MCG_RD_C1(base) |  (value)))
#define MCG_CLR_C1(base, value)  (MCG_WR_C1(base, MCG_RD_C1(base) & ~(value)))
#define MCG_TOG_C1(base, value)  (MCG_WR_C1(base, MCG_RD_C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C1 bitfields
 */

/*!
 * @name Register MCG_C1, field IREFSTEN[0] (RW)
 *
 * Controls whether or not the internal reference clock remains enabled when the
 * MCG enters Stop mode.
 *
 * Values:
 * - 0 - Internal reference clock is disabled in Stop mode.
 * - 1 - Internal reference clock is enabled in Stop mode if IRCLKEN is set or
 *     if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFSTEN field. */
#define MCG_RD_C1_IREFSTEN(base) ((MCG_C1_REG(base) & MCG_C1_IREFSTEN_MASK) >> MCG_C1_IREFSTEN_SHIFT)
#define MCG_BRD_C1_IREFSTEN(base) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IREFSTEN_SHIFT))

/*! @brief Set the IREFSTEN field to a new value. */
#define MCG_WR_C1_IREFSTEN(base, value) (MCG_RMW_C1(base, MCG_C1_IREFSTEN_MASK, MCG_C1_IREFSTEN(value)))
#define MCG_BWR_C1_IREFSTEN(base, value) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IREFSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C1, field IRCLKEN[1] (RW)
 *
 * Enables the internal reference clock for use as MCGIRCLK.
 *
 * Values:
 * - 0 - MCGIRCLK inactive.
 * - 1 - MCGIRCLK active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IRCLKEN field. */
#define MCG_RD_C1_IRCLKEN(base) ((MCG_C1_REG(base) & MCG_C1_IRCLKEN_MASK) >> MCG_C1_IRCLKEN_SHIFT)
#define MCG_BRD_C1_IRCLKEN(base) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IRCLKEN_SHIFT))

/*! @brief Set the IRCLKEN field to a new value. */
#define MCG_WR_C1_IRCLKEN(base, value) (MCG_RMW_C1(base, MCG_C1_IRCLKEN_MASK, MCG_C1_IRCLKEN(value)))
#define MCG_BWR_C1_IRCLKEN(base, value) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IRCLKEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C1, field IREFS[2] (RW)
 *
 * Selects the reference clock source for the FLL.
 *
 * Values:
 * - 0 - External reference clock is selected.
 * - 1 - The slow internal reference clock is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFS field. */
#define MCG_RD_C1_IREFS(base) ((MCG_C1_REG(base) & MCG_C1_IREFS_MASK) >> MCG_C1_IREFS_SHIFT)
#define MCG_BRD_C1_IREFS(base) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IREFS_SHIFT))

/*! @brief Set the IREFS field to a new value. */
#define MCG_WR_C1_IREFS(base, value) (MCG_RMW_C1(base, MCG_C1_IREFS_MASK, MCG_C1_IREFS(value)))
#define MCG_BWR_C1_IREFS(base, value) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IREFS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C1, field FRDIV[5:3] (RW)
 *
 * Selects the amount to divide down the external reference clock for the FLL.
 * The resulting frequency must be in the range 31.25 kHz to 39.0625 kHz (This is
 * required when FLL/DCO is the clock source for MCGOUTCLK . In FBE mode, it is
 * not required to meet this range, but it is recommended in the cases when trying
 * to enter a FLL mode from FBE).
 *
 * Values:
 * - 000 - If RANGE 0 = 0 or OSCSEL=1 , Divide Factor is 1; for all other RANGE
 *     0 values, Divide Factor is 32.
 * - 001 - If RANGE 0 = 0 or OSCSEL=1 , Divide Factor is 2; for all other RANGE
 *     0 values, Divide Factor is 64.
 * - 010 - If RANGE 0 = 0 or OSCSEL=1 , Divide Factor is 4; for all other RANGE
 *     0 values, Divide Factor is 128.
 * - 011 - If RANGE 0 = 0 or OSCSEL=1 , Divide Factor is 8; for all other RANGE
 *     0 values, Divide Factor is 256.
 * - 100 - If RANGE 0 = 0 or OSCSEL=1 , Divide Factor is 16; for all other RANGE
 *     0 values, Divide Factor is 512.
 * - 101 - If RANGE 0 = 0 or OSCSEL=1 , Divide Factor is 32; for all other RANGE
 *     0 values, Divide Factor is 1024.
 * - 110 - If RANGE 0 = 0 or OSCSEL=1 , Divide Factor is 64; for all other RANGE
 *     0 values, Divide Factor is 1280 .
 * - 111 - If RANGE 0 = 0 or OSCSEL=1 , Divide Factor is 128; for all other
 *     RANGE 0 values, Divide Factor is 1536 .
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_FRDIV field. */
#define MCG_RD_C1_FRDIV(base) ((MCG_C1_REG(base) & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
#define MCG_BRD_C1_FRDIV(base) (MCG_RD_C1_FRDIV(base))

/*! @brief Set the FRDIV field to a new value. */
#define MCG_WR_C1_FRDIV(base, value) (MCG_RMW_C1(base, MCG_C1_FRDIV_MASK, MCG_C1_FRDIV(value)))
#define MCG_BWR_C1_FRDIV(base, value) (MCG_WR_C1_FRDIV(base, value))
/*@}*/

/*!
 * @name Register MCG_C1, field CLKS[7:6] (RW)
 *
 * Selects the clock source for MCGOUTCLK .
 *
 * Values:
 * - 00 - Encoding 0 - Output of FLL or PLL is selected (depends on PLLS control
 *     bit).
 * - 01 - Encoding 1 - Internal reference clock is selected.
 * - 10 - Encoding 2 - External reference clock is selected.
 * - 11 - Encoding 3 - Reserved, defaults to 00.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_CLKS field. */
#define MCG_RD_C1_CLKS(base) ((MCG_C1_REG(base) & MCG_C1_CLKS_MASK) >> MCG_C1_CLKS_SHIFT)
#define MCG_BRD_C1_CLKS(base) (MCG_RD_C1_CLKS(base))

/*! @brief Set the CLKS field to a new value. */
#define MCG_WR_C1_CLKS(base, value) (MCG_RMW_C1(base, MCG_C1_CLKS_MASK, MCG_C1_CLKS(value)))
#define MCG_BWR_C1_CLKS(base, value) (MCG_WR_C1_CLKS(base, value))
/*@}*/

/*******************************************************************************
 * MCG_C2 - MCG Control 2 Register
 ******************************************************************************/

/*!
 * @brief MCG_C2 - MCG Control 2 Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire MCG_C2 register
 */
/*@{*/
#define MCG_RD_C2(base)          (MCG_C2_REG(base))
#define MCG_WR_C2(base, value)   (MCG_C2_REG(base) = (value))
#define MCG_RMW_C2(base, mask, value) (MCG_WR_C2(base, (MCG_RD_C2(base) & ~(mask)) | (value)))
#define MCG_SET_C2(base, value)  (MCG_WR_C2(base, MCG_RD_C2(base) |  (value)))
#define MCG_CLR_C2(base, value)  (MCG_WR_C2(base, MCG_RD_C2(base) & ~(value)))
#define MCG_TOG_C2(base, value)  (MCG_WR_C2(base, MCG_RD_C2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C2 bitfields
 */

/*!
 * @name Register MCG_C2, field IRCS[0] (RW)
 *
 * Selects between the fast or slow internal reference clock source.
 *
 * Values:
 * - 0 - Slow internal reference clock selected.
 * - 1 - Fast internal reference clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_IRCS field. */
#define MCG_RD_C2_IRCS(base) ((MCG_C2_REG(base) & MCG_C2_IRCS_MASK) >> MCG_C2_IRCS_SHIFT)
#define MCG_BRD_C2_IRCS(base) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_IRCS_SHIFT))

/*! @brief Set the IRCS field to a new value. */
#define MCG_WR_C2_IRCS(base, value) (MCG_RMW_C2(base, MCG_C2_IRCS_MASK, MCG_C2_IRCS(value)))
#define MCG_BWR_C2_IRCS(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_IRCS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C2, field LP[1] (RW)
 *
 * Controls whether the FLL (or PLL) is disabled in BLPI and BLPE modes. In FBE
 * or PBE modes, setting this bit to 1 will transition the MCG into BLPE mode; in
 * FBI mode, setting this bit to 1 will transition the MCG into BLPI mode. In
 * any other MCG mode, LP bit has no affect.
 *
 * Values:
 * - 0 - FLL (or PLL) is not disabled in bypass modes.
 * - 1 - FLL (or PLL) is disabled in bypass modes (lower power)
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LP field. */
#define MCG_RD_C2_LP(base)   ((MCG_C2_REG(base) & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
#define MCG_BRD_C2_LP(base)  (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_LP_SHIFT))

/*! @brief Set the LP field to a new value. */
#define MCG_WR_C2_LP(base, value) (MCG_RMW_C2(base, MCG_C2_LP_MASK, MCG_C2_LP(value)))
#define MCG_BWR_C2_LP(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_LP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C2, field EREFS0[2] (RW)
 *
 * Selects the source for the external reference clock. Refer to the Oscillator
 * (OSC) chapter for more details.
 *
 * Values:
 * - 0 - External reference clock requested.
 * - 1 - Oscillator requested.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_EREFS0 field. */
#define MCG_RD_C2_EREFS0(base) ((MCG_C2_REG(base) & MCG_C2_EREFS0_MASK) >> MCG_C2_EREFS0_SHIFT)
#define MCG_BRD_C2_EREFS0(base) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_EREFS0_SHIFT))

/*! @brief Set the EREFS0 field to a new value. */
#define MCG_WR_C2_EREFS0(base, value) (MCG_RMW_C2(base, MCG_C2_EREFS0_MASK, MCG_C2_EREFS0(value)))
#define MCG_BWR_C2_EREFS0(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_EREFS0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C2, field HGO0[3] (RW)
 *
 * Controls the crystal oscillator mode of operation. Refer to the Oscillator
 * (OSC) chapter for more details.
 *
 * Values:
 * - 0 - Configure crystal oscillator for low-power operation.
 * - 1 - Configure crystal oscillator for high-gain operation.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_HGO0 field. */
#define MCG_RD_C2_HGO0(base) ((MCG_C2_REG(base) & MCG_C2_HGO0_MASK) >> MCG_C2_HGO0_SHIFT)
#define MCG_BRD_C2_HGO0(base) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_HGO0_SHIFT))

/*! @brief Set the HGO0 field to a new value. */
#define MCG_WR_C2_HGO0(base, value) (MCG_RMW_C2(base, MCG_C2_HGO0_MASK, MCG_C2_HGO0(value)))
#define MCG_BWR_C2_HGO0(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_HGO0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C2, field RANGE0[5:4] (RW)
 *
 * Selects the frequency range for the crystal oscillator or external clock
 * source. Refer to the Oscillator (OSC) chapter for more details and the device data
 * sheet for the frequency ranges used.
 *
 * Values:
 * - 00 - Encoding 0 - Low frequency range selected for the crystal oscillator .
 * - 01 - Encoding 1 - High frequency range selected for the crystal oscillator .
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_RANGE0 field. */
#define MCG_RD_C2_RANGE0(base) ((MCG_C2_REG(base) & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT)
#define MCG_BRD_C2_RANGE0(base) (MCG_RD_C2_RANGE0(base))

/*! @brief Set the RANGE0 field to a new value. */
#define MCG_WR_C2_RANGE0(base, value) (MCG_RMW_C2(base, MCG_C2_RANGE0_MASK, MCG_C2_RANGE0(value)))
#define MCG_BWR_C2_RANGE0(base, value) (MCG_WR_C2_RANGE0(base, value))
/*@}*/

/*!
 * @name Register MCG_C2, field LOCRE0[7] (RW)
 *
 * Determines if a interrupt or a reset request is made following a loss of OSC0
 * external reference clock. The LOCRE0 only has an affect when CME0 is set.
 *
 * Values:
 * - 0 - Interrupt request is generated on a loss of OSC0 external reference
 *     clock.
 * - 1 - Generate a reset request on a loss of OSC0 external reference clock
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LOCRE0 field. */
#define MCG_RD_C2_LOCRE0(base) ((MCG_C2_REG(base) & MCG_C2_LOCRE0_MASK) >> MCG_C2_LOCRE0_SHIFT)
#define MCG_BRD_C2_LOCRE0(base) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_LOCRE0_SHIFT))

/*! @brief Set the LOCRE0 field to a new value. */
#define MCG_WR_C2_LOCRE0(base, value) (MCG_RMW_C2(base, MCG_C2_LOCRE0_MASK, MCG_C2_LOCRE0(value)))
#define MCG_BWR_C2_LOCRE0(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_LOCRE0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_C3 - MCG Control 3 Register
 ******************************************************************************/

/*!
 * @brief MCG_C3 - MCG Control 3 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C3 register
 */
/*@{*/
#define MCG_RD_C3(base)          (MCG_C3_REG(base))
#define MCG_WR_C3(base, value)   (MCG_C3_REG(base) = (value))
#define MCG_RMW_C3(base, mask, value) (MCG_WR_C3(base, (MCG_RD_C3(base) & ~(mask)) | (value)))
#define MCG_SET_C3(base, value)  (MCG_WR_C3(base, MCG_RD_C3(base) |  (value)))
#define MCG_CLR_C3(base, value)  (MCG_WR_C3(base, MCG_RD_C3(base) & ~(value)))
#define MCG_TOG_C3(base, value)  (MCG_WR_C3(base, MCG_RD_C3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MCG_C4 - MCG Control 4 Register
 ******************************************************************************/

/*!
 * @brief MCG_C4 - MCG Control 4 Register (RW)
 *
 * Reset value: 0x00U
 *
 * Reset values for DRST and DMX32 bits are 0.
 */
/*!
 * @name Constants and macros for entire MCG_C4 register
 */
/*@{*/
#define MCG_RD_C4(base)          (MCG_C4_REG(base))
#define MCG_WR_C4(base, value)   (MCG_C4_REG(base) = (value))
#define MCG_RMW_C4(base, mask, value) (MCG_WR_C4(base, (MCG_RD_C4(base) & ~(mask)) | (value)))
#define MCG_SET_C4(base, value)  (MCG_WR_C4(base, MCG_RD_C4(base) |  (value)))
#define MCG_CLR_C4(base, value)  (MCG_WR_C4(base, MCG_RD_C4(base) & ~(value)))
#define MCG_TOG_C4(base, value)  (MCG_WR_C4(base, MCG_RD_C4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C4 bitfields
 */

/*!
 * @name Register MCG_C4, field SCFTRIM[0] (RW)
 *
 * SCFTRIM A value for SCFTRIM is loaded during reset from a factory programmed
 * location . controls the smallest adjustment of the slow internal reference
 * clock frequency. Setting SCFTRIM increases the period and clearing SCFTRIM
 * decreases the period by the smallest amount possible. If an SCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_SCFTRIM field. */
#define MCG_RD_C4_SCFTRIM(base) ((MCG_C4_REG(base) & MCG_C4_SCFTRIM_MASK) >> MCG_C4_SCFTRIM_SHIFT)
#define MCG_BRD_C4_SCFTRIM(base) (BITBAND_ACCESS8(&MCG_C4_REG(base), MCG_C4_SCFTRIM_SHIFT))

/*! @brief Set the SCFTRIM field to a new value. */
#define MCG_WR_C4_SCFTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_SCFTRIM_MASK, MCG_C4_SCFTRIM(value)))
#define MCG_BWR_C4_SCFTRIM(base, value) (BITBAND_ACCESS8(&MCG_C4_REG(base), MCG_C4_SCFTRIM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C4, field FCTRIM[4:1] (RW)
 *
 * FCTRIM A value for FCTRIM is loaded during reset from a factory programmed
 * location . controls the fast internal reference clock frequency by controlling
 * the fast internal reference clock period. The FCTRIM bits are binary weighted
 * (that is, bit 1 adjusts twice as much as bit 0). Increasing the binary value
 * increases the period, and decreasing the value decreases the period. If an
 * FCTRIM[3:0] value stored in nonvolatile memory is to be used, it is your
 * responsibility to copy that value from the nonvolatile memory location to this register.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_FCTRIM field. */
#define MCG_RD_C4_FCTRIM(base) ((MCG_C4_REG(base) & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT)
#define MCG_BRD_C4_FCTRIM(base) (MCG_RD_C4_FCTRIM(base))

/*! @brief Set the FCTRIM field to a new value. */
#define MCG_WR_C4_FCTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_FCTRIM_MASK, MCG_C4_FCTRIM(value)))
#define MCG_BWR_C4_FCTRIM(base, value) (MCG_WR_C4_FCTRIM(base, value))
/*@}*/

/*!
 * @name Register MCG_C4, field DRST_DRS[6:5] (RW)
 *
 * The DRS bits select the frequency range for the FLL output, DCOOUT. When the
 * LP bit is set, writes to the DRS bits are ignored. The DRST read field
 * indicates the current frequency range for DCOOUT. The DRST field does not update
 * immediately after a write to the DRS field due to internal synchronization between
 * clock domains. Refer to DCO Frequency Range table for more details.
 *
 * Values:
 * - 00 - Encoding 0 - Low range (reset default).
 * - 01 - Encoding 1 - Mid range.
 * - 10 - Encoding 2 - Mid-high range.
 * - 11 - Encoding 3 - High range.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DRST_DRS field. */
#define MCG_RD_C4_DRST_DRS(base) ((MCG_C4_REG(base) & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
#define MCG_BRD_C4_DRST_DRS(base) (MCG_RD_C4_DRST_DRS(base))

/*! @brief Set the DRST_DRS field to a new value. */
#define MCG_WR_C4_DRST_DRS(base, value) (MCG_RMW_C4(base, MCG_C4_DRST_DRS_MASK, MCG_C4_DRST_DRS(value)))
#define MCG_BWR_C4_DRST_DRS(base, value) (MCG_WR_C4_DRST_DRS(base, value))
/*@}*/

/*!
 * @name Register MCG_C4, field DMX32[7] (RW)
 *
 * The DMX32 bit controls whether or not the DCO frequency range is narrowed to
 * its maximum frequency with a 32.768 kHz reference. The following table
 * identifies settings for the DCO frequency range. The system clocks derived from this
 * source should not exceed their specified maximums. DRST_DRS DMX32 Reference
 * Range FLL Factor DCO Range 00 0 31.25-39.0625 kHz 640 20-25 MHz 1 32.768 kHz 732
 * 24 MHz 01 0 31.25-39.0625 kHz 1280 40-50 MHz 1 32.768 kHz 1464 48 MHz 10 0
 * 31.25-39.0625 kHz 1920 60-75 MHz 1 32.768 kHz 2197 72 MHz 11 0 31.25-39.0625 kHz
 * 2560 80-100 MHz 1 32.768 kHz 2929 96 MHz
 *
 * Values:
 * - 0 - DCO has a default range of 25%.
 * - 1 - DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DMX32 field. */
#define MCG_RD_C4_DMX32(base) ((MCG_C4_REG(base) & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
#define MCG_BRD_C4_DMX32(base) (BITBAND_ACCESS8(&MCG_C4_REG(base), MCG_C4_DMX32_SHIFT))

/*! @brief Set the DMX32 field to a new value. */
#define MCG_WR_C4_DMX32(base, value) (MCG_RMW_C4(base, MCG_C4_DMX32_MASK, MCG_C4_DMX32(value)))
#define MCG_BWR_C4_DMX32(base, value) (BITBAND_ACCESS8(&MCG_C4_REG(base), MCG_C4_DMX32_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_C5 - MCG Control 5 Register
 ******************************************************************************/

/*!
 * @brief MCG_C5 - MCG Control 5 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C5 register
 */
/*@{*/
#define MCG_RD_C5(base)          (MCG_C5_REG(base))
#define MCG_WR_C5(base, value)   (MCG_C5_REG(base) = (value))
#define MCG_RMW_C5(base, mask, value) (MCG_WR_C5(base, (MCG_RD_C5(base) & ~(mask)) | (value)))
#define MCG_SET_C5(base, value)  (MCG_WR_C5(base, MCG_RD_C5(base) |  (value)))
#define MCG_CLR_C5(base, value)  (MCG_WR_C5(base, MCG_RD_C5(base) & ~(value)))
#define MCG_TOG_C5(base, value)  (MCG_WR_C5(base, MCG_RD_C5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C5 bitfields
 */

/*!
 * @name Register MCG_C5, field PRDIV0[4:0] (RW)
 *
 * Selects the amount to divide down the external reference clock for the PLL.
 * The resulting frequency must be in the range of 2 MHz to 4 MHz. After the PLL
 * is enabled (by setting either PLLCLKEN0 or PLLS), the PRDIV0 value must not be
 * changed when LOCK0 is zero. PLL External Reference Divide Factor PRDIV 0
 * Divide Factor PRDIV 0 Divide Factor PRDIV 0 Divide Factor PRDIV 0 Divide Factor
 * 00000 1 01000 9 10000 17 11000 25 00001 2 01001 10 10001 18 11001 Reserved 00010
 * 3 01010 11 10010 19 11010 Reserved 00011 4 01011 12 10011 20 11011 Reserved
 * 00100 5 01100 13 10100 21 11100 Reserved 00101 6 01101 14 10101 22 11101
 * Reserved 00110 7 01110 15 10110 23 11110 Reserved 00111 8 01111 16 10111 24 11111
 * Reserved
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PRDIV0 field. */
#define MCG_RD_C5_PRDIV0(base) ((MCG_C5_REG(base) & MCG_C5_PRDIV0_MASK) >> MCG_C5_PRDIV0_SHIFT)
#define MCG_BRD_C5_PRDIV0(base) (MCG_RD_C5_PRDIV0(base))

/*! @brief Set the PRDIV0 field to a new value. */
#define MCG_WR_C5_PRDIV0(base, value) (MCG_RMW_C5(base, MCG_C5_PRDIV0_MASK, MCG_C5_PRDIV0(value)))
#define MCG_BWR_C5_PRDIV0(base, value) (MCG_WR_C5_PRDIV0(base, value))
/*@}*/

/*!
 * @name Register MCG_C5, field PLLSTEN0[5] (RW)
 *
 * Enables the PLL Clock during Normal Stop (In Low Power Stop mode, the PLL
 * clock gets disabled even if PLLSTEN 0 =1). All other power modes, PLLSTEN 0 bit
 * has no affect and does not enable the PLL Clock to run if it is written to 1.
 *
 * Values:
 * - 0 - MCGPLLCLK is disabled in any of the Stop modes.
 * - 1 - MCGPLLCLK is enabled if system is in Normal Stop mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PLLSTEN0 field. */
#define MCG_RD_C5_PLLSTEN0(base) ((MCG_C5_REG(base) & MCG_C5_PLLSTEN0_MASK) >> MCG_C5_PLLSTEN0_SHIFT)
#define MCG_BRD_C5_PLLSTEN0(base) (BITBAND_ACCESS8(&MCG_C5_REG(base), MCG_C5_PLLSTEN0_SHIFT))

/*! @brief Set the PLLSTEN0 field to a new value. */
#define MCG_WR_C5_PLLSTEN0(base, value) (MCG_RMW_C5(base, MCG_C5_PLLSTEN0_MASK, MCG_C5_PLLSTEN0(value)))
#define MCG_BWR_C5_PLLSTEN0(base, value) (BITBAND_ACCESS8(&MCG_C5_REG(base), MCG_C5_PLLSTEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C5, field PLLCLKEN0[6] (RW)
 *
 * Enables the PLL independent of PLLS and enables the PLL clock for use as
 * MCGPLLCLK. (PRDIV 0 needs to be programmed to the correct divider to generate a
 * PLL reference clock in the range of 2 - 4 MHz range prior to setting the
 * PLLCLKEN 0 bit). Setting PLLCLKEN 0 will enable the external oscillator if not
 * already enabled. Whenever the PLL is being enabled by means of the PLLCLKEN 0 bit,
 * and the external oscillator is being used as the reference clock, the OSCINIT 0
 * bit should be checked to make sure it is set.
 *
 * Values:
 * - 0 - MCGPLLCLK is inactive.
 * - 1 - MCGPLLCLK is active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PLLCLKEN0 field. */
#define MCG_RD_C5_PLLCLKEN0(base) ((MCG_C5_REG(base) & MCG_C5_PLLCLKEN0_MASK) >> MCG_C5_PLLCLKEN0_SHIFT)
#define MCG_BRD_C5_PLLCLKEN0(base) (BITBAND_ACCESS8(&MCG_C5_REG(base), MCG_C5_PLLCLKEN0_SHIFT))

/*! @brief Set the PLLCLKEN0 field to a new value. */
#define MCG_WR_C5_PLLCLKEN0(base, value) (MCG_RMW_C5(base, MCG_C5_PLLCLKEN0_MASK, MCG_C5_PLLCLKEN0(value)))
#define MCG_BWR_C5_PLLCLKEN0(base, value) (BITBAND_ACCESS8(&MCG_C5_REG(base), MCG_C5_PLLCLKEN0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_C6 - MCG Control 6 Register
 ******************************************************************************/

/*!
 * @brief MCG_C6 - MCG Control 6 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C6 register
 */
/*@{*/
#define MCG_RD_C6(base)          (MCG_C6_REG(base))
#define MCG_WR_C6(base, value)   (MCG_C6_REG(base) = (value))
#define MCG_RMW_C6(base, mask, value) (MCG_WR_C6(base, (MCG_RD_C6(base) & ~(mask)) | (value)))
#define MCG_SET_C6(base, value)  (MCG_WR_C6(base, MCG_RD_C6(base) |  (value)))
#define MCG_CLR_C6(base, value)  (MCG_WR_C6(base, MCG_RD_C6(base) & ~(value)))
#define MCG_TOG_C6(base, value)  (MCG_WR_C6(base, MCG_RD_C6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C6 bitfields
 */

/*!
 * @name Register MCG_C6, field VDIV0[4:0] (RW)
 *
 * Selects the amount to divide the VCO output of the PLL. The VDIV 0 bits
 * establish the multiplication factor (M) applied to the reference clock frequency.
 * After the PLL is enabled (by setting either PLLCLKEN 0 or PLLS), the VDIV 0
 * value must not be changed when LOCK 0 is zero. PLL VCO Divide Factor VDIV 0
 * Multiply Factor VDIV 0 Multiply Factor VDIV 0 Multiply Factor VDIV 0 Multiply
 * Factor 00000 24 01000 32 10000 40 11000 48 00001 25 01001 33 10001 41 11001 49
 * 00010 26 01010 34 10010 42 11010 50 00011 27 01011 35 10011 43 11011 51 00100 28
 * 01100 36 10100 44 11100 52 00101 29 01101 37 10101 45 11101 53 00110 30 01110
 * 38 10110 46 11110 54 00111 31 01111 39 10111 47 11111 55
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_VDIV0 field. */
#define MCG_RD_C6_VDIV0(base) ((MCG_C6_REG(base) & MCG_C6_VDIV0_MASK) >> MCG_C6_VDIV0_SHIFT)
#define MCG_BRD_C6_VDIV0(base) (MCG_RD_C6_VDIV0(base))

/*! @brief Set the VDIV0 field to a new value. */
#define MCG_WR_C6_VDIV0(base, value) (MCG_RMW_C6(base, MCG_C6_VDIV0_MASK, MCG_C6_VDIV0(value)))
#define MCG_BWR_C6_VDIV0(base, value) (MCG_WR_C6_VDIV0(base, value))
/*@}*/

/*!
 * @name Register MCG_C6, field CME0[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the OSC0 external reference
 * mux select. The LOCRE0 bit will determine if a interrupt or a reset request is
 * generated following a loss of OSC0 indication. The CME0 bit should only be
 * set to a logic 1 when the MCG is in an operational mode that uses the external
 * clock (FEE, FBE, PEE, PBE, or BLPE) . Whenever the CME0 bit is set to a logic
 * 1, the value of the RANGE0 bits in the C2 register should not be changed. CME0
 * bit should be set to a logic 0 before the MCG enters any Stop mode. Otherwise,
 * a reset request may occur while in Stop mode. CME0 should also be set to a
 * logic 0 before entering VLPR or VLPW power modes if the MCG is in BLPE mode.
 *
 * Values:
 * - 0 - External clock monitor is disabled for OSC0.
 * - 1 - External clock monitor is enabled for OSC0.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_CME0 field. */
#define MCG_RD_C6_CME0(base) ((MCG_C6_REG(base) & MCG_C6_CME0_MASK) >> MCG_C6_CME0_SHIFT)
#define MCG_BRD_C6_CME0(base) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_CME0_SHIFT))

/*! @brief Set the CME0 field to a new value. */
#define MCG_WR_C6_CME0(base, value) (MCG_RMW_C6(base, MCG_C6_CME0_MASK, MCG_C6_CME0(value)))
#define MCG_BWR_C6_CME0(base, value) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_CME0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C6, field PLLS[6] (RW)
 *
 * Controls whether the PLL or FLL output is selected as the MCG source when
 * CLKS[1:0]=00. If the PLLS bit is cleared and PLLCLKEN 0 is not set, the PLL is
 * disabled in all modes. If the PLLS is set, the FLL is disabled in all modes.
 *
 * Values:
 * - 0 - FLL is selected.
 * - 1 - PLL is selected (PRDIV 0 need to be programmed to the correct divider
 *     to generate a PLL reference clock in the range of 2 - 4 MHz prior to
 *     setting the PLLS bit).
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_PLLS field. */
#define MCG_RD_C6_PLLS(base) ((MCG_C6_REG(base) & MCG_C6_PLLS_MASK) >> MCG_C6_PLLS_SHIFT)
#define MCG_BRD_C6_PLLS(base) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_PLLS_SHIFT))

/*! @brief Set the PLLS field to a new value. */
#define MCG_WR_C6_PLLS(base, value) (MCG_RMW_C6(base, MCG_C6_PLLS_MASK, MCG_C6_PLLS(value)))
#define MCG_BWR_C6_PLLS(base, value) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_PLLS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C6, field LOLIE0[7] (RW)
 *
 * Determines if an interrupt request is made following a loss of lock
 * indication. This bit only has an effect when LOLS 0 is set.
 *
 * Values:
 * - 0 - No interrupt request is generated on loss of lock.
 * - 1 - Generate an interrupt request on loss of lock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_LOLIE0 field. */
#define MCG_RD_C6_LOLIE0(base) ((MCG_C6_REG(base) & MCG_C6_LOLIE0_MASK) >> MCG_C6_LOLIE0_SHIFT)
#define MCG_BRD_C6_LOLIE0(base) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_LOLIE0_SHIFT))

/*! @brief Set the LOLIE0 field to a new value. */
#define MCG_WR_C6_LOLIE0(base, value) (MCG_RMW_C6(base, MCG_C6_LOLIE0_MASK, MCG_C6_LOLIE0(value)))
#define MCG_BWR_C6_LOLIE0(base, value) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_LOLIE0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_S - MCG Status Register
 ******************************************************************************/

/*!
 * @brief MCG_S - MCG Status Register (RW)
 *
 * Reset value: 0x10U
 */
/*!
 * @name Constants and macros for entire MCG_S register
 */
/*@{*/
#define MCG_RD_S(base)           (MCG_S_REG(base))
#define MCG_WR_S(base, value)    (MCG_S_REG(base) = (value))
#define MCG_RMW_S(base, mask, value) (MCG_WR_S(base, (MCG_RD_S(base) & ~(mask)) | (value)))
#define MCG_SET_S(base, value)   (MCG_WR_S(base, MCG_RD_S(base) |  (value)))
#define MCG_CLR_S(base, value)   (MCG_WR_S(base, MCG_RD_S(base) & ~(value)))
#define MCG_TOG_S(base, value)   (MCG_WR_S(base, MCG_RD_S(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_S bitfields
 */

/*!
 * @name Register MCG_S, field IRCST[0] (RO)
 *
 * The IRCST bit indicates the current source for the internal reference clock
 * select clock (IRCSCLK). The IRCST bit does not update immediately after a write
 * to the IRCS bit due to internal synchronization between clock domains. The
 * IRCST bit will only be updated if the internal reference clock is enabled,
 * either by the MCG being in a mode that uses the IRC or by setting the C1[IRCLKEN]
 * bit .
 *
 * Values:
 * - 0 - Source of internal reference clock is the slow clock (32 kHz IRC).
 * - 1 - Source of internal reference clock is the fast clock (2 MHz IRC).
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IRCST field. */
#define MCG_RD_S_IRCST(base) ((MCG_S_REG(base) & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
#define MCG_BRD_S_IRCST(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_IRCST_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field OSCINIT0[1] (RO)
 *
 * This bit, which resets to 0, is set to 1 after the initialization cycles of
 * the crystal oscillator clock have completed. After being set, the bit is
 * cleared to 0 if the OSC is subsequently disabled. Refer to the OSC module's detailed
 * description for more information.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_OSCINIT0 field. */
#define MCG_RD_S_OSCINIT0(base) ((MCG_S_REG(base) & MCG_S_OSCINIT0_MASK) >> MCG_S_OSCINIT0_SHIFT)
#define MCG_BRD_S_OSCINIT0(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_OSCINIT0_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field CLKST[3:2] (RO)
 *
 * These bits indicate the current clock mode. The CLKST bits do not update
 * immediately after a write to the CLKS bits due to internal synchronization between
 * clock domains.
 *
 * Values:
 * - 00 - Encoding 0 - Output of the FLL is selected (reset default).
 * - 01 - Encoding 1 - Internal reference clock is selected.
 * - 10 - Encoding 2 - External reference clock is selected.
 * - 11 - Encoding 3 - Output of the PLL is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_CLKST field. */
#define MCG_RD_S_CLKST(base) ((MCG_S_REG(base) & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
#define MCG_BRD_S_CLKST(base) (MCG_RD_S_CLKST(base))
/*@}*/

/*!
 * @name Register MCG_S, field IREFST[4] (RO)
 *
 * This bit indicates the current source for the FLL reference clock. The IREFST
 * bit does not update immediately after a write to the IREFS bit due to
 * internal synchronization between clock domains.
 *
 * Values:
 * - 0 - Source of FLL reference clock is the external reference clock.
 * - 1 - Source of FLL reference clock is the internal reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IREFST field. */
#define MCG_RD_S_IREFST(base) ((MCG_S_REG(base) & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
#define MCG_BRD_S_IREFST(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_IREFST_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field PLLST[5] (RO)
 *
 * This bit indicates the clock source selected by PLLS . The PLLST bit does not
 * update immediately after a write to the PLLS bit due to internal
 * synchronization between clock domains.
 *
 * Values:
 * - 0 - Source of PLLS clock is FLL clock.
 * - 1 - Source of PLLS clock is PLL clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_PLLST field. */
#define MCG_RD_S_PLLST(base) ((MCG_S_REG(base) & MCG_S_PLLST_MASK) >> MCG_S_PLLST_SHIFT)
#define MCG_BRD_S_PLLST(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_PLLST_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field LOCK0[6] (RO)
 *
 * This bit indicates whether the PLL has acquired lock. Lock detection is
 * disabled when not operating in either PBE or PEE mode unless PLLCLKEN 0 =1 and the
 * MCG is not configured in BLPI or BLPE mode. While the PLL clock is locking to
 * the desired frequency, the MCG PLL clock (MCGPLLCLK) will be gated off until
 * the LOCK 0 bit gets asserted. If the lock status bit is set, changing the value
 * of the PRDIV 0 [4:0] bits in the C5 register or the VDIV0[4:0] bits in the C6
 * register causes the lock status bit to clear and stay cleared until the PLL
 * has reacquired lock. Loss of PLL1 reference clock will also cause the LOCK 0
 * bit to clear until PLL1 has reacquired lock Entry into LLS, VLPS, or regular
 * Stop with PLLSTEN 0 =0 also causes the lock status bit to clear and stay cleared
 * until the Stop mode is exited and the PLL has reacquired lock. Any time the
 * PLL is enabled and the LOCK 0 bit is cleared, the MCGPLLCLK will be gated off
 * until the LOCK 0 bit is asserted again.
 *
 * Values:
 * - 0 - PLL is currently unlocked.
 * - 1 - PLL is currently locked.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_LOCK0 field. */
#define MCG_RD_S_LOCK0(base) ((MCG_S_REG(base) & MCG_S_LOCK0_MASK) >> MCG_S_LOCK0_SHIFT)
#define MCG_BRD_S_LOCK0(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_LOCK0_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field LOLS0[7] (W1C)
 *
 * This bit is a sticky bit indicating the lock status for the PLL. LOLS 0 is
 * set if after acquiring lock, the PLL output frequency has fallen outside the
 * lock exit frequency tolerance, D unl . LOLIE 0 determines whether an interrupt
 * request is made when LOLS 0 is set. LOLRE determines whether a reset request is
 * made when LOLS0 is set. This bit is cleared by reset or by writing a logic 1
 * to it when set. Writing a logic 0 to this bit has no effect.
 *
 * Values:
 * - 0 - PLL has not lost lock since LOLS 0 was last cleared.
 * - 1 - PLL has lost lock since LOLS 0 was last cleared.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_LOLS0 field. */
#define MCG_RD_S_LOLS0(base) ((MCG_S_REG(base) & MCG_S_LOLS0_MASK) >> MCG_S_LOLS0_SHIFT)
#define MCG_BRD_S_LOLS0(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_LOLS0_SHIFT))

/*! @brief Set the LOLS0 field to a new value. */
#define MCG_WR_S_LOLS0(base, value) (MCG_RMW_S(base, MCG_S_LOLS0_MASK, MCG_S_LOLS0(value)))
#define MCG_BWR_S_LOLS0(base, value) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_LOLS0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_SC - MCG Status and Control Register
 ******************************************************************************/

/*!
 * @brief MCG_SC - MCG Status and Control Register (RW)
 *
 * Reset value: 0x02U
 */
/*!
 * @name Constants and macros for entire MCG_SC register
 */
/*@{*/
#define MCG_RD_SC(base)          (MCG_SC_REG(base))
#define MCG_WR_SC(base, value)   (MCG_SC_REG(base) = (value))
#define MCG_RMW_SC(base, mask, value) (MCG_WR_SC(base, (MCG_RD_SC(base) & ~(mask)) | (value)))
#define MCG_SET_SC(base, value)  (MCG_WR_SC(base, MCG_RD_SC(base) |  (value)))
#define MCG_CLR_SC(base, value)  (MCG_WR_SC(base, MCG_RD_SC(base) & ~(value)))
#define MCG_TOG_SC(base, value)  (MCG_WR_SC(base, MCG_RD_SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_SC bitfields
 */

/*!
 * @name Register MCG_SC, field LOCS0[0] (W1C)
 *
 * The LOCS0 indicates when a loss of OSC0 reference clock has occurred. The
 * LOCS0 bit only has an effect when CME0 is set. This bit is cleared by writing a
 * logic 1 to it when set.
 *
 * Values:
 * - 0 - Loss of OSC0 has not occurred.
 * - 1 - Loss of OSC0 has occurred.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_LOCS0 field. */
#define MCG_RD_SC_LOCS0(base) ((MCG_SC_REG(base) & MCG_SC_LOCS0_MASK) >> MCG_SC_LOCS0_SHIFT)
#define MCG_BRD_SC_LOCS0(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_LOCS0_SHIFT))

/*! @brief Set the LOCS0 field to a new value. */
#define MCG_WR_SC_LOCS0(base, value) (MCG_RMW_SC(base, MCG_SC_LOCS0_MASK, MCG_SC_LOCS0(value)))
#define MCG_BWR_SC_LOCS0(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_LOCS0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_SC, field FCRDIV[3:1] (RW)
 *
 * Selects the amount to divide down the fast internal reference clock. The
 * resulting frequency will be in the range 31.25 kHz to 4 MHz (Note: Changing the
 * divider when the Fast IRC is enabled is not supported).
 *
 * Values:
 * - 000 - Divide Factor is 1
 * - 001 - Divide Factor is 2.
 * - 010 - Divide Factor is 4.
 * - 011 - Divide Factor is 8.
 * - 100 - Divide Factor is 16
 * - 101 - Divide Factor is 32
 * - 110 - Divide Factor is 64
 * - 111 - Divide Factor is 128.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FCRDIV field. */
#define MCG_RD_SC_FCRDIV(base) ((MCG_SC_REG(base) & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
#define MCG_BRD_SC_FCRDIV(base) (MCG_RD_SC_FCRDIV(base))

/*! @brief Set the FCRDIV field to a new value. */
#define MCG_WR_SC_FCRDIV(base, value) (MCG_RMW_SC(base, (MCG_SC_FCRDIV_MASK | MCG_SC_LOCS0_MASK), MCG_SC_FCRDIV(value)))
#define MCG_BWR_SC_FCRDIV(base, value) (MCG_WR_SC_FCRDIV(base, value))
/*@}*/

/*!
 * @name Register MCG_SC, field FLTPRSRV[4] (RW)
 *
 * This bit will prevent the FLL filter values from resetting allowing the FLL
 * output frequency to remain the same during clock mode changes where the FLL/DCO
 * output is still valid. (Note: This requires that the FLL reference frequency
 * to remain the same as what it was prior to the new clock mode switch.
 * Otherwise FLL filter and frequency values will change.)
 *
 * Values:
 * - 0 - FLL filter and FLL frequency will reset on changes to currect clock
 *     mode.
 * - 1 - Fll filter and FLL frequency retain their previous values during new
 *     clock mode change.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FLTPRSRV field. */
#define MCG_RD_SC_FLTPRSRV(base) ((MCG_SC_REG(base) & MCG_SC_FLTPRSRV_MASK) >> MCG_SC_FLTPRSRV_SHIFT)
#define MCG_BRD_SC_FLTPRSRV(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_FLTPRSRV_SHIFT))

/*! @brief Set the FLTPRSRV field to a new value. */
#define MCG_WR_SC_FLTPRSRV(base, value) (MCG_RMW_SC(base, (MCG_SC_FLTPRSRV_MASK | MCG_SC_LOCS0_MASK), MCG_SC_FLTPRSRV(value)))
#define MCG_BWR_SC_FLTPRSRV(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_FLTPRSRV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMF[5] (RW)
 *
 * Fail flag for the Automatic Trim Machine (ATM). This bit asserts when the
 * Automatic Trim Machine is enabled (ATME=1) and a write to the C1, C3, C4, and SC
 * registers is detected or the MCG enters into any Stop mode. A write to ATMF
 * clears the flag.
 *
 * Values:
 * - 0 - Automatic Trim Machine completed normally.
 * - 1 - Automatic Trim Machine failed.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMF field. */
#define MCG_RD_SC_ATMF(base) ((MCG_SC_REG(base) & MCG_SC_ATMF_MASK) >> MCG_SC_ATMF_SHIFT)
#define MCG_BRD_SC_ATMF(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATMF_SHIFT))

/*! @brief Set the ATMF field to a new value. */
#define MCG_WR_SC_ATMF(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK), MCG_SC_ATMF(value)))
#define MCG_BWR_SC_ATMF(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATMF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMS[6] (RW)
 *
 * Selects the IRCS clock for Auto Trim Test.
 *
 * Values:
 * - 0 - 32 kHz Internal Reference Clock selected.
 * - 1 - 4 MHz Internal Reference Clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMS field. */
#define MCG_RD_SC_ATMS(base) ((MCG_SC_REG(base) & MCG_SC_ATMS_MASK) >> MCG_SC_ATMS_SHIFT)
#define MCG_BRD_SC_ATMS(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATMS_SHIFT))

/*! @brief Set the ATMS field to a new value. */
#define MCG_WR_SC_ATMS(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK), MCG_SC_ATMS(value)))
#define MCG_BWR_SC_ATMS(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATMS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_SC, field ATME[7] (RW)
 *
 * Enables the Auto Trim Machine to start automatically trimming the selected
 * Internal Reference Clock. ATME deasserts after the Auto Trim Machine has
 * completed trimming all trim bits of the IRCS clock selected by the ATMS bit. Writing
 * to C1, C3, C4, and SC registers or entering Stop mode aborts the auto trim
 * operation and clears this bit.
 *
 * Values:
 * - 0 - Auto Trim Machine disabled.
 * - 1 - Auto Trim Machine enabled.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATME field. */
#define MCG_RD_SC_ATME(base) ((MCG_SC_REG(base) & MCG_SC_ATME_MASK) >> MCG_SC_ATME_SHIFT)
#define MCG_BRD_SC_ATME(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATME_SHIFT))

/*! @brief Set the ATME field to a new value. */
#define MCG_WR_SC_ATME(base, value) (MCG_RMW_SC(base, (MCG_SC_ATME_MASK | MCG_SC_LOCS0_MASK), MCG_SC_ATME(value)))
#define MCG_BWR_SC_ATME(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATME_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_ATCVH - MCG Auto Trim Compare Value High Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVH - MCG Auto Trim Compare Value High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVH register
 */
/*@{*/
#define MCG_RD_ATCVH(base)       (MCG_ATCVH_REG(base))
#define MCG_WR_ATCVH(base, value) (MCG_ATCVH_REG(base) = (value))
#define MCG_RMW_ATCVH(base, mask, value) (MCG_WR_ATCVH(base, (MCG_RD_ATCVH(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVH(base, value) (MCG_WR_ATCVH(base, MCG_RD_ATCVH(base) |  (value)))
#define MCG_CLR_ATCVH(base, value) (MCG_WR_ATCVH(base, MCG_RD_ATCVH(base) & ~(value)))
#define MCG_TOG_ATCVH(base, value) (MCG_WR_ATCVH(base, MCG_RD_ATCVH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVL - MCG Auto Trim Compare Value Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVL register
 */
/*@{*/
#define MCG_RD_ATCVL(base)       (MCG_ATCVL_REG(base))
#define MCG_WR_ATCVL(base, value) (MCG_ATCVL_REG(base) = (value))
#define MCG_RMW_ATCVL(base, mask, value) (MCG_WR_ATCVL(base, (MCG_RD_ATCVL(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVL(base, value) (MCG_WR_ATCVL(base, MCG_RD_ATCVL(base) |  (value)))
#define MCG_CLR_ATCVL(base, value) (MCG_WR_ATCVL(base, MCG_RD_ATCVL(base) & ~(value)))
#define MCG_TOG_ATCVL(base, value) (MCG_WR_ATCVL(base, MCG_RD_ATCVL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MCG_C7 - MCG Control 7 Register
 ******************************************************************************/

/*!
 * @brief MCG_C7 - MCG Control 7 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C7 register
 */
/*@{*/
#define MCG_RD_C7(base)          (MCG_C7_REG(base))
#define MCG_WR_C7(base, value)   (MCG_C7_REG(base) = (value))
#define MCG_RMW_C7(base, mask, value) (MCG_WR_C7(base, (MCG_RD_C7(base) & ~(mask)) | (value)))
#define MCG_SET_C7(base, value)  (MCG_WR_C7(base, MCG_RD_C7(base) |  (value)))
#define MCG_CLR_C7(base, value)  (MCG_WR_C7(base, MCG_RD_C7(base) & ~(value)))
#define MCG_TOG_C7(base, value)  (MCG_WR_C7(base, MCG_RD_C7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C7 bitfields
 */

/*!
 * @name Register MCG_C7, field OSCSEL[0] (RW)
 *
 * Selects the MCG FLL external reference clock
 *
 * Values:
 * - 0 - Selects System Oscillator (OSCCLK).
 * - 1 - Selects 32 kHz RTC Oscillator.
 */
/*@{*/
/*! @brief Read current value of the MCG_C7_OSCSEL field. */
#define MCG_RD_C7_OSCSEL(base) ((MCG_C7_REG(base) & MCG_C7_OSCSEL_MASK) >> MCG_C7_OSCSEL_SHIFT)
#define MCG_BRD_C7_OSCSEL(base) (BITBAND_ACCESS8(&MCG_C7_REG(base), MCG_C7_OSCSEL_SHIFT))

/*! @brief Set the OSCSEL field to a new value. */
#define MCG_WR_C7_OSCSEL(base, value) (MCG_RMW_C7(base, MCG_C7_OSCSEL_MASK, MCG_C7_OSCSEL(value)))
#define MCG_BWR_C7_OSCSEL(base, value) (BITBAND_ACCESS8(&MCG_C7_REG(base), MCG_C7_OSCSEL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_C8 - MCG Control 8 Register
 ******************************************************************************/

/*!
 * @brief MCG_C8 - MCG Control 8 Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire MCG_C8 register
 */
/*@{*/
#define MCG_RD_C8(base)          (MCG_C8_REG(base))
#define MCG_WR_C8(base, value)   (MCG_C8_REG(base) = (value))
#define MCG_RMW_C8(base, mask, value) (MCG_WR_C8(base, (MCG_RD_C8(base) & ~(mask)) | (value)))
#define MCG_SET_C8(base, value)  (MCG_WR_C8(base, MCG_RD_C8(base) |  (value)))
#define MCG_CLR_C8(base, value)  (MCG_WR_C8(base, MCG_RD_C8(base) & ~(value)))
#define MCG_TOG_C8(base, value)  (MCG_WR_C8(base, MCG_RD_C8(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C8 bitfields
 */

/*!
 * @name Register MCG_C8, field LOCS1[0] (W1C)
 *
 * This bit indicates when a loss of clock has occurred. This bit is cleared by
 * writing a logic 1 to it when set.
 *
 * Values:
 * - 0 - Loss of RTC has not occur.
 * - 1 - Loss of RTC has occur
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOCS1 field. */
#define MCG_RD_C8_LOCS1(base) ((MCG_C8_REG(base) & MCG_C8_LOCS1_MASK) >> MCG_C8_LOCS1_SHIFT)
#define MCG_BRD_C8_LOCS1(base) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOCS1_SHIFT))

/*! @brief Set the LOCS1 field to a new value. */
#define MCG_WR_C8_LOCS1(base, value) (MCG_RMW_C8(base, MCG_C8_LOCS1_MASK, MCG_C8_LOCS1(value)))
#define MCG_BWR_C8_LOCS1(base, value) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOCS1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C8, field CME1[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the output of the RTC
 * external reference clock. The LOCRE1 bit will determine if a interrupt or a reset
 * request is generated following a loss of RTC clock indication. The CME1 bit
 * should only be set to a logic 1 when the MCG is in an operational mode that uses
 * the external clock (FEE, FBE, PEE, PBE, or BLPE). CME1 bit must be set to a
 * logic 0 before the MCG enters any Stop mode. Otherwise, a reset request may occur
 * while in Stop mode. CME1 should also be set to a logic 0 before entering VLPR
 * or VLPW power modes if the MCG is in BLPE mode.
 *
 * Values:
 * - 0 - External clock monitor is disabled for RTC clock.
 * - 1 - External clock monitor is enabled for RTC clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_CME1 field. */
#define MCG_RD_C8_CME1(base) ((MCG_C8_REG(base) & MCG_C8_CME1_MASK) >> MCG_C8_CME1_SHIFT)
#define MCG_BRD_C8_CME1(base) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_CME1_SHIFT))

/*! @brief Set the CME1 field to a new value. */
#define MCG_WR_C8_CME1(base, value) (MCG_RMW_C8(base, (MCG_C8_CME1_MASK | MCG_C8_LOCS1_MASK), MCG_C8_CME1(value)))
#define MCG_BWR_C8_CME1(base, value) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_CME1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C8, field LOLRE[6] (RW)
 *
 * Values:
 * - 0 - Interrupt request is generated on a PLL loss of lock indication. The
 *     PLL loss of lock interrupt enable bit must also be set to generate the
 *     interrupt request.
 * - 1 - Generate a reset request on a PLL loss of lock indication.
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOLRE field. */
#define MCG_RD_C8_LOLRE(base) ((MCG_C8_REG(base) & MCG_C8_LOLRE_MASK) >> MCG_C8_LOLRE_SHIFT)
#define MCG_BRD_C8_LOLRE(base) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOLRE_SHIFT))

/*! @brief Set the LOLRE field to a new value. */
#define MCG_WR_C8_LOLRE(base, value) (MCG_RMW_C8(base, (MCG_C8_LOLRE_MASK | MCG_C8_LOCS1_MASK), MCG_C8_LOLRE(value)))
#define MCG_BWR_C8_LOLRE(base, value) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOLRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C8, field LOCRE1[7] (RW)
 *
 * Determines if a interrupt or a reset request is made following a loss of RTC
 * external reference clock. The LOCRE1 only has an affect when CME1 is set.
 *
 * Values:
 * - 0 - Interrupt request is generated on a loss of RTC external reference
 *     clock.
 * - 1 - Generate a reset request on a loss of RTC external reference clock
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOCRE1 field. */
#define MCG_RD_C8_LOCRE1(base) ((MCG_C8_REG(base) & MCG_C8_LOCRE1_MASK) >> MCG_C8_LOCRE1_SHIFT)
#define MCG_BRD_C8_LOCRE1(base) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOCRE1_SHIFT))

/*! @brief Set the LOCRE1 field to a new value. */
#define MCG_WR_C8_LOCRE1(base, value) (MCG_RMW_C8(base, (MCG_C8_LOCRE1_MASK | MCG_C8_LOCS1_MASK), MCG_C8_LOCRE1(value)))
#define MCG_BWR_C8_LOCRE1(base, value) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOCRE1_SHIFT) = (value))
/*@}*/

/* MCG C2[EREFS] backward compatibility */
#define MCG_RD_C2_EREFS(base)         (MCG_RD_C2_EREFS0(base))
#define MCG_BRD_C2_EREFS(base)        (MCG_BRD_C2_EREFS0(base))
#define MCG_WR_C2_EREFS(base, value)  (MCG_WR_C2_EREFS0((base), (value)))
#define MCG_BWR_C2_EREFS(base, value) (MCG_BWR_C2_EREFS0((base), (value)))
/* MCG C2[HGO] backward compatibility */
#define MCG_RD_C2_HGO(base)         (MCG_RD_C2_HGO0(base))
#define MCG_BRD_C2_HGO(base)        (MCG_BRD_C2_HGO0(base))
#define MCG_WR_C2_HGO(base, value)  (MCG_WR_C2_HGO0((base), (value)))
#define MCG_BWR_C2_HGO(base, value) (MCG_BWR_C2_HGO0((base), (value)))
/* MCG C2[RANGE] backward compatibility */
#define MCG_RD_C2_RANGE(base)         (MCG_RD_C2_RANGE0(base))
#define MCG_BRD_C2_RANGE(base)        (MCG_BRD_C2_RANGE0(base))
#define MCG_WR_C2_RANGE(base, value)  (MCG_WR_C2_RANGE0((base), (value)))
#define MCG_BWR_C2_RANGE(base, value) (MCG_BWR_C2_RANGE0((base), (value)))

/*
 * MK20D5 NV
 *
 * Flash configuration field
 *
 * Registers defined in this header file:
 * - NV_BACKKEY3 - Backdoor Comparison Key 3.
 * - NV_BACKKEY2 - Backdoor Comparison Key 2.
 * - NV_BACKKEY1 - Backdoor Comparison Key 1.
 * - NV_BACKKEY0 - Backdoor Comparison Key 0.
 * - NV_BACKKEY7 - Backdoor Comparison Key 7.
 * - NV_BACKKEY6 - Backdoor Comparison Key 6.
 * - NV_BACKKEY5 - Backdoor Comparison Key 5.
 * - NV_BACKKEY4 - Backdoor Comparison Key 4.
 * - NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 * - NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 * - NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 * - NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 * - NV_FSEC - Non-volatile Flash Security Register
 * - NV_FOPT - Non-volatile Flash Option Register
 * - NV_FEPROT - Non-volatile EERAM Protection Register
 * - NV_FDPROT - Non-volatile D-Flash Protection Register
 */

#define NV_INSTANCE_COUNT (1U) /*!< Number of instances of the NV module. */
#define FTFL_FlashConfig_IDX (0U) /*!< Instance number for FTFL_FlashConfig. */

/*******************************************************************************
 * NV_BACKKEY3 - Backdoor Comparison Key 3.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY3 - Backdoor Comparison Key 3. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY3 register
 */
/*@{*/
#define NV_RD_BACKKEY3(base)     (NV_BACKKEY3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY2 - Backdoor Comparison Key 2.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY2 - Backdoor Comparison Key 2. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY2 register
 */
/*@{*/
#define NV_RD_BACKKEY2(base)     (NV_BACKKEY2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY1 - Backdoor Comparison Key 1.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY1 - Backdoor Comparison Key 1. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY1 register
 */
/*@{*/
#define NV_RD_BACKKEY1(base)     (NV_BACKKEY1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY0 - Backdoor Comparison Key 0.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY0 - Backdoor Comparison Key 0. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY0 register
 */
/*@{*/
#define NV_RD_BACKKEY0(base)     (NV_BACKKEY0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY7 - Backdoor Comparison Key 7.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY7 - Backdoor Comparison Key 7. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY7 register
 */
/*@{*/
#define NV_RD_BACKKEY7(base)     (NV_BACKKEY7_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY6 - Backdoor Comparison Key 6.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY6 - Backdoor Comparison Key 6. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY6 register
 */
/*@{*/
#define NV_RD_BACKKEY6(base)     (NV_BACKKEY6_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY5 - Backdoor Comparison Key 5.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY5 - Backdoor Comparison Key 5. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY5 register
 */
/*@{*/
#define NV_RD_BACKKEY5(base)     (NV_BACKKEY5_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY4 - Backdoor Comparison Key 4.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY4 - Backdoor Comparison Key 4. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY4 register
 */
/*@{*/
#define NV_RD_BACKKEY4(base)     (NV_BACKKEY4_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT3 register
 */
/*@{*/
#define NV_RD_FPROT3(base)       (NV_FPROT3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT2 register
 */
/*@{*/
#define NV_RD_FPROT2(base)       (NV_FPROT2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT1 register
 */
/*@{*/
#define NV_RD_FPROT1(base)       (NV_FPROT1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT0 register
 */
/*@{*/
#define NV_RD_FPROT0(base)       (NV_FPROT0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FSEC - Non-volatile Flash Security Register
 ******************************************************************************/

/*!
 * @brief NV_FSEC - Non-volatile Flash Security Register (RO)
 *
 * Reset value: 0xFFU
 *
 * Allows the user to customize the operation of the MCU at boot time
 */
/*!
 * @name Constants and macros for entire NV_FSEC register
 */
/*@{*/
#define NV_RD_FSEC(base)         (NV_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FSEC bitfields
 */

/*!
 * @name Register NV_FSEC, field SEC[1:0] (RO)
 *
 * Values:
 * - 10 - MCU security status is unsecure
 * - 11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_SEC field. */
#define NV_RD_FSEC_SEC(base) ((NV_FSEC_REG(base) & NV_FSEC_SEC_MASK) >> NV_FSEC_SEC_SHIFT)
#define NV_BRD_FSEC_SEC(base) (NV_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field FSLACC[3:2] (RO)
 *
 * Values:
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_FSLACC field. */
#define NV_RD_FSEC_FSLACC(base) ((NV_FSEC_REG(base) & NV_FSEC_FSLACC_MASK) >> NV_FSEC_FSLACC_SHIFT)
#define NV_BRD_FSEC_FSLACC(base) (NV_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field MEEN[5:4] (RO)
 *
 * Values:
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_MEEN field. */
#define NV_RD_FSEC_MEEN(base) ((NV_FSEC_REG(base) & NV_FSEC_MEEN_MASK) >> NV_FSEC_MEEN_SHIFT)
#define NV_BRD_FSEC_MEEN(base) (NV_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field KEYEN[7:6] (RO)
 *
 * Values:
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_KEYEN field. */
#define NV_RD_FSEC_KEYEN(base) ((NV_FSEC_REG(base) & NV_FSEC_KEYEN_MASK) >> NV_FSEC_KEYEN_SHIFT)
#define NV_BRD_FSEC_KEYEN(base) (NV_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * NV_FOPT - Non-volatile Flash Option Register
 ******************************************************************************/

/*!
 * @brief NV_FOPT - Non-volatile Flash Option Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FOPT register
 */
/*@{*/
#define NV_RD_FOPT(base)         (NV_FOPT_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FOPT bitfields
 */

/*!
 * @name Register NV_FOPT, field LPBOOT[0] (RO)
 *
 * Values:
 * - 00 - Low-power boot
 * - 01 - Normal boot
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT field. */
#define NV_RD_FOPT_LPBOOT(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT_MASK) >> NV_FOPT_LPBOOT_SHIFT)
#define NV_BRD_FOPT_LPBOOT(base) (BITBAND_ACCESS8(&NV_FOPT_REG(base), NV_FOPT_LPBOOT_SHIFT))
/*@}*/

/*!
 * @name Register NV_FOPT, field EZPORT_DIS[1] (RO)
 *
 * Values:
 * - 00 - EzPort operation is disabled
 * - 01 - EzPort operation is enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_EZPORT_DIS field. */
#define NV_RD_FOPT_EZPORT_DIS(base) ((NV_FOPT_REG(base) & NV_FOPT_EZPORT_DIS_MASK) >> NV_FOPT_EZPORT_DIS_SHIFT)
#define NV_BRD_FOPT_EZPORT_DIS(base) (BITBAND_ACCESS8(&NV_FOPT_REG(base), NV_FOPT_EZPORT_DIS_SHIFT))
/*@}*/

/*!
 * @name Register NV_FOPT, field NMI_DIS[2] (RO)
 *
 * Values:
 * - 00 - NMI interrupts are always blocked
 * - 01 - NMI_b pin/interrupts reset default to enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_NMI_DIS field. */
#define NV_RD_FOPT_NMI_DIS(base) ((NV_FOPT_REG(base) & NV_FOPT_NMI_DIS_MASK) >> NV_FOPT_NMI_DIS_SHIFT)
#define NV_BRD_FOPT_NMI_DIS(base) (BITBAND_ACCESS8(&NV_FOPT_REG(base), NV_FOPT_NMI_DIS_SHIFT))
/*@}*/

/*******************************************************************************
 * NV_FEPROT - Non-volatile EERAM Protection Register
 ******************************************************************************/

/*!
 * @brief NV_FEPROT - Non-volatile EERAM Protection Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FEPROT register
 */
/*@{*/
#define NV_RD_FEPROT(base)       (NV_FEPROT_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FDPROT - Non-volatile D-Flash Protection Register
 ******************************************************************************/

/*!
 * @brief NV_FDPROT - Non-volatile D-Flash Protection Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FDPROT register
 */
/*@{*/
#define NV_RD_FDPROT(base)       (NV_FDPROT_REG(base))
/*@}*/

/*
 * MK20D5 OSC
 *
 * Oscillator
 *
 * Registers defined in this header file:
 * - OSC_CR - OSC Control Register
 */

#define OSC_INSTANCE_COUNT (1U) /*!< Number of instances of the OSC module. */
#define OSC0_IDX (0U) /*!< Instance number for OSC0. */

/*******************************************************************************
 * OSC_CR - OSC Control Register
 ******************************************************************************/

/*!
 * @brief OSC_CR - OSC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * After OSC is enabled and starts generating the clocks, the configurations
 * such as low power and frequency range, must not be changed.
 */
/*!
 * @name Constants and macros for entire OSC_CR register
 */
/*@{*/
#define OSC_RD_CR(base)          (OSC_CR_REG(base))
#define OSC_WR_CR(base, value)   (OSC_CR_REG(base) = (value))
#define OSC_RMW_CR(base, mask, value) (OSC_WR_CR(base, (OSC_RD_CR(base) & ~(mask)) | (value)))
#define OSC_SET_CR(base, value)  (OSC_WR_CR(base, OSC_RD_CR(base) |  (value)))
#define OSC_CLR_CR(base, value)  (OSC_WR_CR(base, OSC_RD_CR(base) & ~(value)))
#define OSC_TOG_CR(base, value)  (OSC_WR_CR(base, OSC_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual OSC_CR bitfields
 */

/*!
 * @name Register OSC_CR, field SC16P[0] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 16 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC16P field. */
#define OSC_RD_CR_SC16P(base) ((OSC_CR_REG(base) & OSC_CR_SC16P_MASK) >> OSC_CR_SC16P_SHIFT)
#define OSC_BRD_CR_SC16P(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC16P_SHIFT))

/*! @brief Set the SC16P field to a new value. */
#define OSC_WR_CR_SC16P(base, value) (OSC_RMW_CR(base, OSC_CR_SC16P_MASK, OSC_CR_SC16P(value)))
#define OSC_BWR_CR_SC16P(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC16P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field SC8P[1] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 8 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC8P field. */
#define OSC_RD_CR_SC8P(base) ((OSC_CR_REG(base) & OSC_CR_SC8P_MASK) >> OSC_CR_SC8P_SHIFT)
#define OSC_BRD_CR_SC8P(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC8P_SHIFT))

/*! @brief Set the SC8P field to a new value. */
#define OSC_WR_CR_SC8P(base, value) (OSC_RMW_CR(base, OSC_CR_SC8P_MASK, OSC_CR_SC8P(value)))
#define OSC_BWR_CR_SC8P(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC8P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field SC4P[2] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 4 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC4P field. */
#define OSC_RD_CR_SC4P(base) ((OSC_CR_REG(base) & OSC_CR_SC4P_MASK) >> OSC_CR_SC4P_SHIFT)
#define OSC_BRD_CR_SC4P(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC4P_SHIFT))

/*! @brief Set the SC4P field to a new value. */
#define OSC_WR_CR_SC4P(base, value) (OSC_RMW_CR(base, OSC_CR_SC4P_MASK, OSC_CR_SC4P(value)))
#define OSC_BWR_CR_SC4P(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC4P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field SC2P[3] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 2 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC2P field. */
#define OSC_RD_CR_SC2P(base) ((OSC_CR_REG(base) & OSC_CR_SC2P_MASK) >> OSC_CR_SC2P_SHIFT)
#define OSC_BRD_CR_SC2P(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC2P_SHIFT))

/*! @brief Set the SC2P field to a new value. */
#define OSC_WR_CR_SC2P(base, value) (OSC_RMW_CR(base, OSC_CR_SC2P_MASK, OSC_CR_SC2P(value)))
#define OSC_BWR_CR_SC2P(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC2P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field EREFSTEN[5] (RW)
 *
 * Controls whether or not the external reference clock (OSCERCLK) remains
 * enabled when MCU enters Stop mode.
 *
 * Values:
 * - 0 - External reference clock is disabled in Stop mode.
 * - 1 - External reference clock stays enabled in Stop mode if ERCLKEN is set
 *     before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_EREFSTEN field. */
#define OSC_RD_CR_EREFSTEN(base) ((OSC_CR_REG(base) & OSC_CR_EREFSTEN_MASK) >> OSC_CR_EREFSTEN_SHIFT)
#define OSC_BRD_CR_EREFSTEN(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_EREFSTEN_SHIFT))

/*! @brief Set the EREFSTEN field to a new value. */
#define OSC_WR_CR_EREFSTEN(base, value) (OSC_RMW_CR(base, OSC_CR_EREFSTEN_MASK, OSC_CR_EREFSTEN(value)))
#define OSC_BWR_CR_EREFSTEN(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_EREFSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field ERCLKEN[7] (RW)
 *
 * Enables external reference clock (OSCERCLK).
 *
 * Values:
 * - 0 - External reference clock is inactive.
 * - 1 - External reference clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_ERCLKEN field. */
#define OSC_RD_CR_ERCLKEN(base) ((OSC_CR_REG(base) & OSC_CR_ERCLKEN_MASK) >> OSC_CR_ERCLKEN_SHIFT)
#define OSC_BRD_CR_ERCLKEN(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_ERCLKEN_SHIFT))

/*! @brief Set the ERCLKEN field to a new value. */
#define OSC_WR_CR_ERCLKEN(base, value) (OSC_RMW_CR(base, OSC_CR_ERCLKEN_MASK, OSC_CR_ERCLKEN(value)))
#define OSC_BWR_CR_ERCLKEN(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_ERCLKEN_SHIFT) = (value))
/*@}*/

/*
 * MK20D5 PDB
 *
 * Programmable Delay Block
 *
 * Registers defined in this header file:
 * - PDB_SC - Status and Control Register
 * - PDB_MOD - Modulus Register
 * - PDB_CNT - Counter Register
 * - PDB_IDLY - Interrupt Delay Register
 * - PDB_C1 - Channel n Control Register 1
 * - PDB_S - Channel n Status Register
 * - PDB_DLY - Channel n Delay 0 Register
 * - PDB_POEN - Pulse-Out n Enable Register
 * - PDB_PODLY - Pulse-Out n Delay Register
 */

#define PDB_INSTANCE_COUNT (1U) /*!< Number of instances of the PDB module. */
#define PDB0_IDX (0U) /*!< Instance number for PDB0. */

/*******************************************************************************
 * PDB_SC - Status and Control Register
 ******************************************************************************/

/*!
 * @brief PDB_SC - Status and Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_SC register
 */
/*@{*/
#define PDB_RD_SC(base)          (PDB_SC_REG(base))
#define PDB_WR_SC(base, value)   (PDB_SC_REG(base) = (value))
#define PDB_RMW_SC(base, mask, value) (PDB_WR_SC(base, (PDB_RD_SC(base) & ~(mask)) | (value)))
#define PDB_SET_SC(base, value)  (PDB_WR_SC(base, PDB_RD_SC(base) |  (value)))
#define PDB_CLR_SC(base, value)  (PDB_WR_SC(base, PDB_RD_SC(base) & ~(value)))
#define PDB_TOG_SC(base, value)  (PDB_WR_SC(base, PDB_RD_SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_SC bitfields
 */

/*!
 * @name Register PDB_SC, field LDOK[0] (RW)
 *
 * Writing 1 to this bit updates the internal registers of MOD, IDLY, CHnDLYm,
 * DACINTx, and POyDLY with the values written to their buffers. The MOD, IDLY,
 * CHnDLYm, DACINTx, and POyDLY will take effect according to the LDMOD. After 1 is
 * written to LDOK bit, the values in the buffers of above registers are not
 * effective and the buffers cannot be written until the values in buffers are
 * loaded into their internal registers. LDOK can be written only when PDBEN is set or
 * it can be written at the same time with PDBEN being written to 1. It is
 * automatically cleared when the values in buffers are loaded into the internal
 * registers or the PDBEN is cleared. Writing 0 to it has no effect.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDOK field. */
#define PDB_RD_SC_LDOK(base) ((PDB_SC_REG(base) & PDB_SC_LDOK_MASK) >> PDB_SC_LDOK_SHIFT)
#define PDB_BRD_SC_LDOK(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_LDOK_SHIFT))

/*! @brief Set the LDOK field to a new value. */
#define PDB_WR_SC_LDOK(base, value) (PDB_RMW_SC(base, PDB_SC_LDOK_MASK, PDB_SC_LDOK(value)))
#define PDB_BWR_SC_LDOK(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_LDOK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field CONT[1] (RW)
 *
 * This bit enables the PDB operation in Continuous mode.
 *
 * Values:
 * - 0 - PDB operation in One-Shot mode
 * - 1 - PDB operation in Continuous mode
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_CONT field. */
#define PDB_RD_SC_CONT(base) ((PDB_SC_REG(base) & PDB_SC_CONT_MASK) >> PDB_SC_CONT_SHIFT)
#define PDB_BRD_SC_CONT(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_CONT_SHIFT))

/*! @brief Set the CONT field to a new value. */
#define PDB_WR_SC_CONT(base, value) (PDB_RMW_SC(base, PDB_SC_CONT_MASK, PDB_SC_CONT(value)))
#define PDB_BWR_SC_CONT(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_CONT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field MULT[3:2] (RW)
 *
 * This bit selects the multiplication factor of the prescaler divider for the
 * counter clock.
 *
 * Values:
 * - 00 - Multiplication factor is 1
 * - 01 - Multiplication factor is 10
 * - 10 - Multiplication factor is 20
 * - 11 - Multiplication factor is 40
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_MULT field. */
#define PDB_RD_SC_MULT(base) ((PDB_SC_REG(base) & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT)
#define PDB_BRD_SC_MULT(base) (PDB_RD_SC_MULT(base))

/*! @brief Set the MULT field to a new value. */
#define PDB_WR_SC_MULT(base, value) (PDB_RMW_SC(base, PDB_SC_MULT_MASK, PDB_SC_MULT(value)))
#define PDB_BWR_SC_MULT(base, value) (PDB_WR_SC_MULT(base, value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIE[5] (RW)
 *
 * This bit enables the PDB interrupt. When this bit is set and DMAEN is
 * cleared, PDBIF generates a PDB interrupt.
 *
 * Values:
 * - 0 - PDB interrupt disabled
 * - 1 - PDB interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIE field. */
#define PDB_RD_SC_PDBIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBIE_MASK) >> PDB_SC_PDBIE_SHIFT)
#define PDB_BRD_SC_PDBIE(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIE_SHIFT))

/*! @brief Set the PDBIE field to a new value. */
#define PDB_WR_SC_PDBIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIE_MASK, PDB_SC_PDBIE(value)))
#define PDB_BWR_SC_PDBIE(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIF[6] (RW)
 *
 * This bit is set when the counter value is equal to the IDLY register. Writing
 * zero clears this bit.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIF field. */
#define PDB_RD_SC_PDBIF(base) ((PDB_SC_REG(base) & PDB_SC_PDBIF_MASK) >> PDB_SC_PDBIF_SHIFT)
#define PDB_BRD_SC_PDBIF(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIF_SHIFT))

/*! @brief Set the PDBIF field to a new value. */
#define PDB_WR_SC_PDBIF(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIF_MASK, PDB_SC_PDBIF(value)))
#define PDB_BWR_SC_PDBIF(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEN[7] (RW)
 *
 * Values:
 * - 0 - PDB disabled. Counter is off.
 * - 1 - PDB enabled
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEN field. */
#define PDB_RD_SC_PDBEN(base) ((PDB_SC_REG(base) & PDB_SC_PDBEN_MASK) >> PDB_SC_PDBEN_SHIFT)
#define PDB_BRD_SC_PDBEN(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEN_SHIFT))

/*! @brief Set the PDBEN field to a new value. */
#define PDB_WR_SC_PDBEN(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEN_MASK, PDB_SC_PDBEN(value)))
#define PDB_BWR_SC_PDBEN(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field TRGSEL[11:8] (RW)
 *
 * Selects the trigger input source for the PDB. The trigger input source can be
 * internal or external (EXTRG pin), or the software trigger.
 *
 * Values:
 * - 0000 - Trigger-In 0 is selected
 * - 0001 - Trigger-In 1 is selected
 * - 0010 - Trigger-In 2 is selected
 * - 0011 - Trigger-In 3 is selected
 * - 0100 - Trigger-In 4 is selected
 * - 0101 - Trigger-In 5 is selected
 * - 0110 - Trigger-In 6 is selected
 * - 0111 - Trigger-In 7 is selected
 * - 1000 - Trigger-In 8 is selected
 * - 1001 - Trigger-In 9 is selected
 * - 1010 - Trigger-In 10 is selected
 * - 1011 - Trigger-In 11 is selected
 * - 1100 - Trigger-In 12 is selected
 * - 1101 - Trigger-In 13 is selected
 * - 1110 - Trigger-In 14 is selected
 * - 1111 - Software trigger is selected
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_TRGSEL field. */
#define PDB_RD_SC_TRGSEL(base) ((PDB_SC_REG(base) & PDB_SC_TRGSEL_MASK) >> PDB_SC_TRGSEL_SHIFT)
#define PDB_BRD_SC_TRGSEL(base) (PDB_RD_SC_TRGSEL(base))

/*! @brief Set the TRGSEL field to a new value. */
#define PDB_WR_SC_TRGSEL(base, value) (PDB_RMW_SC(base, PDB_SC_TRGSEL_MASK, PDB_SC_TRGSEL(value)))
#define PDB_BWR_SC_TRGSEL(base, value) (PDB_WR_SC_TRGSEL(base, value))
/*@}*/

/*!
 * @name Register PDB_SC, field PRESCALER[14:12] (RW)
 *
 * Values:
 * - 000 - Counting uses the peripheral clock divided by multiplication factor
 *     selected by MULT.
 * - 001 - Counting uses the peripheral clock divided by twice of the
 *     multiplication factor selected by MULT.
 * - 010 - Counting uses the peripheral clock divided by four times of the
 *     multiplication factor selected by MULT.
 * - 011 - Counting uses the peripheral clock divided by eight times of the
 *     multiplication factor selected by MULT.
 * - 100 - Counting uses the peripheral clock divided by 16 times of the
 *     multiplication factor selected by MULT.
 * - 101 - Counting uses the peripheral clock divided by 32 times of the
 *     multiplication factor selected by MULT.
 * - 110 - Counting uses the peripheral clock divided by 64 times of the
 *     multiplication factor selected by MULT.
 * - 111 - Counting uses the peripheral clock divided by 128 times of the
 *     multiplication factor selected by MULT.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PRESCALER field. */
#define PDB_RD_SC_PRESCALER(base) ((PDB_SC_REG(base) & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT)
#define PDB_BRD_SC_PRESCALER(base) (PDB_RD_SC_PRESCALER(base))

/*! @brief Set the PRESCALER field to a new value. */
#define PDB_WR_SC_PRESCALER(base, value) (PDB_RMW_SC(base, PDB_SC_PRESCALER_MASK, PDB_SC_PRESCALER(value)))
#define PDB_BWR_SC_PRESCALER(base, value) (PDB_WR_SC_PRESCALER(base, value))
/*@}*/

/*!
 * @name Register PDB_SC, field DMAEN[15] (RW)
 *
 * When DMA is enabled, the PDBIF flag generates a DMA request instead of an
 * interrupt.
 *
 * Values:
 * - 0 - DMA disabled
 * - 1 - DMA enabled
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_DMAEN field. */
#define PDB_RD_SC_DMAEN(base) ((PDB_SC_REG(base) & PDB_SC_DMAEN_MASK) >> PDB_SC_DMAEN_SHIFT)
#define PDB_BRD_SC_DMAEN(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define PDB_WR_SC_DMAEN(base, value) (PDB_RMW_SC(base, PDB_SC_DMAEN_MASK, PDB_SC_DMAEN(value)))
#define PDB_BWR_SC_DMAEN(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_DMAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field SWTRIG[16] (WORZ)
 *
 * When PDB is enabled and the software trigger is selected as the trigger input
 * source, writing 1 to this bit reset and restarts the counter. Writing 0 to
 * this bit has no effect. Reading this bit results 0.
 */
/*@{*/
/*! @brief Set the SWTRIG field to a new value. */
#define PDB_WR_SC_SWTRIG(base, value) (PDB_RMW_SC(base, PDB_SC_SWTRIG_MASK, PDB_SC_SWTRIG(value)))
#define PDB_BWR_SC_SWTRIG(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_SWTRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEIE[17] (RW)
 *
 * This bit enables the PDB sequence error interrupt. When this bit is set, any
 * of the PDB channel sequence error flags generates a PDB sequence error
 * interrupt.
 *
 * Values:
 * - 0 - PDB sequence error interrupt disabled.
 * - 1 - PDB sequence error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEIE field. */
#define PDB_RD_SC_PDBEIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBEIE_MASK) >> PDB_SC_PDBEIE_SHIFT)
#define PDB_BRD_SC_PDBEIE(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEIE_SHIFT))

/*! @brief Set the PDBEIE field to a new value. */
#define PDB_WR_SC_PDBEIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEIE_MASK, PDB_SC_PDBEIE(value)))
#define PDB_BWR_SC_PDBEIE(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field LDMOD[19:18] (RW)
 *
 * Selects the mode to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,
 * after 1 is written to LDOK.
 *
 * Values:
 * - 00 - The internal registers are loaded with the values from their buffers
 *     immediately after 1 is written to LDOK.
 * - 01 - The internal registers are loaded with the values from their buffers
 *     when the PDB counter reaches the MOD register value after 1 is written to
 *     LDOK.
 * - 10 - The internal registers are loaded with the values from their buffers
 *     when a trigger input event is detected after 1 is written to LDOK.
 * - 11 - The internal registers are loaded with the values from their buffers
 *     when either the PDB counter reaches the MOD register value or a trigger
 *     input event is detected, after 1 is written to LDOK.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDMOD field. */
#define PDB_RD_SC_LDMOD(base) ((PDB_SC_REG(base) & PDB_SC_LDMOD_MASK) >> PDB_SC_LDMOD_SHIFT)
#define PDB_BRD_SC_LDMOD(base) (PDB_RD_SC_LDMOD(base))

/*! @brief Set the LDMOD field to a new value. */
#define PDB_WR_SC_LDMOD(base, value) (PDB_RMW_SC(base, PDB_SC_LDMOD_MASK, PDB_SC_LDMOD(value)))
#define PDB_BWR_SC_LDMOD(base, value) (PDB_WR_SC_LDMOD(base, value))
/*@}*/

/*******************************************************************************
 * PDB_MOD - Modulus Register
 ******************************************************************************/

/*!
 * @brief PDB_MOD - Modulus Register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_MOD register
 */
/*@{*/
#define PDB_RD_MOD(base)         (PDB_MOD_REG(base))
#define PDB_WR_MOD(base, value)  (PDB_MOD_REG(base) = (value))
#define PDB_RMW_MOD(base, mask, value) (PDB_WR_MOD(base, (PDB_RD_MOD(base) & ~(mask)) | (value)))
#define PDB_SET_MOD(base, value) (PDB_WR_MOD(base, PDB_RD_MOD(base) |  (value)))
#define PDB_CLR_MOD(base, value) (PDB_WR_MOD(base, PDB_RD_MOD(base) & ~(value)))
#define PDB_TOG_MOD(base, value) (PDB_WR_MOD(base, PDB_RD_MOD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_MOD bitfields
 */

/*!
 * @name Register PDB_MOD, field MOD[15:0] (RW)
 *
 * These bits specify the period of the counter. When the counter reaches this
 * value, it will be reset back to zero. If the PDB is in Continuous mode, the
 * count begins anew. Reading these bits returns the value of internal register that
 * is effective for the current cycle of PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_MOD_MOD field. */
#define PDB_RD_MOD_MOD(base) ((PDB_MOD_REG(base) & PDB_MOD_MOD_MASK) >> PDB_MOD_MOD_SHIFT)
#define PDB_BRD_MOD_MOD(base) (PDB_RD_MOD_MOD(base))

/*! @brief Set the MOD field to a new value. */
#define PDB_WR_MOD_MOD(base, value) (PDB_RMW_MOD(base, PDB_MOD_MOD_MASK, PDB_MOD_MOD(value)))
#define PDB_BWR_MOD_MOD(base, value) (PDB_WR_MOD_MOD(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CNT - Counter Register
 ******************************************************************************/

/*!
 * @brief PDB_CNT - Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CNT register
 */
/*@{*/
#define PDB_RD_CNT(base)         (PDB_CNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual PDB_CNT bitfields
 */

/*!
 * @name Register PDB_CNT, field CNT[15:0] (RO)
 *
 * These read-only bits contain the current value of the counter.
 */
/*@{*/
/*! @brief Read current value of the PDB_CNT_CNT field. */
#define PDB_RD_CNT_CNT(base) ((PDB_CNT_REG(base) & PDB_CNT_CNT_MASK) >> PDB_CNT_CNT_SHIFT)
#define PDB_BRD_CNT_CNT(base) (PDB_RD_CNT_CNT(base))
/*@}*/

/*******************************************************************************
 * PDB_IDLY - Interrupt Delay Register
 ******************************************************************************/

/*!
 * @brief PDB_IDLY - Interrupt Delay Register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_IDLY register
 */
/*@{*/
#define PDB_RD_IDLY(base)        (PDB_IDLY_REG(base))
#define PDB_WR_IDLY(base, value) (PDB_IDLY_REG(base) = (value))
#define PDB_RMW_IDLY(base, mask, value) (PDB_WR_IDLY(base, (PDB_RD_IDLY(base) & ~(mask)) | (value)))
#define PDB_SET_IDLY(base, value) (PDB_WR_IDLY(base, PDB_RD_IDLY(base) |  (value)))
#define PDB_CLR_IDLY(base, value) (PDB_WR_IDLY(base, PDB_RD_IDLY(base) & ~(value)))
#define PDB_TOG_IDLY(base, value) (PDB_WR_IDLY(base, PDB_RD_IDLY(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_IDLY bitfields
 */

/*!
 * @name Register PDB_IDLY, field IDLY[15:0] (RW)
 *
 * These bits specify the delay value to schedule the PDB interrupt. It can be
 * used to schedule an independent interrupt at some point in the PDB cycle. If
 * enabled, a PDB interrupt is generated, when the counter is equal to the IDLY.
 * Reading these bits returns the value of internal register that is effective for
 * the current cycle of the PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_IDLY_IDLY field. */
#define PDB_RD_IDLY_IDLY(base) ((PDB_IDLY_REG(base) & PDB_IDLY_IDLY_MASK) >> PDB_IDLY_IDLY_SHIFT)
#define PDB_BRD_IDLY_IDLY(base) (PDB_RD_IDLY_IDLY(base))

/*! @brief Set the IDLY field to a new value. */
#define PDB_WR_IDLY_IDLY(base, value) (PDB_RMW_IDLY(base, PDB_IDLY_IDLY_MASK, PDB_IDLY_IDLY(value)))
#define PDB_BWR_IDLY_IDLY(base, value) (PDB_WR_IDLY_IDLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_C1 - Channel n Control Register 1
 ******************************************************************************/

/*!
 * @brief PDB_C1 - Channel n Control Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one Control Register, CHnC1. The bits in this register
 * control the functionality of each PDB channel operation.
 */
/*!
 * @name Constants and macros for entire PDB_C1 register
 */
/*@{*/
#define PDB_RD_C1(base, index)   (PDB_C1_REG(base, index))
#define PDB_WR_C1(base, index, value) (PDB_C1_REG(base, index) = (value))
#define PDB_RMW_C1(base, index, mask, value) (PDB_WR_C1(base, index, (PDB_RD_C1(base, index) & ~(mask)) | (value)))
#define PDB_SET_C1(base, index, value) (PDB_WR_C1(base, index, PDB_RD_C1(base, index) |  (value)))
#define PDB_CLR_C1(base, index, value) (PDB_WR_C1(base, index, PDB_RD_C1(base, index) & ~(value)))
#define PDB_TOG_C1(base, index, value) (PDB_WR_C1(base, index, PDB_RD_C1(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_C1 bitfields
 */

/*!
 * @name Register PDB_C1, field EN[7:0] (RW)
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger disabled.
 * - 1 - PDB channel's corresponding pre-trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_EN field. */
#define PDB_RD_C1_EN(base, index) ((PDB_C1_REG(base, index) & PDB_C1_EN_MASK) >> PDB_C1_EN_SHIFT)
#define PDB_BRD_C1_EN(base, index) (PDB_RD_C1_EN(base, index))

/*! @brief Set the EN field to a new value. */
#define PDB_WR_C1_EN(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_EN_MASK, PDB_C1_EN(value)))
#define PDB_BWR_C1_EN(base, index, value) (PDB_WR_C1_EN(base, index, value))
/*@}*/

/*!
 * @name Register PDB_C1, field TOS[15:8] (RW)
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger is in bypassed mode. The
 *     pre-trigger asserts one peripheral clock cycle after a rising edge is detected
 *     on selected trigger input source or software trigger is selected and SWTRIG
 *     is written with 1.
 * - 1 - PDB channel's corresponding pre-trigger asserts when the counter
 *     reaches the channel delay register plus one peripheral clock cycle after a
 *     rising edge is detected on selected trigger input source or software trigger is
 *     selected and SETRIG is written with 1.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_TOS field. */
#define PDB_RD_C1_TOS(base, index) ((PDB_C1_REG(base, index) & PDB_C1_TOS_MASK) >> PDB_C1_TOS_SHIFT)
#define PDB_BRD_C1_TOS(base, index) (PDB_RD_C1_TOS(base, index))

/*! @brief Set the TOS field to a new value. */
#define PDB_WR_C1_TOS(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_TOS_MASK, PDB_C1_TOS(value)))
#define PDB_BWR_C1_TOS(base, index, value) (PDB_WR_C1_TOS(base, index, value))
/*@}*/

/*!
 * @name Register PDB_C1, field BB[23:16] (RW)
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger back-to-back operation disabled.
 * - 1 - PDB channel's corresponding pre-trigger back-to-back operation enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_BB field. */
#define PDB_RD_C1_BB(base, index) ((PDB_C1_REG(base, index) & PDB_C1_BB_MASK) >> PDB_C1_BB_SHIFT)
#define PDB_BRD_C1_BB(base, index) (PDB_RD_C1_BB(base, index))

/*! @brief Set the BB field to a new value. */
#define PDB_WR_C1_BB(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_BB_MASK, PDB_C1_BB(value)))
#define PDB_BWR_C1_BB(base, index, value) (PDB_WR_C1_BB(base, index, value))
/*@}*/

/*******************************************************************************
 * PDB_S - Channel n Status Register
 ******************************************************************************/

/*!
 * @brief PDB_S - Channel n Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_S register
 */
/*@{*/
#define PDB_RD_S(base, index)    (PDB_S_REG(base, index))
#define PDB_WR_S(base, index, value) (PDB_S_REG(base, index) = (value))
#define PDB_RMW_S(base, index, mask, value) (PDB_WR_S(base, index, (PDB_RD_S(base, index) & ~(mask)) | (value)))
#define PDB_SET_S(base, index, value) (PDB_WR_S(base, index, PDB_RD_S(base, index) |  (value)))
#define PDB_CLR_S(base, index, value) (PDB_WR_S(base, index, PDB_RD_S(base, index) & ~(value)))
#define PDB_TOG_S(base, index, value) (PDB_WR_S(base, index, PDB_RD_S(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_S bitfields
 */

/*!
 * @name Register PDB_S, field ERR[7:0] (RW)
 *
 * Values:
 * - 0 - Sequence error not detected on PDB channel's corresponding pre-trigger.
 * - 1 - Sequence error detected on PDB channel's corresponding pre-trigger.
 *     ADCn block can be triggered for a conversion by one pre-trigger from PDB
 *     channel n. When one conversion, which is triggered by one of the pre-triggers
 *     from PDB channel n, is in progress, new trigger from PDB channel's
 *     corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set.
 *     Writing 1's to clear the sequence error flags.
 */
/*@{*/
/*! @brief Read current value of the PDB_S_ERR field. */
#define PDB_RD_S_ERR(base, index) ((PDB_S_REG(base, index) & PDB_S_ERR_MASK) >> PDB_S_ERR_SHIFT)
#define PDB_BRD_S_ERR(base, index) (PDB_RD_S_ERR(base, index))

/*! @brief Set the ERR field to a new value. */
#define PDB_WR_S_ERR(base, index, value) (PDB_RMW_S(base, index, PDB_S_ERR_MASK, PDB_S_ERR(value)))
#define PDB_BWR_S_ERR(base, index, value) (PDB_WR_S_ERR(base, index, value))
/*@}*/

/*!
 * @name Register PDB_S, field CF[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the PDB_S_CF field. */
#define PDB_RD_S_CF(base, index) ((PDB_S_REG(base, index) & PDB_S_CF_MASK) >> PDB_S_CF_SHIFT)
#define PDB_BRD_S_CF(base, index) (PDB_RD_S_CF(base, index))

/*! @brief Set the CF field to a new value. */
#define PDB_WR_S_CF(base, index, value) (PDB_RMW_S(base, index, PDB_S_CF_MASK, PDB_S_CF(value)))
#define PDB_BWR_S_CF(base, index, value) (PDB_WR_S_CF(base, index, value))
/*@}*/

/*******************************************************************************
 * PDB_DLY - Channel n Delay 0 Register
 ******************************************************************************/

/*!
 * @brief PDB_DLY - Channel n Delay 0 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_DLY register
 */
/*@{*/
#define PDB_RD_DLY(base, index, index2) (PDB_DLY_REG(base, index, index2))
#define PDB_WR_DLY(base, index, index2, value) (PDB_DLY_REG(base, index, index2) = (value))
#define PDB_RMW_DLY(base, index, index2, mask, value) (PDB_WR_DLY(base, index, index2, (PDB_RD_DLY(base, index, index2) & ~(mask)) | (value)))
#define PDB_SET_DLY(base, index, index2, value) (PDB_WR_DLY(base, index, index2, PDB_RD_DLY(base, index, index2) |  (value)))
#define PDB_CLR_DLY(base, index, index2, value) (PDB_WR_DLY(base, index, index2, PDB_RD_DLY(base, index, index2) & ~(value)))
#define PDB_TOG_DLY(base, index, index2, value) (PDB_WR_DLY(base, index, index2, PDB_RD_DLY(base, index, index2) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_DLY bitfields
 */

/*!
 * @name Register PDB_DLY, field DLY[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the PDB_DLY_DLY field. */
#define PDB_RD_DLY_DLY(base, index, index2) ((PDB_DLY_REG(base, index, index2) & PDB_DLY_DLY_MASK) >> PDB_DLY_DLY_SHIFT)
#define PDB_BRD_DLY_DLY(base, index, index2) (PDB_RD_DLY_DLY(base, index, index2))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_DLY_DLY(base, index, index2, value) (PDB_RMW_DLY(base, index, index2, PDB_DLY_DLY_MASK, PDB_DLY_DLY(value)))
#define PDB_BWR_DLY_DLY(base, index, index2, value) (PDB_WR_DLY_DLY(base, index, index2, value))
/*@}*/

/*******************************************************************************
 * PDB_POEN - Pulse-Out n Enable Register
 ******************************************************************************/

/*!
 * @brief PDB_POEN - Pulse-Out n Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_POEN register
 */
/*@{*/
#define PDB_RD_POEN(base)        (PDB_POEN_REG(base))
#define PDB_WR_POEN(base, value) (PDB_POEN_REG(base) = (value))
#define PDB_RMW_POEN(base, mask, value) (PDB_WR_POEN(base, (PDB_RD_POEN(base) & ~(mask)) | (value)))
#define PDB_SET_POEN(base, value) (PDB_WR_POEN(base, PDB_RD_POEN(base) |  (value)))
#define PDB_CLR_POEN(base, value) (PDB_WR_POEN(base, PDB_RD_POEN(base) & ~(value)))
#define PDB_TOG_POEN(base, value) (PDB_WR_POEN(base, PDB_RD_POEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_POEN bitfields
 */

/*!
 * @name Register PDB_POEN, field POEN[7:0] (RW)
 *
 * These bits enable the pulse output. Only lower Y bits are implemented in this
 * MCU.
 *
 * Values:
 * - 0 - PDB Pulse-Out disabled
 * - 1 - PDB Pulse-Out enabled
 */
/*@{*/
/*! @brief Read current value of the PDB_POEN_POEN field. */
#define PDB_RD_POEN_POEN(base) ((PDB_POEN_REG(base) & PDB_POEN_POEN_MASK) >> PDB_POEN_POEN_SHIFT)
#define PDB_BRD_POEN_POEN(base) (PDB_RD_POEN_POEN(base))

/*! @brief Set the POEN field to a new value. */
#define PDB_WR_POEN_POEN(base, value) (PDB_RMW_POEN(base, PDB_POEN_POEN_MASK, PDB_POEN_POEN(value)))
#define PDB_BWR_POEN_POEN(base, value) (PDB_WR_POEN_POEN(base, value))
/*@}*/

/*******************************************************************************
 * PDB_PODLY - Pulse-Out n Delay Register
 ******************************************************************************/

/*!
 * @brief PDB_PODLY - Pulse-Out n Delay Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_PODLY register
 */
/*@{*/
#define PDB_RD_PODLY(base, index) (PDB_PODLY_REG(base, index))
#define PDB_WR_PODLY(base, index, value) (PDB_PODLY_REG(base, index) = (value))
#define PDB_RMW_PODLY(base, index, mask, value) (PDB_WR_PODLY(base, index, (PDB_RD_PODLY(base, index) & ~(mask)) | (value)))
#define PDB_SET_PODLY(base, index, value) (PDB_WR_PODLY(base, index, PDB_RD_PODLY(base, index) |  (value)))
#define PDB_CLR_PODLY(base, index, value) (PDB_WR_PODLY(base, index, PDB_RD_PODLY(base, index) & ~(value)))
#define PDB_TOG_PODLY(base, index, value) (PDB_WR_PODLY(base, index, PDB_RD_PODLY(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_PODLY bitfields
 */

/*!
 * @name Register PDB_PODLY, field DLY2[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY2 field. */
#define PDB_RD_PODLY_DLY2(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY2_MASK) >> PDB_PODLY_DLY2_SHIFT)
#define PDB_BRD_PODLY_DLY2(base, index) (PDB_RD_PODLY_DLY2(base, index))

/*! @brief Set the DLY2 field to a new value. */
#define PDB_WR_PODLY_DLY2(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY2_MASK, PDB_PODLY_DLY2(value)))
#define PDB_BWR_PODLY_DLY2(base, index, value) (PDB_WR_PODLY_DLY2(base, index, value))
/*@}*/

/*!
 * @name Register PDB_PODLY, field DLY1[31:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY1 field. */
#define PDB_RD_PODLY_DLY1(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY1_MASK) >> PDB_PODLY_DLY1_SHIFT)
#define PDB_BRD_PODLY_DLY1(base, index) (PDB_RD_PODLY_DLY1(base, index))

/*! @brief Set the DLY1 field to a new value. */
#define PDB_WR_PODLY_DLY1(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY1_MASK, PDB_PODLY_DLY1(value)))
#define PDB_BWR_PODLY_DLY1(base, index, value) (PDB_WR_PODLY_DLY1(base, index, value))
/*@}*/

/*
 * MK20D5 PIT
 *
 * Periodic Interrupt Timer
 *
 * Registers defined in this header file:
 * - PIT_MCR - PIT Module Control Register
 * - PIT_LDVAL - Timer Load Value Register
 * - PIT_CVAL - Current Timer Value Register
 * - PIT_TCTRL - Timer Control Register
 * - PIT_TFLG - Timer Flag Register
 */

#define PIT_INSTANCE_COUNT (1U) /*!< Number of instances of the PIT module. */
#define PIT_IDX (0U) /*!< Instance number for PIT. */

/*******************************************************************************
 * PIT_MCR - PIT Module Control Register
 ******************************************************************************/

/*!
 * @brief PIT_MCR - PIT Module Control Register (RW)
 *
 * Reset value: 0x00000002U
 *
 * This register controls whether the timer clocks should be enabled and whether
 * the timers should run in debug mode.
 */
/*!
 * @name Constants and macros for entire PIT_MCR register
 */
/*@{*/
#define PIT_RD_MCR(base)         (PIT_MCR_REG(base))
#define PIT_WR_MCR(base, value)  (PIT_MCR_REG(base) = (value))
#define PIT_RMW_MCR(base, mask, value) (PIT_WR_MCR(base, (PIT_RD_MCR(base) & ~(mask)) | (value)))
#define PIT_SET_MCR(base, value) (PIT_WR_MCR(base, PIT_RD_MCR(base) |  (value)))
#define PIT_CLR_MCR(base, value) (PIT_WR_MCR(base, PIT_RD_MCR(base) & ~(value)))
#define PIT_TOG_MCR(base, value) (PIT_WR_MCR(base, PIT_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PIT_MCR bitfields
 */

/*!
 * @name Register PIT_MCR, field FRZ[0] (RW)
 *
 * Allows the timers to be stopped when the device enters debug mode.
 *
 * Values:
 * - 0 - Timers continue to run in debug mode.
 * - 1 - Timers are stopped in debug mode.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_FRZ field. */
#define PIT_RD_MCR_FRZ(base) ((PIT_MCR_REG(base) & PIT_MCR_FRZ_MASK) >> PIT_MCR_FRZ_SHIFT)
#define PIT_BRD_MCR_FRZ(base) (BITBAND_ACCESS32(&PIT_MCR_REG(base), PIT_MCR_FRZ_SHIFT))

/*! @brief Set the FRZ field to a new value. */
#define PIT_WR_MCR_FRZ(base, value) (PIT_RMW_MCR(base, PIT_MCR_FRZ_MASK, PIT_MCR_FRZ(value)))
#define PIT_BWR_MCR_FRZ(base, value) (BITBAND_ACCESS32(&PIT_MCR_REG(base), PIT_MCR_FRZ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PIT_MCR, field MDIS[1] (RW)
 *
 * This is used to disable the module clock. This bit must be enabled before any
 * other setup is done.
 *
 * Values:
 * - 0 - Clock for PIT Timers is enabled.
 * - 1 - Clock for PIT Timers is disabled.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_MDIS field. */
#define PIT_RD_MCR_MDIS(base) ((PIT_MCR_REG(base) & PIT_MCR_MDIS_MASK) >> PIT_MCR_MDIS_SHIFT)
#define PIT_BRD_MCR_MDIS(base) (BITBAND_ACCESS32(&PIT_MCR_REG(base), PIT_MCR_MDIS_SHIFT))

/*! @brief Set the MDIS field to a new value. */
#define PIT_WR_MCR_MDIS(base, value) (PIT_RMW_MCR(base, PIT_MCR_MDIS_MASK, PIT_MCR_MDIS(value)))
#define PIT_BWR_MCR_MDIS(base, value) (BITBAND_ACCESS32(&PIT_MCR_REG(base), PIT_MCR_MDIS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PIT_LDVAL - Timer Load Value Register
 ******************************************************************************/

/*!
 * @brief PIT_LDVAL - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts.
 */
/*!
 * @name Constants and macros for entire PIT_LDVAL register
 */
/*@{*/
#define PIT_RD_LDVAL(base, index) (PIT_LDVAL_REG(base, index))
#define PIT_WR_LDVAL(base, index, value) (PIT_LDVAL_REG(base, index) = (value))
#define PIT_RMW_LDVAL(base, index, mask, value) (PIT_WR_LDVAL(base, index, (PIT_RD_LDVAL(base, index) & ~(mask)) | (value)))
#define PIT_SET_LDVAL(base, index, value) (PIT_WR_LDVAL(base, index, PIT_RD_LDVAL(base, index) |  (value)))
#define PIT_CLR_LDVAL(base, index, value) (PIT_WR_LDVAL(base, index, PIT_RD_LDVAL(base, index) & ~(value)))
#define PIT_TOG_LDVAL(base, index, value) (PIT_WR_LDVAL(base, index, PIT_RD_LDVAL(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * PIT_CVAL - Current Timer Value Register
 ******************************************************************************/

/*!
 * @brief PIT_CVAL - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position.
 */
/*!
 * @name Constants and macros for entire PIT_CVAL register
 */
/*@{*/
#define PIT_RD_CVAL(base, index) (PIT_CVAL_REG(base, index))
/*@}*/

/*******************************************************************************
 * PIT_TCTRL - Timer Control Register
 ******************************************************************************/

/*!
 * @brief PIT_TCTRL - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These register contain the control bits for each timer.
 */
/*!
 * @name Constants and macros for entire PIT_TCTRL register
 */
/*@{*/
#define PIT_RD_TCTRL(base, index) (PIT_TCTRL_REG(base, index))
#define PIT_WR_TCTRL(base, index, value) (PIT_TCTRL_REG(base, index) = (value))
#define PIT_RMW_TCTRL(base, index, mask, value) (PIT_WR_TCTRL(base, index, (PIT_RD_TCTRL(base, index) & ~(mask)) | (value)))
#define PIT_SET_TCTRL(base, index, value) (PIT_WR_TCTRL(base, index, PIT_RD_TCTRL(base, index) |  (value)))
#define PIT_CLR_TCTRL(base, index, value) (PIT_WR_TCTRL(base, index, PIT_RD_TCTRL(base, index) & ~(value)))
#define PIT_TOG_TCTRL(base, index, value) (PIT_WR_TCTRL(base, index, PIT_RD_TCTRL(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TCTRL bitfields
 */

/*!
 * @name Register PIT_TCTRL, field TEN[0] (RW)
 *
 * Values:
 * - 0 - Timer n is disabled.
 * - 1 - Timer n is active.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TEN field. */
#define PIT_RD_TCTRL_TEN(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TEN_MASK) >> PIT_TCTRL_TEN_SHIFT)
#define PIT_BRD_TCTRL_TEN(base, index) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TEN_SHIFT))

/*! @brief Set the TEN field to a new value. */
#define PIT_WR_TCTRL_TEN(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TEN_MASK, PIT_TCTRL_TEN(value)))
#define PIT_BWR_TCTRL_TEN(base, index, value) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PIT_TCTRL, field TIE[1] (RW)
 *
 * Values:
 * - 0 - Interrupt requests from Timer n are disabled.
 * - 1 - Interrupt will be requested whenever TIF is set.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TIE field. */
#define PIT_RD_TCTRL_TIE(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TIE_MASK) >> PIT_TCTRL_TIE_SHIFT)
#define PIT_BRD_TCTRL_TIE(base, index) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TIE_SHIFT))

/*! @brief Set the TIE field to a new value. */
#define PIT_WR_TCTRL_TIE(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TIE_MASK, PIT_TCTRL_TIE(value)))
#define PIT_BWR_TCTRL_TIE(base, index, value) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PIT_TFLG - Timer Flag Register
 ******************************************************************************/

/*!
 * @brief PIT_TFLG - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags.
 */
/*!
 * @name Constants and macros for entire PIT_TFLG register
 */
/*@{*/
#define PIT_RD_TFLG(base, index) (PIT_TFLG_REG(base, index))
#define PIT_WR_TFLG(base, index, value) (PIT_TFLG_REG(base, index) = (value))
#define PIT_RMW_TFLG(base, index, mask, value) (PIT_WR_TFLG(base, index, (PIT_RD_TFLG(base, index) & ~(mask)) | (value)))
#define PIT_SET_TFLG(base, index, value) (PIT_WR_TFLG(base, index, PIT_RD_TFLG(base, index) |  (value)))
#define PIT_CLR_TFLG(base, index, value) (PIT_WR_TFLG(base, index, PIT_RD_TFLG(base, index) & ~(value)))
#define PIT_TOG_TFLG(base, index, value) (PIT_WR_TFLG(base, index, PIT_RD_TFLG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TFLG bitfields
 */

/*!
 * @name Register PIT_TFLG, field TIF[0] (W1C)
 *
 * Values:
 * - 0 - Time-out has not yet occurred.
 * - 1 - Time-out has occurred.
 */
/*@{*/
/*! @brief Read current value of the PIT_TFLG_TIF field. */
#define PIT_RD_TFLG_TIF(base, index) ((PIT_TFLG_REG(base, index) & PIT_TFLG_TIF_MASK) >> PIT_TFLG_TIF_SHIFT)
#define PIT_BRD_TFLG_TIF(base, index) (BITBAND_ACCESS32(&PIT_TFLG_REG(base, index), PIT_TFLG_TIF_SHIFT))

/*! @brief Set the TIF field to a new value. */
#define PIT_WR_TFLG_TIF(base, index, value) (PIT_RMW_TFLG(base, index, PIT_TFLG_TIF_MASK, PIT_TFLG_TIF(value)))
#define PIT_BWR_TFLG_TIF(base, index, value) (BITBAND_ACCESS32(&PIT_TFLG_REG(base, index), PIT_TFLG_TIF_SHIFT) = (value))
/*@}*/

/*
 * MK20D5 PMC
 *
 * Power Management Controller
 *
 * Registers defined in this header file:
 * - PMC_LVDSC1 - Low Voltage Detect Status and Control 1 Register
 * - PMC_LVDSC2 - Low Voltage Detect Status and Control 2 Register
 * - PMC_REGSC - Regulator Status and Control Register
 */

#define PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define PMC_IDX (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * PMC_LVDSC1 - Low Voltage Detect Status and Control 1 Register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC1 - Low Voltage Detect Status and Control 1 Register (RW)
 *
 * Reset value: 0x10U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the LVD system is disabled regardless of LVDSC1 settings. To protect
 * systems that must have LVD always on, configure the SMC's power mode
 * protection register (PMPROT) to disallow any very low power or low leakage modes from
 * being enabled. See the device's data sheet for the exact LVD trip voltages. The
 * LVDV bits are reset solely on a POR Only event. The register's other bits are
 * reset on Chip Reset not VLLS. For more information about these reset types,
 * refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define PMC_RD_LVDSC1(base)      (PMC_LVDSC1_REG(base))
#define PMC_WR_LVDSC1(base, value) (PMC_LVDSC1_REG(base) = (value))
#define PMC_RMW_LVDSC1(base, mask, value) (PMC_WR_LVDSC1(base, (PMC_RD_LVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC1(base, value) (PMC_WR_LVDSC1(base, PMC_RD_LVDSC1(base) |  (value)))
#define PMC_CLR_LVDSC1(base, value) (PMC_WR_LVDSC1(base, PMC_RD_LVDSC1(base) & ~(value)))
#define PMC_TOG_LVDSC1(base, value) (PMC_WR_LVDSC1(base, PMC_RD_LVDSC1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDV[1:0] (RW)
 *
 * Selects the LVD trip point voltage (V LVD ).
 *
 * Values:
 * - 00 - Low trip point selected (V LVD = V LVDL )
 * - 01 - High trip point selected (V LVD = V LVDH )
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDV field. */
#define PMC_RD_LVDSC1_LVDV(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDV_MASK) >> PMC_LVDSC1_LVDV_SHIFT)
#define PMC_BRD_LVDSC1_LVDV(base) (PMC_RD_LVDSC1_LVDV(base))

/*! @brief Set the LVDV field to a new value. */
#define PMC_WR_LVDSC1_LVDV(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDV_MASK, PMC_LVDSC1_LVDV(value)))
#define PMC_BWR_LVDSC1_LVDV(base, value) (PMC_WR_LVDSC1_LVDV(base, value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This write-once bit enables LVDF events to generate a hardware reset.
 * Additional writes are ignored.
 *
 * Values:
 * - 0 - LVDF does not generate hardware resets
 * - 1 - Force an MCU reset when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define PMC_RD_LVDSC1_LVDRE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDRE_MASK) >> PMC_LVDSC1_LVDRE_SHIFT)
#define PMC_BRD_LVDSC1_LVDRE(base) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT))

/*! @brief Set the LVDRE field to a new value. */
#define PMC_WR_LVDSC1_LVDRE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDRE_MASK, PMC_LVDSC1_LVDRE(value)))
#define PMC_BWR_LVDSC1_LVDRE(base, value) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVDF = 1.
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define PMC_RD_LVDSC1_LVDIE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDIE_MASK) >> PMC_LVDSC1_LVDIE_SHIFT)
#define PMC_BRD_LVDSC1_LVDIE(base) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT))

/*! @brief Set the LVDIE field to a new value. */
#define PMC_WR_LVDSC1_LVDIE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDIE_MASK, PMC_LVDSC1_LVDIE(value)))
#define PMC_BWR_LVDSC1_LVDIE(base, value) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WORZ)
 *
 * This write-only bit is used to acknowledge low voltage detection errors
 * (write 1 to clear LVDF). Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVDACK field to a new value. */
#define PMC_WR_LVDSC1_LVDACK(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDACK_MASK, PMC_LVDSC1_LVDACK(value)))
#define PMC_BWR_LVDSC1_LVDACK(base, value) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This read-only status bit indicates a low-voltage detect event.
 *
 * Values:
 * - 0 - Low-voltage event not detected
 * - 1 - Low-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define PMC_RD_LVDSC1_LVDF(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDF_MASK) >> PMC_LVDSC1_LVDF_SHIFT)
#define PMC_BRD_LVDSC1_LVDF(base) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDF_SHIFT))
/*@}*/

/*******************************************************************************
 * PMC_LVDSC2 - Low Voltage Detect Status and Control 2 Register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC2 - Low Voltage Detect Status and Control 2 Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * warning function. While the device is in the very low power or low leakage modes,
 * the LVD system is disabled regardless of LVDSC2 settings. See the device's
 * data sheet for the exact LVD trip voltages. The LVW trip voltages depend on LVWV
 * and LVDV bits. The LVWV bits are reset solely on a POR Only event. The
 * register's other bits are reset on Chip Reset not VLLS. For more information about
 * these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define PMC_RD_LVDSC2(base)      (PMC_LVDSC2_REG(base))
#define PMC_WR_LVDSC2(base, value) (PMC_LVDSC2_REG(base) = (value))
#define PMC_RMW_LVDSC2(base, mask, value) (PMC_WR_LVDSC2(base, (PMC_RD_LVDSC2(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC2(base, value) (PMC_WR_LVDSC2(base, PMC_RD_LVDSC2(base) |  (value)))
#define PMC_CLR_LVDSC2(base, value) (PMC_WR_LVDSC2(base, PMC_RD_LVDSC2(base) & ~(value)))
#define PMC_TOG_LVDSC2(base, value) (PMC_WR_LVDSC2(base, PMC_RD_LVDSC2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWV[1:0] (RW)
 *
 * Selects the LVW trip point voltage (V LVW ). The actual voltage for the
 * warning depends on LVDSC1[LVDV].
 *
 * Values:
 * - 00 - Low trip point selected (V LVW = V LVW1 )
 * - 01 - Mid 1 trip point selected (V LVW = V LVW2 )
 * - 10 - Mid 2 trip point selected (V LVW = V LVW3 )
 * - 11 - High trip point selected (V LVW = V LVW4 )
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWV field. */
#define PMC_RD_LVDSC2_LVWV(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWV_MASK) >> PMC_LVDSC2_LVWV_SHIFT)
#define PMC_BRD_LVDSC2_LVWV(base) (PMC_RD_LVDSC2_LVWV(base))

/*! @brief Set the LVWV field to a new value. */
#define PMC_WR_LVDSC2_LVWV(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWV_MASK, PMC_LVDSC2_LVWV(value)))
#define PMC_BWR_LVDSC2_LVWV(base, value) (PMC_WR_LVDSC2_LVWV(base, value))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVWF = 1.
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define PMC_RD_LVDSC2_LVWIE(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWIE_MASK) >> PMC_LVDSC2_LVWIE_SHIFT)
#define PMC_BRD_LVDSC2_LVWIE(base) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT))

/*! @brief Set the LVWIE field to a new value. */
#define PMC_WR_LVDSC2_LVWIE(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWIE_MASK, PMC_LVDSC2_LVWIE(value)))
#define PMC_BWR_LVDSC2_LVWIE(base, value) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWACK[6] (WORZ)
 *
 * This write-only bit is used to acknowledge low voltage warning errors (write
 * 1 to clear LVWF). Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVWACK field to a new value. */
#define PMC_WR_LVDSC2_LVWACK(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWACK_MASK, PMC_LVDSC2_LVWACK(value)))
#define PMC_BWR_LVDSC2_LVWACK(base, value) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This read-only status bit indicates a low-voltage warning event. LVWF is set
 * when V Supply transitions below the trip point or after reset and V Supply is
 * already below V LVW .
 *
 * Values:
 * - 0 - Low-voltage warning event not detected
 * - 1 - Low-voltage warning event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define PMC_RD_LVDSC2_LVWF(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWF_MASK) >> PMC_LVDSC2_LVWF_SHIFT)
#define PMC_BRD_LVDSC2_LVWF(base) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWF_SHIFT))
/*@}*/

/*******************************************************************************
 * PMC_REGSC - Regulator Status and Control Register
 ******************************************************************************/

/*!
 * @brief PMC_REGSC - Regulator Status and Control Register (RW)
 *
 * Reset value: 0x04U
 *
 * The power management controller contains an internal voltage regulator. The
 * voltage regulator design uses a bandgap reference that is also available
 * through a buffer as input to certain internal peripherals, such as the CMP and ADC.
 * The internal regulator provides a status bit (REGONS) indicating the regulator
 * is in run regulation. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. See the Reset section for more
 * information.
 */
/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define PMC_RD_REGSC(base)       (PMC_REGSC_REG(base))
#define PMC_WR_REGSC(base, value) (PMC_REGSC_REG(base) = (value))
#define PMC_RMW_REGSC(base, mask, value) (PMC_WR_REGSC(base, (PMC_RD_REGSC(base) & ~(mask)) | (value)))
#define PMC_SET_REGSC(base, value) (PMC_WR_REGSC(base, PMC_RD_REGSC(base) |  (value)))
#define PMC_CLR_REGSC(base, value) (PMC_WR_REGSC(base, PMC_RD_REGSC(base) & ~(value)))
#define PMC_TOG_REGSC(base, value) (PMC_WR_REGSC(base, PMC_RD_REGSC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BGBE[0] (RW)
 *
 * Enables the bandgap buffer.
 *
 * Values:
 * - 0 - Bandgap buffer not enabled
 * - 1 - Bandgap buffer enabled
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGBE field. */
#define PMC_RD_REGSC_BGBE(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGBE_MASK) >> PMC_REGSC_BGBE_SHIFT)
#define PMC_BRD_REGSC_BGBE(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_BGBE_SHIFT))

/*! @brief Set the BGBE field to a new value. */
#define PMC_WR_REGSC_BGBE(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGBE_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGBE(value)))
#define PMC_BWR_REGSC_BGBE(base, value) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_BGBE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGONS[2] (RO)
 *
 * This read-only bit provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0 - Regulator is in stop regulation or in transition to/from it
 * - 1 - Regulator is in run regulation
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_REGONS field. */
#define PMC_RD_REGSC_REGONS(base) ((PMC_REGSC_REG(base) & PMC_REGSC_REGONS_MASK) >> PMC_REGSC_REGONS_SHIFT)
#define PMC_BRD_REGSC_REGONS(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_REGONS_SHIFT))
/*@}*/

/*!
 * @name Register PMC_REGSC, field ACKISO[3] (W1C)
 *
 * Reading this bit indicates whether certain peripherals and the I/O pads are
 * in a latched state as a result of having been in a VLLS mode. Writing one to
 * this bit when it is set releases the I/O pads and certain peripherals to their
 * normal run mode state. After recovering from a VLLS mode, user should restore
 * chip configuration before clearing ACKISO. In particular, pin configuration for
 * enabled LLWU wakeup pins should be restored to avoid any LLWU flag from being
 * falsely set when ACKISO is cleared.
 *
 * Values:
 * - 0 - Peripherals and I/O pads are in normal run state
 * - 1 - Certain peripherals and I/O pads are in an isolated and latched state
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_ACKISO field. */
#define PMC_RD_REGSC_ACKISO(base) ((PMC_REGSC_REG(base) & PMC_REGSC_ACKISO_MASK) >> PMC_REGSC_ACKISO_SHIFT)
#define PMC_BRD_REGSC_ACKISO(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_ACKISO_SHIFT))

/*! @brief Set the ACKISO field to a new value. */
#define PMC_WR_REGSC_ACKISO(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_ACKISO_MASK, PMC_REGSC_ACKISO(value)))
#define PMC_BWR_REGSC_ACKISO(base, value) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_ACKISO_SHIFT) = (value))
/*@}*/

/*
 * MK20D5 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - PORT_PCR - Pin Control Register n
 * - PORT_GPCLR - Global Pin Control Low Register
 * - PORT_GPCHR - Global Pin Control High Register
 * - PORT_ISFR - Interrupt Status Flag Register
 * - PORT_DFER - Digital Filter Enable Register
 * - PORT_DFCR - Digital Filter Clock Register
 * - PORT_DFWR - Digital Filter Width Register
 */

#define PORT_INSTANCE_COUNT (5U) /*!< Number of instances of the PORT module. */
#define PORTA_IDX (0U) /*!< Instance number for PORTA. */
#define PORTB_IDX (1U) /*!< Instance number for PORTB. */
#define PORTC_IDX (2U) /*!< Instance number for PORTC. */
#define PORTD_IDX (3U) /*!< Instance number for PORTD. */
#define PORTE_IDX (4U) /*!< Instance number for PORTE. */

/*******************************************************************************
 * PORT_PCR - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief PORT_PCR - Pin Control Register n (RW)
 *
 * Reset value: 0x00000000U
 *
 * For PCR1 to PCR5 of the port A, bit 0, 1, 6, 8, 9,10 reset to 1; for the PCR0
 * of the port A, bit 1, 6, 8, 9, 10 reset to 1; in other conditions, all bits
 * reset to 0.
 */
/*!
 * @name Constants and macros for entire PORT_PCR register
 */
/*@{*/
#define PORT_RD_PCR(base, index) (PORT_PCR_REG(base, index))
#define PORT_WR_PCR(base, index, value) (PORT_PCR_REG(base, index) = (value))
#define PORT_RMW_PCR(base, index, mask, value) (PORT_WR_PCR(base, index, (PORT_RD_PCR(base, index) & ~(mask)) | (value)))
#define PORT_SET_PCR(base, index, value) (PORT_WR_PCR(base, index, PORT_RD_PCR(base, index) |  (value)))
#define PORT_CLR_PCR(base, index, value) (PORT_WR_PCR(base, index, PORT_RD_PCR(base, index) & ~(value)))
#define PORT_TOG_PCR(base, index, value) (PORT_WR_PCR(base, index, PORT_RD_PCR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCR bitfields
 */

/*!
 * @name Register PORT_PCR, field PS[0] (RW)
 *
 * Values:
 * - 0 - Internal pull-down resistor is enabled on the corresponding pin, if the
 *     corresponding Port Pull Enable Register bit is set.
 * - 1 - Internal pull-up resistor is enabled on the corresponding pin, if the
 *     corresponding Port Pull Enable Register bit is set.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PS field. */
#define PORT_RD_PCR_PS(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PS_MASK) >> PORT_PCR_PS_SHIFT)
#define PORT_BRD_PCR_PS(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT))

/*! @brief Set the PS field to a new value. */
#define PORT_WR_PCR_PS(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PS(value)))
#define PORT_BWR_PCR_PS(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field PE[1] (RW)
 *
 * Values:
 * - 0 - Internal pull-up or pull-down resistor is not enabled on the
 *     corresponding pin.
 * - 1 - Internal pull-up or pull-down resistor is enabled on the corresponding
 *     pin, provided pin is configured as a digital input.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PE field. */
#define PORT_RD_PCR_PE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PE_MASK) >> PORT_PCR_PE_SHIFT)
#define PORT_BRD_PCR_PE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT))

/*! @brief Set the PE field to a new value. */
#define PORT_WR_PCR_PE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PE(value)))
#define PORT_BWR_PCR_PE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field SRE[2] (RW)
 *
 * Values:
 * - 0 - Fast slew rate is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 1 - Slow slew rate is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_SRE field. */
#define PORT_RD_PCR_SRE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_SRE_MASK) >> PORT_PCR_SRE_SHIFT)
#define PORT_BRD_PCR_SRE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT))

/*! @brief Set the SRE field to a new value. */
#define PORT_WR_PCR_SRE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_SRE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_SRE(value)))
#define PORT_BWR_PCR_SRE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field PFE[4] (RW)
 *
 * Values:
 * - 0 - Passive Input Filter is disabled on the corresponding pin.
 * - 1 - Passive Input Filter is enabled on the corresponding pin, provided pin
 *     is configured as a digital input. A low pass filter (10 MHz to 30 MHz
 *     bandwidth) is enabled on the digital input path. Disable the Passive Input
 *     Filter when supporting high speed interfaces (> 2 MHz) on the pin.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PFE field. */
#define PORT_RD_PCR_PFE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PFE_MASK) >> PORT_PCR_PFE_SHIFT)
#define PORT_BRD_PCR_PFE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT))

/*! @brief Set the PFE field to a new value. */
#define PORT_WR_PCR_PFE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PFE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PFE(value)))
#define PORT_BWR_PCR_PFE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field ODE[5] (RW)
 *
 * Values:
 * - 0 - Open Drain output is disabled on the corresponding pin.
 * - 1 - Open Drain output is enabled on the corresponding pin, provided pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ODE field. */
#define PORT_RD_PCR_ODE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ODE_MASK) >> PORT_PCR_ODE_SHIFT)
#define PORT_BRD_PCR_ODE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ODE_SHIFT))

/*! @brief Set the ODE field to a new value. */
#define PORT_WR_PCR_ODE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_ODE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_ODE(value)))
#define PORT_BWR_PCR_ODE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field DSE[6] (RW)
 *
 * Values:
 * - 0 - Low drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 1 - High drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_DSE field. */
#define PORT_RD_PCR_DSE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_DSE_MASK) >> PORT_PCR_DSE_SHIFT)
#define PORT_BRD_PCR_DSE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT))

/*! @brief Set the DSE field to a new value. */
#define PORT_WR_PCR_DSE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_DSE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_DSE(value)))
#define PORT_BWR_PCR_DSE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field MUX[10:8] (RW)
 *
 * Values:
 * - 000 - Pin Disabled (Analog).
 * - 001 - Alternative 1 (GPIO).
 * - 010 - Alternative 2 (chip specific).
 * - 011 - Alternative 3 (chip specific).
 * - 100 - Alternative 4 (chip specific).
 * - 101 - Alternative 5 (chip specific).
 * - 110 - Alternative 6 (chip specific).
 * - 111 - Alternative 7 (chip specific / JTAG / NMI).
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_MUX field. */
#define PORT_RD_PCR_MUX(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_MUX_MASK) >> PORT_PCR_MUX_SHIFT)
#define PORT_BRD_PCR_MUX(base, index) (PORT_RD_PCR_MUX(base, index))

/*! @brief Set the MUX field to a new value. */
#define PORT_WR_PCR_MUX(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_MUX_MASK | PORT_PCR_ISF_MASK), PORT_PCR_MUX(value)))
#define PORT_BWR_PCR_MUX(base, index, value) (PORT_WR_PCR_MUX(base, index, value))
/*@}*/

/*!
 * @name Register PORT_PCR, field LK[15] (RW)
 *
 * Values:
 * - 0 - Pin Control Register bits [15:0] are not locked.
 * - 1 - Pin Control Register bits [15:0] are locked and cannot be updated until
 *     the next System Reset.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_LK field. */
#define PORT_RD_PCR_LK(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_LK_MASK) >> PORT_PCR_LK_SHIFT)
#define PORT_BRD_PCR_LK(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_LK_SHIFT))

/*! @brief Set the LK field to a new value. */
#define PORT_WR_PCR_LK(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_LK_MASK | PORT_PCR_ISF_MASK), PORT_PCR_LK(value)))
#define PORT_BWR_PCR_LK(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_LK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field IRQC[19:16] (RW)
 *
 * Values:
 * - 0000 - Interrupt/DMA Request disabled.
 * - 0001 - DMA Request on rising edge.
 * - 0010 - DMA Request on falling edge.
 * - 0011 - DMA Request on either edge.
 * - 0100 - Reserved.
 * - 1000 - Interrupt when logic zero.
 * - 1001 - Interrupt on rising edge.
 * - 1010 - Interrupt on falling edge.
 * - 1011 - Interrupt on either edge.
 * - 1100 - Interrupt when logic one.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_IRQC field. */
#define PORT_RD_PCR_IRQC(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_IRQC_MASK) >> PORT_PCR_IRQC_SHIFT)
#define PORT_BRD_PCR_IRQC(base, index) (PORT_RD_PCR_IRQC(base, index))

/*! @brief Set the IRQC field to a new value. */
#define PORT_WR_PCR_IRQC(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_IRQC_MASK | PORT_PCR_ISF_MASK), PORT_PCR_IRQC(value)))
#define PORT_BWR_PCR_IRQC(base, index, value) (PORT_WR_PCR_IRQC(base, index, value))
/*@}*/

/*!
 * @name Register PORT_PCR, field ISF[24] (W1C)
 *
 * Values:
 * - 0 - Configured interrupt has not been detected.
 * - 1 - Configured interrupt has been detected. If pin is configured to
 *     generate a DMA request then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer, otherwise the flag
 *     remains set until a logic one is written to that flag. If configured for a level
 *     sensitive interrupt that remains asserted then flag will set again
 *     immediately.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ISF field. */
#define PORT_RD_PCR_ISF(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ISF_MASK) >> PORT_PCR_ISF_SHIFT)
#define PORT_BRD_PCR_ISF(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT))

/*! @brief Set the ISF field to a new value. */
#define PORT_WR_PCR_ISF(base, index, value) (PORT_RMW_PCR(base, index, PORT_PCR_ISF_MASK, PORT_PCR_ISF(value)))
#define PORT_BWR_PCR_ISF(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define PORT_RD_GPCLR(base)      (PORT_GPCLR_REG(base))
#define PORT_WR_GPCLR(base, value) (PORT_GPCLR_REG(base) = (value))
#define PORT_RMW_GPCLR(base, mask, value) (PORT_WR_GPCLR(base, (PORT_RD_GPCLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Value to be written to bits [15:0] of all Pin Control Registers that are
 * enabled by the Global Pin Write Enable field, provided the corresponding register
 * has not been locked.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCLR_GPWD(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWD_MASK, PORT_GPCLR_GPWD(value)))
#define PORT_BWR_GPCLR_GPWD(base, value) (PORT_WR_GPCLR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * When set, causes bits [15:0] of the corresponding Pin Control Register (15
 * through 0) to update with the value in the Global Pin Write Data field.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCLR_GPWE(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWE_MASK, PORT_GPCLR_GPWE(value)))
#define PORT_BWR_GPCLR_GPWE(base, value) (PORT_WR_GPCLR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define PORT_RD_GPCHR(base)      (PORT_GPCHR_REG(base))
#define PORT_WR_GPCHR(base, value) (PORT_GPCHR_REG(base) = (value))
#define PORT_RMW_GPCHR(base, mask, value) (PORT_WR_GPCHR(base, (PORT_RD_GPCHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Value to be written to bits [15:0] of all Pin Control Registers that are
 * enabled by the Global Pin Write Enable field, provided the corresponding register
 * has not been locked.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCHR_GPWD(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWD_MASK, PORT_GPCHR_GPWD(value)))
#define PORT_BWR_GPCHR_GPWD(base, value) (PORT_WR_GPCHR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * When set, causes bits [15:0] of the corresponding Pin Control Register (31
 * through 16) to update with the value in the Global Pin Write Data field.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCHR_GPWE(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWE_MASK, PORT_GPCHR_GPWE(value)))
#define PORT_BWR_GPCHR_GPWE(base, value) (PORT_WR_GPCHR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * Interrupt Status Flag for each pin is also visible in the corresponding Pin
 * Control Register, and each flag can be cleared in either location.
 */
/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define PORT_RD_ISFR(base)       (PORT_ISFR_REG(base))
#define PORT_WR_ISFR(base, value) (PORT_ISFR_REG(base) = (value))
#define PORT_RMW_ISFR(base, mask, value) (PORT_WR_ISFR(base, (PORT_RD_ISFR(base) & ~(mask)) | (value)))
#define PORT_SET_ISFR(base, value) (PORT_WR_ISFR(base, PORT_RD_ISFR(base) |  (value)))
#define PORT_CLR_ISFR(base, value) (PORT_WR_ISFR(base, PORT_RD_ISFR(base) & ~(value)))
#define PORT_TOG_ISFR(base, value) (PORT_WR_ISFR(base, PORT_RD_ISFR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * PORT_DFER - Digital Filter Enable Register
 ******************************************************************************/

/*!
 * @brief PORT_DFER - Digital Filter Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PORT_DFER register
 */
/*@{*/
#define PORT_RD_DFER(base)       (PORT_DFER_REG(base))
#define PORT_WR_DFER(base, value) (PORT_DFER_REG(base) = (value))
#define PORT_RMW_DFER(base, mask, value) (PORT_WR_DFER(base, (PORT_RD_DFER(base) & ~(mask)) | (value)))
#define PORT_SET_DFER(base, value) (PORT_WR_DFER(base, PORT_RD_DFER(base) |  (value)))
#define PORT_CLR_DFER(base, value) (PORT_WR_DFER(base, PORT_RD_DFER(base) & ~(value)))
#define PORT_TOG_DFER(base, value) (PORT_WR_DFER(base, PORT_RD_DFER(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * PORT_DFCR - Digital Filter Clock Register
 ******************************************************************************/

/*!
 * @brief PORT_DFCR - Digital Filter Clock Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PORT_DFCR register
 */
/*@{*/
#define PORT_RD_DFCR(base)       (PORT_DFCR_REG(base))
#define PORT_WR_DFCR(base, value) (PORT_DFCR_REG(base) = (value))
#define PORT_RMW_DFCR(base, mask, value) (PORT_WR_DFCR(base, (PORT_RD_DFCR(base) & ~(mask)) | (value)))
#define PORT_SET_DFCR(base, value) (PORT_WR_DFCR(base, PORT_RD_DFCR(base) |  (value)))
#define PORT_CLR_DFCR(base, value) (PORT_WR_DFCR(base, PORT_RD_DFCR(base) & ~(value)))
#define PORT_TOG_DFCR(base, value) (PORT_WR_DFCR(base, PORT_RD_DFCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFCR bitfields
 */

/*!
 * @name Register PORT_DFCR, field CS[0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the clock source for the digital input filters. Changing the filter
 * clock source should only be done after disabling all enabled digital filters.
 *
 * Values:
 * - 0 - Digital Filters are clocked by the bus clock.
 * - 1 - Digital Filters are clocked by the 1 kHz LPO clock.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFCR_CS field. */
#define PORT_RD_DFCR_CS(base) ((PORT_DFCR_REG(base) & PORT_DFCR_CS_MASK) >> PORT_DFCR_CS_SHIFT)
#define PORT_BRD_DFCR_CS(base) (BITBAND_ACCESS32(&PORT_DFCR_REG(base), PORT_DFCR_CS_SHIFT))

/*! @brief Set the CS field to a new value. */
#define PORT_WR_DFCR_CS(base, value) (PORT_RMW_DFCR(base, PORT_DFCR_CS_MASK, PORT_DFCR_CS(value)))
#define PORT_BWR_DFCR_CS(base, value) (BITBAND_ACCESS32(&PORT_DFCR_REG(base), PORT_DFCR_CS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PORT_DFWR - Digital Filter Width Register
 ******************************************************************************/

/*!
 * @brief PORT_DFWR - Digital Filter Width Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFWR register
 */
/*@{*/
#define PORT_RD_DFWR(base)       (PORT_DFWR_REG(base))
#define PORT_WR_DFWR(base, value) (PORT_DFWR_REG(base) = (value))
#define PORT_RMW_DFWR(base, mask, value) (PORT_WR_DFWR(base, (PORT_RD_DFWR(base) & ~(mask)) | (value)))
#define PORT_SET_DFWR(base, value) (PORT_WR_DFWR(base, PORT_RD_DFWR(base) |  (value)))
#define PORT_CLR_DFWR(base, value) (PORT_WR_DFWR(base, PORT_RD_DFWR(base) & ~(value)))
#define PORT_TOG_DFWR(base, value) (PORT_WR_DFWR(base, PORT_RD_DFWR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFWR bitfields
 */

/*!
 * @name Register PORT_DFWR, field FILT[4:0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the maximum size of the glitches (in clock cycles) the digital filter
 * absorbs for enabled digital filters. Glitches that are longer than this
 * register setting (in clock cycles) will pass through the digital filter, while
 * glitches that are equal to or less than this register setting (in clock cycles)
 * will be filtered. Changing the filter length should only be done after disabling
 * all enabled filters.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFWR_FILT field. */
#define PORT_RD_DFWR_FILT(base) ((PORT_DFWR_REG(base) & PORT_DFWR_FILT_MASK) >> PORT_DFWR_FILT_SHIFT)
#define PORT_BRD_DFWR_FILT(base) (PORT_RD_DFWR_FILT(base))

/*! @brief Set the FILT field to a new value. */
#define PORT_WR_DFWR_FILT(base, value) (PORT_RMW_DFWR(base, PORT_DFWR_FILT_MASK, PORT_DFWR_FILT(value)))
#define PORT_BWR_DFWR_FILT(base, value) (PORT_WR_DFWR_FILT(base, value))
/*@}*/

/*
 * MK20D5 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - RCM_SRS0 - System Reset Status Register 0
 * - RCM_SRS1 - System Reset Status Register 1
 * - RCM_RPFC - Reset Pin Filter Control Register
 * - RCM_RPFW - Reset Pin Filter Width Register
 * - RCM_MR - Mode Register
 */

#define RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define RCM_IDX (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * RCM_SRS0 - System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief RCM_SRS0 - System Reset Status Register 0 (RO)
 *
 * Reset value: 0x82U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 VLLS mode wakeup due to RESET
 * pin assertion - 0x41 VLLS mode wakeup due to other wakeup sources - 0x01 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS0 register
 */
/*@{*/
#define RCM_RD_SRS0(base)        (RCM_SRS0_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS0 bitfields
 */

/*!
 * @name Register RCM_SRS0, field WAKEUP[0] (RO)
 *
 * Indicates a reset was caused by an enabled LLWU module wakeup source while
 * the chip was in a low leakage mode. In LLS mode, the RESET pin is the only
 * wakeup source that can cause this reset. Any enabled wakeup source in a VLLSx mode
 * causes a reset. This bit is cleared by any reset except WAKEUP.
 *
 * Values:
 * - 0 - Reset not caused by LLWU module wakeup source
 * - 1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WAKEUP field. */
#define RCM_RD_SRS0_WAKEUP(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WAKEUP_MASK) >> RCM_SRS0_WAKEUP_SHIFT)
#define RCM_BRD_SRS0_WAKEUP(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_WAKEUP_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LVD[1] (RO)
 *
 * If the LVDRE bit is set and the supply drops below the LVD trip voltage, an
 * LVD reset occurs. This bit is also set by POR.
 *
 * Values:
 * - 0 - Reset not caused by LVD trip or POR
 * - 1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LVD field. */
#define RCM_RD_SRS0_LVD(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LVD_MASK) >> RCM_SRS0_LVD_SHIFT)
#define RCM_BRD_SRS0_LVD(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_LVD_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOC[2] (RO)
 *
 * Indicates a reset was caused by a loss of external clock. The MCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the detailed
 * MCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0 - Reset not caused by a loss of external clock.
 * - 1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOC field. */
#define RCM_RD_SRS0_LOC(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOC_MASK) >> RCM_SRS0_LOC_SHIFT)
#define RCM_BRD_SRS0_LOC(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_LOC_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOL[3] (RO)
 *
 * Indicates a reset was caused by a loss of lock in the MCG PLL. See the MCG
 * description for information on the loss-of-clock event.
 *
 * Values:
 * - 0 - Reset not caused by a loss of lock in the PLL
 * - 1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOL field. */
#define RCM_RD_SRS0_LOL(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOL_MASK) >> RCM_SRS0_LOL_SHIFT)
#define RCM_BRD_SRS0_LOL(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_LOL_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field WDOG[5] (RO)
 *
 * Indicates a reset was caused by the watchdog timer timing out. This reset
 * source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0 - Reset not caused by watchdog timeout
 * - 1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WDOG field. */
#define RCM_RD_SRS0_WDOG(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WDOG_MASK) >> RCM_SRS0_WDOG_SHIFT)
#define RCM_BRD_SRS0_WDOG(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_WDOG_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field PIN[6] (RO)
 *
 * Indicates a reset was caused by an active-low level on the external RESETpin.
 *
 * Values:
 * - 0 - Reset not caused by external reset pin
 * - 1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_PIN field. */
#define RCM_RD_SRS0_PIN(base) ((RCM_SRS0_REG(base) & RCM_SRS0_PIN_MASK) >> RCM_SRS0_PIN_SHIFT)
#define RCM_BRD_SRS0_PIN(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_PIN_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field POR[7] (RO)
 *
 * Indicates a reset was caused by the power-on detection logic. Because the
 * internal supply voltage was ramping up at the time, the low-voltage reset (LVD)
 * status bit is also set to indicate that the reset occurred while the internal
 * supply was below the LVD threshold.
 *
 * Values:
 * - 0 - Reset not caused by POR
 * - 1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_POR field. */
#define RCM_RD_SRS0_POR(base) ((RCM_SRS0_REG(base) & RCM_SRS0_POR_MASK) >> RCM_SRS0_POR_SHIFT)
#define RCM_BRD_SRS0_POR(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_POR_SHIFT))
/*@}*/

/*******************************************************************************
 * RCM_SRS1 - System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief RCM_SRS1 - System Reset Status Register 1 (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x00 LVD (without POR) - 0x00 VLLS mode wakeup - 0x00 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS1 register
 */
/*@{*/
#define RCM_RD_SRS1(base)        (RCM_SRS1_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS1 bitfields
 */

/*!
 * @name Register RCM_SRS1, field JTAG[0] (RO)
 *
 * Indicates a reset was caused by JTAG selection of certain IR codes (EZPORT,
 * EXTEST, HIGHZ, and CLAMP).
 *
 * Values:
 * - 0 - Reset not caused by JTAG
 * - 1 - Reset caused by JTAG
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_JTAG field. */
#define RCM_RD_SRS1_JTAG(base) ((RCM_SRS1_REG(base) & RCM_SRS1_JTAG_MASK) >> RCM_SRS1_JTAG_SHIFT)
#define RCM_BRD_SRS1_JTAG(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_JTAG_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field LOCKUP[1] (RO)
 *
 * Indicates a reset was caused by the ARM core indication of a LOCKUP event.
 *
 * Values:
 * - 0 - Reset not caused by core LOCKUP event
 * - 1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_LOCKUP field. */
#define RCM_RD_SRS1_LOCKUP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_LOCKUP_MASK) >> RCM_SRS1_LOCKUP_SHIFT)
#define RCM_BRD_SRS1_LOCKUP(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_LOCKUP_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SW[2] (RO)
 *
 * Indicates a reset was caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SW field. */
#define RCM_RD_SRS1_SW(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SW_MASK) >> RCM_SRS1_SW_SHIFT)
#define RCM_BRD_SRS1_SW(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_SW_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field MDM_AP[3] (RO)
 *
 * Indicates a reset was caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_MDM_AP field. */
#define RCM_RD_SRS1_MDM_AP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_MDM_AP_MASK) >> RCM_SRS1_MDM_AP_SHIFT)
#define RCM_BRD_SRS1_MDM_AP(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_MDM_AP_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field EZPT[4] (RO)
 *
 * Indicates a reset was caused by EzPort receiving the RESET command while the
 * device is in EzPort mode.
 *
 * Values:
 * - 0 - Reset not caused by EzPort receiving the RESET command while the device
 *     is in EzPort mode
 * - 1 - Reset caused by EzPort receiving the RESET command while the device is
 *     in EzPort mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_EZPT field. */
#define RCM_RD_SRS1_EZPT(base) ((RCM_SRS1_REG(base) & RCM_SRS1_EZPT_MASK) >> RCM_SRS1_EZPT_SHIFT)
#define RCM_BRD_SRS1_EZPT(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_EZPT_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SACKERR[5] (RO)
 *
 * Indicates a reset was caused, after an attempt to enter stop mode, by a
 * failure of one or more peripherals to acknowledge within approximately one second
 * to enter stop mode.
 *
 * Values:
 * - 0 - Reset not caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 * - 1 - Reset caused by peripheral failure to acknowledge attempt to enter stop
 *     mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SACKERR field. */
#define RCM_RD_SRS1_SACKERR(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SACKERR_MASK) >> RCM_SRS1_SACKERR_SHIFT)
#define RCM_BRD_SRS1_SACKERR(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_SACKERR_SHIFT))
/*@}*/

/*******************************************************************************
 * RCM_RPFC - Reset Pin Filter Control Register
 ******************************************************************************/

/*!
 * @brief RCM_RPFC - Reset Pin Filter Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of bits 2-0 are for Chip POR only. They are unaffected by
 * other reset types. The bus clock filter is reset when disabled or when entering
 * stop mode. The LPO filter is reset when disabled or when entering any low
 * leakage stop mode.
 */
/*!
 * @name Constants and macros for entire RCM_RPFC register
 */
/*@{*/
#define RCM_RD_RPFC(base)        (RCM_RPFC_REG(base))
#define RCM_WR_RPFC(base, value) (RCM_RPFC_REG(base) = (value))
#define RCM_RMW_RPFC(base, mask, value) (RCM_WR_RPFC(base, (RCM_RD_RPFC(base) & ~(mask)) | (value)))
#define RCM_SET_RPFC(base, value) (RCM_WR_RPFC(base, RCM_RD_RPFC(base) |  (value)))
#define RCM_CLR_RPFC(base, value) (RCM_WR_RPFC(base, RCM_RD_RPFC(base) & ~(value)))
#define RCM_TOG_RPFC(base, value) (RCM_WR_RPFC(base, RCM_RD_RPFC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFC bitfields
 */

/*!
 * @name Register RCM_RPFC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 00 - All filtering disabled
 * - 01 - Bus clock filter enabled for normal operation
 * - 10 - LPO clock filter enabled for normal operation
 * - 11 - Reserved (all filtering disabled)
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSRW field. */
#define RCM_RD_RPFC_RSTFLTSRW(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSRW_MASK) >> RCM_RPFC_RSTFLTSRW_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSRW(base) (RCM_RD_RPFC_RSTFLTSRW(base))

/*! @brief Set the RSTFLTSRW field to a new value. */
#define RCM_WR_RPFC_RSTFLTSRW(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSRW_MASK, RCM_RPFC_RSTFLTSRW(value)))
#define RCM_BWR_RPFC_RSTFLTSRW(base, value) (RCM_WR_RPFC_RSTFLTSRW(base, value))
/*@}*/

/*!
 * @name Register RCM_RPFC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in stop mode.
 *
 * Values:
 * - 0 - All filtering disabled
 * - 1 - LPO clock filter enabled
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSS field. */
#define RCM_RD_RPFC_RSTFLTSS(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSS_MASK) >> RCM_RPFC_RSTFLTSS_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSS(base) (BITBAND_ACCESS8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSS_SHIFT))

/*! @brief Set the RSTFLTSS field to a new value. */
#define RCM_WR_RPFC_RSTFLTSS(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSS_MASK, RCM_RPFC_RSTFLTSS(value)))
#define RCM_BWR_RPFC_RSTFLTSS(base, value) (BITBAND_ACCESS8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RCM_RPFW - Reset Pin Filter Width Register
 ******************************************************************************/

/*!
 * @brief RCM_RPFW - Reset Pin Filter Width Register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of the bits in the RSTFLTSEL field are for Chip POR only.
 * They are unaffected by other reset types.
 */
/*!
 * @name Constants and macros for entire RCM_RPFW register
 */
/*@{*/
#define RCM_RD_RPFW(base)        (RCM_RPFW_REG(base))
#define RCM_WR_RPFW(base, value) (RCM_RPFW_REG(base) = (value))
#define RCM_RMW_RPFW(base, mask, value) (RCM_WR_RPFW(base, (RCM_RD_RPFW(base) & ~(mask)) | (value)))
#define RCM_SET_RPFW(base, value) (RCM_WR_RPFW(base, RCM_RD_RPFW(base) |  (value)))
#define RCM_CLR_RPFW(base, value) (RCM_WR_RPFW(base, RCM_RD_RPFW(base) & ~(value)))
#define RCM_TOG_RPFW(base, value) (RCM_WR_RPFW(base, RCM_RD_RPFW(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFW bitfields
 */

/*!
 * @name Register RCM_RPFW, field RSTFLTSEL[4:0] (RW)
 *
 * Selects the reset pin bus clock filter width.
 *
 * Values:
 * - 00000 - Bus clock filter count is 1
 * - 00001 - Bus clock filter count is 2
 * - 00010 - Bus clock filter count is 3
 * - 00011 - Bus clock filter count is 4
 * - 00100 - Bus clock filter count is 5
 * - 00101 - Bus clock filter count is 6
 * - 00110 - Bus clock filter count is 7
 * - 00111 - Bus clock filter count is 8
 * - 01000 - Bus clock filter count is 9
 * - 01001 - Bus clock filter count is 10
 * - 01010 - Bus clock filter count is 11
 * - 01011 - Bus clock filter count is 12
 * - 01100 - Bus clock filter count is 13
 * - 01101 - Bus clock filter count is 14
 * - 01110 - Bus clock filter count is 15
 * - 01111 - Bus clock filter count is 16
 * - 10000 - Bus clock filter count is 17
 * - 10001 - Bus clock filter count is 18
 * - 10010 - Bus clock filter count is 19
 * - 10011 - Bus clock filter count is 20
 * - 10100 - Bus clock filter count is 21
 * - 10101 - Bus clock filter count is 22
 * - 10110 - Bus clock filter count is 23
 * - 10111 - Bus clock filter count is 24
 * - 11000 - Bus clock filter count is 25
 * - 11001 - Bus clock filter count is 26
 * - 11010 - Bus clock filter count is 27
 * - 11011 - Bus clock filter count is 28
 * - 11100 - Bus clock filter count is 29
 * - 11101 - Bus clock filter count is 30
 * - 11110 - Bus clock filter count is 31
 * - 11111 - Bus clock filter count is 32
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFW_RSTFLTSEL field. */
#define RCM_RD_RPFW_RSTFLTSEL(base) ((RCM_RPFW_REG(base) & RCM_RPFW_RSTFLTSEL_MASK) >> RCM_RPFW_RSTFLTSEL_SHIFT)
#define RCM_BRD_RPFW_RSTFLTSEL(base) (RCM_RD_RPFW_RSTFLTSEL(base))

/*! @brief Set the RSTFLTSEL field to a new value. */
#define RCM_WR_RPFW_RSTFLTSEL(base, value) (RCM_RMW_RPFW(base, RCM_RPFW_RSTFLTSEL_MASK, RCM_RPFW_RSTFLTSEL(value)))
#define RCM_BWR_RPFW_RSTFLTSEL(base, value) (RCM_WR_RPFW_RSTFLTSEL(base, value))
/*@}*/

/*******************************************************************************
 * RCM_MR - Mode Register
 ******************************************************************************/

/*!
 * @brief RCM_MR - Mode Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the state of the
 * mode pins during the last Chip Reset.
 */
/*!
 * @name Constants and macros for entire RCM_MR register
 */
/*@{*/
#define RCM_RD_MR(base)          (RCM_MR_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_MR bitfields
 */

/*!
 * @name Register RCM_MR, field EZP_MS[1] (RO)
 *
 * Reflects the state of the EZP_MS pin during the last Chip Reset
 *
 * Values:
 * - 0 - Pin negated (logic 1)
 * - 1 - Pin asserted (logic 0)
 */
/*@{*/
/*! @brief Read current value of the RCM_MR_EZP_MS field. */
#define RCM_RD_MR_EZP_MS(base) ((RCM_MR_REG(base) & RCM_MR_EZP_MS_MASK) >> RCM_MR_EZP_MS_SHIFT)
#define RCM_BRD_MR_EZP_MS(base) (BITBAND_ACCESS8(&RCM_MR_REG(base), RCM_MR_EZP_MS_SHIFT))
/*@}*/

/*
 * MK20D5 RFSYS
 *
 * System register file
 *
 * Registers defined in this header file:
 * - RFSYS_REG - Register file register
 */

#define RFSYS_INSTANCE_COUNT (1U) /*!< Number of instances of the RFSYS module. */
#define RFSYS_IDX (0U) /*!< Instance number for RFSYS. */

/*******************************************************************************
 * RFSYS_REG - Register file register
 ******************************************************************************/

/*!
 * @brief RFSYS_REG - Register file register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each register can be accessed as 8-, 16-, or 32-bits.
 */
/*!
 * @name Constants and macros for entire RFSYS_REG register
 */
/*@{*/
#define RFSYS_RD_REG(base, index) (RFSYS_REG_REG(base, index))
#define RFSYS_WR_REG(base, index, value) (RFSYS_REG_REG(base, index) = (value))
#define RFSYS_RMW_REG(base, index, mask, value) (RFSYS_WR_REG(base, index, (RFSYS_RD_REG(base, index) & ~(mask)) | (value)))
#define RFSYS_SET_REG(base, index, value) (RFSYS_WR_REG(base, index, RFSYS_RD_REG(base, index) |  (value)))
#define RFSYS_CLR_REG(base, index, value) (RFSYS_WR_REG(base, index, RFSYS_RD_REG(base, index) & ~(value)))
#define RFSYS_TOG_REG(base, index, value) (RFSYS_WR_REG(base, index, RFSYS_RD_REG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RFSYS_REG bitfields
 */

/*!
 * @name Register RFSYS_REG, field LL[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_LL field. */
#define RFSYS_RD_REG_LL(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_LL_MASK) >> RFSYS_REG_LL_SHIFT)
#define RFSYS_BRD_REG_LL(base, index) (RFSYS_RD_REG_LL(base, index))

/*! @brief Set the LL field to a new value. */
#define RFSYS_WR_REG_LL(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_LL_MASK, RFSYS_REG_LL(value)))
#define RFSYS_BWR_REG_LL(base, index, value) (RFSYS_WR_REG_LL(base, index, value))
/*@}*/

/*!
 * @name Register RFSYS_REG, field LH[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_LH field. */
#define RFSYS_RD_REG_LH(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_LH_MASK) >> RFSYS_REG_LH_SHIFT)
#define RFSYS_BRD_REG_LH(base, index) (RFSYS_RD_REG_LH(base, index))

/*! @brief Set the LH field to a new value. */
#define RFSYS_WR_REG_LH(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_LH_MASK, RFSYS_REG_LH(value)))
#define RFSYS_BWR_REG_LH(base, index, value) (RFSYS_WR_REG_LH(base, index, value))
/*@}*/

/*!
 * @name Register RFSYS_REG, field HL[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_HL field. */
#define RFSYS_RD_REG_HL(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_HL_MASK) >> RFSYS_REG_HL_SHIFT)
#define RFSYS_BRD_REG_HL(base, index) (RFSYS_RD_REG_HL(base, index))

/*! @brief Set the HL field to a new value. */
#define RFSYS_WR_REG_HL(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_HL_MASK, RFSYS_REG_HL(value)))
#define RFSYS_BWR_REG_HL(base, index, value) (RFSYS_WR_REG_HL(base, index, value))
/*@}*/

/*!
 * @name Register RFSYS_REG, field HH[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_HH field. */
#define RFSYS_RD_REG_HH(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_HH_MASK) >> RFSYS_REG_HH_SHIFT)
#define RFSYS_BRD_REG_HH(base, index) (RFSYS_RD_REG_HH(base, index))

/*! @brief Set the HH field to a new value. */
#define RFSYS_WR_REG_HH(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_HH_MASK, RFSYS_REG_HH(value)))
#define RFSYS_BWR_REG_HH(base, index, value) (RFSYS_WR_REG_HH(base, index, value))
/*@}*/

/*
 * MK20D5 RFVBAT
 *
 * VBAT register file
 *
 * Registers defined in this header file:
 * - RFVBAT_REG - VBAT register file register
 */

#define RFVBAT_INSTANCE_COUNT (1U) /*!< Number of instances of the RFVBAT module. */
#define RFVBAT_IDX (0U) /*!< Instance number for RFVBAT. */

/*******************************************************************************
 * RFVBAT_REG - VBAT register file register
 ******************************************************************************/

/*!
 * @brief RFVBAT_REG - VBAT register file register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each register can be accessed as 8-, 16-, or 32-bits.
 */
/*!
 * @name Constants and macros for entire RFVBAT_REG register
 */
/*@{*/
#define RFVBAT_RD_REG(base, index) (RFVBAT_REG_REG(base, index))
#define RFVBAT_WR_REG(base, index, value) (RFVBAT_REG_REG(base, index) = (value))
#define RFVBAT_RMW_REG(base, index, mask, value) (RFVBAT_WR_REG(base, index, (RFVBAT_RD_REG(base, index) & ~(mask)) | (value)))
#define RFVBAT_SET_REG(base, index, value) (RFVBAT_WR_REG(base, index, RFVBAT_RD_REG(base, index) |  (value)))
#define RFVBAT_CLR_REG(base, index, value) (RFVBAT_WR_REG(base, index, RFVBAT_RD_REG(base, index) & ~(value)))
#define RFVBAT_TOG_REG(base, index, value) (RFVBAT_WR_REG(base, index, RFVBAT_RD_REG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RFVBAT_REG bitfields
 */

/*!
 * @name Register RFVBAT_REG, field LL[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_LL field. */
#define RFVBAT_RD_REG_LL(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_LL_MASK) >> RFVBAT_REG_LL_SHIFT)
#define RFVBAT_BRD_REG_LL(base, index) (RFVBAT_RD_REG_LL(base, index))

/*! @brief Set the LL field to a new value. */
#define RFVBAT_WR_REG_LL(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_LL_MASK, RFVBAT_REG_LL(value)))
#define RFVBAT_BWR_REG_LL(base, index, value) (RFVBAT_WR_REG_LL(base, index, value))
/*@}*/

/*!
 * @name Register RFVBAT_REG, field LH[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_LH field. */
#define RFVBAT_RD_REG_LH(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_LH_MASK) >> RFVBAT_REG_LH_SHIFT)
#define RFVBAT_BRD_REG_LH(base, index) (RFVBAT_RD_REG_LH(base, index))

/*! @brief Set the LH field to a new value. */
#define RFVBAT_WR_REG_LH(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_LH_MASK, RFVBAT_REG_LH(value)))
#define RFVBAT_BWR_REG_LH(base, index, value) (RFVBAT_WR_REG_LH(base, index, value))
/*@}*/

/*!
 * @name Register RFVBAT_REG, field HL[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_HL field. */
#define RFVBAT_RD_REG_HL(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_HL_MASK) >> RFVBAT_REG_HL_SHIFT)
#define RFVBAT_BRD_REG_HL(base, index) (RFVBAT_RD_REG_HL(base, index))

/*! @brief Set the HL field to a new value. */
#define RFVBAT_WR_REG_HL(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_HL_MASK, RFVBAT_REG_HL(value)))
#define RFVBAT_BWR_REG_HL(base, index, value) (RFVBAT_WR_REG_HL(base, index, value))
/*@}*/

/*!
 * @name Register RFVBAT_REG, field HH[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_HH field. */
#define RFVBAT_RD_REG_HH(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_HH_MASK) >> RFVBAT_REG_HH_SHIFT)
#define RFVBAT_BRD_REG_HH(base, index) (RFVBAT_RD_REG_HH(base, index))

/*! @brief Set the HH field to a new value. */
#define RFVBAT_WR_REG_HH(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_HH_MASK, RFVBAT_REG_HH(value)))
#define RFVBAT_BWR_REG_HH(base, index, value) (RFVBAT_WR_REG_HH(base, index, value))
/*@}*/

/*
 * MK20D5 RTC
 *
 * Secure Real Time Clock
 *
 * Registers defined in this header file:
 * - RTC_TSR - RTC Time Seconds Register
 * - RTC_TPR - RTC Time Prescaler Register
 * - RTC_TAR - RTC Time Alarm Register
 * - RTC_TCR - RTC Time Compensation Register
 * - RTC_CR - RTC Control Register
 * - RTC_SR - RTC Status Register
 * - RTC_LR - RTC Lock Register
 * - RTC_IER - RTC Interrupt Enable Register
 * - RTC_WAR - RTC Write Access Register
 * - RTC_RAR - RTC Read Access Register
 */

#define RTC_INSTANCE_COUNT (1U) /*!< Number of instances of the RTC module. */
#define RTC_IDX (0U) /*!< Instance number for RTC. */

/*******************************************************************************
 * RTC_TSR - RTC Time Seconds Register
 ******************************************************************************/

/*!
 * @brief RTC_TSR - RTC Time Seconds Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TSR register
 */
/*@{*/
#define RTC_RD_TSR(base)         (RTC_TSR_REG(base))
#define RTC_WR_TSR(base, value)  (RTC_TSR_REG(base) = (value))
#define RTC_RMW_TSR(base, mask, value) (RTC_WR_TSR(base, (RTC_RD_TSR(base) & ~(mask)) | (value)))
#define RTC_SET_TSR(base, value) (RTC_WR_TSR(base, RTC_RD_TSR(base) |  (value)))
#define RTC_CLR_TSR(base, value) (RTC_WR_TSR(base, RTC_RD_TSR(base) & ~(value)))
#define RTC_TOG_TSR(base, value) (RTC_WR_TSR(base, RTC_RD_TSR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * RTC_TPR - RTC Time Prescaler Register
 ******************************************************************************/

/*!
 * @brief RTC_TPR - RTC Time Prescaler Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TPR register
 */
/*@{*/
#define RTC_RD_TPR(base)         (RTC_TPR_REG(base))
#define RTC_WR_TPR(base, value)  (RTC_TPR_REG(base) = (value))
#define RTC_RMW_TPR(base, mask, value) (RTC_WR_TPR(base, (RTC_RD_TPR(base) & ~(mask)) | (value)))
#define RTC_SET_TPR(base, value) (RTC_WR_TPR(base, RTC_RD_TPR(base) |  (value)))
#define RTC_CLR_TPR(base, value) (RTC_WR_TPR(base, RTC_RD_TPR(base) & ~(value)))
#define RTC_TOG_TPR(base, value) (RTC_WR_TPR(base, RTC_RD_TPR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TPR bitfields
 */

/*!
 * @name Register RTC_TPR, field TPR[15:0] (RW)
 *
 * When the time counter is enabled, the TPR is read only and increments every
 * 32.768 kHz clock cycle. The time counter will read as zero when SR[TOF] or
 * SR[TIF] are set. When the time counter is disabled, the TPR can be read or
 * written. The TSR[TSR] increments when bit 14 of the TPR transitions from a logic one
 * to a logic zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_TPR_TPR field. */
#define RTC_RD_TPR_TPR(base) ((RTC_TPR_REG(base) & RTC_TPR_TPR_MASK) >> RTC_TPR_TPR_SHIFT)
#define RTC_BRD_TPR_TPR(base) (RTC_RD_TPR_TPR(base))

/*! @brief Set the TPR field to a new value. */
#define RTC_WR_TPR_TPR(base, value) (RTC_RMW_TPR(base, RTC_TPR_TPR_MASK, RTC_TPR_TPR(value)))
#define RTC_BWR_TPR_TPR(base, value) (RTC_WR_TPR_TPR(base, value))
/*@}*/

/*******************************************************************************
 * RTC_TAR - RTC Time Alarm Register
 ******************************************************************************/

/*!
 * @brief RTC_TAR - RTC Time Alarm Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TAR register
 */
/*@{*/
#define RTC_RD_TAR(base)         (RTC_TAR_REG(base))
#define RTC_WR_TAR(base, value)  (RTC_TAR_REG(base) = (value))
#define RTC_RMW_TAR(base, mask, value) (RTC_WR_TAR(base, (RTC_RD_TAR(base) & ~(mask)) | (value)))
#define RTC_SET_TAR(base, value) (RTC_WR_TAR(base, RTC_RD_TAR(base) |  (value)))
#define RTC_CLR_TAR(base, value) (RTC_WR_TAR(base, RTC_RD_TAR(base) & ~(value)))
#define RTC_TOG_TAR(base, value) (RTC_WR_TAR(base, RTC_RD_TAR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * RTC_TCR - RTC Time Compensation Register
 ******************************************************************************/

/*!
 * @brief RTC_TCR - RTC Time Compensation Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TCR register
 */
/*@{*/
#define RTC_RD_TCR(base)         (RTC_TCR_REG(base))
#define RTC_WR_TCR(base, value)  (RTC_TCR_REG(base) = (value))
#define RTC_RMW_TCR(base, mask, value) (RTC_WR_TCR(base, (RTC_RD_TCR(base) & ~(mask)) | (value)))
#define RTC_SET_TCR(base, value) (RTC_WR_TCR(base, RTC_RD_TCR(base) |  (value)))
#define RTC_CLR_TCR(base, value) (RTC_WR_TCR(base, RTC_RD_TCR(base) & ~(value)))
#define RTC_TOG_TCR(base, value) (RTC_WR_TCR(base, RTC_RD_TCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TCR bitfields
 */

/*!
 * @name Register RTC_TCR, field TCR[7:0] (RW)
 *
 * Configures the number of 32.768 kHz clock cycles in each second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 *
 * Values:
 * - 10000000 - Time prescaler register overflows every 32896 clock cycles.
 * - 11111111 - Time prescaler register overflows every 32769 clock cycles.
 * - 0 - Time prescaler register overflows every 32768 clock cycles.
 * - 1 - Time prescaler register overflows every 32767 clock cycles.
 * - 1111111 - Time prescaler register overflows every 32641 clock cycles.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCR field. */
#define RTC_RD_TCR_TCR(base) ((RTC_TCR_REG(base) & RTC_TCR_TCR_MASK) >> RTC_TCR_TCR_SHIFT)
#define RTC_BRD_TCR_TCR(base) (RTC_RD_TCR_TCR(base))

/*! @brief Set the TCR field to a new value. */
#define RTC_WR_TCR_TCR(base, value) (RTC_RMW_TCR(base, RTC_TCR_TCR_MASK, RTC_TCR_TCR(value)))
#define RTC_BWR_TCR_TCR(base, value) (RTC_WR_TCR_TCR(base, value))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIR[15:8] (RW)
 *
 * Configures the compensation interval in seconds from 1 to 256 to control how
 * frequently the TCR should adjust the number of 32.768 kHz cycles in each
 * second. The value written should be one less than the number of seconds (for
 * example, write zero to configure for a compensation interval of one second). This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIR field. */
#define RTC_RD_TCR_CIR(base) ((RTC_TCR_REG(base) & RTC_TCR_CIR_MASK) >> RTC_TCR_CIR_SHIFT)
#define RTC_BRD_TCR_CIR(base) (RTC_RD_TCR_CIR(base))

/*! @brief Set the CIR field to a new value. */
#define RTC_WR_TCR_CIR(base, value) (RTC_RMW_TCR(base, RTC_TCR_CIR_MASK, RTC_TCR_CIR(value)))
#define RTC_BWR_TCR_CIR(base, value) (RTC_WR_TCR_CIR(base, value))
/*@}*/

/*!
 * @name Register RTC_TCR, field TCV[23:16] (RO)
 *
 * Current value used by the compensation logic for the present second interval.
 * Updated once a second if the CIC equals 0 with the contents of the TCR field.
 * If the CIC does not equal zero then it is loaded with zero (compensation is
 * not enabled for that second increment).
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCV field. */
#define RTC_RD_TCR_TCV(base) ((RTC_TCR_REG(base) & RTC_TCR_TCV_MASK) >> RTC_TCR_TCV_SHIFT)
#define RTC_BRD_TCR_TCV(base) (RTC_RD_TCR_TCV(base))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIC[31:24] (RO)
 *
 * Current value of the compensation interval counter. If the compensation
 * interval counter equals zero then it is loaded with the contents of the CIR. If the
 * CIC does not equal zero then it is decremented once a second.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIC field. */
#define RTC_RD_TCR_CIC(base) ((RTC_TCR_REG(base) & RTC_TCR_CIC_MASK) >> RTC_TCR_CIC_SHIFT)
#define RTC_BRD_TCR_CIC(base) (RTC_RD_TCR_CIC(base))
/*@}*/

/*******************************************************************************
 * RTC_CR - RTC Control Register
 ******************************************************************************/

/*!
 * @brief RTC_CR - RTC Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_CR register
 */
/*@{*/
#define RTC_RD_CR(base)          (RTC_CR_REG(base))
#define RTC_WR_CR(base, value)   (RTC_CR_REG(base) = (value))
#define RTC_RMW_CR(base, mask, value) (RTC_WR_CR(base, (RTC_RD_CR(base) & ~(mask)) | (value)))
#define RTC_SET_CR(base, value)  (RTC_WR_CR(base, RTC_RD_CR(base) |  (value)))
#define RTC_CLR_CR(base, value)  (RTC_WR_CR(base, RTC_RD_CR(base) & ~(value)))
#define RTC_TOG_CR(base, value)  (RTC_WR_CR(base, RTC_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_CR bitfields
 */

/*!
 * @name Register RTC_CR, field SWR[0] (RW)
 *
 * Values:
 * - 0 - No effect
 * - 1 - Resets all RTC registers except for the SWR bit and the RTC_WAR and
 *     RTC_RAR registers. The SWR bit is cleared after VBAT POR and by software
 *     explicitly clearing it.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SWR field. */
#define RTC_RD_CR_SWR(base)  ((RTC_CR_REG(base) & RTC_CR_SWR_MASK) >> RTC_CR_SWR_SHIFT)
#define RTC_BRD_CR_SWR(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SWR_SHIFT))

/*! @brief Set the SWR field to a new value. */
#define RTC_WR_CR_SWR(base, value) (RTC_RMW_CR(base, RTC_CR_SWR_MASK, RTC_CR_SWR(value)))
#define RTC_BWR_CR_SWR(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SWR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field WPE[1] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0 - Wakeup pin is disabled.
 * - 1 - Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt
 *     asserts and the chip is powered down.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_WPE field. */
#define RTC_RD_CR_WPE(base)  ((RTC_CR_REG(base) & RTC_CR_WPE_MASK) >> RTC_CR_WPE_SHIFT)
#define RTC_BRD_CR_WPE(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPE_SHIFT))

/*! @brief Set the WPE field to a new value. */
#define RTC_WR_CR_WPE(base, value) (RTC_RMW_CR(base, RTC_CR_WPE_MASK, RTC_CR_WPE(value)))
#define RTC_BWR_CR_WPE(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SUP[2] (RW)
 *
 * Values:
 * - 0 - Non-supervisor mode write accesses are not supported and generate a bus
 *     error.
 * - 1 - Non-supervisor mode write accesses are supported.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SUP field. */
#define RTC_RD_CR_SUP(base)  ((RTC_CR_REG(base) & RTC_CR_SUP_MASK) >> RTC_CR_SUP_SHIFT)
#define RTC_BRD_CR_SUP(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SUP_SHIFT))

/*! @brief Set the SUP field to a new value. */
#define RTC_WR_CR_SUP(base, value) (RTC_RMW_CR(base, RTC_CR_SUP_MASK, RTC_CR_SUP(value)))
#define RTC_BWR_CR_SUP(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SUP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field UM[3] (RW)
 *
 * Allows the SR[TCE] to be written even when the Status Register is locked.
 * When set, the SR[TCE] can always be written if the SR[TIF] or SR[TOF] are set or
 * if the SR[TCE] is clear.
 *
 * Values:
 * - 0 - Registers cannot be written when locked.
 * - 1 - Registers can be written when locked under limited conditions.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_UM field. */
#define RTC_RD_CR_UM(base)   ((RTC_CR_REG(base) & RTC_CR_UM_MASK) >> RTC_CR_UM_SHIFT)
#define RTC_BRD_CR_UM(base)  (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_UM_SHIFT))

/*! @brief Set the UM field to a new value. */
#define RTC_WR_CR_UM(base, value) (RTC_RMW_CR(base, RTC_CR_UM_MASK, RTC_CR_UM(value)))
#define RTC_BWR_CR_UM(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_UM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field OSCE[8] (RW)
 *
 * Values:
 * - 0 - 32.768 kHz oscillator is disabled.
 * - 1 - 32.768 kHz oscillator is enabled. After setting this bit, wait the
 *     oscillator startup time before enabling the time counter to allow the 32.768
 *     kHz clock time to stabilize.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_OSCE field. */
#define RTC_RD_CR_OSCE(base) ((RTC_CR_REG(base) & RTC_CR_OSCE_MASK) >> RTC_CR_OSCE_SHIFT)
#define RTC_BRD_CR_OSCE(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_OSCE_SHIFT))

/*! @brief Set the OSCE field to a new value. */
#define RTC_WR_CR_OSCE(base, value) (RTC_RMW_CR(base, RTC_CR_OSCE_MASK, RTC_CR_OSCE(value)))
#define RTC_BWR_CR_OSCE(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_OSCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field CLKO[9] (RW)
 *
 * Values:
 * - 0 - The 32kHz clock is output to other peripherals
 * - 1 - The 32kHz clock is not output to other peripherals
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_CLKO field. */
#define RTC_RD_CR_CLKO(base) ((RTC_CR_REG(base) & RTC_CR_CLKO_MASK) >> RTC_CR_CLKO_SHIFT)
#define RTC_BRD_CR_CLKO(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_CLKO_SHIFT))

/*! @brief Set the CLKO field to a new value. */
#define RTC_WR_CR_CLKO(base, value) (RTC_RMW_CR(base, RTC_CR_CLKO_MASK, RTC_CR_CLKO(value)))
#define RTC_BWR_CR_CLKO(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_CLKO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC16P[10] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC16P field. */
#define RTC_RD_CR_SC16P(base) ((RTC_CR_REG(base) & RTC_CR_SC16P_MASK) >> RTC_CR_SC16P_SHIFT)
#define RTC_BRD_CR_SC16P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC16P_SHIFT))

/*! @brief Set the SC16P field to a new value. */
#define RTC_WR_CR_SC16P(base, value) (RTC_RMW_CR(base, RTC_CR_SC16P_MASK, RTC_CR_SC16P(value)))
#define RTC_BWR_CR_SC16P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC16P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC8P[11] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC8P field. */
#define RTC_RD_CR_SC8P(base) ((RTC_CR_REG(base) & RTC_CR_SC8P_MASK) >> RTC_CR_SC8P_SHIFT)
#define RTC_BRD_CR_SC8P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC8P_SHIFT))

/*! @brief Set the SC8P field to a new value. */
#define RTC_WR_CR_SC8P(base, value) (RTC_RMW_CR(base, RTC_CR_SC8P_MASK, RTC_CR_SC8P(value)))
#define RTC_BWR_CR_SC8P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC8P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC4P[12] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC4P field. */
#define RTC_RD_CR_SC4P(base) ((RTC_CR_REG(base) & RTC_CR_SC4P_MASK) >> RTC_CR_SC4P_SHIFT)
#define RTC_BRD_CR_SC4P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC4P_SHIFT))

/*! @brief Set the SC4P field to a new value. */
#define RTC_WR_CR_SC4P(base, value) (RTC_RMW_CR(base, RTC_CR_SC4P_MASK, RTC_CR_SC4P(value)))
#define RTC_BWR_CR_SC4P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC4P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC2P[13] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC2P field. */
#define RTC_RD_CR_SC2P(base) ((RTC_CR_REG(base) & RTC_CR_SC2P_MASK) >> RTC_CR_SC2P_SHIFT)
#define RTC_BRD_CR_SC2P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC2P_SHIFT))

/*! @brief Set the SC2P field to a new value. */
#define RTC_WR_CR_SC2P(base, value) (RTC_RMW_CR(base, RTC_CR_SC2P_MASK, RTC_CR_SC2P(value)))
#define RTC_BWR_CR_SC2P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC2P_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_SR - RTC Status Register
 ******************************************************************************/

/*!
 * @brief RTC_SR - RTC Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire RTC_SR register
 */
/*@{*/
#define RTC_RD_SR(base)          (RTC_SR_REG(base))
#define RTC_WR_SR(base, value)   (RTC_SR_REG(base) = (value))
#define RTC_RMW_SR(base, mask, value) (RTC_WR_SR(base, (RTC_RD_SR(base) & ~(mask)) | (value)))
#define RTC_SET_SR(base, value)  (RTC_WR_SR(base, RTC_RD_SR(base) |  (value)))
#define RTC_CLR_SR(base, value)  (RTC_WR_SR(base, RTC_RD_SR(base) & ~(value)))
#define RTC_TOG_SR(base, value)  (RTC_WR_SR(base, RTC_RD_SR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_SR bitfields
 */

/*!
 * @name Register RTC_SR, field TIF[0] (RO)
 *
 * The time invalid flag is set on VBAT POR or software reset. The TSR and TPR
 * do not increment and read as zero when this bit is set. This bit is cleared by
 * writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time is valid.
 * - 1 - Time is invalid and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TIF field. */
#define RTC_RD_SR_TIF(base)  ((RTC_SR_REG(base) & RTC_SR_TIF_MASK) >> RTC_SR_TIF_SHIFT)
#define RTC_BRD_SR_TIF(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TIF_SHIFT))
/*@}*/

/*!
 * @name Register RTC_SR, field TOF[1] (RO)
 *
 * Time overflow flag is set when the time counter is enabled and overflows. The
 * TSR and TPR do not increment and read as zero when this bit is set. This bit
 * is cleared by writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time overflow has not occurred.
 * - 1 - Time overflow has occurred and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TOF field. */
#define RTC_RD_SR_TOF(base)  ((RTC_SR_REG(base) & RTC_SR_TOF_MASK) >> RTC_SR_TOF_SHIFT)
#define RTC_BRD_SR_TOF(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TOF_SHIFT))
/*@}*/

/*!
 * @name Register RTC_SR, field TAF[2] (RO)
 *
 * Time alarm flag is set when the TAR[TAR] equals the TSR[TSR] and the TSR[TSR]
 * increments. This bit is cleared by writing the TAR register.
 *
 * Values:
 * - 0 - Time alarm has not occurred.
 * - 1 - Time alarm has occurred.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TAF field. */
#define RTC_RD_SR_TAF(base)  ((RTC_SR_REG(base) & RTC_SR_TAF_MASK) >> RTC_SR_TAF_SHIFT)
#define RTC_BRD_SR_TAF(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TAF_SHIFT))
/*@}*/

/*!
 * @name Register RTC_SR, field TCE[4] (RW)
 *
 * When time counter is disabled the TSR register and TPR register are
 * writeable, but do not increment. When time counter is enabled the TSR register and TPR
 * register are not writeable, but increment.
 *
 * Values:
 * - 0 - Time counter is disabled.
 * - 1 - Time counter is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TCE field. */
#define RTC_RD_SR_TCE(base)  ((RTC_SR_REG(base) & RTC_SR_TCE_MASK) >> RTC_SR_TCE_SHIFT)
#define RTC_BRD_SR_TCE(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TCE_SHIFT))

/*! @brief Set the TCE field to a new value. */
#define RTC_WR_SR_TCE(base, value) (RTC_RMW_SR(base, RTC_SR_TCE_MASK, RTC_SR_TCE(value)))
#define RTC_BWR_SR_TCE(base, value) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TCE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_LR - RTC Lock Register
 ******************************************************************************/

/*!
 * @brief RTC_LR - RTC Lock Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_LR register
 */
/*@{*/
#define RTC_RD_LR(base)          (RTC_LR_REG(base))
#define RTC_WR_LR(base, value)   (RTC_LR_REG(base) = (value))
#define RTC_RMW_LR(base, mask, value) (RTC_WR_LR(base, (RTC_RD_LR(base) & ~(mask)) | (value)))
#define RTC_SET_LR(base, value)  (RTC_WR_LR(base, RTC_RD_LR(base) |  (value)))
#define RTC_CLR_LR(base, value)  (RTC_WR_LR(base, RTC_RD_LR(base) & ~(value)))
#define RTC_TOG_LR(base, value)  (RTC_WR_LR(base, RTC_RD_LR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_LR bitfields
 */

/*!
 * @name Register RTC_LR, field TCL[3] (RW)
 *
 * Once cleared, this bit can only be set by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Time compensation register is locked and writes are ignored.
 * - 1 - Time compensation register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_TCL field. */
#define RTC_RD_LR_TCL(base)  ((RTC_LR_REG(base) & RTC_LR_TCL_MASK) >> RTC_LR_TCL_SHIFT)
#define RTC_BRD_LR_TCL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_TCL_SHIFT))

/*! @brief Set the TCL field to a new value. */
#define RTC_WR_LR_TCL(base, value) (RTC_RMW_LR(base, RTC_LR_TCL_MASK, RTC_LR_TCL(value)))
#define RTC_BWR_LR_TCL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_TCL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_LR, field CRL[4] (RW)
 *
 * Once cleared, this bit can only be set by VBAT POR.
 *
 * Values:
 * - 0 - Control register is locked and writes are ignored.
 * - 1 - Control register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_CRL field. */
#define RTC_RD_LR_CRL(base)  ((RTC_LR_REG(base) & RTC_LR_CRL_MASK) >> RTC_LR_CRL_SHIFT)
#define RTC_BRD_LR_CRL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_CRL_SHIFT))

/*! @brief Set the CRL field to a new value. */
#define RTC_WR_LR_CRL(base, value) (RTC_RMW_LR(base, RTC_LR_CRL_MASK, RTC_LR_CRL(value)))
#define RTC_BWR_LR_CRL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_CRL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_LR, field SRL[5] (RW)
 *
 * Once cleared, this bit can only be set by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Status register is locked and writes are ignored.
 * - 1 - Status register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_SRL field. */
#define RTC_RD_LR_SRL(base)  ((RTC_LR_REG(base) & RTC_LR_SRL_MASK) >> RTC_LR_SRL_SHIFT)
#define RTC_BRD_LR_SRL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_SRL_SHIFT))

/*! @brief Set the SRL field to a new value. */
#define RTC_WR_LR_SRL(base, value) (RTC_RMW_LR(base, RTC_LR_SRL_MASK, RTC_LR_SRL(value)))
#define RTC_BWR_LR_SRL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_SRL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_LR, field LRL[6] (RW)
 *
 * Once cleared, this bit can only be set by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Lock register is locked and writes are ignored.
 * - 1 - Lock register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_LRL field. */
#define RTC_RD_LR_LRL(base)  ((RTC_LR_REG(base) & RTC_LR_LRL_MASK) >> RTC_LR_LRL_SHIFT)
#define RTC_BRD_LR_LRL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_LRL_SHIFT))

/*! @brief Set the LRL field to a new value. */
#define RTC_WR_LR_LRL(base, value) (RTC_RMW_LR(base, RTC_LR_LRL_MASK, RTC_LR_LRL(value)))
#define RTC_BWR_LR_LRL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_LRL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_IER - RTC Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief RTC_IER - RTC Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000007U
 */
/*!
 * @name Constants and macros for entire RTC_IER register
 */
/*@{*/
#define RTC_RD_IER(base)         (RTC_IER_REG(base))
#define RTC_WR_IER(base, value)  (RTC_IER_REG(base) = (value))
#define RTC_RMW_IER(base, mask, value) (RTC_WR_IER(base, (RTC_RD_IER(base) & ~(mask)) | (value)))
#define RTC_SET_IER(base, value) (RTC_WR_IER(base, RTC_RD_IER(base) |  (value)))
#define RTC_CLR_IER(base, value) (RTC_WR_IER(base, RTC_RD_IER(base) & ~(value)))
#define RTC_TOG_IER(base, value) (RTC_WR_IER(base, RTC_RD_IER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_IER bitfields
 */

/*!
 * @name Register RTC_IER, field TIIE[0] (RW)
 *
 * Values:
 * - 0 - Time invalid flag does not generate an interrupt.
 * - 1 - Time invalid flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TIIE field. */
#define RTC_RD_IER_TIIE(base) ((RTC_IER_REG(base) & RTC_IER_TIIE_MASK) >> RTC_IER_TIIE_SHIFT)
#define RTC_BRD_IER_TIIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TIIE_SHIFT))

/*! @brief Set the TIIE field to a new value. */
#define RTC_WR_IER_TIIE(base, value) (RTC_RMW_IER(base, RTC_IER_TIIE_MASK, RTC_IER_TIIE(value)))
#define RTC_BWR_IER_TIIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TIIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TOIE[1] (RW)
 *
 * Values:
 * - 0 - Time overflow flag does not generate an interrupt.
 * - 1 - Time overflow flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TOIE field. */
#define RTC_RD_IER_TOIE(base) ((RTC_IER_REG(base) & RTC_IER_TOIE_MASK) >> RTC_IER_TOIE_SHIFT)
#define RTC_BRD_IER_TOIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TOIE_SHIFT))

/*! @brief Set the TOIE field to a new value. */
#define RTC_WR_IER_TOIE(base, value) (RTC_RMW_IER(base, RTC_IER_TOIE_MASK, RTC_IER_TOIE(value)))
#define RTC_BWR_IER_TOIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TOIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TAIE[2] (RW)
 *
 * Values:
 * - 0 - Time alarm flag does not generate an interrupt.
 * - 1 - Time alarm flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TAIE field. */
#define RTC_RD_IER_TAIE(base) ((RTC_IER_REG(base) & RTC_IER_TAIE_MASK) >> RTC_IER_TAIE_SHIFT)
#define RTC_BRD_IER_TAIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TAIE_SHIFT))

/*! @brief Set the TAIE field to a new value. */
#define RTC_WR_IER_TAIE(base, value) (RTC_RMW_IER(base, RTC_IER_TAIE_MASK, RTC_IER_TAIE(value)))
#define RTC_BWR_IER_TAIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TAIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TSIE[4] (RW)
 *
 * The seconds interrupt is an edge-sensitive interrupt with a dedicated
 * interrupt vector. It is generated once a second and requires no software overhead
 * (there is no corresponding status flag to clear).
 *
 * Values:
 * - 0 - Seconds interrupt is disabled.
 * - 1 - Seconds interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TSIE field. */
#define RTC_RD_IER_TSIE(base) ((RTC_IER_REG(base) & RTC_IER_TSIE_MASK) >> RTC_IER_TSIE_SHIFT)
#define RTC_BRD_IER_TSIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TSIE_SHIFT))

/*! @brief Set the TSIE field to a new value. */
#define RTC_WR_IER_TSIE(base, value) (RTC_RMW_IER(base, RTC_IER_TSIE_MASK, RTC_IER_TSIE(value)))
#define RTC_BWR_IER_TSIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TSIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_WAR - RTC Write Access Register
 ******************************************************************************/

/*!
 * @brief RTC_WAR - RTC Write Access Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_WAR register
 */
/*@{*/
#define RTC_RD_WAR(base)         (RTC_WAR_REG(base))
#define RTC_WR_WAR(base, value)  (RTC_WAR_REG(base) = (value))
#define RTC_RMW_WAR(base, mask, value) (RTC_WR_WAR(base, (RTC_RD_WAR(base) & ~(mask)) | (value)))
#define RTC_SET_WAR(base, value) (RTC_WR_WAR(base, RTC_RD_WAR(base) |  (value)))
#define RTC_CLR_WAR(base, value) (RTC_WR_WAR(base, RTC_RD_WAR(base) & ~(value)))
#define RTC_TOG_WAR(base, value) (RTC_WR_WAR(base, RTC_RD_WAR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_WAR bitfields
 */

/*!
 * @name Register RTC_WAR, field TSRW[0] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the time seconds register are ignored.
 * - 1 - Writes to the time seconds register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TSRW field. */
#define RTC_RD_WAR_TSRW(base) ((RTC_WAR_REG(base) & RTC_WAR_TSRW_MASK) >> RTC_WAR_TSRW_SHIFT)
#define RTC_BRD_WAR_TSRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TSRW_SHIFT))

/*! @brief Set the TSRW field to a new value. */
#define RTC_WR_WAR_TSRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TSRW_MASK, RTC_WAR_TSRW(value)))
#define RTC_BWR_WAR_TSRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TSRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field TPRW[1] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the time prescaler register are ignored.
 * - 1 - Writes to the time prescaler register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TPRW field. */
#define RTC_RD_WAR_TPRW(base) ((RTC_WAR_REG(base) & RTC_WAR_TPRW_MASK) >> RTC_WAR_TPRW_SHIFT)
#define RTC_BRD_WAR_TPRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TPRW_SHIFT))

/*! @brief Set the TPRW field to a new value. */
#define RTC_WR_WAR_TPRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TPRW_MASK, RTC_WAR_TPRW(value)))
#define RTC_BWR_WAR_TPRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TPRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field TARW[2] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the time alarm register are ignored.
 * - 1 - Writes to the time alarm register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TARW field. */
#define RTC_RD_WAR_TARW(base) ((RTC_WAR_REG(base) & RTC_WAR_TARW_MASK) >> RTC_WAR_TARW_SHIFT)
#define RTC_BRD_WAR_TARW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TARW_SHIFT))

/*! @brief Set the TARW field to a new value. */
#define RTC_WR_WAR_TARW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TARW_MASK, RTC_WAR_TARW(value)))
#define RTC_BWR_WAR_TARW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TARW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field TCRW[3] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the time compensation register are ignored.
 * - 1 - Writes to the time compensation register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TCRW field. */
#define RTC_RD_WAR_TCRW(base) ((RTC_WAR_REG(base) & RTC_WAR_TCRW_MASK) >> RTC_WAR_TCRW_SHIFT)
#define RTC_BRD_WAR_TCRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TCRW_SHIFT))

/*! @brief Set the TCRW field to a new value. */
#define RTC_WR_WAR_TCRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TCRW_MASK, RTC_WAR_TCRW(value)))
#define RTC_BWR_WAR_TCRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TCRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field CRW[4] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the control register are ignored.
 * - 1 - Writes to the control register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_CRW field. */
#define RTC_RD_WAR_CRW(base) ((RTC_WAR_REG(base) & RTC_WAR_CRW_MASK) >> RTC_WAR_CRW_SHIFT)
#define RTC_BRD_WAR_CRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_CRW_SHIFT))

/*! @brief Set the CRW field to a new value. */
#define RTC_WR_WAR_CRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_CRW_MASK, RTC_WAR_CRW(value)))
#define RTC_BWR_WAR_CRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_CRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field SRW[5] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the status register are ignored.
 * - 1 - Writes to the status register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_SRW field. */
#define RTC_RD_WAR_SRW(base) ((RTC_WAR_REG(base) & RTC_WAR_SRW_MASK) >> RTC_WAR_SRW_SHIFT)
#define RTC_BRD_WAR_SRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_SRW_SHIFT))

/*! @brief Set the SRW field to a new value. */
#define RTC_WR_WAR_SRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_SRW_MASK, RTC_WAR_SRW(value)))
#define RTC_BWR_WAR_SRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_SRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field LRW[6] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the lock register are ignored.
 * - 1 - Writes to the lock register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_LRW field. */
#define RTC_RD_WAR_LRW(base) ((RTC_WAR_REG(base) & RTC_WAR_LRW_MASK) >> RTC_WAR_LRW_SHIFT)
#define RTC_BRD_WAR_LRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_LRW_SHIFT))

/*! @brief Set the LRW field to a new value. */
#define RTC_WR_WAR_LRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_LRW_MASK, RTC_WAR_LRW(value)))
#define RTC_BWR_WAR_LRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_LRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field IERW[7] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the interupt enable register are ignored.
 * - 1 - Writes to the interrupt enable register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_IERW field. */
#define RTC_RD_WAR_IERW(base) ((RTC_WAR_REG(base) & RTC_WAR_IERW_MASK) >> RTC_WAR_IERW_SHIFT)
#define RTC_BRD_WAR_IERW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_IERW_SHIFT))

/*! @brief Set the IERW field to a new value. */
#define RTC_WR_WAR_IERW(base, value) (RTC_RMW_WAR(base, RTC_WAR_IERW_MASK, RTC_WAR_IERW(value)))
#define RTC_BWR_WAR_IERW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_IERW_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_RAR - RTC Read Access Register
 ******************************************************************************/

/*!
 * @brief RTC_RAR - RTC Read Access Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_RAR register
 */
/*@{*/
#define RTC_RD_RAR(base)         (RTC_RAR_REG(base))
#define RTC_WR_RAR(base, value)  (RTC_RAR_REG(base) = (value))
#define RTC_RMW_RAR(base, mask, value) (RTC_WR_RAR(base, (RTC_RD_RAR(base) & ~(mask)) | (value)))
#define RTC_SET_RAR(base, value) (RTC_WR_RAR(base, RTC_RD_RAR(base) |  (value)))
#define RTC_CLR_RAR(base, value) (RTC_WR_RAR(base, RTC_RD_RAR(base) & ~(value)))
#define RTC_TOG_RAR(base, value) (RTC_WR_RAR(base, RTC_RD_RAR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_RAR bitfields
 */

/*!
 * @name Register RTC_RAR, field TSRR[0] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the time seconds register are ignored.
 * - 1 - Reads to the time seconds register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TSRR field. */
#define RTC_RD_RAR_TSRR(base) ((RTC_RAR_REG(base) & RTC_RAR_TSRR_MASK) >> RTC_RAR_TSRR_SHIFT)
#define RTC_BRD_RAR_TSRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TSRR_SHIFT))

/*! @brief Set the TSRR field to a new value. */
#define RTC_WR_RAR_TSRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TSRR_MASK, RTC_RAR_TSRR(value)))
#define RTC_BWR_RAR_TSRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TSRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field TPRR[1] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the time prescaler register are ignored.
 * - 1 - Reads to the time prescaler register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TPRR field. */
#define RTC_RD_RAR_TPRR(base) ((RTC_RAR_REG(base) & RTC_RAR_TPRR_MASK) >> RTC_RAR_TPRR_SHIFT)
#define RTC_BRD_RAR_TPRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TPRR_SHIFT))

/*! @brief Set the TPRR field to a new value. */
#define RTC_WR_RAR_TPRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TPRR_MASK, RTC_RAR_TPRR(value)))
#define RTC_BWR_RAR_TPRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TPRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field TARR[2] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the time alarm register are ignored.
 * - 1 - Reads to the time alarm register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TARR field. */
#define RTC_RD_RAR_TARR(base) ((RTC_RAR_REG(base) & RTC_RAR_TARR_MASK) >> RTC_RAR_TARR_SHIFT)
#define RTC_BRD_RAR_TARR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TARR_SHIFT))

/*! @brief Set the TARR field to a new value. */
#define RTC_WR_RAR_TARR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TARR_MASK, RTC_RAR_TARR(value)))
#define RTC_BWR_RAR_TARR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TARR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field TCRR[3] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset
 *
 * Values:
 * - 0 - Reads to the time compensation register are ignored.
 * - 1 - Reads to the time compensation register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TCRR field. */
#define RTC_RD_RAR_TCRR(base) ((RTC_RAR_REG(base) & RTC_RAR_TCRR_MASK) >> RTC_RAR_TCRR_SHIFT)
#define RTC_BRD_RAR_TCRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TCRR_SHIFT))

/*! @brief Set the TCRR field to a new value. */
#define RTC_WR_RAR_TCRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TCRR_MASK, RTC_RAR_TCRR(value)))
#define RTC_BWR_RAR_TCRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TCRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field CRR[4] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the control register are ignored.
 * - 1 - Reads to the control register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_CRR field. */
#define RTC_RD_RAR_CRR(base) ((RTC_RAR_REG(base) & RTC_RAR_CRR_MASK) >> RTC_RAR_CRR_SHIFT)
#define RTC_BRD_RAR_CRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_CRR_SHIFT))

/*! @brief Set the CRR field to a new value. */
#define RTC_WR_RAR_CRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_CRR_MASK, RTC_RAR_CRR(value)))
#define RTC_BWR_RAR_CRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_CRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field SRR[5] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the status register are ignored.
 * - 1 - Reads to the status register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_SRR field. */
#define RTC_RD_RAR_SRR(base) ((RTC_RAR_REG(base) & RTC_RAR_SRR_MASK) >> RTC_RAR_SRR_SHIFT)
#define RTC_BRD_RAR_SRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_SRR_SHIFT))

/*! @brief Set the SRR field to a new value. */
#define RTC_WR_RAR_SRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_SRR_MASK, RTC_RAR_SRR(value)))
#define RTC_BWR_RAR_SRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_SRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field LRR[6] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the lock register are ignored.
 * - 1 - Reads to the lock register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_LRR field. */
#define RTC_RD_RAR_LRR(base) ((RTC_RAR_REG(base) & RTC_RAR_LRR_MASK) >> RTC_RAR_LRR_SHIFT)
#define RTC_BRD_RAR_LRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_LRR_SHIFT))

/*! @brief Set the LRR field to a new value. */
#define RTC_WR_RAR_LRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_LRR_MASK, RTC_RAR_LRR(value)))
#define RTC_BWR_RAR_LRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_LRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field IERR[7] (RW)
 *
 * Once cleared, this bit is only set by system reset. It is not affected by
 * VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the interrupt enable register are ignored.
 * - 1 - Reads to the interrupt enable register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_IERR field. */
#define RTC_RD_RAR_IERR(base) ((RTC_RAR_REG(base) & RTC_RAR_IERR_MASK) >> RTC_RAR_IERR_SHIFT)
#define RTC_BRD_RAR_IERR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_IERR_SHIFT))

/*! @brief Set the IERR field to a new value. */
#define RTC_WR_RAR_IERR(base, value) (RTC_RMW_RAR(base, RTC_RAR_IERR_MASK, RTC_RAR_IERR(value)))
#define RTC_BWR_RAR_IERR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_IERR_SHIFT) = (value))
/*@}*/

/*
 * MK20D5 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - SIM_SOPT1 - System Options Register 1
 * - SIM_SOPT1CFG - SOPT1 Configuration Register
 * - SIM_SOPT2 - System Options Register 2
 * - SIM_SOPT4 - System Options Register 4
 * - SIM_SOPT5 - System Options Register 5
 * - SIM_SOPT7 - System Options Register 7
 * - SIM_SDID - System Device Identification Register
 * - SIM_SCGC4 - System Clock Gating Control Register 4
 * - SIM_SCGC5 - System Clock Gating Control Register 5
 * - SIM_SCGC6 - System Clock Gating Control Register 6
 * - SIM_SCGC7 - System Clock Gating Control Register 7
 * - SIM_CLKDIV1 - System Clock Divider Register 1
 * - SIM_CLKDIV2 - System Clock Divider Register 2
 * - SIM_FCFG1 - Flash Configuration Register 1
 * - SIM_FCFG2 - Flash Configuration Register 2
 * - SIM_UIDH - Unique Identification Register High
 * - SIM_UIDMH - Unique Identification Register Mid-High
 * - SIM_UIDML - Unique Identification Register Mid Low
 * - SIM_UIDL - Unique Identification Register Low
 */

#define SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define SIM_IDX (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * SIM_SOPT1 - System Options Register 1
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1 - System Options Register 1 (RW)
 *
 * Reset value: 0x80000000U
 *
 * The SOPT1 register is only reset on POR or LVD.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1 register
 */
/*@{*/
#define SIM_RD_SOPT1(base)       (SIM_SOPT1_REG(base))
#define SIM_WR_SOPT1(base, value) (SIM_SOPT1_REG(base) = (value))
#define SIM_RMW_SOPT1(base, mask, value) (SIM_WR_SOPT1(base, (SIM_RD_SOPT1(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1(base, value) (SIM_WR_SOPT1(base, SIM_RD_SOPT1(base) |  (value)))
#define SIM_CLR_SOPT1(base, value) (SIM_WR_SOPT1(base, SIM_RD_SOPT1(base) & ~(value)))
#define SIM_TOG_SOPT1(base, value) (SIM_WR_SOPT1(base, SIM_RD_SOPT1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1 bitfields
 */

/*!
 * @name Register SIM_SOPT1, field RAMSIZE[15:12] (RO)
 *
 * This field specifies the amount of system RAM available on the device.
 *
 * Values:
 * - 0000 - Undefined
 * - 0001 - 8 KBytes
 * - 0010 - Undefined
 * - 0011 - 16 KBytes
 * - 0100 - Undefined
 * - 0101 - Undefined
 * - 0110 - Undefined
 * - 0111 - Undefined
 * - 1000 - Undefined
 * - 1001 - Undefined
 * - 1010 - Undefined
 * - 1011 - Undefined
 * - 1100 - Undefined
 * - 1101 - Undefined
 * - 1110 - Undefined
 * - 1111 - Undefined
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_RAMSIZE field. */
#define SIM_RD_SOPT1_RAMSIZE(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_RAMSIZE_MASK) >> SIM_SOPT1_RAMSIZE_SHIFT)
#define SIM_BRD_SOPT1_RAMSIZE(base) (SIM_RD_SOPT1_RAMSIZE(base))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field OSC32KSEL[19:18] (RW)
 *
 * Selects the 32 kHz clock source (ERCLK32K) for TSI and LPTMR. This bit is
 * reset only for POR/LVD.
 *
 * Values:
 * - 00 - System oscillator (OSC32KCLK)
 * - 01 - Reserved
 * - 10 - RTC 32.768kHz oscillator
 * - 11 - LPO 1 kHz
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_OSC32KSEL field. */
#define SIM_RD_SOPT1_OSC32KSEL(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHIFT)
#define SIM_BRD_SOPT1_OSC32KSEL(base) (SIM_RD_SOPT1_OSC32KSEL(base))

/*! @brief Set the OSC32KSEL field to a new value. */
#define SIM_WR_SOPT1_OSC32KSEL(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_OSC32KSEL_MASK, SIM_SOPT1_OSC32KSEL(value)))
#define SIM_BWR_SOPT1_OSC32KSEL(base, value) (SIM_WR_SOPT1_OSC32KSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBVSTBY[29] (RW)
 *
 * Controls whether the USB voltage regulator is placed in standby mode during
 * VLPR and VLPW modes.
 *
 * Values:
 * - 0 - USB voltage regulator not in standby during VLPR and VLPW modes.
 * - 1 - USB voltage regulator in standby during VLPR and VLPW modes.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_USBVSTBY field. */
#define SIM_RD_SOPT1_USBVSTBY(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_USBVSTBY_MASK) >> SIM_SOPT1_USBVSTBY_SHIFT)
#define SIM_BRD_SOPT1_USBVSTBY(base) (BITBAND_ACCESS32(&SIM_SOPT1_REG(base), SIM_SOPT1_USBVSTBY_SHIFT))

/*! @brief Set the USBVSTBY field to a new value. */
#define SIM_WR_SOPT1_USBVSTBY(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_USBVSTBY_MASK, SIM_SOPT1_USBVSTBY(value)))
#define SIM_BWR_SOPT1_USBVSTBY(base, value) (BITBAND_ACCESS32(&SIM_SOPT1_REG(base), SIM_SOPT1_USBVSTBY_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBSSTBY[30] (RW)
 *
 * Controls whether the USB voltage regulator is placed in standby mode during
 * Stop, VLPS, LLS and VLLS modes.
 *
 * Values:
 * - 0 - USB voltage regulator not in standby during Stop, VLPS, LLS and VLLS
 *     modes.
 * - 1 - USB voltage regulator in standby during Stop, VLPS, LLS and VLLS modes.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_USBSSTBY field. */
#define SIM_RD_SOPT1_USBSSTBY(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_USBSSTBY_MASK) >> SIM_SOPT1_USBSSTBY_SHIFT)
#define SIM_BRD_SOPT1_USBSSTBY(base) (BITBAND_ACCESS32(&SIM_SOPT1_REG(base), SIM_SOPT1_USBSSTBY_SHIFT))

/*! @brief Set the USBSSTBY field to a new value. */
#define SIM_WR_SOPT1_USBSSTBY(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_USBSSTBY_MASK, SIM_SOPT1_USBSSTBY(value)))
#define SIM_BWR_SOPT1_USBSSTBY(base, value) (BITBAND_ACCESS32(&SIM_SOPT1_REG(base), SIM_SOPT1_USBSSTBY_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBREGEN[31] (RW)
 *
 * Controls whether the USB voltage regulator is enabled.
 *
 * Values:
 * - 0 - USB voltage regulator is disabled.
 * - 1 - USB voltage regulator is enabled.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_USBREGEN field. */
#define SIM_RD_SOPT1_USBREGEN(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_USBREGEN_MASK) >> SIM_SOPT1_USBREGEN_SHIFT)
#define SIM_BRD_SOPT1_USBREGEN(base) (BITBAND_ACCESS32(&SIM_SOPT1_REG(base), SIM_SOPT1_USBREGEN_SHIFT))

/*! @brief Set the USBREGEN field to a new value. */
#define SIM_WR_SOPT1_USBREGEN(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_USBREGEN_MASK, SIM_SOPT1_USBREGEN(value)))
#define SIM_BWR_SOPT1_USBREGEN(base, value) (BITBAND_ACCESS32(&SIM_SOPT1_REG(base), SIM_SOPT1_USBREGEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SOPT1CFG - SOPT1 Configuration Register
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1CFG - SOPT1 Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SOPT1CFG register is reset on System Reset not VLLS.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1CFG register
 */
/*@{*/
#define SIM_RD_SOPT1CFG(base)    (SIM_SOPT1CFG_REG(base))
#define SIM_WR_SOPT1CFG(base, value) (SIM_SOPT1CFG_REG(base) = (value))
#define SIM_RMW_SOPT1CFG(base, mask, value) (SIM_WR_SOPT1CFG(base, (SIM_RD_SOPT1CFG(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1CFG(base, value) (SIM_WR_SOPT1CFG(base, SIM_RD_SOPT1CFG(base) |  (value)))
#define SIM_CLR_SOPT1CFG(base, value) (SIM_WR_SOPT1CFG(base, SIM_RD_SOPT1CFG(base) & ~(value)))
#define SIM_TOG_SOPT1CFG(base, value) (SIM_WR_SOPT1CFG(base, SIM_RD_SOPT1CFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1CFG bitfields
 */

/*!
 * @name Register SIM_SOPT1CFG, field URWE[24] (RW)
 *
 * Writing one to the URWE bit allows the SOPT1 USBREGEN bit to be written. This
 * register bit clears after a write to USBREGEN.
 *
 * Values:
 * - 0 - SOPT1 USBREGEN cannot be written.
 * - 1 - SOPT1 USBREGEN can be written.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1CFG_URWE field. */
#define SIM_RD_SOPT1CFG_URWE(base) ((SIM_SOPT1CFG_REG(base) & SIM_SOPT1CFG_URWE_MASK) >> SIM_SOPT1CFG_URWE_SHIFT)
#define SIM_BRD_SOPT1CFG_URWE(base) (BITBAND_ACCESS32(&SIM_SOPT1CFG_REG(base), SIM_SOPT1CFG_URWE_SHIFT))

/*! @brief Set the URWE field to a new value. */
#define SIM_WR_SOPT1CFG_URWE(base, value) (SIM_RMW_SOPT1CFG(base, SIM_SOPT1CFG_URWE_MASK, SIM_SOPT1CFG_URWE(value)))
#define SIM_BWR_SOPT1CFG_URWE(base, value) (BITBAND_ACCESS32(&SIM_SOPT1CFG_REG(base), SIM_SOPT1CFG_URWE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT1CFG, field UVSWE[25] (RW)
 *
 * Writing one to the UVSWE bit allows the SOPT1 USBSSTB bit to be written. This
 * register bit clears after a write to USBVSTB.
 *
 * Values:
 * - 0 - SOPT1 USBVSTB cannot be written.
 * - 1 - SOPT1 USBVSTB can be written.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1CFG_UVSWE field. */
#define SIM_RD_SOPT1CFG_UVSWE(base) ((SIM_SOPT1CFG_REG(base) & SIM_SOPT1CFG_UVSWE_MASK) >> SIM_SOPT1CFG_UVSWE_SHIFT)
#define SIM_BRD_SOPT1CFG_UVSWE(base) (BITBAND_ACCESS32(&SIM_SOPT1CFG_REG(base), SIM_SOPT1CFG_UVSWE_SHIFT))

/*! @brief Set the UVSWE field to a new value. */
#define SIM_WR_SOPT1CFG_UVSWE(base, value) (SIM_RMW_SOPT1CFG(base, SIM_SOPT1CFG_UVSWE_MASK, SIM_SOPT1CFG_UVSWE(value)))
#define SIM_BWR_SOPT1CFG_UVSWE(base, value) (BITBAND_ACCESS32(&SIM_SOPT1CFG_REG(base), SIM_SOPT1CFG_UVSWE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT1CFG, field USSWE[26] (RW)
 *
 * Writing one to the USSWE bit allows the SOPT1 USBSSTB bit to be written. This
 * register bit clears after a write to USBSSTB.
 *
 * Values:
 * - 0 - SOPT1 USBSSTB cannot be written.
 * - 1 - SOPT1 USBSSTB can be written.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1CFG_USSWE field. */
#define SIM_RD_SOPT1CFG_USSWE(base) ((SIM_SOPT1CFG_REG(base) & SIM_SOPT1CFG_USSWE_MASK) >> SIM_SOPT1CFG_USSWE_SHIFT)
#define SIM_BRD_SOPT1CFG_USSWE(base) (BITBAND_ACCESS32(&SIM_SOPT1CFG_REG(base), SIM_SOPT1CFG_USSWE_SHIFT))

/*! @brief Set the USSWE field to a new value. */
#define SIM_WR_SOPT1CFG_USSWE(base, value) (SIM_RMW_SOPT1CFG(base, SIM_SOPT1CFG_USSWE_MASK, SIM_SOPT1CFG_USSWE(value)))
#define SIM_BWR_SOPT1CFG_USSWE(base, value) (BITBAND_ACCESS32(&SIM_SOPT1CFG_REG(base), SIM_SOPT1CFG_USSWE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SOPT2 - System Options Register 2
 ******************************************************************************/

/*!
 * @brief SIM_SOPT2 - System Options Register 2 (RW)
 *
 * Reset value: 0x00001000U
 *
 * SOPT2 contains the controls for selecting many of the module clock source
 * options on this device. See the Clock Distribution chapter for more information
 * including clocking diagrams and definitions of device clocks.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT2 register
 */
/*@{*/
#define SIM_RD_SOPT2(base)       (SIM_SOPT2_REG(base))
#define SIM_WR_SOPT2(base, value) (SIM_SOPT2_REG(base) = (value))
#define SIM_RMW_SOPT2(base, mask, value) (SIM_WR_SOPT2(base, (SIM_RD_SOPT2(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT2(base, value) (SIM_WR_SOPT2(base, SIM_RD_SOPT2(base) |  (value)))
#define SIM_CLR_SOPT2(base, value) (SIM_WR_SOPT2(base, SIM_RD_SOPT2(base) & ~(value)))
#define SIM_TOG_SOPT2(base, value) (SIM_WR_SOPT2(base, SIM_RD_SOPT2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT2 bitfields
 */

/*!
 * @name Register SIM_SOPT2, field RTCCLKOUTSEL[4] (RW)
 *
 * Selects either the RTC 1 Hz clock or the 32.768kHz clock to be output on the
 * RTC_CLKOUT pin.
 *
 * Values:
 * - 0 - RTC 1 Hz clock is output on the RTC_CLKOUT pin.
 * - 1 - RTC 32.768kHz clock is output on the RTC_CLKOUT pin.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_RTCCLKOUTSEL field. */
#define SIM_RD_SOPT2_RTCCLKOUTSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_RTCCLKOUTSEL_MASK) >> SIM_SOPT2_RTCCLKOUTSEL_SHIFT)
#define SIM_BRD_SOPT2_RTCCLKOUTSEL(base) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_RTCCLKOUTSEL_SHIFT))

/*! @brief Set the RTCCLKOUTSEL field to a new value. */
#define SIM_WR_SOPT2_RTCCLKOUTSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_RTCCLKOUTSEL_MASK, SIM_SOPT2_RTCCLKOUTSEL(value)))
#define SIM_BWR_SOPT2_RTCCLKOUTSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_RTCCLKOUTSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field CLKOUTSEL[7:5] (RW)
 *
 * Selects the clock to output on the CLKOUT pin.
 *
 * Values:
 * - 000 - Reserved
 * - 001 - Reserved
 * - 010 - Flash clock
 * - 011 - LPO clock (1 kHz)
 * - 100 - IRCLK
 * - 101 - RTC 32.768kHz
 * - 110 - ERCLK0
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_CLKOUTSEL field. */
#define SIM_RD_SOPT2_CLKOUTSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_CLKOUTSEL_MASK) >> SIM_SOPT2_CLKOUTSEL_SHIFT)
#define SIM_BRD_SOPT2_CLKOUTSEL(base) (SIM_RD_SOPT2_CLKOUTSEL(base))

/*! @brief Set the CLKOUTSEL field to a new value. */
#define SIM_WR_SOPT2_CLKOUTSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_CLKOUTSEL_MASK, SIM_SOPT2_CLKOUTSEL(value)))
#define SIM_BWR_SOPT2_CLKOUTSEL(base, value) (SIM_WR_SOPT2_CLKOUTSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field PTD7PAD[11] (RW)
 *
 * Controls the output drive strength of the PTD7 pin by selecting either one or
 * two pads to drive it.
 *
 * Values:
 * - 0 - Single-pad drive strength for PTD7.
 * - 1 - Double pad drive strength for PTD7.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_PTD7PAD field. */
#define SIM_RD_SOPT2_PTD7PAD(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_PTD7PAD_MASK) >> SIM_SOPT2_PTD7PAD_SHIFT)
#define SIM_BRD_SOPT2_PTD7PAD(base) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_PTD7PAD_SHIFT))

/*! @brief Set the PTD7PAD field to a new value. */
#define SIM_WR_SOPT2_PTD7PAD(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_PTD7PAD_MASK, SIM_SOPT2_PTD7PAD(value)))
#define SIM_BWR_SOPT2_PTD7PAD(base, value) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_PTD7PAD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field TRACECLKSEL[12] (RW)
 *
 * Selects the core/system clock or MCG output clock (MCGOUTCLK) as the trace
 * clock source.
 *
 * Values:
 * - 0 - MCGOUTCLK
 * - 1 - Core/system clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_TRACECLKSEL field. */
#define SIM_RD_SOPT2_TRACECLKSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_TRACECLKSEL_MASK) >> SIM_SOPT2_TRACECLKSEL_SHIFT)
#define SIM_BRD_SOPT2_TRACECLKSEL(base) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_TRACECLKSEL_SHIFT))

/*! @brief Set the TRACECLKSEL field to a new value. */
#define SIM_WR_SOPT2_TRACECLKSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_TRACECLKSEL_MASK, SIM_SOPT2_TRACECLKSEL(value)))
#define SIM_BWR_SOPT2_TRACECLKSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_TRACECLKSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field PLLFLLSEL[16] (RW)
 *
 * Selects the MCGPLLCLK or MCGFLLCLK clock for various peripheral clocking
 * options.
 *
 * Values:
 * - 0 - MCGFLLCLK clock
 * - 1 - MCGPLLCLK clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_PLLFLLSEL field. */
#define SIM_RD_SOPT2_PLLFLLSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_PLLFLLSEL_MASK) >> SIM_SOPT2_PLLFLLSEL_SHIFT)
#define SIM_BRD_SOPT2_PLLFLLSEL(base) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_PLLFLLSEL_SHIFT))

/*! @brief Set the PLLFLLSEL field to a new value. */
#define SIM_WR_SOPT2_PLLFLLSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_PLLFLLSEL_MASK, SIM_SOPT2_PLLFLLSEL(value)))
#define SIM_BWR_SOPT2_PLLFLLSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_PLLFLLSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field USBSRC[18] (RW)
 *
 * Selects the clock source for the USB 48 MHz clock.
 *
 * Values:
 * - 0 - External bypass clock (USB_CLKIN).
 * - 1 - MCGPLLCLK/MCGFLLCLK clock divided by the USB fractional divider. See
 *     the SIM_CLKDIV2[USBFRAC, USBDIV] descriptions.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_USBSRC field. */
#define SIM_RD_SOPT2_USBSRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_USBSRC_MASK) >> SIM_SOPT2_USBSRC_SHIFT)
#define SIM_BRD_SOPT2_USBSRC(base) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_USBSRC_SHIFT))

/*! @brief Set the USBSRC field to a new value. */
#define SIM_WR_SOPT2_USBSRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_USBSRC_MASK, SIM_SOPT2_USBSRC(value)))
#define SIM_BWR_SOPT2_USBSRC(base, value) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_USBSRC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SOPT4 - System Options Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SOPT4 - System Options Register 4 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT4 register
 */
/*@{*/
#define SIM_RD_SOPT4(base)       (SIM_SOPT4_REG(base))
#define SIM_WR_SOPT4(base, value) (SIM_SOPT4_REG(base) = (value))
#define SIM_RMW_SOPT4(base, mask, value) (SIM_WR_SOPT4(base, (SIM_RD_SOPT4(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT4(base, value) (SIM_WR_SOPT4(base, SIM_RD_SOPT4(base) |  (value)))
#define SIM_CLR_SOPT4(base, value) (SIM_WR_SOPT4(base, SIM_RD_SOPT4(base) & ~(value)))
#define SIM_TOG_SOPT4(base, value) (SIM_WR_SOPT4(base, SIM_RD_SOPT4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT4 bitfields
 */

/*!
 * @name Register SIM_SOPT4, field FTM0FLT0[0] (RW)
 *
 * Selects the source of FTM0 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM0_FLT0 pin
 * - 1 - CMP0 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0FLT0 field. */
#define SIM_RD_SOPT4_FTM0FLT0(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0FLT0_MASK) >> SIM_SOPT4_FTM0FLT0_SHIFT)
#define SIM_BRD_SOPT4_FTM0FLT0(base) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT0_SHIFT))

/*! @brief Set the FTM0FLT0 field to a new value. */
#define SIM_WR_SOPT4_FTM0FLT0(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0FLT0_MASK, SIM_SOPT4_FTM0FLT0(value)))
#define SIM_BWR_SOPT4_FTM0FLT0(base, value) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0FLT1[1] (RW)
 *
 * Selects the source of FTM0 fault 1. The pin source for fault 1 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM0_FLT1 pin
 * - 1 - CMP1 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0FLT1 field. */
#define SIM_RD_SOPT4_FTM0FLT1(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0FLT1_MASK) >> SIM_SOPT4_FTM0FLT1_SHIFT)
#define SIM_BRD_SOPT4_FTM0FLT1(base) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT1_SHIFT))

/*! @brief Set the FTM0FLT1 field to a new value. */
#define SIM_WR_SOPT4_FTM0FLT1(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0FLT1_MASK, SIM_SOPT4_FTM0FLT1(value)))
#define SIM_BWR_SOPT4_FTM0FLT1(base, value) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1FLT0[4] (RW)
 *
 * Selects the source of FTM1 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM1_FLT0 pin
 * - 1 - CMP0 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1FLT0 field. */
#define SIM_RD_SOPT4_FTM1FLT0(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1FLT0_MASK) >> SIM_SOPT4_FTM1FLT0_SHIFT)
#define SIM_BRD_SOPT4_FTM1FLT0(base) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1FLT0_SHIFT))

/*! @brief Set the FTM1FLT0 field to a new value. */
#define SIM_WR_SOPT4_FTM1FLT0(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1FLT0_MASK, SIM_SOPT4_FTM1FLT0(value)))
#define SIM_BWR_SOPT4_FTM1FLT0(base, value) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1FLT0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1CH0SRC[19:18] (RW)
 *
 * Selects the source for FTM1 channel 0 input capture. When the FTM is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 00 - FTM1_CH0 signal
 * - 01 - CMP0 output
 * - 10 - CMP1 output
 * - 11 - USB start of frame pulse
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1CH0SRC field. */
#define SIM_RD_SOPT4_FTM1CH0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1CH0SRC_MASK) >> SIM_SOPT4_FTM1CH0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM1CH0SRC(base) (SIM_RD_SOPT4_FTM1CH0SRC(base))

/*! @brief Set the FTM1CH0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM1CH0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1CH0SRC_MASK, SIM_SOPT4_FTM1CH0SRC(value)))
#define SIM_BWR_SOPT4_FTM1CH0SRC(base, value) (SIM_WR_SOPT4_FTM1CH0SRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0CLKSEL[24] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM0 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - FTM_CLK0 pin
 * - 1 - FTM_CLK1 pin
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0CLKSEL field. */
#define SIM_RD_SOPT4_FTM0CLKSEL(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0CLKSEL_MASK) >> SIM_SOPT4_FTM0CLKSEL_SHIFT)
#define SIM_BRD_SOPT4_FTM0CLKSEL(base) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0CLKSEL_SHIFT))

/*! @brief Set the FTM0CLKSEL field to a new value. */
#define SIM_WR_SOPT4_FTM0CLKSEL(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0CLKSEL_MASK, SIM_SOPT4_FTM0CLKSEL(value)))
#define SIM_BWR_SOPT4_FTM0CLKSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0CLKSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1CLKSEL[25] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM1 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - FTM_CLK0 pin
 * - 1 - FTM_CLK1 pin
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1CLKSEL field. */
#define SIM_RD_SOPT4_FTM1CLKSEL(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1CLKSEL_MASK) >> SIM_SOPT4_FTM1CLKSEL_SHIFT)
#define SIM_BRD_SOPT4_FTM1CLKSEL(base) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1CLKSEL_SHIFT))

/*! @brief Set the FTM1CLKSEL field to a new value. */
#define SIM_WR_SOPT4_FTM1CLKSEL(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1CLKSEL_MASK, SIM_SOPT4_FTM1CLKSEL(value)))
#define SIM_BWR_SOPT4_FTM1CLKSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1CLKSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0TRG0SRC[28] (RW)
 *
 * Selects the source of FTM0 hardware trigger 0.
 *
 * Values:
 * - 0 - HSCMP0 output drives FTM0 hardware trigger 0
 * - 1 - FTM1 channel match drives FTM0 hardware trigger 0
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0TRG0SRC field. */
#define SIM_RD_SOPT4_FTM0TRG0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0TRG0SRC_MASK) >> SIM_SOPT4_FTM0TRG0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM0TRG0SRC(base) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0TRG0SRC_SHIFT))

/*! @brief Set the FTM0TRG0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM0TRG0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0TRG0SRC_MASK, SIM_SOPT4_FTM0TRG0SRC(value)))
#define SIM_BWR_SOPT4_FTM0TRG0SRC(base, value) (BITBAND_ACCESS32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0TRG0SRC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SOPT5 - System Options Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SOPT5 - System Options Register 5 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT5 register
 */
/*@{*/
#define SIM_RD_SOPT5(base)       (SIM_SOPT5_REG(base))
#define SIM_WR_SOPT5(base, value) (SIM_SOPT5_REG(base) = (value))
#define SIM_RMW_SOPT5(base, mask, value) (SIM_WR_SOPT5(base, (SIM_RD_SOPT5(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT5(base, value) (SIM_WR_SOPT5(base, SIM_RD_SOPT5(base) |  (value)))
#define SIM_CLR_SOPT5(base, value) (SIM_WR_SOPT5(base, SIM_RD_SOPT5(base) & ~(value)))
#define SIM_TOG_SOPT5(base, value) (SIM_WR_SOPT5(base, SIM_RD_SOPT5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT5 bitfields
 */

/*!
 * @name Register SIM_SOPT5, field UART0TXSRC[0] (RW)
 *
 * Selects the source for the UART 0 transmit data.
 *
 * Values:
 * - 0 - UART0_TX pin
 * - 1 - UART0_TX pin modulated with FTM1 channel 0 output
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART0TXSRC field. */
#define SIM_RD_SOPT5_UART0TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART0TXSRC_MASK) >> SIM_SOPT5_UART0TXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART0TXSRC(base) (BITBAND_ACCESS32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART0TXSRC_SHIFT))

/*! @brief Set the UART0TXSRC field to a new value. */
#define SIM_WR_SOPT5_UART0TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART0TXSRC_MASK, SIM_SOPT5_UART0TXSRC(value)))
#define SIM_BWR_SOPT5_UART0TXSRC(base, value) (BITBAND_ACCESS32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART0TXSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART0RXSRC[3:2] (RW)
 *
 * Selects the source for the UART 0 receive data.
 *
 * Values:
 * - 00 - UART0_RX pin
 * - 01 - CMP0
 * - 10 - CMP1
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART0RXSRC field. */
#define SIM_RD_SOPT5_UART0RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART0RXSRC_MASK) >> SIM_SOPT5_UART0RXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART0RXSRC(base) (SIM_RD_SOPT5_UART0RXSRC(base))

/*! @brief Set the UART0RXSRC field to a new value. */
#define SIM_WR_SOPT5_UART0RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART0RXSRC_MASK, SIM_SOPT5_UART0RXSRC(value)))
#define SIM_BWR_SOPT5_UART0RXSRC(base, value) (SIM_WR_SOPT5_UART0RXSRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1TXSRC[4] (RW)
 *
 * Selects the source for the UART 1 transmit data.
 *
 * Values:
 * - 0 - UART1_TX pin
 * - 1 - UART1_TX pin modulated with FTM1 channel 0 output
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART1TXSRC field. */
#define SIM_RD_SOPT5_UART1TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART1TXSRC_MASK) >> SIM_SOPT5_UART1TXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART1TXSRC(base) (BITBAND_ACCESS32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART1TXSRC_SHIFT))

/*! @brief Set the UART1TXSRC field to a new value. */
#define SIM_WR_SOPT5_UART1TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART1TXSRC_MASK, SIM_SOPT5_UART1TXSRC(value)))
#define SIM_BWR_SOPT5_UART1TXSRC(base, value) (BITBAND_ACCESS32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART1TXSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1RXSRC[7:6] (RW)
 *
 * Selects the source for the UART 1 receive data.
 *
 * Values:
 * - 00 - UART1_RX pin
 * - 01 - CMP0
 * - 10 - CMP1
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART1RXSRC field. */
#define SIM_RD_SOPT5_UART1RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART1RXSRC_MASK) >> SIM_SOPT5_UART1RXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART1RXSRC(base) (SIM_RD_SOPT5_UART1RXSRC(base))

/*! @brief Set the UART1RXSRC field to a new value. */
#define SIM_WR_SOPT5_UART1RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART1RXSRC_MASK, SIM_SOPT5_UART1RXSRC(value)))
#define SIM_BWR_SOPT5_UART1RXSRC(base, value) (SIM_WR_SOPT5_UART1RXSRC(base, value))
/*@}*/

/*******************************************************************************
 * SIM_SOPT7 - System Options Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SOPT7 - System Options Register 7 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT7 register
 */
/*@{*/
#define SIM_RD_SOPT7(base)       (SIM_SOPT7_REG(base))
#define SIM_WR_SOPT7(base, value) (SIM_SOPT7_REG(base) = (value))
#define SIM_RMW_SOPT7(base, mask, value) (SIM_WR_SOPT7(base, (SIM_RD_SOPT7(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT7(base, value) (SIM_WR_SOPT7(base, SIM_RD_SOPT7(base) |  (value)))
#define SIM_CLR_SOPT7(base, value) (SIM_WR_SOPT7(base, SIM_RD_SOPT7(base) & ~(value)))
#define SIM_TOG_SOPT7(base, value) (SIM_WR_SOPT7(base, SIM_RD_SOPT7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT7 bitfields
 */

/*!
 * @name Register SIM_SOPT7, field ADC0TRGSEL[3:0] (RW)
 *
 * Selects the ADC0 trigger source when alternative triggers are functional in
 * stop and VLPS modes. .
 *
 * Values:
 * - 0000 - PDB external trigger pin input (PDB0_EXTRG)
 * - 0001 - High speed comparator 0 output
 * - 0010 - High speed comparator 1 output
 * - 0011 - Reserved
 * - 0100 - PIT trigger 0
 * - 0101 - PIT trigger 1
 * - 0110 - PIT trigger 2
 * - 0111 - PIT trigger 3
 * - 1000 - FTM0 trigger
 * - 1001 - FTM1 trigger
 * - 1010 - Unused
 * - 1011 - Unused
 * - 1100 - RTC alarm
 * - 1101 - RTC seconds
 * - 1110 - Low-power timer trigger
 * - 1111 - Unused
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0TRGSEL field. */
#define SIM_RD_SOPT7_ADC0TRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0TRGSEL_MASK) >> SIM_SOPT7_ADC0TRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC0TRGSEL(base) (SIM_RD_SOPT7_ADC0TRGSEL(base))

/*! @brief Set the ADC0TRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC0TRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0TRGSEL_MASK, SIM_SOPT7_ADC0TRGSEL(value)))
#define SIM_BWR_SOPT7_ADC0TRGSEL(base, value) (SIM_WR_SOPT7_ADC0TRGSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0PRETRGSEL[4] (RW)
 *
 * Selects the ADC0 pre-trigger source when alternative triggers are enabled
 * through ADC0ALTTRGEN.
 *
 * Values:
 * - 0 - Pre-trigger A
 * - 1 - Pre-trigger B
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0PRETRGSEL field. */
#define SIM_RD_SOPT7_ADC0PRETRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0PRETRGSEL_MASK) >> SIM_SOPT7_ADC0PRETRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC0PRETRGSEL(base) (BITBAND_ACCESS32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0PRETRGSEL_SHIFT))

/*! @brief Set the ADC0PRETRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC0PRETRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0PRETRGSEL_MASK, SIM_SOPT7_ADC0PRETRGSEL(value)))
#define SIM_BWR_SOPT7_ADC0PRETRGSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0PRETRGSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0ALTTRGEN[7] (RW)
 *
 * Enable alternative conversion triggers for ADC0.
 *
 * Values:
 * - 0 - PDB trigger selected for ADC0.
 * - 1 - Alternate trigger selected for ADC0.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0ALTTRGEN field. */
#define SIM_RD_SOPT7_ADC0ALTTRGEN(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0ALTTRGEN_MASK) >> SIM_SOPT7_ADC0ALTTRGEN_SHIFT)
#define SIM_BRD_SOPT7_ADC0ALTTRGEN(base) (BITBAND_ACCESS32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0ALTTRGEN_SHIFT))

/*! @brief Set the ADC0ALTTRGEN field to a new value. */
#define SIM_WR_SOPT7_ADC0ALTTRGEN(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0ALTTRGEN_MASK, SIM_SOPT7_ADC0ALTTRGEN(value)))
#define SIM_BWR_SOPT7_ADC0ALTTRGEN(base, value) (BITBAND_ACCESS32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0ALTTRGEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define SIM_RD_SDID(base)        (SIM_SDID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[3:0] (RO)
 *
 * Specifies the pincount of the device.
 *
 * Values:
 * - 0000 - Reserved
 * - 0001 - Reserved
 * - 0010 - 32-pin
 * - 0011 - Reserved
 * - 0100 - 48-pin
 * - 0101 - 64-pin
 * - 0110 - Reserved
 * - 0111 - Reserved
 * - 1000 - Reserved
 * - 1001 - Reserved
 * - 1010 - Reserved
 * - 1011 - Reserved
 * - 1100 - Reserved
 * - 1101 - Reserved
 * - 1110 - Reserved
 * - 1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_PINID field. */
#define SIM_RD_SDID_PINID(base) ((SIM_SDID_REG(base) & SIM_SDID_PINID_MASK) >> SIM_SDID_PINID_SHIFT)
#define SIM_BRD_SDID_PINID(base) (SIM_RD_SDID_PINID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMID[6:4] (RO)
 *
 * Specifies the Kinetis family of the device.
 *
 * Values:
 * - 000 - K10
 * - 001 - K20
 * - 010 - Reserved
 * - 011 - Reserved
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_FAMID field. */
#define SIM_RD_SDID_FAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_FAMID_MASK) >> SIM_SDID_FAMID_SHIFT)
#define SIM_BRD_SDID_FAMID(base) (SIM_RD_SDID_FAMID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[15:12] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_REVID field. */
#define SIM_RD_SDID_REVID(base) ((SIM_SDID_REG(base) & SIM_SDID_REVID_MASK) >> SIM_SDID_REVID_SHIFT)
#define SIM_BRD_SDID_REVID(base) (SIM_RD_SDID_REVID(base))
/*@}*/

/*******************************************************************************
 * SIM_SCGC4 - System Clock Gating Control Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SCGC4 - System Clock Gating Control Register 4 (RW)
 *
 * Reset value: 0xF0100030U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC4 register
 */
/*@{*/
#define SIM_RD_SCGC4(base)       (SIM_SCGC4_REG(base))
#define SIM_WR_SCGC4(base, value) (SIM_SCGC4_REG(base) = (value))
#define SIM_RMW_SCGC4(base, mask, value) (SIM_WR_SCGC4(base, (SIM_RD_SCGC4(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC4(base, value) (SIM_WR_SCGC4(base, SIM_RD_SCGC4(base) |  (value)))
#define SIM_CLR_SCGC4(base, value) (SIM_WR_SCGC4(base, SIM_RD_SCGC4(base) & ~(value)))
#define SIM_TOG_SCGC4(base, value) (SIM_WR_SCGC4(base, SIM_RD_SCGC4(base) ^  (value)))
/*@}*/

/* Unified clock gate bit access macros */
#define SIM_SCGC_BIT_REG(base, index)        (*((volatile uint32_t *)&SIM_SCGC4_REG(base) + (((uint32_t)(index) >> 5) - 3U)))
#define SIM_SCGC_BIT_SHIFT(index)            ((uint32_t)(index) & ((1U << 5) - 1U))
#define SIM_RD_SCGC_BIT(base, index)         (SIM_SCGC_BIT_REG((base), (index)) & (1U << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BRD_SCGC_BIT(base, index)        (BITBAND_ACCESS32(&SIM_SCGC_BIT_REG((base), (index)), SIM_SCGC_BIT_SHIFT(index)))
#define SIM_WR_SCGC_BIT(base, index, value)  (SIM_SCGC_BIT_REG((base), (index)) = (SIM_SCGC_BIT_REG((base), (index)) & ~(1U << SIM_SCGC_BIT_SHIFT(index))) | ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BWR_SCGC_BIT(base, index, value) (BITBAND_ACCESS32(&SIM_SCGC_BIT_REG((base), (index)), SIM_SCGC_BIT_SHIFT(index)) = (uint32_t)(value))

/*
 * Constants & macros for individual SIM_SCGC4 bitfields
 */

/*!
 * @name Register SIM_SCGC4, field EWM[1] (RW)
 *
 * This bit controls the clock gate to the EWM module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_EWM field. */
#define SIM_RD_SCGC4_EWM(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_EWM_MASK) >> SIM_SCGC4_EWM_SHIFT)
#define SIM_BRD_SCGC4_EWM(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_EWM_SHIFT))

/*! @brief Set the EWM field to a new value. */
#define SIM_WR_SCGC4_EWM(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_EWM_MASK, SIM_SCGC4_EWM(value)))
#define SIM_BWR_SCGC4_EWM(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_EWM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMT[2] (RW)
 *
 * This bit controls the clock gate to the CMT module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_CMT field. */
#define SIM_RD_SCGC4_CMT(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_CMT_MASK) >> SIM_SCGC4_CMT_SHIFT)
#define SIM_BRD_SCGC4_CMT(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMT_SHIFT))

/*! @brief Set the CMT field to a new value. */
#define SIM_WR_SCGC4_CMT(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_CMT_MASK, SIM_SCGC4_CMT(value)))
#define SIM_BWR_SCGC4_CMT(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C0[6] (RW)
 *
 * This bit controls the clock gate to the I 2 C0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_I2C0 field. */
#define SIM_RD_SCGC4_I2C0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_I2C0_MASK) >> SIM_SCGC4_I2C0_SHIFT)
#define SIM_BRD_SCGC4_I2C0(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_I2C0_SHIFT))

/*! @brief Set the I2C0 field to a new value. */
#define SIM_WR_SCGC4_I2C0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_I2C0_MASK, SIM_SCGC4_I2C0(value)))
#define SIM_BWR_SCGC4_I2C0(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_I2C0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART0[10] (RW)
 *
 * This bit controls the clock gate to the UART0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART0 field. */
#define SIM_RD_SCGC4_UART0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART0_MASK) >> SIM_SCGC4_UART0_SHIFT)
#define SIM_BRD_SCGC4_UART0(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART0_SHIFT))

/*! @brief Set the UART0 field to a new value. */
#define SIM_WR_SCGC4_UART0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART0_MASK, SIM_SCGC4_UART0(value)))
#define SIM_BWR_SCGC4_UART0(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART1[11] (RW)
 *
 * This bit controls the clock gate to the UART1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART1 field. */
#define SIM_RD_SCGC4_UART1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART1_MASK) >> SIM_SCGC4_UART1_SHIFT)
#define SIM_BRD_SCGC4_UART1(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART1_SHIFT))

/*! @brief Set the UART1 field to a new value. */
#define SIM_WR_SCGC4_UART1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART1_MASK, SIM_SCGC4_UART1(value)))
#define SIM_BWR_SCGC4_UART1(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART2[12] (RW)
 *
 * This bit controls the clock gate to the UART2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART2 field. */
#define SIM_RD_SCGC4_UART2(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART2_MASK) >> SIM_SCGC4_UART2_SHIFT)
#define SIM_BRD_SCGC4_UART2(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART2_SHIFT))

/*! @brief Set the UART2 field to a new value. */
#define SIM_WR_SCGC4_UART2(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART2_MASK, SIM_SCGC4_UART2(value)))
#define SIM_BWR_SCGC4_UART2(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field USBOTG[18] (RW)
 *
 * This bit controls the clock gate to the USB module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_USBOTG field. */
#define SIM_RD_SCGC4_USBOTG(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_USBOTG_MASK) >> SIM_SCGC4_USBOTG_SHIFT)
#define SIM_BRD_SCGC4_USBOTG(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_USBOTG_SHIFT))

/*! @brief Set the USBOTG field to a new value. */
#define SIM_WR_SCGC4_USBOTG(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_USBOTG_MASK, SIM_SCGC4_USBOTG(value)))
#define SIM_BWR_SCGC4_USBOTG(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_USBOTG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMP[19] (RW)
 *
 * This bit controls the clock gate to the comparator module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_CMP field. */
#define SIM_RD_SCGC4_CMP(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_CMP_MASK) >> SIM_SCGC4_CMP_SHIFT)
#define SIM_BRD_SCGC4_CMP(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMP_SHIFT))

/*! @brief Set the CMP field to a new value. */
#define SIM_WR_SCGC4_CMP(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_CMP_MASK, SIM_SCGC4_CMP(value)))
#define SIM_BWR_SCGC4_CMP(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field VREF[20] (RW)
 *
 * This bit controls the clock gate to the VREF module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_VREF field. */
#define SIM_RD_SCGC4_VREF(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_VREF_MASK) >> SIM_SCGC4_VREF_SHIFT)
#define SIM_BRD_SCGC4_VREF(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_VREF_SHIFT))

/*! @brief Set the VREF field to a new value. */
#define SIM_WR_SCGC4_VREF(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_VREF_MASK, SIM_SCGC4_VREF(value)))
#define SIM_BWR_SCGC4_VREF(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_VREF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SCGC5 - System Clock Gating Control Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SCGC5 - System Clock Gating Control Register 5 (RW)
 *
 * Reset value: 0x00040182U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC5 register
 */
/*@{*/
#define SIM_RD_SCGC5(base)       (SIM_SCGC5_REG(base))
#define SIM_WR_SCGC5(base, value) (SIM_SCGC5_REG(base) = (value))
#define SIM_RMW_SCGC5(base, mask, value) (SIM_WR_SCGC5(base, (SIM_RD_SCGC5(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC5(base, value) (SIM_WR_SCGC5(base, SIM_RD_SCGC5(base) |  (value)))
#define SIM_CLR_SCGC5(base, value) (SIM_WR_SCGC5(base, SIM_RD_SCGC5(base) & ~(value)))
#define SIM_TOG_SCGC5(base, value) (SIM_WR_SCGC5(base, SIM_RD_SCGC5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC5 bitfields
 */

/*!
 * @name Register SIM_SCGC5, field LPTIMER[0] (RW)
 *
 * This bit controls software access to the Low Power Timer module.
 *
 * Values:
 * - 0 - Access disabled
 * - 1 - Access enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_LPTIMER field. */
#define SIM_RD_SCGC5_LPTIMER(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_LPTIMER_MASK) >> SIM_SCGC5_LPTIMER_SHIFT)
#define SIM_BRD_SCGC5_LPTIMER(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_LPTIMER_SHIFT))

/*! @brief Set the LPTIMER field to a new value. */
#define SIM_WR_SCGC5_LPTIMER(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_LPTIMER_MASK, SIM_SCGC5_LPTIMER(value)))
#define SIM_BWR_SCGC5_LPTIMER(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_LPTIMER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field TSI[5] (RW)
 *
 * This bit controls the clock gate to the TSI module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_TSI field. */
#define SIM_RD_SCGC5_TSI(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_TSI_MASK) >> SIM_SCGC5_TSI_SHIFT)
#define SIM_BRD_SCGC5_TSI(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_TSI_SHIFT))

/*! @brief Set the TSI field to a new value. */
#define SIM_WR_SCGC5_TSI(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_TSI_MASK, SIM_SCGC5_TSI(value)))
#define SIM_BWR_SCGC5_TSI(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_TSI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTA[9] (RW)
 *
 * This bit controls the clock gate to the Port A module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTA field. */
#define SIM_RD_SCGC5_PORTA(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTA_MASK) >> SIM_SCGC5_PORTA_SHIFT)
#define SIM_BRD_SCGC5_PORTA(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTA_SHIFT))

/*! @brief Set the PORTA field to a new value. */
#define SIM_WR_SCGC5_PORTA(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTA_MASK, SIM_SCGC5_PORTA(value)))
#define SIM_BWR_SCGC5_PORTA(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTB[10] (RW)
 *
 * This bit controls the clock gate to the Port B module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTB field. */
#define SIM_RD_SCGC5_PORTB(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTB_MASK) >> SIM_SCGC5_PORTB_SHIFT)
#define SIM_BRD_SCGC5_PORTB(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTB_SHIFT))

/*! @brief Set the PORTB field to a new value. */
#define SIM_WR_SCGC5_PORTB(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTB_MASK, SIM_SCGC5_PORTB(value)))
#define SIM_BWR_SCGC5_PORTB(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTC[11] (RW)
 *
 * This bit controls the clock gate to the Port C module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTC field. */
#define SIM_RD_SCGC5_PORTC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTC_MASK) >> SIM_SCGC5_PORTC_SHIFT)
#define SIM_BRD_SCGC5_PORTC(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTC_SHIFT))

/*! @brief Set the PORTC field to a new value. */
#define SIM_WR_SCGC5_PORTC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTC_MASK, SIM_SCGC5_PORTC(value)))
#define SIM_BWR_SCGC5_PORTC(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTD[12] (RW)
 *
 * This bit controls the clock gate to the Port D module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTD field. */
#define SIM_RD_SCGC5_PORTD(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTD_MASK) >> SIM_SCGC5_PORTD_SHIFT)
#define SIM_BRD_SCGC5_PORTD(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTD_SHIFT))

/*! @brief Set the PORTD field to a new value. */
#define SIM_WR_SCGC5_PORTD(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTD_MASK, SIM_SCGC5_PORTD(value)))
#define SIM_BWR_SCGC5_PORTD(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTE[13] (RW)
 *
 * This bit controls the clock gate to the Port E module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTE field. */
#define SIM_RD_SCGC5_PORTE(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTE_MASK) >> SIM_SCGC5_PORTE_SHIFT)
#define SIM_BRD_SCGC5_PORTE(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTE_SHIFT))

/*! @brief Set the PORTE field to a new value. */
#define SIM_WR_SCGC5_PORTE(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTE_MASK, SIM_SCGC5_PORTE(value)))
#define SIM_BWR_SCGC5_PORTE(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SCGC6 - System Clock Gating Control Register 6
 ******************************************************************************/

/*!
 * @brief SIM_SCGC6 - System Clock Gating Control Register 6 (RW)
 *
 * Reset value: 0x40000001U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC6 register
 */
/*@{*/
#define SIM_RD_SCGC6(base)       (SIM_SCGC6_REG(base))
#define SIM_WR_SCGC6(base, value) (SIM_SCGC6_REG(base) = (value))
#define SIM_RMW_SCGC6(base, mask, value) (SIM_WR_SCGC6(base, (SIM_RD_SCGC6(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC6(base, value) (SIM_WR_SCGC6(base, SIM_RD_SCGC6(base) |  (value)))
#define SIM_CLR_SCGC6(base, value) (SIM_WR_SCGC6(base, SIM_RD_SCGC6(base) & ~(value)))
#define SIM_TOG_SCGC6(base, value) (SIM_WR_SCGC6(base, SIM_RD_SCGC6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC6 bitfields
 */

/*!
 * @name Register SIM_SCGC6, field FTFL[0] (RW)
 *
 * This bit controls the clock gate to the flash memory. Flash reads are still
 * supported while the flash memory is clock gated, but entry into low power modes
 * is blocked.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTFL field. */
#define SIM_RD_SCGC6_FTFL(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTFL_MASK) >> SIM_SCGC6_FTFL_SHIFT)
#define SIM_BRD_SCGC6_FTFL(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTFL_SHIFT))

/*! @brief Set the FTFL field to a new value. */
#define SIM_WR_SCGC6_FTFL(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTFL_MASK, SIM_SCGC6_FTFL(value)))
#define SIM_BWR_SCGC6_FTFL(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTFL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DMAMUX[1] (RW)
 *
 * This bit controls the clock gate to the DMA Mux module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DMAMUX field. */
#define SIM_RD_SCGC6_DMAMUX(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DMAMUX_MASK) >> SIM_SCGC6_DMAMUX_SHIFT)
#define SIM_BRD_SCGC6_DMAMUX(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_DMAMUX_SHIFT))

/*! @brief Set the DMAMUX field to a new value. */
#define SIM_WR_SCGC6_DMAMUX(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DMAMUX_MASK, SIM_SCGC6_DMAMUX(value)))
#define SIM_BWR_SCGC6_DMAMUX(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_DMAMUX_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI0[12] (RW)
 *
 * This bit controls the clock gate to the SPI0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_SPI0 field. */
#define SIM_RD_SCGC6_SPI0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_SPI0_MASK) >> SIM_SCGC6_SPI0_SHIFT)
#define SIM_BRD_SCGC6_SPI0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI0_SHIFT))

/*! @brief Set the SPI0 field to a new value. */
#define SIM_WR_SCGC6_SPI0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_SPI0_MASK, SIM_SCGC6_SPI0(value)))
#define SIM_BWR_SCGC6_SPI0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field I2S[15] (RW)
 *
 * This bit controls the clock gate to the I 2 S module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_I2S field. */
#define SIM_RD_SCGC6_I2S(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_I2S_MASK) >> SIM_SCGC6_I2S_SHIFT)
#define SIM_BRD_SCGC6_I2S(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_I2S_SHIFT))

/*! @brief Set the I2S field to a new value. */
#define SIM_WR_SCGC6_I2S(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_I2S_MASK, SIM_SCGC6_I2S(value)))
#define SIM_BWR_SCGC6_I2S(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_I2S_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field CRC[18] (RW)
 *
 * This bit controls the clock gate to the CRC module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_CRC field. */
#define SIM_RD_SCGC6_CRC(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_CRC_MASK) >> SIM_SCGC6_CRC_SHIFT)
#define SIM_BRD_SCGC6_CRC(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_CRC_SHIFT))

/*! @brief Set the CRC field to a new value. */
#define SIM_WR_SCGC6_CRC(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_CRC_MASK, SIM_SCGC6_CRC(value)))
#define SIM_BWR_SCGC6_CRC(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_CRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field USBDCD[21] (RW)
 *
 * This bit controls the clock gate to the USB DCD module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_USBDCD field. */
#define SIM_RD_SCGC6_USBDCD(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_USBDCD_MASK) >> SIM_SCGC6_USBDCD_SHIFT)
#define SIM_BRD_SCGC6_USBDCD(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_USBDCD_SHIFT))

/*! @brief Set the USBDCD field to a new value. */
#define SIM_WR_SCGC6_USBDCD(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_USBDCD_MASK, SIM_SCGC6_USBDCD(value)))
#define SIM_BWR_SCGC6_USBDCD(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_USBDCD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PDB[22] (RW)
 *
 * This bit controls the clock gate to the PDB module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PDB field. */
#define SIM_RD_SCGC6_PDB(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PDB_MASK) >> SIM_SCGC6_PDB_SHIFT)
#define SIM_BRD_SCGC6_PDB(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_PDB_SHIFT))

/*! @brief Set the PDB field to a new value. */
#define SIM_WR_SCGC6_PDB(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PDB_MASK, SIM_SCGC6_PDB(value)))
#define SIM_BWR_SCGC6_PDB(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_PDB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PIT[23] (RW)
 *
 * This bit controls the clock gate to the PIT module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PIT field. */
#define SIM_RD_SCGC6_PIT(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PIT_MASK) >> SIM_SCGC6_PIT_SHIFT)
#define SIM_BRD_SCGC6_PIT(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_PIT_SHIFT))

/*! @brief Set the PIT field to a new value. */
#define SIM_WR_SCGC6_PIT(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PIT_MASK, SIM_SCGC6_PIT(value)))
#define SIM_BWR_SCGC6_PIT(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_PIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM0[24] (RW)
 *
 * This bit controls the clock gate to the FTM0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTM0 field. */
#define SIM_RD_SCGC6_FTM0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTM0_MASK) >> SIM_SCGC6_FTM0_SHIFT)
#define SIM_BRD_SCGC6_FTM0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM0_SHIFT))

/*! @brief Set the FTM0 field to a new value. */
#define SIM_WR_SCGC6_FTM0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTM0_MASK, SIM_SCGC6_FTM0(value)))
#define SIM_BWR_SCGC6_FTM0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM1[25] (RW)
 *
 * This bit controls the clock gate to the FTM1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTM1 field. */
#define SIM_RD_SCGC6_FTM1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTM1_MASK) >> SIM_SCGC6_FTM1_SHIFT)
#define SIM_BRD_SCGC6_FTM1(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM1_SHIFT))

/*! @brief Set the FTM1 field to a new value. */
#define SIM_WR_SCGC6_FTM1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTM1_MASK, SIM_SCGC6_FTM1(value)))
#define SIM_BWR_SCGC6_FTM1(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field ADC0[27] (RW)
 *
 * This bit controls the clock gate to the ADC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_ADC0 field. */
#define SIM_RD_SCGC6_ADC0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_ADC0_MASK) >> SIM_SCGC6_ADC0_SHIFT)
#define SIM_BRD_SCGC6_ADC0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_ADC0_SHIFT))

/*! @brief Set the ADC0 field to a new value. */
#define SIM_WR_SCGC6_ADC0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_ADC0_MASK, SIM_SCGC6_ADC0(value)))
#define SIM_BWR_SCGC6_ADC0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_ADC0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field RTC[29] (RW)
 *
 * This bit controls software access and interrupts to the RTC module.
 *
 * Values:
 * - 0 - Access and interrupts disabled
 * - 1 - Access and interrupts enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_RTC field. */
#define SIM_RD_SCGC6_RTC(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_RTC_MASK) >> SIM_SCGC6_RTC_SHIFT)
#define SIM_BRD_SCGC6_RTC(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_RTC_SHIFT))

/*! @brief Set the RTC field to a new value. */
#define SIM_WR_SCGC6_RTC(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_RTC_MASK, SIM_SCGC6_RTC(value)))
#define SIM_BWR_SCGC6_RTC(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_RTC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SCGC7 - System Clock Gating Control Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SCGC7 - System Clock Gating Control Register 7 (RW)
 *
 * Reset value: 0x00000002U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC7 register
 */
/*@{*/
#define SIM_RD_SCGC7(base)       (SIM_SCGC7_REG(base))
#define SIM_WR_SCGC7(base, value) (SIM_SCGC7_REG(base) = (value))
#define SIM_RMW_SCGC7(base, mask, value) (SIM_WR_SCGC7(base, (SIM_RD_SCGC7(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC7(base, value) (SIM_WR_SCGC7(base, SIM_RD_SCGC7(base) |  (value)))
#define SIM_CLR_SCGC7(base, value) (SIM_WR_SCGC7(base, SIM_RD_SCGC7(base) & ~(value)))
#define SIM_TOG_SCGC7(base, value) (SIM_WR_SCGC7(base, SIM_RD_SCGC7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC7 bitfields
 */

/*!
 * @name Register SIM_SCGC7, field DMA[1] (RW)
 *
 * This bit controls the clock gate to the DMA module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_DMA field. */
#define SIM_RD_SCGC7_DMA(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_DMA_MASK) >> SIM_SCGC7_DMA_SHIFT)
#define SIM_BRD_SCGC7_DMA(base) (BITBAND_ACCESS32(&SIM_SCGC7_REG(base), SIM_SCGC7_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define SIM_WR_SCGC7_DMA(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_DMA_MASK, SIM_SCGC7_DMA(value)))
#define SIM_BWR_SCGC7_DMA(base, value) (BITBAND_ACCESS32(&SIM_SCGC7_REG(base), SIM_SCGC7_DMA_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV1 - System Clock Divider Register 1
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV1 - System Clock Divider Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CLKDIV1 register cannot be written to when the device is in VLPR mode.
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV1 register
 */
/*@{*/
#define SIM_RD_CLKDIV1(base)     (SIM_CLKDIV1_REG(base))
#define SIM_WR_CLKDIV1(base, value) (SIM_CLKDIV1_REG(base) = (value))
#define SIM_RMW_CLKDIV1(base, mask, value) (SIM_WR_CLKDIV1(base, (SIM_RD_CLKDIV1(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV1(base, value) (SIM_WR_CLKDIV1(base, SIM_RD_CLKDIV1(base) |  (value)))
#define SIM_CLR_CLKDIV1(base, value) (SIM_WR_CLKDIV1(base, SIM_RD_CLKDIV1(base) & ~(value)))
#define SIM_TOG_CLKDIV1(base, value) (SIM_WR_CLKDIV1(base, SIM_RD_CLKDIV1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV1 bitfields
 */

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV4[19:16] (RW)
 *
 * This field sets the divide value for the flash clock. At the end of reset, it
 * is loaded with either 0001 or 1111 depending on FTFL_FOPT[LPBOOT].
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV4 field. */
#define SIM_RD_CLKDIV1_OUTDIV4(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV4(base) (SIM_RD_CLKDIV1_OUTDIV4(base))

/*! @brief Set the OUTDIV4 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV4(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV4_MASK, SIM_CLKDIV1_OUTDIV4(value)))
#define SIM_BWR_CLKDIV1_OUTDIV4(base, value) (SIM_WR_CLKDIV1_OUTDIV4(base, value))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV2[27:24] (RW)
 *
 * This field sets the divide value for the peripheral clock. At the end of
 * reset, it is loaded with either 0000 or 0111 depending on FTFL_FOPT[LPBOOT].
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV2 field. */
#define SIM_RD_CLKDIV1_OUTDIV2(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV2(base) (SIM_RD_CLKDIV1_OUTDIV2(base))

/*! @brief Set the OUTDIV2 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV2(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV2_MASK, SIM_CLKDIV1_OUTDIV2(value)))
#define SIM_BWR_CLKDIV1_OUTDIV2(base, value) (SIM_WR_CLKDIV1_OUTDIV2(base, value))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV1[31:28] (RW)
 *
 * This field sets the divide value for the core/system clock. At the end of
 * reset, it is loaded with either 0000 or 0111 depending on FTFL_FOPT[LPBOOT].
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV1 field. */
#define SIM_RD_CLKDIV1_OUTDIV1(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV1(base) (SIM_RD_CLKDIV1_OUTDIV1(base))

/*! @brief Set the OUTDIV1 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV1(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV1_MASK, SIM_CLKDIV1_OUTDIV1(value)))
#define SIM_BWR_CLKDIV1_OUTDIV1(base, value) (SIM_WR_CLKDIV1_OUTDIV1(base, value))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV2 - System Clock Divider Register 2
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV2 - System Clock Divider Register 2 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV2 register
 */
/*@{*/
#define SIM_RD_CLKDIV2(base)     (SIM_CLKDIV2_REG(base))
#define SIM_WR_CLKDIV2(base, value) (SIM_CLKDIV2_REG(base) = (value))
#define SIM_RMW_CLKDIV2(base, mask, value) (SIM_WR_CLKDIV2(base, (SIM_RD_CLKDIV2(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV2(base, value) (SIM_WR_CLKDIV2(base, SIM_RD_CLKDIV2(base) |  (value)))
#define SIM_CLR_CLKDIV2(base, value) (SIM_WR_CLKDIV2(base, SIM_RD_CLKDIV2(base) & ~(value)))
#define SIM_TOG_CLKDIV2(base, value) (SIM_WR_CLKDIV2(base, SIM_RD_CLKDIV2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV2 bitfields
 */

/*!
 * @name Register SIM_CLKDIV2, field USBFRAC[0] (RW)
 *
 * This field sets the fraction multiply value for the fractional clock divider
 * when the MCGFLLCLK/MCGPLLCLK clock is the USB clock source (SOPT2[USBSRC] =
 * 1). Divider output clock = Divider input clock * [ (USBFRAC+1) / (USBDIV+1) ]
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV2_USBFRAC field. */
#define SIM_RD_CLKDIV2_USBFRAC(base) ((SIM_CLKDIV2_REG(base) & SIM_CLKDIV2_USBFRAC_MASK) >> SIM_CLKDIV2_USBFRAC_SHIFT)
#define SIM_BRD_CLKDIV2_USBFRAC(base) (BITBAND_ACCESS32(&SIM_CLKDIV2_REG(base), SIM_CLKDIV2_USBFRAC_SHIFT))

/*! @brief Set the USBFRAC field to a new value. */
#define SIM_WR_CLKDIV2_USBFRAC(base, value) (SIM_RMW_CLKDIV2(base, SIM_CLKDIV2_USBFRAC_MASK, SIM_CLKDIV2_USBFRAC(value)))
#define SIM_BWR_CLKDIV2_USBFRAC(base, value) (BITBAND_ACCESS32(&SIM_CLKDIV2_REG(base), SIM_CLKDIV2_USBFRAC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_CLKDIV2, field USBDIV[3:1] (RW)
 *
 * This field sets the divide value for the fractional clock divider when the
 * MCGFLLCLK/MCGPLLCLK clock is the USB clock source (SOPT2[USBSRC] = 1). Divider
 * output clock = Divider input clock * [ (USBFRAC+1) / (USBDIV+1) ]
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV2_USBDIV field. */
#define SIM_RD_CLKDIV2_USBDIV(base) ((SIM_CLKDIV2_REG(base) & SIM_CLKDIV2_USBDIV_MASK) >> SIM_CLKDIV2_USBDIV_SHIFT)
#define SIM_BRD_CLKDIV2_USBDIV(base) (SIM_RD_CLKDIV2_USBDIV(base))

/*! @brief Set the USBDIV field to a new value. */
#define SIM_WR_CLKDIV2_USBDIV(base, value) (SIM_RMW_CLKDIV2(base, SIM_CLKDIV2_USBDIV_MASK, SIM_CLKDIV2_USBDIV(value)))
#define SIM_BWR_CLKDIV2_USBDIV(base, value) (SIM_WR_CLKDIV2_USBDIV(base, value))
/*@}*/

/*******************************************************************************
 * SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset value of EESIZE and DEPART are based on user programming in user
 * IFR via the PGMPART flash command.
 */
/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define SIM_RD_FCFG1(base)       (SIM_FCFG1_REG(base))
#define SIM_WR_FCFG1(base, value) (SIM_FCFG1_REG(base) = (value))
#define SIM_RMW_FCFG1(base, mask, value) (SIM_WR_FCFG1(base, (SIM_RD_FCFG1(base) & ~(mask)) | (value)))
#define SIM_SET_FCFG1(base, value) (SIM_WR_FCFG1(base, SIM_RD_FCFG1(base) |  (value)))
#define SIM_CLR_FCFG1(base, value) (SIM_WR_FCFG1(base, SIM_RD_FCFG1(base) & ~(value)))
#define SIM_TOG_FCFG1(base, value) (SIM_WR_FCFG1(base, SIM_RD_FCFG1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the Flash memory
 * is placed in a low power state. This bit should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0 - Flash is enabled
 * - 1 - Flash is disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define SIM_RD_FCFG1_FLASHDIS(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDIS_MASK) >> SIM_FCFG1_FLASHDIS_SHIFT)
#define SIM_BRD_FCFG1_FLASHDIS(base) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT))

/*! @brief Set the FLASHDIS field to a new value. */
#define SIM_WR_FCFG1_FLASHDIS(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDIS_MASK, SIM_FCFG1_FLASHDIS(value)))
#define SIM_BWR_FCFG1_FLASHDIS(base, value) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, Flash memory is disabled for the duration of Wait mode. An attempt
 * by the DMA or other bus master to access the Flash when the Flash is disabled
 * will result in a bus error. This bit should be clear during VLP modes. The
 * Flash will be automatically enabled again at the end of Wait mode so interrupt
 * vectors do not need to be relocated out of Flash memory. The wakeup time from
 * Wait mode is extended when this bit is set.
 *
 * Values:
 * - 0 - Flash remains enabled during Wait mode
 * - 1 - Flash is disabled for the duration of Wait mode
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define SIM_RD_FCFG1_FLASHDOZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDOZE_MASK) >> SIM_FCFG1_FLASHDOZE_SHIFT)
#define SIM_BRD_FCFG1_FLASHDOZE(base) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT))

/*! @brief Set the FLASHDOZE field to a new value. */
#define SIM_WR_FCFG1_FLASHDOZE(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDOZE_MASK, SIM_FCFG1_FLASHDOZE(value)))
#define SIM_BWR_FCFG1_FLASHDOZE(base, value) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field DEPART[11:8] (RO)
 *
 * Data flash / EEPROM backup split . See DEPART bit description in FTFL chapter.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_DEPART field. */
#define SIM_RD_FCFG1_DEPART(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_DEPART_MASK) >> SIM_FCFG1_DEPART_SHIFT)
#define SIM_BRD_FCFG1_DEPART(base) (SIM_RD_FCFG1_DEPART(base))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field EESIZE[19:16] (RO)
 *
 * EEPROM data size .
 *
 * Values:
 * - 0000 - Reserved
 * - 0001 - Reserved
 * - 0010 - Reserved
 * - 0011 - 2 KB
 * - 0100 - 1 KB
 * - 0101 - 512 Bytes
 * - 0110 - 256 Bytes
 * - 0111 - 128 Bytes
 * - 1000 - 64 Bytes
 * - 1001 - 32 Bytes
 * - 1111 - 0 Bytes
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_EESIZE field. */
#define SIM_RD_FCFG1_EESIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_EESIZE_MASK) >> SIM_FCFG1_EESIZE_SHIFT)
#define SIM_BRD_FCFG1_EESIZE(base) (SIM_RD_FCFG1_EESIZE(base))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * This field specifies the amount of program flash memory available on the
 * device . Undefined values are reserved.
 *
 * Values:
 * - 0011 - 32 KB of program flash memory, 1 KB protection region
 * - 0101 - 64 KB of program flash memory, 2 KB protection region
 * - 0111 - 128 KB of program flash, 4 KB protection region
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define SIM_RD_FCFG1_PFSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT)
#define SIM_BRD_FCFG1_PFSIZE(base) (SIM_RD_FCFG1_PFSIZE(base))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field NVMSIZE[31:28] (RO)
 *
 * This field specifies the amount of FlexNVM memory available on the device .
 * Undefined values are reserved.
 *
 * Values:
 * - 0000 - 0 KB of FlexNVM
 * - 0011 - 32 KB of FlexNVM, 4 KB protection region
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_NVMSIZE field. */
#define SIM_RD_FCFG1_NVMSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_NVMSIZE_MASK) >> SIM_FCFG1_NVMSIZE_SHIFT)
#define SIM_BRD_FCFG1_NVMSIZE(base) (SIM_RD_FCFG1_NVMSIZE(base))
/*@}*/

/*******************************************************************************
 * SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define SIM_RD_FCFG2(base)       (SIM_FCFG2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR1[22:16] (RO)
 *
 * This field concatenated with leading zeros plus the FlexNVM base address
 * indicates the first invalid address of the FlexNVM (flash block 1). For example,
 * if MAXADDR1 = 0x20 the first invalid address of flash block 1 is 0x4_0000 +
 * 0x1000_0000 . This would be the MAXADDR1 value for a device with 256 KB FlexNVM.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR1 field. */
#define SIM_RD_FCFG2_MAXADDR1(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR1_MASK) >> SIM_FCFG2_MAXADDR1_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR1(base) (SIM_RD_FCFG2_MAXADDR1(base))
/*@}*/

/*!
 * @name Register SIM_FCFG2, field PFLSH[23] (RO)
 *
 * For devices with FlexNVM, this bit is always clear.
 *
 * Values:
 * - 0 - Physical flash block 1 is used as FlexNVM
 * - 1 - Physical flash block 1 is used as program flash
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_PFLSH field. */
#define SIM_RD_FCFG2_PFLSH(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_PFLSH_MASK) >> SIM_FCFG2_PFLSH_SHIFT)
#define SIM_BRD_FCFG2_PFLSH(base) (BITBAND_ACCESS32(&SIM_FCFG2_REG(base), SIM_FCFG2_PFLSH_SHIFT))
/*@}*/

/*!
 * @name Register SIM_FCFG2, field MAXADDR0[30:24] (RO)
 *
 * This field concatenated with leading zeros indicates the first invalid
 * address of flash block 0 (program flash 0). For example, if MAXADDR0 = 0x20 the
 * first invalid address of flash block 0 is 0x0004_0000. This would be the MAXADDR0
 * value for a device with 256 KB program flash in flash block 0.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR0 field. */
#define SIM_RD_FCFG2_MAXADDR0(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR0_MASK) >> SIM_FCFG2_MAXADDR0_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR0(base) (SIM_RD_FCFG2_MAXADDR0(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDH - Unique Identification Register High
 ******************************************************************************/

/*!
 * @brief SIM_UIDH - Unique Identification Register High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDH register
 */
/*@{*/
#define SIM_RD_UIDH(base)        (SIM_UIDH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define SIM_RD_UIDMH(base)       (SIM_UIDMH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDML - Unique Identification Register Mid Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDML - Unique Identification Register Mid Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define SIM_RD_UIDML(base)       (SIM_UIDML_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define SIM_RD_UIDL(base)        (SIM_UIDL_REG(base))
/*@}*/

/*
 * MK20D5 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - SMC_PMPROT - Power Mode Protection Register
 * - SMC_PMCTRL - Power Mode Control Register
 * - SMC_VLLSCTRL - VLLS Control Register
 * - SMC_PMSTAT - Power Mode Status Register
 */

#define SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define SMC_IDX (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * SMC_PMPROT - Power Mode Protection Register
 ******************************************************************************/

/*!
 * @brief SMC_PMPROT - Power Mode Protection Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides protection for entry into any low power run or stop
 * mode. The actual enabling of the low power run or stop mode occurs by
 * configuring the power mode control register (PMCTRL). The PMPROT register can be written
 * only once after any system reset. If the MCU is configured for a disallowed
 * or reserved power mode, the MCU remains in its current power mode. For example,
 * if the MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode
 * using PMCTRL[RUNM] is blocked and the RUNM bits remain 00b, indicating the
 * MCU is still in normal run mode. This register is reset on Chip Reset not VLLS
 * and by reset types that trigger Chip Reset not VLLS. It is unaffected by reset
 * types that do not trigger Chip Reset not VLLS. See the Reset section details
 * for more information.
 */
/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define SMC_RD_PMPROT(base)      (SMC_PMPROT_REG(base))
#define SMC_WR_PMPROT(base, value) (SMC_PMPROT_REG(base) = (value))
#define SMC_RMW_PMPROT(base, mask, value) (SMC_WR_PMPROT(base, (SMC_RD_PMPROT(base) & ~(mask)) | (value)))
#define SMC_SET_PMPROT(base, value) (SMC_WR_PMPROT(base, SMC_RD_PMPROT(base) |  (value)))
#define SMC_CLR_PMPROT(base, value) (SMC_WR_PMPROT(base, SMC_RD_PMPROT(base) & ~(value)))
#define SMC_TOG_PMPROT(base, value) (SMC_WR_PMPROT(base, SMC_RD_PMPROT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLLS[1] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write once
 * bit allows the MCU to enter any very low leakage stop mode (VLLSx).
 *
 * Values:
 * - 0 - Any VLLSx mode is not allowed
 * - 1 - Any VLLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLLS field. */
#define SMC_RD_PMPROT_AVLLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLLS_MASK) >> SMC_PMPROT_AVLLS_SHIFT)
#define SMC_BRD_PMPROT_AVLLS(base) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLLS_SHIFT))

/*! @brief Set the AVLLS field to a new value. */
#define SMC_WR_PMPROT_AVLLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLLS_MASK, SMC_PMPROT_AVLLS(value)))
#define SMC_BWR_PMPROT_AVLLS(base, value) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLLS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field ALLS[3] (RW)
 *
 * This write once bit allows the MCU to enter any low leakage stop mode (LLS)
 * provided the appropriate control bits are set up in PMCTRL.
 *
 * Values:
 * - 0 - LLS is not allowed
 * - 1 - LLS is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_ALLS field. */
#define SMC_RD_PMPROT_ALLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_ALLS_MASK) >> SMC_PMPROT_ALLS_SHIFT)
#define SMC_BRD_PMPROT_ALLS(base) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_ALLS_SHIFT))

/*! @brief Set the ALLS field to a new value. */
#define SMC_WR_PMPROT_ALLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_ALLS_MASK, SMC_PMPROT_ALLS(value)))
#define SMC_BWR_PMPROT_ALLS(base, value) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_ALLS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * bit allows the MCU to enter any very low power modes: VLPR, VLPW, and VLPS.
 *
 * Values:
 * - 0 - VLPR, VLPW and VLPS are not allowed
 * - 1 - VLPR, VLPW and VLPS are allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define SMC_RD_PMPROT_AVLP(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLP_MASK) >> SMC_PMPROT_AVLP_SHIFT)
#define SMC_BRD_PMPROT_AVLP(base) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT))

/*! @brief Set the AVLP field to a new value. */
#define SMC_WR_PMPROT_AVLP(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLP_MASK, SMC_PMPROT_AVLP(value)))
#define SMC_BWR_PMPROT_AVLP(base, value) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SMC_PMCTRL - Power Mode Control Register
 ******************************************************************************/

/*!
 * @brief SMC_PMCTRL - Power Mode Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The PMCTRL register controls entry into low power run and stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details. for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define SMC_RD_PMCTRL(base)      (SMC_PMCTRL_REG(base))
#define SMC_WR_PMCTRL(base, value) (SMC_PMCTRL_REG(base) = (value))
#define SMC_RMW_PMCTRL(base, mask, value) (SMC_WR_PMCTRL(base, (SMC_RD_PMCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_PMCTRL(base, value) (SMC_WR_PMCTRL(base, SMC_RD_PMCTRL(base) |  (value)))
#define SMC_CLR_PMCTRL(base, value) (SMC_WR_PMCTRL(base, SMC_RD_PMCTRL(base) & ~(value)))
#define SMC_TOG_PMCTRL(base, value) (SMC_WR_PMCTRL(base, SMC_RD_PMCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, this field controls entry into the selected stop mode when
 * sleep-now or sleep-on-exit mode is entered with SLEEPDEEP=1 . When this field is
 * set to VLLSx, the VLLSCTRL register is used to further select the particular
 * VLLS sub-mode which will be entered. Writes to this field are blocked if the
 * protection level has not been enabled using the PMPROT register. After any system
 * reset, this field is cleared by hardware on any successful write to the
 * PMPROT register.
 *
 * Values:
 * - 000 - Normal stop (STOP)
 * - 001 - Reserved
 * - 010 - Very low power stop (VLPS)
 * - 011 - Low leakage stop (LLS)
 * - 100 - Very low leakage stop (VLLSx)
 * - 101 - Reserved
 * - 110 - Reseved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define SMC_RD_PMCTRL_STOPM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPM_MASK) >> SMC_PMCTRL_STOPM_SHIFT)
#define SMC_BRD_PMCTRL_STOPM(base) (SMC_RD_PMCTRL_STOPM(base))

/*! @brief Set the STOPM field to a new value. */
#define SMC_WR_PMCTRL_STOPM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_STOPM_MASK, SMC_PMCTRL_STOPM(value)))
#define SMC_BWR_PMCTRL_STOPM(base, value) (SMC_WR_PMCTRL_STOPM(base, value))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt or reset occured
 * during the previous stop mode entry sequence, preventing the system from
 * entering that mode. This bit is cleared by hardware at the beginning of any stop
 * mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0 - The previous stop mode entry was successsful.
 * - 1 - The previous stop mode entry was aborted.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define SMC_RD_PMCTRL_STOPA(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPA_MASK) >> SMC_PMCTRL_STOPA_SHIFT)
#define SMC_BRD_PMCTRL_STOPA(base) (BITBAND_ACCESS8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPA_SHIFT))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, this field causes entry into the selected run mode. Writes to
 * this field are blocked if the protection level has not been enabled using the
 * PMPROT register. This field is cleared by hardware on any exit to normal RUN
 * mode. RUNM should only be set to VLPR when PMSTAT=RUN. Once written to VLPR,
 * RUNM should not be written back to RUN until PMSTAT=VLPR. RUNM should only be set
 * to RUN when PMSTAT=VLPR. Once written to RUN, RUNM should not be written back
 * to VLPR until PMSTAT=RUN.
 *
 * Values:
 * - 00 - Normal run mode (RUN)
 * - 01 - Reserved
 * - 10 - Very low power run mode (VLPR)
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define SMC_RD_PMCTRL_RUNM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_RUNM_MASK) >> SMC_PMCTRL_RUNM_SHIFT)
#define SMC_BRD_PMCTRL_RUNM(base) (SMC_RD_PMCTRL_RUNM(base))

/*! @brief Set the RUNM field to a new value. */
#define SMC_WR_PMCTRL_RUNM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_RUNM_MASK, SMC_PMCTRL_RUNM(value)))
#define SMC_BWR_PMCTRL_RUNM(base, value) (SMC_WR_PMCTRL_RUNM(base, value))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field LPWUI[7] (RW)
 *
 * Causes the SMC to exit to normal RUN mode when any active MCU interrupt
 * occurs while in a VLP mode (VLPR, VLPW or VLPS). If VLPS mode was entered directly
 * from RUN mode, the SMC will always exit back to normal RUN mode regardless of
 * the LPWUI setting. LPWUI should only be modified while the system is in RUN
 * mode i.e. when PMSTAT=RUN.
 *
 * Values:
 * - 0 - The system remains in a VLP mode on an interrupt
 * - 1 - The system exits to normal RUN mode on an interrupt
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_LPWUI field. */
#define SMC_RD_PMCTRL_LPWUI(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_LPWUI_MASK) >> SMC_PMCTRL_LPWUI_SHIFT)
#define SMC_BRD_PMCTRL_LPWUI(base) (BITBAND_ACCESS8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_LPWUI_SHIFT))

/*! @brief Set the LPWUI field to a new value. */
#define SMC_WR_PMCTRL_LPWUI(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_LPWUI_MASK, SMC_PMCTRL_LPWUI(value)))
#define SMC_BWR_PMCTRL_LPWUI(base, value) (BITBAND_ACCESS8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_LPWUI_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SMC_VLLSCTRL - VLLS Control Register
 ******************************************************************************/

/*!
 * @brief SMC_VLLSCTRL - VLLS Control Register (RW)
 *
 * Reset value: 0x03U
 *
 * The VLLSCTRL register selects which VLLSx mode is entered if STOPM=VLLS and
 * controls power to FlexRAM during VLLS2. This register is reset on Chip POR not
 * VLLS and by reset types that trigger Chip POR not VLLS. It is unaffected by
 * reset types that do not trigger Chip POR not VLLS. See the Reset section
 * details. for more information.
 */
/*!
 * @name Constants and macros for entire SMC_VLLSCTRL register
 */
/*@{*/
#define SMC_RD_VLLSCTRL(base)    (SMC_VLLSCTRL_REG(base))
#define SMC_WR_VLLSCTRL(base, value) (SMC_VLLSCTRL_REG(base) = (value))
#define SMC_RMW_VLLSCTRL(base, mask, value) (SMC_WR_VLLSCTRL(base, (SMC_RD_VLLSCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_VLLSCTRL(base, value) (SMC_WR_VLLSCTRL(base, SMC_RD_VLLSCTRL(base) |  (value)))
#define SMC_CLR_VLLSCTRL(base, value) (SMC_WR_VLLSCTRL(base, SMC_RD_VLLSCTRL(base) & ~(value)))
#define SMC_TOG_VLLSCTRL(base, value) (SMC_WR_VLLSCTRL(base, SMC_RD_VLLSCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SMC_VLLSCTRL bitfields
 */

/*!
 * @name Register SMC_VLLSCTRL, field VLLSM[2:0] (RW)
 *
 * This field controls which VLLS sub-mode to enter if STOPM=VLLS.
 *
 * Values:
 * - 000 - VLLS0
 * - 001 - VLLS1
 * - 010 - VLLS2
 * - 011 - VLLS3
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_VLLSCTRL_VLLSM field. */
#define SMC_RD_VLLSCTRL_VLLSM(base) ((SMC_VLLSCTRL_REG(base) & SMC_VLLSCTRL_VLLSM_MASK) >> SMC_VLLSCTRL_VLLSM_SHIFT)
#define SMC_BRD_VLLSCTRL_VLLSM(base) (SMC_RD_VLLSCTRL_VLLSM(base))

/*! @brief Set the VLLSM field to a new value. */
#define SMC_WR_VLLSCTRL_VLLSM(base, value) (SMC_RMW_VLLSCTRL(base, SMC_VLLSCTRL_VLLSM_MASK, SMC_VLLSCTRL_VLLSM(value)))
#define SMC_BWR_VLLSCTRL_VLLSM(base, value) (SMC_WR_VLLSCTRL_VLLSM(base, value))
/*@}*/

/*!
 * @name Register SMC_VLLSCTRL, field PORPO[5] (RW)
 *
 * This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 *
 * Values:
 * - 0 - POR detect circuit is enabled in VLLS0
 * - 1 - POR detect circuit is disabled in VLLS0
 */
/*@{*/
/*! @brief Read current value of the SMC_VLLSCTRL_PORPO field. */
#define SMC_RD_VLLSCTRL_PORPO(base) ((SMC_VLLSCTRL_REG(base) & SMC_VLLSCTRL_PORPO_MASK) >> SMC_VLLSCTRL_PORPO_SHIFT)
#define SMC_BRD_VLLSCTRL_PORPO(base) (BITBAND_ACCESS8(&SMC_VLLSCTRL_REG(base), SMC_VLLSCTRL_PORPO_SHIFT))

/*! @brief Set the PORPO field to a new value. */
#define SMC_WR_VLLSCTRL_PORPO(base, value) (SMC_RMW_VLLSCTRL(base, SMC_VLLSCTRL_PORPO_MASK, SMC_VLLSCTRL_PORPO(value)))
#define SMC_BWR_VLLSCTRL_PORPO(base, value) (BITBAND_ACCESS8(&SMC_VLLSCTRL_REG(base), SMC_VLLSCTRL_PORPO_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SMC_PMSTAT - Power Mode Status Register
 ******************************************************************************/

/*!
 * @brief SMC_PMSTAT - Power Mode Status Register (RO)
 *
 * Reset value: 0x01U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details. for more information.
 */
/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define SMC_RD_PMSTAT(base)      (SMC_PMSTAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual SMC_PMSTAT bitfields
 */

/*!
 * @name Register SMC_PMSTAT, field PMSTAT[6:0] (RO)
 *
 * When debug is enabled, the PMSTAT will not update to STOP or VLPS
 */
/*@{*/
/*! @brief Read current value of the SMC_PMSTAT_PMSTAT field. */
#define SMC_RD_PMSTAT_PMSTAT(base) ((SMC_PMSTAT_REG(base) & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT)
#define SMC_BRD_PMSTAT_PMSTAT(base) (SMC_RD_PMSTAT_PMSTAT(base))
/*@}*/

/*
 * MK20D5 SPI
 *
 * Deserial Serial Peripheral Interface
 *
 * Registers defined in this header file:
 * - SPI_MCR - DSPI Module Configuration Register
 * - SPI_TCR - DSPI Transfer Count Register
 * - SPI_CTAR - DSPI Clock and Transfer Attributes Register (In Master Mode)
 * - SPI_CTAR_SLAVE - DSPI Clock and Transfer Attributes Register (In Slave Mode)
 * - SPI_SR - DSPI Status Register
 * - SPI_RSER - DSPI DMA/Interrupt Request Select and Enable Register
 * - SPI_PUSHR - DSPI PUSH TX FIFO Register In Master Mode
 * - SPI_PUSHR_SLAVE - DSPI PUSH TX FIFO Register In Slave Mode
 * - SPI_POPR - DSPI POP RX FIFO Register
 * - SPI_TXFR0 - DSPI Transmit FIFO Registers
 * - SPI_TXFR1 - DSPI Transmit FIFO Registers
 * - SPI_TXFR2 - DSPI Transmit FIFO Registers
 * - SPI_TXFR3 - DSPI Transmit FIFO Registers
 * - SPI_RXFR0 - DSPI Receive FIFO Registers
 * - SPI_RXFR1 - DSPI Receive FIFO Registers
 * - SPI_RXFR2 - DSPI Receive FIFO Registers
 * - SPI_RXFR3 - DSPI Receive FIFO Registers
 */

#define SPI_INSTANCE_COUNT (1U) /*!< Number of instances of the SPI module. */
#define SPI0_IDX (0U) /*!< Instance number for SPI0. */

/*******************************************************************************
 * SPI_MCR - DSPI Module Configuration Register
 ******************************************************************************/

/*!
 * @brief SPI_MCR - DSPI Module Configuration Register (RW)
 *
 * Reset value: 0x00004001U
 *
 * Contains bits to configure various attributes associated with DSPI
 * operations. The HALT and MDIS bits can be changed at any time, but they only take effect
 * on the next frame boundary. Only the HALT and MDIS bits in the MCR can be
 * changed, while the DSPI is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_MCR register
 */
/*@{*/
#define SPI_RD_MCR(base)         (SPI_MCR_REG(base))
#define SPI_WR_MCR(base, value)  (SPI_MCR_REG(base) = (value))
#define SPI_RMW_MCR(base, mask, value) (SPI_WR_MCR(base, (SPI_RD_MCR(base) & ~(mask)) | (value)))
#define SPI_SET_MCR(base, value) (SPI_WR_MCR(base, SPI_RD_MCR(base) |  (value)))
#define SPI_CLR_MCR(base, value) (SPI_WR_MCR(base, SPI_RD_MCR(base) & ~(value)))
#define SPI_TOG_MCR(base, value) (SPI_WR_MCR(base, SPI_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_MCR bitfields
 */

/*!
 * @name Register SPI_MCR, field HALT[0] (RW)
 *
 * Starts and stops DSPI transfers.
 *
 * Values:
 * - 0 - Start transfers.
 * - 1 - Stop transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_HALT field. */
#define SPI_RD_MCR_HALT(base) ((SPI_MCR_REG(base) & SPI_MCR_HALT_MASK) >> SPI_MCR_HALT_SHIFT)
#define SPI_BRD_MCR_HALT(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_HALT_SHIFT))

/*! @brief Set the HALT field to a new value. */
#define SPI_WR_MCR_HALT(base, value) (SPI_RMW_MCR(base, SPI_MCR_HALT_MASK, SPI_MCR_HALT(value)))
#define SPI_BWR_MCR_HALT(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_HALT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field SMPL_PT[9:8] (RW)
 *
 * Controls when the DSPI master samples SIN in Modified Transfer Format. This
 * field is valid only when CPHA bit in CTAR register is 0.
 *
 * Values:
 * - 00 - 0 system clocks between SCK edge and SIN sample
 * - 01 - 1 system clock between SCK edge and SIN sample
 * - 10 - 2 system clocks between SCK edge and SIN sample
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_SMPL_PT field. */
#define SPI_RD_MCR_SMPL_PT(base) ((SPI_MCR_REG(base) & SPI_MCR_SMPL_PT_MASK) >> SPI_MCR_SMPL_PT_SHIFT)
#define SPI_BRD_MCR_SMPL_PT(base) (SPI_RD_MCR_SMPL_PT(base))

/*! @brief Set the SMPL_PT field to a new value. */
#define SPI_WR_MCR_SMPL_PT(base, value) (SPI_RMW_MCR(base, SPI_MCR_SMPL_PT_MASK, SPI_MCR_SMPL_PT(value)))
#define SPI_BWR_MCR_SMPL_PT(base, value) (SPI_WR_MCR_SMPL_PT(base, value))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_RXF[10] (WORZ)
 *
 * Flushes the RX FIFO. Writing a 1 to CLR_RXF clears the RX Counter. The
 * CLR_RXF bit is always read as zero.
 *
 * Values:
 * - 0 - Do not clear the Rx FIFO counter.
 * - 1 - Clear the Rx FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_RXF field to a new value. */
#define SPI_WR_MCR_CLR_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_RXF_MASK, SPI_MCR_CLR_RXF(value)))
#define SPI_BWR_MCR_CLR_RXF(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_CLR_RXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_TXF[11] (WORZ)
 *
 * Flushes the TX FIFO. Writing a 1 to CLR_TXF clears the TX FIFO Counter. The
 * CLR_TXF bit is always read as zero.
 *
 * Values:
 * - 0 - Do not clear the Tx FIFO counter.
 * - 1 - Clear the Tx FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_TXF field to a new value. */
#define SPI_WR_MCR_CLR_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_TXF_MASK, SPI_MCR_CLR_TXF(value)))
#define SPI_BWR_MCR_CLR_TXF(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_CLR_TXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_RXF[12] (RW)
 *
 * When the RX FIFO is disabled, the receive part of the DSPI operates as a
 * simplified double-buffered SPI. This bit can only be written when the MDIS bit is
 * cleared.
 *
 * Values:
 * - 0 - Rx FIFO is enabled.
 * - 1 - Rx FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_RXF field. */
#define SPI_RD_MCR_DIS_RXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_RXF_MASK) >> SPI_MCR_DIS_RXF_SHIFT)
#define SPI_BRD_MCR_DIS_RXF(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DIS_RXF_SHIFT))

/*! @brief Set the DIS_RXF field to a new value. */
#define SPI_WR_MCR_DIS_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_RXF_MASK, SPI_MCR_DIS_RXF(value)))
#define SPI_BWR_MCR_DIS_RXF(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DIS_RXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_TXF[13] (RW)
 *
 * When the TX FIFO is disabled, the transmit part of the DSPI operates as a
 * simplified double-buffered SPI. This bit can only be written when the MDIS bit is
 * cleared.
 *
 * Values:
 * - 0 - Tx FIFO is enabled.
 * - 1 - Tx FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_TXF field. */
#define SPI_RD_MCR_DIS_TXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_TXF_MASK) >> SPI_MCR_DIS_TXF_SHIFT)
#define SPI_BRD_MCR_DIS_TXF(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DIS_TXF_SHIFT))

/*! @brief Set the DIS_TXF field to a new value. */
#define SPI_WR_MCR_DIS_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_TXF_MASK, SPI_MCR_DIS_TXF(value)))
#define SPI_BWR_MCR_DIS_TXF(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DIS_TXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field MDIS[14] (RW)
 *
 * Allows the clock to be stopped to the non-memory mapped logic in the DSPI
 * effectively putting the DSPI in a software controlled power-saving state. The
 * reset value of the MDIS bit is parameterized, with a default reset value of "0".
 *
 * Values:
 * - 0 - Enable DSPI clocks.
 * - 1 - Allow external logic to disable DSPI clocks.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MDIS field. */
#define SPI_RD_MCR_MDIS(base) ((SPI_MCR_REG(base) & SPI_MCR_MDIS_MASK) >> SPI_MCR_MDIS_SHIFT)
#define SPI_BRD_MCR_MDIS(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MDIS_SHIFT))

/*! @brief Set the MDIS field to a new value. */
#define SPI_WR_MCR_MDIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_MDIS_MASK, SPI_MCR_MDIS(value)))
#define SPI_BWR_MCR_MDIS(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field DOZE[15] (RW)
 *
 * Provides support for an externally controlled Doze mode power-saving
 * mechanism.
 *
 * Values:
 * - 0 - Doze mode has no effect on DSPI.
 * - 1 - Doze mode disables DSPI.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DOZE field. */
#define SPI_RD_MCR_DOZE(base) ((SPI_MCR_REG(base) & SPI_MCR_DOZE_MASK) >> SPI_MCR_DOZE_SHIFT)
#define SPI_BRD_MCR_DOZE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DOZE_SHIFT))

/*! @brief Set the DOZE field to a new value. */
#define SPI_WR_MCR_DOZE(base, value) (SPI_RMW_MCR(base, SPI_MCR_DOZE_MASK, SPI_MCR_DOZE(value)))
#define SPI_BWR_MCR_DOZE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DOZE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSIS[21:16] (RW)
 *
 * Determines the inactive state of PCSx.
 *
 * Values:
 * - 0 - The inactive state of PCSx is low.
 * - 1 - The inactive state of PCSx is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_PCSIS field. */
#define SPI_RD_MCR_PCSIS(base) ((SPI_MCR_REG(base) & SPI_MCR_PCSIS_MASK) >> SPI_MCR_PCSIS_SHIFT)
#define SPI_BRD_MCR_PCSIS(base) (SPI_RD_MCR_PCSIS(base))

/*! @brief Set the PCSIS field to a new value. */
#define SPI_WR_MCR_PCSIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_PCSIS_MASK, SPI_MCR_PCSIS(value)))
#define SPI_BWR_MCR_PCSIS(base, value) (SPI_WR_MCR_PCSIS(base, value))
/*@}*/

/*!
 * @name Register SPI_MCR, field ROOE[24] (RW)
 *
 * In the RX FIFO overflow condition, configures the DSPI to ignore the incoming
 * serial data or overwrite existing data. If the RX FIFO is full and new data
 * is received, the data from the transfer, generating the overflow, is ignored or
 * shifted into the shift register.
 *
 * Values:
 * - 0 - Incoming data is ignored.
 * - 1 - Incoming data is shifted into the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_ROOE field. */
#define SPI_RD_MCR_ROOE(base) ((SPI_MCR_REG(base) & SPI_MCR_ROOE_MASK) >> SPI_MCR_ROOE_SHIFT)
#define SPI_BRD_MCR_ROOE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_ROOE_SHIFT))

/*! @brief Set the ROOE field to a new value. */
#define SPI_WR_MCR_ROOE(base, value) (SPI_RMW_MCR(base, SPI_MCR_ROOE_MASK, SPI_MCR_ROOE(value)))
#define SPI_BWR_MCR_ROOE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_ROOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSSE[25] (RW)
 *
 * Enables the PCS[5]/ PCSS to operate as a PCS Strobe output signal.
 *
 * Values:
 * - 0 - PCS[5]/PCSS is used as the Peripheral Chip Select[5] signal.
 * - 1 - PCS[5]/PCSS is used as an active-low PCS Strobe signal.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_PCSSE field. */
#define SPI_RD_MCR_PCSSE(base) ((SPI_MCR_REG(base) & SPI_MCR_PCSSE_MASK) >> SPI_MCR_PCSSE_SHIFT)
#define SPI_BRD_MCR_PCSSE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_PCSSE_SHIFT))

/*! @brief Set the PCSSE field to a new value. */
#define SPI_WR_MCR_PCSSE(base, value) (SPI_RMW_MCR(base, SPI_MCR_PCSSE_MASK, SPI_MCR_PCSSE(value)))
#define SPI_BWR_MCR_PCSSE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_PCSSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field MTFE[26] (RW)
 *
 * Enables a modified transfer format to be used.
 *
 * Values:
 * - 0 - Modified SPI transfer format disabled.
 * - 1 - Modified SPI transfer format enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MTFE field. */
#define SPI_RD_MCR_MTFE(base) ((SPI_MCR_REG(base) & SPI_MCR_MTFE_MASK) >> SPI_MCR_MTFE_SHIFT)
#define SPI_BRD_MCR_MTFE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MTFE_SHIFT))

/*! @brief Set the MTFE field to a new value. */
#define SPI_WR_MCR_MTFE(base, value) (SPI_RMW_MCR(base, SPI_MCR_MTFE_MASK, SPI_MCR_MTFE(value)))
#define SPI_BWR_MCR_MTFE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MTFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field FRZ[27] (RW)
 *
 * Enables the DSPI transfers to be stopped on the next frame boundary when the
 * device enters Debug mode.
 *
 * Values:
 * - 0 - Do not halt serial transfers in debug mode.
 * - 1 - Halt serial transfers in debug mode.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_FRZ field. */
#define SPI_RD_MCR_FRZ(base) ((SPI_MCR_REG(base) & SPI_MCR_FRZ_MASK) >> SPI_MCR_FRZ_SHIFT)
#define SPI_BRD_MCR_FRZ(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_FRZ_SHIFT))

/*! @brief Set the FRZ field to a new value. */
#define SPI_WR_MCR_FRZ(base, value) (SPI_RMW_MCR(base, SPI_MCR_FRZ_MASK, SPI_MCR_FRZ(value)))
#define SPI_BWR_MCR_FRZ(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_FRZ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field DCONF[29:28] (RW)
 *
 * Selects among the different configurations of the DSPI.
 *
 * Values:
 * - 00 - SPI
 * - 01 - Reserved
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DCONF field. */
#define SPI_RD_MCR_DCONF(base) ((SPI_MCR_REG(base) & SPI_MCR_DCONF_MASK) >> SPI_MCR_DCONF_SHIFT)
#define SPI_BRD_MCR_DCONF(base) (SPI_RD_MCR_DCONF(base))

/*! @brief Set the DCONF field to a new value. */
#define SPI_WR_MCR_DCONF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DCONF_MASK, SPI_MCR_DCONF(value)))
#define SPI_BWR_MCR_DCONF(base, value) (SPI_WR_MCR_DCONF(base, value))
/*@}*/

/*!
 * @name Register SPI_MCR, field CONT_SCKE[30] (RW)
 *
 * Enables the Serial Communication Clock (SCK) to run continuously.
 *
 * Values:
 * - 0 - Continuous SCK disabled.
 * - 1 - Continuous SCK enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_CONT_SCKE field. */
#define SPI_RD_MCR_CONT_SCKE(base) ((SPI_MCR_REG(base) & SPI_MCR_CONT_SCKE_MASK) >> SPI_MCR_CONT_SCKE_SHIFT)
#define SPI_BRD_MCR_CONT_SCKE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_CONT_SCKE_SHIFT))

/*! @brief Set the CONT_SCKE field to a new value. */
#define SPI_WR_MCR_CONT_SCKE(base, value) (SPI_RMW_MCR(base, SPI_MCR_CONT_SCKE_MASK, SPI_MCR_CONT_SCKE(value)))
#define SPI_BWR_MCR_CONT_SCKE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_CONT_SCKE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field MSTR[31] (RW)
 *
 * Configures the DSPI for either master mode or slave mode.
 *
 * Values:
 * - 0 - DSPI is in slave mode.
 * - 1 - DSPI is in master mode.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MSTR field. */
#define SPI_RD_MCR_MSTR(base) ((SPI_MCR_REG(base) & SPI_MCR_MSTR_MASK) >> SPI_MCR_MSTR_SHIFT)
#define SPI_BRD_MCR_MSTR(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MSTR_SHIFT))

/*! @brief Set the MSTR field to a new value. */
#define SPI_WR_MCR_MSTR(base, value) (SPI_RMW_MCR(base, SPI_MCR_MSTR_MASK, SPI_MCR_MSTR(value)))
#define SPI_BWR_MCR_MSTR(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MSTR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_TCR - DSPI Transfer Count Register
 ******************************************************************************/

/*!
 * @brief SPI_TCR - DSPI Transfer Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCR contains a counter that indicates the number of SPI transfers made. The
 * transfer counter is intended to assist in queue management. Do not write the
 * TCR when the DSPI is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_TCR register
 */
/*@{*/
#define SPI_RD_TCR(base)         (SPI_TCR_REG(base))
#define SPI_WR_TCR(base, value)  (SPI_TCR_REG(base) = (value))
#define SPI_RMW_TCR(base, mask, value) (SPI_WR_TCR(base, (SPI_RD_TCR(base) & ~(mask)) | (value)))
#define SPI_SET_TCR(base, value) (SPI_WR_TCR(base, SPI_RD_TCR(base) |  (value)))
#define SPI_CLR_TCR(base, value) (SPI_WR_TCR(base, SPI_RD_TCR(base) & ~(value)))
#define SPI_TOG_TCR(base, value) (SPI_WR_TCR(base, SPI_RD_TCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_TCR bitfields
 */

/*!
 * @name Register SPI_TCR, field SPI_TCNT[31:16] (RW)
 *
 * Counts the number of SPI transfers the DSPI makes. The SPI_TCNT field
 * increments every time the last bit of a SPI frame is transmitted. A value written to
 * SPI_TCNT presets the counter to that value. SPI_TCNT is reset to zero at the
 * beginning of the frame when the CTCNT field is set in the executing SPI
 * command. The Transfer Counter wraps around; incrementing the counter past 65535
 * resets the counter to zero.
 */
/*@{*/
/*! @brief Read current value of the SPI_TCR_SPI_TCNT field. */
#define SPI_RD_TCR_SPI_TCNT(base) ((SPI_TCR_REG(base) & SPI_TCR_SPI_TCNT_MASK) >> SPI_TCR_SPI_TCNT_SHIFT)
#define SPI_BRD_TCR_SPI_TCNT(base) (SPI_RD_TCR_SPI_TCNT(base))

/*! @brief Set the SPI_TCNT field to a new value. */
#define SPI_WR_TCR_SPI_TCNT(base, value) (SPI_RMW_TCR(base, SPI_TCR_SPI_TCNT_MASK, SPI_TCR_SPI_TCNT(value)))
#define SPI_BWR_TCR_SPI_TCNT(base, value) (SPI_WR_TCR_SPI_TCNT(base, value))
/*@}*/

/*******************************************************************************
 * SPI_CTAR_SLAVE - DSPI Clock and Transfer Attributes Register (In Slave Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR_SLAVE - DSPI Clock and Transfer Attributes Register (In Slave Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * When the DSPI is configured as an SPI bus slave, the CTAR0 register is used.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR_SLAVE register
 */
/*@{*/
#define SPI_RD_CTAR_SLAVE(base, index) (SPI_CTAR_SLAVE_REG(base, index))
#define SPI_WR_CTAR_SLAVE(base, index, value) (SPI_CTAR_SLAVE_REG(base, index) = (value))
#define SPI_RMW_CTAR_SLAVE(base, index, mask, value) (SPI_WR_CTAR_SLAVE(base, index, (SPI_RD_CTAR_SLAVE(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR_SLAVE(base, index, value) (SPI_WR_CTAR_SLAVE(base, index, SPI_RD_CTAR_SLAVE(base, index) |  (value)))
#define SPI_CLR_CTAR_SLAVE(base, index, value) (SPI_WR_CTAR_SLAVE(base, index, SPI_RD_CTAR_SLAVE(base, index) & ~(value)))
#define SPI_TOG_CTAR_SLAVE(base, index, value) (SPI_WR_CTAR_SLAVE(base, index, SPI_RD_CTAR_SLAVE(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR_SLAVE bitfields
 */

/*!
 * @name Register SPI_CTAR_SLAVE, field CPHA[25] (RW)
 *
 * Values:
 * - 0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPHA field. */
#define SPI_RD_CTAR_SLAVE_CPHA(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPHA_MASK) >> SPI_CTAR_SLAVE_CPHA_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPHA(base, index) (BITBAND_ACCESS32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPHA_SHIFT))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPHA(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPHA_MASK, SPI_CTAR_SLAVE_CPHA(value)))
#define SPI_BWR_CTAR_SLAVE_CPHA(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPHA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field CPOL[26] (RW)
 *
 * Values:
 * - 0 - The inactive state value of SCK is low.
 * - 1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPOL field. */
#define SPI_RD_CTAR_SLAVE_CPOL(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPOL_MASK) >> SPI_CTAR_SLAVE_CPOL_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPOL(base, index) (BITBAND_ACCESS32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPOL_SHIFT))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPOL(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPOL_MASK, SPI_CTAR_SLAVE_CPOL(value)))
#define SPI_BWR_CTAR_SLAVE_CPOL(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field FMSZ[31:27] (RW)
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_FMSZ field. */
#define SPI_RD_CTAR_SLAVE_FMSZ(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT)
#define SPI_BRD_CTAR_SLAVE_FMSZ(base, index) (SPI_RD_CTAR_SLAVE_FMSZ(base, index))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_SLAVE_FMSZ(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_FMSZ_MASK, SPI_CTAR_SLAVE_FMSZ(value)))
#define SPI_BWR_CTAR_SLAVE_FMSZ(base, index, value) (SPI_WR_CTAR_SLAVE_FMSZ(base, index, value))
/*@}*/

/*******************************************************************************
 * SPI_CTAR - DSPI Clock and Transfer Attributes Register (In Master Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR - DSPI Clock and Transfer Attributes Register (In Master Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * CTAR registers are used to define different transfer attributes. The number
 * of CTAR registers is parameterized in the RTL and can be from two to eight
 * registers. Do not write to the CTAR registers while the DSPI is in the Running
 * state. In master mode, the CTAR registers define combinations of transfer
 * attributes such as frame size, clock phase and polarity, data bit ordering, baud
 * rate, and various delays. In slave mode, a subset of the bitfields in CTAR0 are
 * used to set the slave transfer attributes. When the DSPI is configured as an SPI
 * master, the CTAS field in the command portion of the TX FIFO entry selects
 * which of the CTAR register is used. When the DSPI is configured as an SPI bus
 * slave, the CTAR0 register is used.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR register
 */
/*@{*/
#define SPI_RD_CTAR(base, index) (SPI_CTAR_REG(base, index))
#define SPI_WR_CTAR(base, index, value) (SPI_CTAR_REG(base, index) = (value))
#define SPI_RMW_CTAR(base, index, mask, value) (SPI_WR_CTAR(base, index, (SPI_RD_CTAR(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR(base, index, value) (SPI_WR_CTAR(base, index, SPI_RD_CTAR(base, index) |  (value)))
#define SPI_CLR_CTAR(base, index, value) (SPI_WR_CTAR(base, index, SPI_RD_CTAR(base, index) & ~(value)))
#define SPI_TOG_CTAR(base, index, value) (SPI_WR_CTAR(base, index, SPI_RD_CTAR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR bitfields
 */

/*!
 * @name Register SPI_CTAR, field BR[3:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_BR field. */
#define SPI_RD_CTAR_BR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_BR_MASK) >> SPI_CTAR_BR_SHIFT)
#define SPI_BRD_CTAR_BR(base, index) (SPI_RD_CTAR_BR(base, index))

/*! @brief Set the BR field to a new value. */
#define SPI_WR_CTAR_BR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_BR_MASK, SPI_CTAR_BR(value)))
#define SPI_BWR_CTAR_BR(base, index, value) (SPI_WR_CTAR_BR(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DT[7:4] (RW)
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DT field. */
#define SPI_RD_CTAR_DT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DT_MASK) >> SPI_CTAR_DT_SHIFT)
#define SPI_BRD_CTAR_DT(base, index) (SPI_RD_CTAR_DT(base, index))

/*! @brief Set the DT field to a new value. */
#define SPI_WR_CTAR_DT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DT_MASK, SPI_CTAR_DT(value)))
#define SPI_BWR_CTAR_DT(base, index, value) (SPI_WR_CTAR_DT(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field ASC[11:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_ASC field. */
#define SPI_RD_CTAR_ASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_ASC_MASK) >> SPI_CTAR_ASC_SHIFT)
#define SPI_BRD_CTAR_ASC(base, index) (SPI_RD_CTAR_ASC(base, index))

/*! @brief Set the ASC field to a new value. */
#define SPI_WR_CTAR_ASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_ASC_MASK, SPI_CTAR_ASC(value)))
#define SPI_BWR_CTAR_ASC(base, index, value) (SPI_WR_CTAR_ASC(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CSSCK[15:12] (RW)
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CSSCK field. */
#define SPI_RD_CTAR_CSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CSSCK_MASK) >> SPI_CTAR_CSSCK_SHIFT)
#define SPI_BRD_CTAR_CSSCK(base, index) (SPI_RD_CTAR_CSSCK(base, index))

/*! @brief Set the CSSCK field to a new value. */
#define SPI_WR_CTAR_CSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CSSCK_MASK, SPI_CTAR_CSSCK(value)))
#define SPI_BWR_CTAR_CSSCK(base, index, value) (SPI_WR_CTAR_CSSCK(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PBR[17:16] (RW)
 *
 * Values:
 * - 00 - Baud Rate Prescaler value is 2.
 * - 01 - Baud Rate Prescaler value is 3.
 * - 10 - Baud Rate Prescaler value is 5.
 * - 11 - Baud Rate Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PBR field. */
#define SPI_RD_CTAR_PBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PBR_MASK) >> SPI_CTAR_PBR_SHIFT)
#define SPI_BRD_CTAR_PBR(base, index) (SPI_RD_CTAR_PBR(base, index))

/*! @brief Set the PBR field to a new value. */
#define SPI_WR_CTAR_PBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PBR_MASK, SPI_CTAR_PBR(value)))
#define SPI_BWR_CTAR_PBR(base, index, value) (SPI_WR_CTAR_PBR(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PDT[19:18] (RW)
 *
 * Values:
 * - 00 - Delay after Transfer Prescaler value is 1.
 * - 01 - Delay after Transfer Prescaler value is 3.
 * - 10 - Delay after Transfer Prescaler value is 5.
 * - 11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PDT field. */
#define SPI_RD_CTAR_PDT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PDT_MASK) >> SPI_CTAR_PDT_SHIFT)
#define SPI_BRD_CTAR_PDT(base, index) (SPI_RD_CTAR_PDT(base, index))

/*! @brief Set the PDT field to a new value. */
#define SPI_WR_CTAR_PDT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PDT_MASK, SPI_CTAR_PDT(value)))
#define SPI_BWR_CTAR_PDT(base, index, value) (SPI_WR_CTAR_PDT(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PASC[21:20] (RW)
 *
 * Values:
 * - 00 - Delay after Transfer Prescaler value is 1.
 * - 01 - Delay after Transfer Prescaler value is 3.
 * - 10 - Delay after Transfer Prescaler value is 5.
 * - 11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PASC field. */
#define SPI_RD_CTAR_PASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PASC_MASK) >> SPI_CTAR_PASC_SHIFT)
#define SPI_BRD_CTAR_PASC(base, index) (SPI_RD_CTAR_PASC(base, index))

/*! @brief Set the PASC field to a new value. */
#define SPI_WR_CTAR_PASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PASC_MASK, SPI_CTAR_PASC(value)))
#define SPI_BWR_CTAR_PASC(base, index, value) (SPI_WR_CTAR_PASC(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PCSSCK[23:22] (RW)
 *
 * Values:
 * - 00 - PCS to SCK Prescaler value is 1.
 * - 01 - PCS to SCK Prescaler value is 3.
 * - 10 - PCS to SCK Prescaler value is 5.
 * - 11 - PCS to SCK Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PCSSCK field. */
#define SPI_RD_CTAR_PCSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PCSSCK_MASK) >> SPI_CTAR_PCSSCK_SHIFT)
#define SPI_BRD_CTAR_PCSSCK(base, index) (SPI_RD_CTAR_PCSSCK(base, index))

/*! @brief Set the PCSSCK field to a new value. */
#define SPI_WR_CTAR_PCSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PCSSCK_MASK, SPI_CTAR_PCSSCK(value)))
#define SPI_BWR_CTAR_PCSSCK(base, index, value) (SPI_WR_CTAR_PCSSCK(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field LSBFE[24] (RW)
 *
 * Values:
 * - 0 - Data is transferred MSB first.
 * - 1 - Data is transferred LSB first.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_LSBFE field. */
#define SPI_RD_CTAR_LSBFE(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_LSBFE_MASK) >> SPI_CTAR_LSBFE_SHIFT)
#define SPI_BRD_CTAR_LSBFE(base, index) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_LSBFE_SHIFT))

/*! @brief Set the LSBFE field to a new value. */
#define SPI_WR_CTAR_LSBFE(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_LSBFE_MASK, SPI_CTAR_LSBFE(value)))
#define SPI_BWR_CTAR_LSBFE(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_LSBFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPHA[25] (RW)
 *
 * Values:
 * - 0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPHA field. */
#define SPI_RD_CTAR_CPHA(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPHA_MASK) >> SPI_CTAR_CPHA_SHIFT)
#define SPI_BRD_CTAR_CPHA(base, index) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPHA_SHIFT))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_CPHA(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPHA_MASK, SPI_CTAR_CPHA(value)))
#define SPI_BWR_CTAR_CPHA(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPHA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPOL[26] (RW)
 *
 * Values:
 * - 0 - The inactive state value of SCK is low.
 * - 1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPOL field. */
#define SPI_RD_CTAR_CPOL(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPOL_MASK) >> SPI_CTAR_CPOL_SHIFT)
#define SPI_BRD_CTAR_CPOL(base, index) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPOL_SHIFT))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_CPOL(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPOL_MASK, SPI_CTAR_CPOL(value)))
#define SPI_BWR_CTAR_CPOL(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field FMSZ[30:27] (RW)
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_FMSZ field. */
#define SPI_RD_CTAR_FMSZ(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT)
#define SPI_BRD_CTAR_FMSZ(base, index) (SPI_RD_CTAR_FMSZ(base, index))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_FMSZ(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_FMSZ_MASK, SPI_CTAR_FMSZ(value)))
#define SPI_BWR_CTAR_FMSZ(base, index, value) (SPI_WR_CTAR_FMSZ(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DBR[31] (RW)
 *
 * Values:
 * - 0 - The baud rate is computed normally with a 50/50 duty cycle.
 * - 1 - The baud rate is doubled with the duty cycle depending on the Baud Rate
 *     Prescaler.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DBR field. */
#define SPI_RD_CTAR_DBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DBR_MASK) >> SPI_CTAR_DBR_SHIFT)
#define SPI_BRD_CTAR_DBR(base, index) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_DBR_SHIFT))

/*! @brief Set the DBR field to a new value. */
#define SPI_WR_CTAR_DBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DBR_MASK, SPI_CTAR_DBR(value)))
#define SPI_BWR_CTAR_DBR(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_DBR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_SR - DSPI Status Register
 ******************************************************************************/

/*!
 * @brief SPI_SR - DSPI Status Register (RW)
 *
 * Reset value: 0x02000000U
 *
 * SR contains status and flag bits. The bits reflect the status of the DSPI and
 * indicate the occurrence of events that can generate interrupt or DMA
 * requests. Software can clear flag bits in the SR by writing a 1 to them. Writing a 0
 * to a flag bit has no effect. This register may not be writable in module
 * disable mode due to the use of power saving mechanisms.
 */
/*!
 * @name Constants and macros for entire SPI_SR register
 */
/*@{*/
#define SPI_RD_SR(base)          (SPI_SR_REG(base))
#define SPI_WR_SR(base, value)   (SPI_SR_REG(base) = (value))
#define SPI_RMW_SR(base, mask, value) (SPI_WR_SR(base, (SPI_RD_SR(base) & ~(mask)) | (value)))
#define SPI_SET_SR(base, value)  (SPI_WR_SR(base, SPI_RD_SR(base) |  (value)))
#define SPI_CLR_SR(base, value)  (SPI_WR_SR(base, SPI_RD_SR(base) & ~(value)))
#define SPI_TOG_SR(base, value)  (SPI_WR_SR(base, SPI_RD_SR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_SR bitfields
 */

/*!
 * @name Register SPI_SR, field POPNXTPTR[3:0] (RO)
 *
 * Contains a pointer to the RX FIFO entry to be returned when the POPR is read.
 * The POPNXTPTR is updated when the POPR is read.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_POPNXTPTR field. */
#define SPI_RD_SR_POPNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_POPNXTPTR_MASK) >> SPI_SR_POPNXTPTR_SHIFT)
#define SPI_BRD_SR_POPNXTPTR(base) (SPI_RD_SR_POPNXTPTR(base))
/*@}*/

/*!
 * @name Register SPI_SR, field RXCTR[7:4] (RO)
 *
 * Indicates the number of entries in the RX FIFO. The RXCTR is decremented
 * every time the POPR is read. The RXCTR is incremented every time data is
 * transferred from the shift register to the RX FIFO.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RXCTR field. */
#define SPI_RD_SR_RXCTR(base) ((SPI_SR_REG(base) & SPI_SR_RXCTR_MASK) >> SPI_SR_RXCTR_SHIFT)
#define SPI_BRD_SR_RXCTR(base) (SPI_RD_SR_RXCTR(base))
/*@}*/

/*!
 * @name Register SPI_SR, field TXNXTPTR[11:8] (RO)
 *
 * Indicates which TX FIFO Entry is transmitted during the next transfer. The
 * TXNXTPTR field is updated every time SPI data is transferred from the TX FIFO to
 * the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXNXTPTR field. */
#define SPI_RD_SR_TXNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_TXNXTPTR_MASK) >> SPI_SR_TXNXTPTR_SHIFT)
#define SPI_BRD_SR_TXNXTPTR(base) (SPI_RD_SR_TXNXTPTR(base))
/*@}*/

/*!
 * @name Register SPI_SR, field TXCTR[15:12] (RO)
 *
 * Indicates the number of valid entries in the TX FIFO. The TXCTR is
 * incremented every time the PUSHR is written. The TXCTR is decremented every time a SPI
 * command is executed and the SPI data is transferred to the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXCTR field. */
#define SPI_RD_SR_TXCTR(base) ((SPI_SR_REG(base) & SPI_SR_TXCTR_MASK) >> SPI_SR_TXCTR_SHIFT)
#define SPI_BRD_SR_TXCTR(base) (SPI_RD_SR_TXCTR(base))
/*@}*/

/*!
 * @name Register SPI_SR, field RFDF[17] (W1C)
 *
 * Provides a method for the DSPI to request that entries be removed from the RX
 * FIFO. The bit is set while the RX FIFO is not empty. The RFDF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller when the
 * RX FIFO is empty.
 *
 * Values:
 * - 0 - Rx FIFO is empty.
 * - 1 - Rx FIFO is not empty.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFDF field. */
#define SPI_RD_SR_RFDF(base) ((SPI_SR_REG(base) & SPI_SR_RFDF_MASK) >> SPI_SR_RFDF_SHIFT)
#define SPI_BRD_SR_RFDF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_RFDF_SHIFT))

/*! @brief Set the RFDF field to a new value. */
#define SPI_WR_SR_RFDF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_RFDF(value)))
#define SPI_BWR_SR_RFDF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_RFDF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field RFOF[19] (W1C)
 *
 * Indicates an overflow condition in the RX FIFO. The bit is set when the RX
 * FIFO and shift register are full and a transfer is initiated. The bit remains
 * set until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No Rx FIFO overflow.
 * - 1 - Rx FIFO overflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFOF field. */
#define SPI_RD_SR_RFOF(base) ((SPI_SR_REG(base) & SPI_SR_RFOF_MASK) >> SPI_SR_RFOF_SHIFT)
#define SPI_BRD_SR_RFOF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_RFOF_SHIFT))

/*! @brief Set the RFOF field to a new value. */
#define SPI_WR_SR_RFOF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFOF_MASK | SPI_SR_RFDF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_RFOF(value)))
#define SPI_BWR_SR_RFOF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_RFOF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field TFFF[25] (W1C)
 *
 * Provides a method for the DSPI to request more entries to be added to the TX
 * FIFO. The TFFF bit is set while the TX FIFO is not full. The TFFF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller to the
 * TX FIFO full request. The Reset Value of this bit is 0 if MCR[MDIS] = 1. The
 * Reset Value of this bit is 1 if MCR[MDIS] = 0.
 *
 * Values:
 * - 0 - Tx FIFO is full.
 * - 1 - Tx FIFO is not full.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFFF field. */
#define SPI_RD_SR_TFFF(base) ((SPI_SR_REG(base) & SPI_SR_TFFF_MASK) >> SPI_SR_TFFF_SHIFT)
#define SPI_BRD_SR_TFFF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TFFF_SHIFT))

/*! @brief Set the TFFF field to a new value. */
#define SPI_WR_SR_TFFF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFFF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_TFFF(value)))
#define SPI_BWR_SR_TFFF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TFFF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field TFUF[27] (W1C)
 *
 * Indicates an underflow condition in the TX FIFO. The transmit underflow
 * condition is detected only for DSPI blocks operating in slave mode and SPI
 * configuration. TFUF is set when the TX FIFO of a DSPI operating in SPI slave mode is
 * empty and an external SPI master initiates a transfer. The TFUF bit remains set
 * until cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No Tx FIFO underflow.
 * - 1 - Tx FIFO underflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFUF field. */
#define SPI_RD_SR_TFUF(base) ((SPI_SR_REG(base) & SPI_SR_TFUF_MASK) >> SPI_SR_TFUF_SHIFT)
#define SPI_BRD_SR_TFUF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TFUF_SHIFT))

/*! @brief Set the TFUF field to a new value. */
#define SPI_WR_SR_TFUF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFUF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_TFUF(value)))
#define SPI_BWR_SR_TFUF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TFUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field EOQF[28] (W1C)
 *
 * Indicates that the last entry in a queue has been transmitted when the DSPI
 * is in master mode. The EOQF bit is set when the TX FIFO entry has the EOQ bit
 * set in the command halfword and the end of the transfer is reached. The EOQF
 * bit remains set until cleared by writing a 1 to it. When the EOQF bit is set,
 * the TXRXS bit is automatically cleared.
 *
 * Values:
 * - 0 - EOQ is not set in the executing command.
 * - 1 - EOQ is set in the executing SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_EOQF field. */
#define SPI_RD_SR_EOQF(base) ((SPI_SR_REG(base) & SPI_SR_EOQF_MASK) >> SPI_SR_EOQF_SHIFT)
#define SPI_BRD_SR_EOQF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_EOQF_SHIFT))

/*! @brief Set the EOQF field to a new value. */
#define SPI_WR_SR_EOQF(base, value) (SPI_RMW_SR(base, (SPI_SR_EOQF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_EOQF(value)))
#define SPI_BWR_SR_EOQF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_EOQF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field TXRXS[30] (W1C)
 *
 * Reflects the run status of the DSPI.
 *
 * Values:
 * - 0 - Transmit and receive operations are disabled (DSPI is in stopped state).
 * - 1 - Transmit and receive operations are enabled (DSPI is in running state).
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXRXS field. */
#define SPI_RD_SR_TXRXS(base) ((SPI_SR_REG(base) & SPI_SR_TXRXS_MASK) >> SPI_SR_TXRXS_SHIFT)
#define SPI_BRD_SR_TXRXS(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TXRXS_SHIFT))

/*! @brief Set the TXRXS field to a new value. */
#define SPI_WR_SR_TXRXS(base, value) (SPI_RMW_SR(base, (SPI_SR_TXRXS_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TCF_MASK), SPI_SR_TXRXS(value)))
#define SPI_BWR_SR_TXRXS(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TXRXS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field TCF[31] (W1C)
 *
 * Indicates that all bits in a frame have been shifted out. TCF remains set
 * until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - Transfer not complete.
 * - 1 - Transfer complete.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TCF field. */
#define SPI_RD_SR_TCF(base)  ((SPI_SR_REG(base) & SPI_SR_TCF_MASK) >> SPI_SR_TCF_SHIFT)
#define SPI_BRD_SR_TCF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TCF_SHIFT))

/*! @brief Set the TCF field to a new value. */
#define SPI_WR_SR_TCF(base, value) (SPI_RMW_SR(base, (SPI_SR_TCF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK), SPI_SR_TCF(value)))
#define SPI_BWR_SR_TCF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TCF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_RSER - DSPI DMA/Interrupt Request Select and Enable Register
 ******************************************************************************/

/*!
 * @brief SPI_RSER - DSPI DMA/Interrupt Request Select and Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RSER controls DMA and interrupt requests. Do not write to the RSER while the
 * DSPI is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_RSER register
 */
/*@{*/
#define SPI_RD_RSER(base)        (SPI_RSER_REG(base))
#define SPI_WR_RSER(base, value) (SPI_RSER_REG(base) = (value))
#define SPI_RMW_RSER(base, mask, value) (SPI_WR_RSER(base, (SPI_RD_RSER(base) & ~(mask)) | (value)))
#define SPI_SET_RSER(base, value) (SPI_WR_RSER(base, SPI_RD_RSER(base) |  (value)))
#define SPI_CLR_RSER(base, value) (SPI_WR_RSER(base, SPI_RD_RSER(base) & ~(value)))
#define SPI_TOG_RSER(base, value) (SPI_WR_RSER(base, SPI_RD_RSER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_RSER bitfields
 */

/*!
 * @name Register SPI_RSER, field RFDF_DIRS[16] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When the
 * RFDF flag bit in the SR is set, and the RFDF_RE bit in the RSER is set, the
 * RFDF_DIRS bit selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - Interrupt request.
 * - 1 - DMA request.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_DIRS field. */
#define SPI_RD_RSER_RFDF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_DIRS_MASK) >> SPI_RSER_RFDF_DIRS_SHIFT)
#define SPI_BRD_RSER_RFDF_DIRS(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFDF_DIRS_SHIFT))

/*! @brief Set the RFDF_DIRS field to a new value. */
#define SPI_WR_RSER_RFDF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_DIRS_MASK, SPI_RSER_RFDF_DIRS(value)))
#define SPI_BWR_RSER_RFDF_DIRS(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFDF_DIRS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFDF_RE[17] (RW)
 *
 * Enables the RFDF flag in the SR to generate a request. The RFDF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - RFDF interrupt or DMA requests are disabled
 * - 1 - RFDF interrupt or DMA requests are enabled
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_RE field. */
#define SPI_RD_RSER_RFDF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_RE_MASK) >> SPI_RSER_RFDF_RE_SHIFT)
#define SPI_BRD_RSER_RFDF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFDF_RE_SHIFT))

/*! @brief Set the RFDF_RE field to a new value. */
#define SPI_WR_RSER_RFDF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_RE_MASK, SPI_RSER_RFDF_RE(value)))
#define SPI_BWR_RSER_RFDF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFDF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFOF_RE[19] (RW)
 *
 * Enables the RFOF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - RFOF interrupt requests are disabled.
 * - 1 - RFOF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFOF_RE field. */
#define SPI_RD_RSER_RFOF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFOF_RE_MASK) >> SPI_RSER_RFOF_RE_SHIFT)
#define SPI_BRD_RSER_RFOF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFOF_RE_SHIFT))

/*! @brief Set the RFOF_RE field to a new value. */
#define SPI_WR_RSER_RFOF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFOF_RE_MASK, SPI_RSER_RFOF_RE(value)))
#define SPI_BWR_RSER_RFOF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFOF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_DIRS[24] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When the
 * TFFF flag bit in the SR is set and the TFFF_RE bit in the RSER register is set,
 * this bit selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - TFFF flag generates interrupt requests.
 * - 1 - TFFF flag generates DMA requests.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_DIRS field. */
#define SPI_RD_RSER_TFFF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_DIRS_MASK) >> SPI_RSER_TFFF_DIRS_SHIFT)
#define SPI_BRD_RSER_TFFF_DIRS(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFFF_DIRS_SHIFT))

/*! @brief Set the TFFF_DIRS field to a new value. */
#define SPI_WR_RSER_TFFF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_DIRS_MASK, SPI_RSER_TFFF_DIRS(value)))
#define SPI_BWR_RSER_TFFF_DIRS(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFFF_DIRS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_RE[25] (RW)
 *
 * Enables the TFFF flag in the SR to generate a request. The TFFF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - TFFF interrupts or DMA requests are disabled.
 * - 1 - TFFF interrupts or DMA requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_RE field. */
#define SPI_RD_RSER_TFFF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_RE_MASK) >> SPI_RSER_TFFF_RE_SHIFT)
#define SPI_BRD_RSER_TFFF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFFF_RE_SHIFT))

/*! @brief Set the TFFF_RE field to a new value. */
#define SPI_WR_RSER_TFFF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_RE_MASK, SPI_RSER_TFFF_RE(value)))
#define SPI_BWR_RSER_TFFF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFFF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFUF_RE[27] (RW)
 *
 * Enables the TFUF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - TFUF interrupt requests are disabled.
 * - 1 - TFUF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFUF_RE field. */
#define SPI_RD_RSER_TFUF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFUF_RE_MASK) >> SPI_RSER_TFUF_RE_SHIFT)
#define SPI_BRD_RSER_TFUF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFUF_RE_SHIFT))

/*! @brief Set the TFUF_RE field to a new value. */
#define SPI_WR_RSER_TFUF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFUF_RE_MASK, SPI_RSER_TFUF_RE(value)))
#define SPI_BWR_RSER_TFUF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFUF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field EOQF_RE[28] (RW)
 *
 * Enables the EOQF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - EOQF interrupt requests are disabled.
 * - 1 - EOQF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_EOQF_RE field. */
#define SPI_RD_RSER_EOQF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_EOQF_RE_MASK) >> SPI_RSER_EOQF_RE_SHIFT)
#define SPI_BRD_RSER_EOQF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_EOQF_RE_SHIFT))

/*! @brief Set the EOQF_RE field to a new value. */
#define SPI_WR_RSER_EOQF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_EOQF_RE_MASK, SPI_RSER_EOQF_RE(value)))
#define SPI_BWR_RSER_EOQF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_EOQF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field TCF_RE[31] (RW)
 *
 * Enables TCF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - TCF interrupt requests are disabled.
 * - 1 - TCF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TCF_RE field. */
#define SPI_RD_RSER_TCF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TCF_RE_MASK) >> SPI_RSER_TCF_RE_SHIFT)
#define SPI_BRD_RSER_TCF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TCF_RE_SHIFT))

/*! @brief Set the TCF_RE field to a new value. */
#define SPI_WR_RSER_TCF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TCF_RE_MASK, SPI_RSER_TCF_RE(value)))
#define SPI_BWR_RSER_TCF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TCF_RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR - DSPI PUSH TX FIFO Register In Master Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR - DSPI PUSH TX FIFO Register In Master Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * PUSHR provides the means to write to the TX FIFO. Data written to this
 * register is transferred to the TX FIFO. Eight- or sixteen-bit write accesses to the
 * PUSHR transfer all 32 register bits to the TX FIFO. The register structure is
 * different in master and slave modes. In master mode the register provides
 * 16-bit command and 16-bit data to the TX FIFO. In slave mode all 32 register bits
 * can be used as data, supporting up to 32-bit SPI frame operation.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR register
 */
/*@{*/
#define SPI_RD_PUSHR(base)       (SPI_PUSHR_REG(base))
#define SPI_WR_PUSHR(base, value) (SPI_PUSHR_REG(base) = (value))
#define SPI_RMW_PUSHR(base, mask, value) (SPI_WR_PUSHR(base, (SPI_RD_PUSHR(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR(base, value) (SPI_WR_PUSHR(base, SPI_RD_PUSHR(base) |  (value)))
#define SPI_CLR_PUSHR(base, value) (SPI_WR_PUSHR(base, SPI_RD_PUSHR(base) & ~(value)))
#define SPI_TOG_PUSHR(base, value) (SPI_WR_PUSHR(base, SPI_RD_PUSHR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR bitfields
 */

/*!
 * @name Register SPI_PUSHR, field TXDATA[15:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_TXDATA field. */
#define SPI_RD_PUSHR_TXDATA(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_TXDATA_MASK) >> SPI_PUSHR_TXDATA_SHIFT)
#define SPI_BRD_PUSHR_TXDATA(base) (SPI_RD_PUSHR_TXDATA(base))

/*! @brief Set the TXDATA field to a new value. */
#define SPI_WR_PUSHR_TXDATA(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_TXDATA_MASK, SPI_PUSHR_TXDATA(value)))
#define SPI_BWR_PUSHR_TXDATA(base, value) (SPI_WR_PUSHR_TXDATA(base, value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field PCS[21:16] (RW)
 *
 * Select which PCS signals are to be asserted for the transfer. Refer to the
 * chip configuration chapter for the number of PCS signals used in this MCU.
 *
 * Values:
 * - 0 - Negate the PCS[x] signal.
 * - 1 - Assert the PCS[x] signal.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_PCS field. */
#define SPI_RD_PUSHR_PCS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_PCS_MASK) >> SPI_PUSHR_PCS_SHIFT)
#define SPI_BRD_PUSHR_PCS(base) (SPI_RD_PUSHR_PCS(base))

/*! @brief Set the PCS field to a new value. */
#define SPI_WR_PUSHR_PCS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_PCS_MASK, SPI_PUSHR_PCS(value)))
#define SPI_BWR_PUSHR_PCS(base, value) (SPI_WR_PUSHR_PCS(base, value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTCNT[26] (RW)
 *
 * Clears the SPI_TCNT field in the TCR register. The SPI_TCNT field is cleared
 * before the DSPI starts transmitting the current SPI frame.
 *
 * Values:
 * - 0 - Do not clear the TCR[SPI_TCNT] field.
 * - 1 - Clear the TCR[SPI_TCNT] field.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTCNT field. */
#define SPI_RD_PUSHR_CTCNT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTCNT_MASK) >> SPI_PUSHR_CTCNT_SHIFT)
#define SPI_BRD_PUSHR_CTCNT(base) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTCNT_SHIFT))

/*! @brief Set the CTCNT field to a new value. */
#define SPI_WR_PUSHR_CTCNT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTCNT_MASK, SPI_PUSHR_CTCNT(value)))
#define SPI_BWR_PUSHR_CTCNT(base, value) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTCNT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field EOQ[27] (RW)
 *
 * Host software uses this bit to signal to the DSPI that the current SPI
 * transfer is the last in a queue. At the end of the transfer, the EOQF bit in the SR
 * is set.
 *
 * Values:
 * - 0 - The SPI data is not the last data to transfer.
 * - 1 - The SPI data is the last data to transfer.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_EOQ field. */
#define SPI_RD_PUSHR_EOQ(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_EOQ_MASK) >> SPI_PUSHR_EOQ_SHIFT)
#define SPI_BRD_PUSHR_EOQ(base) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_EOQ_SHIFT))

/*! @brief Set the EOQ field to a new value. */
#define SPI_WR_PUSHR_EOQ(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_EOQ_MASK, SPI_PUSHR_EOQ(value)))
#define SPI_BWR_PUSHR_EOQ(base, value) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_EOQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTAS[30:28] (RW)
 *
 * Selects which CTAR register to use in master mode to specify the transfer
 * attributes for the associated SPI frame. In SPI slave mode, CTAR0 is used. See
 * the Chip Configuration chapter to determine how many CTAR registers this device
 * has. You should not program a value in this field for a register that is not
 * present.
 *
 * Values:
 * - 000 - CTAR0
 * - 001 - CTAR1
 * - 010 - Reserved
 * - 011 - Reserved
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTAS field. */
#define SPI_RD_PUSHR_CTAS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTAS_MASK) >> SPI_PUSHR_CTAS_SHIFT)
#define SPI_BRD_PUSHR_CTAS(base) (SPI_RD_PUSHR_CTAS(base))

/*! @brief Set the CTAS field to a new value. */
#define SPI_WR_PUSHR_CTAS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTAS_MASK, SPI_PUSHR_CTAS(value)))
#define SPI_BWR_PUSHR_CTAS(base, value) (SPI_WR_PUSHR_CTAS(base, value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CONT[31] (RW)
 *
 * Selects a Continuous Selection Format. The bit is used in SPI master mode.
 * The bit enables the selected PCS signals to remain asserted between transfers.
 *
 * Values:
 * - 0 - Return PCSn signals to their inactive state between transfers.
 * - 1 - Keep PCSn signals asserted between transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CONT field. */
#define SPI_RD_PUSHR_CONT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CONT_MASK) >> SPI_PUSHR_CONT_SHIFT)
#define SPI_BRD_PUSHR_CONT(base) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_CONT_SHIFT))

/*! @brief Set the CONT field to a new value. */
#define SPI_WR_PUSHR_CONT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CONT_MASK, SPI_PUSHR_CONT(value)))
#define SPI_BWR_PUSHR_CONT(base, value) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_CONT_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR_SLAVE - DSPI PUSH TX FIFO Register In Slave Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR_SLAVE - DSPI PUSH TX FIFO Register In Slave Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * PUSHR provides the means to write to the TX FIFO. Data written to this
 * register is transferred to the TX FIFO. Eight- or sixteen-bit write accesses to the
 * PUSHR transfer all 32 register bits to the TX FIFO. The register structure is
 * different in master and slave modes. In master mode the register provides
 * 16-bit command and 16-bit data to the TX FIFO. In slave mode all 32 register bits
 * can be used as data, supporting up to 32-bit SPI frame operation.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR_SLAVE register
 */
/*@{*/
#define SPI_RD_PUSHR_SLAVE(base) (SPI_PUSHR_SLAVE_REG(base))
#define SPI_WR_PUSHR_SLAVE(base, value) (SPI_PUSHR_SLAVE_REG(base) = (value))
#define SPI_RMW_PUSHR_SLAVE(base, mask, value) (SPI_WR_PUSHR_SLAVE(base, (SPI_RD_PUSHR_SLAVE(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR_SLAVE(base, value) (SPI_WR_PUSHR_SLAVE(base, SPI_RD_PUSHR_SLAVE(base) |  (value)))
#define SPI_CLR_PUSHR_SLAVE(base, value) (SPI_WR_PUSHR_SLAVE(base, SPI_RD_PUSHR_SLAVE(base) & ~(value)))
#define SPI_TOG_PUSHR_SLAVE(base, value) (SPI_WR_PUSHR_SLAVE(base, SPI_RD_PUSHR_SLAVE(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * SPI_POPR - DSPI POP RX FIFO Register
 ******************************************************************************/

/*!
 * @brief SPI_POPR - DSPI POP RX FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * POPR is used to read the RX FIFO. Eight- or sixteen-bit read accesses to the
 * POPR have the same effect on the RX FIFO as 32-bit read accesses. A write to
 * this register will generate a Transfer Error.
 */
/*!
 * @name Constants and macros for entire SPI_POPR register
 */
/*@{*/
#define SPI_RD_POPR(base)        (SPI_POPR_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR0 - DSPI Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR0 - DSPI Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn provide visibility into the TX FIFO for debugging purposes. Each
 * register is an entry in the TX FIFO. The registers are read-only and cannot be
 * modified. Reading the TXFRx registers does not alter the state of the TX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR0 register
 */
/*@{*/
#define SPI_RD_TXFR0(base)       (SPI_TXFR0_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR0 bitfields
 */

/*!
 * @name Register SPI_TXFR0, field TXDATA[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXDATA field. */
#define SPI_RD_TXFR0_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXDATA_MASK) >> SPI_TXFR0_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXDATA(base) (SPI_RD_TXFR0_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR0, field TXCMD_TXDATA[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXCMD_TXDATA field. */
#define SPI_RD_TXFR0_TXCMD_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXCMD_TXDATA_MASK) >> SPI_TXFR0_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXCMD_TXDATA(base) (SPI_RD_TXFR0_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR1 - DSPI Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR1 - DSPI Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn provide visibility into the TX FIFO for debugging purposes. Each
 * register is an entry in the TX FIFO. The registers are read-only and cannot be
 * modified. Reading the TXFRx registers does not alter the state of the TX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR1 register
 */
/*@{*/
#define SPI_RD_TXFR1(base)       (SPI_TXFR1_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR1 bitfields
 */

/*!
 * @name Register SPI_TXFR1, field TXDATA[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXDATA field. */
#define SPI_RD_TXFR1_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXDATA_MASK) >> SPI_TXFR1_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXDATA(base) (SPI_RD_TXFR1_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR1, field TXCMD_TXDATA[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXCMD_TXDATA field. */
#define SPI_RD_TXFR1_TXCMD_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXCMD_TXDATA_MASK) >> SPI_TXFR1_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXCMD_TXDATA(base) (SPI_RD_TXFR1_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR2 - DSPI Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR2 - DSPI Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn provide visibility into the TX FIFO for debugging purposes. Each
 * register is an entry in the TX FIFO. The registers are read-only and cannot be
 * modified. Reading the TXFRx registers does not alter the state of the TX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR2 register
 */
/*@{*/
#define SPI_RD_TXFR2(base)       (SPI_TXFR2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR2 bitfields
 */

/*!
 * @name Register SPI_TXFR2, field TXDATA[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXDATA field. */
#define SPI_RD_TXFR2_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXDATA_MASK) >> SPI_TXFR2_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXDATA(base) (SPI_RD_TXFR2_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR2, field TXCMD_TXDATA[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXCMD_TXDATA field. */
#define SPI_RD_TXFR2_TXCMD_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXCMD_TXDATA_MASK) >> SPI_TXFR2_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXCMD_TXDATA(base) (SPI_RD_TXFR2_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR3 - DSPI Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR3 - DSPI Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn provide visibility into the TX FIFO for debugging purposes. Each
 * register is an entry in the TX FIFO. The registers are read-only and cannot be
 * modified. Reading the TXFRx registers does not alter the state of the TX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR3 register
 */
/*@{*/
#define SPI_RD_TXFR3(base)       (SPI_TXFR3_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR3 bitfields
 */

/*!
 * @name Register SPI_TXFR3, field TXDATA[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXDATA field. */
#define SPI_RD_TXFR3_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXDATA_MASK) >> SPI_TXFR3_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXDATA(base) (SPI_RD_TXFR3_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR3, field TXCMD_TXDATA[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXCMD_TXDATA field. */
#define SPI_RD_TXFR3_TXCMD_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXCMD_TXDATA_MASK) >> SPI_TXFR3_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXCMD_TXDATA(base) (SPI_RD_TXFR3_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR0 - DSPI Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR0 - DSPI Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR0 register
 */
/*@{*/
#define SPI_RD_RXFR0(base)       (SPI_RXFR0_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR1 - DSPI Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR1 - DSPI Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR1 register
 */
/*@{*/
#define SPI_RD_RXFR1(base)       (SPI_RXFR1_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR2 - DSPI Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR2 - DSPI Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR2 register
 */
/*@{*/
#define SPI_RD_RXFR2(base)       (SPI_RXFR2_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR3 - DSPI Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR3 - DSPI Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR3 register
 */
/*@{*/
#define SPI_RD_RXFR3(base)       (SPI_RXFR3_REG(base))
/*@}*/

/*
 * MK20D5 TSI
 *
 * Touch Sensing Input
 *
 * Registers defined in this header file:
 * - TSI_GENCS - General Control and Status Register
 * - TSI_SCANC - SCAN Control Register
 * - TSI_PEN - Pin Enable Register
 * - TSI_WUCNTR - Wake-Up Channel Counter Register
 * - TSI_CNTR1 - Counter Register
 * - TSI_CNTR3 - Counter Register
 * - TSI_CNTR5 - Counter Register
 * - TSI_CNTR7 - Counter Register
 * - TSI_CNTR9 - Counter Register
 * - TSI_CNTR11 - Counter Register
 * - TSI_CNTR13 - Counter Register
 * - TSI_CNTR15 - Counter Register
 * - TSI_THRESHOLD - Low Power Channel Threshold Register
 */

#define TSI_INSTANCE_COUNT (1U) /*!< Number of instances of the TSI module. */
#define TSI0_IDX (0U) /*!< Instance number for TSI0. */

/*******************************************************************************
 * TSI_GENCS - General Control and Status Register
 ******************************************************************************/

/*!
 * @brief TSI_GENCS - General Control and Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_GENCS register
 */
/*@{*/
#define TSI_RD_GENCS(base)       (TSI_GENCS_REG(base))
#define TSI_WR_GENCS(base, value) (TSI_GENCS_REG(base) = (value))
#define TSI_RMW_GENCS(base, mask, value) (TSI_WR_GENCS(base, (TSI_RD_GENCS(base) & ~(mask)) | (value)))
#define TSI_SET_GENCS(base, value) (TSI_WR_GENCS(base, TSI_RD_GENCS(base) |  (value)))
#define TSI_CLR_GENCS(base, value) (TSI_WR_GENCS(base, TSI_RD_GENCS(base) & ~(value)))
#define TSI_TOG_GENCS(base, value) (TSI_WR_GENCS(base, TSI_RD_GENCS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TSI_GENCS bitfields
 */

/*!
 * @name Register TSI_GENCS, field STPE[0] (RW)
 *
 * TSI STOP Enable while in Low Power Modes (STOP, VLPS, LLS and VLLS{3,2,1})
 *
 * Values:
 * - 0 - Disable TSI when MCU goes into low power modes.
 * - 1 - Allows TSI to continue running in all low power modes.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_STPE field. */
#define TSI_RD_GENCS_STPE(base) ((TSI_GENCS_REG(base) & TSI_GENCS_STPE_MASK) >> TSI_GENCS_STPE_SHIFT)
#define TSI_BRD_GENCS_STPE(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_STPE_SHIFT))

/*! @brief Set the STPE field to a new value. */
#define TSI_WR_GENCS_STPE(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_STPE_MASK, TSI_GENCS_STPE(value)))
#define TSI_BWR_GENCS_STPE(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_STPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field STM[1] (RW)
 *
 * Values:
 * - 0 - Software trigger scan.
 * - 1 - Periodical Scan.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_STM field. */
#define TSI_RD_GENCS_STM(base) ((TSI_GENCS_REG(base) & TSI_GENCS_STM_MASK) >> TSI_GENCS_STM_SHIFT)
#define TSI_BRD_GENCS_STM(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_STM_SHIFT))

/*! @brief Set the STM field to a new value. */
#define TSI_WR_GENCS_STM(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_STM_MASK, TSI_GENCS_STM(value)))
#define TSI_BWR_GENCS_STM(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_STM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field ESOR[4] (RW)
 *
 * Values:
 * - 0 - Out-of-Range interrupt is allowed.
 * - 1 - End-of-Scan interrupt is allowed.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_ESOR field. */
#define TSI_RD_GENCS_ESOR(base) ((TSI_GENCS_REG(base) & TSI_GENCS_ESOR_MASK) >> TSI_GENCS_ESOR_SHIFT)
#define TSI_BRD_GENCS_ESOR(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_ESOR_SHIFT))

/*! @brief Set the ESOR field to a new value. */
#define TSI_WR_GENCS_ESOR(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_ESOR_MASK, TSI_GENCS_ESOR(value)))
#define TSI_BWR_GENCS_ESOR(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_ESOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field ERIE[5] (RW)
 *
 * Caused either by a Short or Overrun Error.
 *
 * Values:
 * - 0 - Interrupt disabled for error.
 * - 1 - Interrupt enabled for error.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_ERIE field. */
#define TSI_RD_GENCS_ERIE(base) ((TSI_GENCS_REG(base) & TSI_GENCS_ERIE_MASK) >> TSI_GENCS_ERIE_SHIFT)
#define TSI_BRD_GENCS_ERIE(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_ERIE_SHIFT))

/*! @brief Set the ERIE field to a new value. */
#define TSI_WR_GENCS_ERIE(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_ERIE_MASK, TSI_GENCS_ERIE(value)))
#define TSI_BWR_GENCS_ERIE(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_ERIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field TSIIE[6] (RW)
 *
 * Values:
 * - 0 - Interrupt from TSI is disabled
 * - 1 - Interrupt from TSI is enabled
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_TSIIE field. */
#define TSI_RD_GENCS_TSIIE(base) ((TSI_GENCS_REG(base) & TSI_GENCS_TSIIE_MASK) >> TSI_GENCS_TSIIE_SHIFT)
#define TSI_BRD_GENCS_TSIIE(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_TSIIE_SHIFT))

/*! @brief Set the TSIIE field to a new value. */
#define TSI_WR_GENCS_TSIIE(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_TSIIE_MASK, TSI_GENCS_TSIIE(value)))
#define TSI_BWR_GENCS_TSIIE(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_TSIIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field TSIEN[7] (RW)
 *
 * Values:
 * - 0 - TSI module is disabled
 * - 1 - TSI module is enabled
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_TSIEN field. */
#define TSI_RD_GENCS_TSIEN(base) ((TSI_GENCS_REG(base) & TSI_GENCS_TSIEN_MASK) >> TSI_GENCS_TSIEN_SHIFT)
#define TSI_BRD_GENCS_TSIEN(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_TSIEN_SHIFT))

/*! @brief Set the TSIEN field to a new value. */
#define TSI_WR_GENCS_TSIEN(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_TSIEN_MASK, TSI_GENCS_TSIEN(value)))
#define TSI_BWR_GENCS_TSIEN(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_TSIEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field SWTS[8] (WO)
 *
 * Write a "1" to this bit will start a scan sequence and write a "0" to this
 * bit has no effect.
 */
/*@{*/
/*! @brief Set the SWTS field to a new value. */
#define TSI_WR_GENCS_SWTS(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_SWTS_MASK, TSI_GENCS_SWTS(value)))
#define TSI_BWR_GENCS_SWTS(base, value) (TSI_WR_GENCS_SWTS(base, value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field SCNIP[9] (RO)
 *
 * "1" indicates a scanning process is in progress,this bit is read-only and
 * changes automatically by the TSI model.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_SCNIP field. */
#define TSI_RD_GENCS_SCNIP(base) ((TSI_GENCS_REG(base) & TSI_GENCS_SCNIP_MASK) >> TSI_GENCS_SCNIP_SHIFT)
#define TSI_BRD_GENCS_SCNIP(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_SCNIP_SHIFT))
/*@}*/

/*!
 * @name Register TSI_GENCS, field OVRF[12] (RW)
 *
 * Values:
 * - 0 - No over run.
 * - 1 - Over Run occurred.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_OVRF field. */
#define TSI_RD_GENCS_OVRF(base) ((TSI_GENCS_REG(base) & TSI_GENCS_OVRF_MASK) >> TSI_GENCS_OVRF_SHIFT)
#define TSI_BRD_GENCS_OVRF(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_OVRF_SHIFT))

/*! @brief Set the OVRF field to a new value. */
#define TSI_WR_GENCS_OVRF(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_OVRF_MASK, TSI_GENCS_OVRF(value)))
#define TSI_BWR_GENCS_OVRF(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_OVRF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field EXTERF[13] (RW)
 *
 * This flag is set when an active electrode has a result register either 0x0000
 * or 0xFFFF. Write "1", when this flag is set, to clear it..
 *
 * Values:
 * - 0 - No fault happend on TSI electrodes
 * - 1 - Short to VDD or VSS was detected on one or more electrodes.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_EXTERF field. */
#define TSI_RD_GENCS_EXTERF(base) ((TSI_GENCS_REG(base) & TSI_GENCS_EXTERF_MASK) >> TSI_GENCS_EXTERF_SHIFT)
#define TSI_BRD_GENCS_EXTERF(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_EXTERF_SHIFT))

/*! @brief Set the EXTERF field to a new value. */
#define TSI_WR_GENCS_EXTERF(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_EXTERF_MASK, TSI_GENCS_EXTERF(value)))
#define TSI_BWR_GENCS_EXTERF(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_EXTERF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field OUTRGF[14] (RW)
 *
 * This flag is set if the result register of the low power enabled electrode is
 * outside the range defined by the TSI_THRESHOLD register. This flag is only
 * set when the TSI is in low power mode. It can be read once the CPU wakes up.
 * Write "1" , when this flag is set, to clear it..
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_OUTRGF field. */
#define TSI_RD_GENCS_OUTRGF(base) ((TSI_GENCS_REG(base) & TSI_GENCS_OUTRGF_MASK) >> TSI_GENCS_OUTRGF_SHIFT)
#define TSI_BRD_GENCS_OUTRGF(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_OUTRGF_SHIFT))

/*! @brief Set the OUTRGF field to a new value. */
#define TSI_WR_GENCS_OUTRGF(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_OUTRGF_MASK, TSI_GENCS_OUTRGF(value)))
#define TSI_BWR_GENCS_OUTRGF(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_OUTRGF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field EOSF[15] (RW)
 *
 * This flag is set when all active electrodes are scanned is ended after a scan
 * trigger. Write "1" , when this flag is set, to clear it..
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_EOSF field. */
#define TSI_RD_GENCS_EOSF(base) ((TSI_GENCS_REG(base) & TSI_GENCS_EOSF_MASK) >> TSI_GENCS_EOSF_SHIFT)
#define TSI_BRD_GENCS_EOSF(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_EOSF_SHIFT))

/*! @brief Set the EOSF field to a new value. */
#define TSI_WR_GENCS_EOSF(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_EOSF_MASK, TSI_GENCS_EOSF(value)))
#define TSI_BWR_GENCS_EOSF(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_EOSF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field PS[18:16] (RW)
 *
 * This bit-field can only be changed if the TSI module is disabled (TSIEN bit =
 * 0)
 *
 * Values:
 * - 000 - Electrode Oscillator Frequency divided by 1
 * - 001 - Electrode Oscillator Frequency divided by 2
 * - 010 - Electrode Oscillator Frequency divided by 4
 * - 011 - Electrode Oscillator Frequency divided by 8
 * - 100 - Electrode Oscillator Frequency divided by 16
 * - 101 - Electrode Oscillator Frequency divided by 32
 * - 110 - Electrode Oscillator Frequency divided by 64
 * - 111 - Electrode Oscillator Frequency divided by 128
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_PS field. */
#define TSI_RD_GENCS_PS(base) ((TSI_GENCS_REG(base) & TSI_GENCS_PS_MASK) >> TSI_GENCS_PS_SHIFT)
#define TSI_BRD_GENCS_PS(base) (TSI_RD_GENCS_PS(base))

/*! @brief Set the PS field to a new value. */
#define TSI_WR_GENCS_PS(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_PS_MASK, TSI_GENCS_PS(value)))
#define TSI_BWR_GENCS_PS(base, value) (TSI_WR_GENCS_PS(base, value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field NSCN[23:19] (RW)
 *
 * This bit-field can only be changed if the TSI module is disabled (TSIEN bit =
 * 0).
 *
 * Values:
 * - 00000 - Once per electrode
 * - 00001 - Twice per electrode
 * - 00010 - 3 times per electrode
 * - 00011 - 4 times per electrode
 * - 00100 - 5 times per electrode
 * - 00101 - 6 times per electrode
 * - 00110 - 7 times per electrode
 * - 00111 - 8 times per electrode
 * - 01000 - 9 times per electrode
 * - 01001 - 10 times per electrode
 * - 01010 - 11 times per electrode
 * - 01011 - 12 times per electrode
 * - 01100 - 13 times per electrode
 * - 01101 - 14 times per electrode
 * - 01110 - 15 times per electrode
 * - 01111 - 16 times per electrode
 * - 10000 - 17 times per electrode
 * - 10001 - 18 times per electrode
 * - 10010 - 19 times per electrode
 * - 10011 - 20 times per electrode
 * - 10100 - 21 times per electrode
 * - 10101 - 22 times per electrode
 * - 10110 - 23 times per electrode
 * - 10111 - 24 times per electrode
 * - 11000 - 25 times per electrode
 * - 11001 - 26 times per electrode
 * - 11010 - 27 times per electrode
 * - 11011 - 28 times per electrode
 * - 11100 - 29 times per electrode
 * - 11101 - 30 times per electrode
 * - 11110 - 31 times per electrode
 * - 11111 - 32 times per electrode
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_NSCN field. */
#define TSI_RD_GENCS_NSCN(base) ((TSI_GENCS_REG(base) & TSI_GENCS_NSCN_MASK) >> TSI_GENCS_NSCN_SHIFT)
#define TSI_BRD_GENCS_NSCN(base) (TSI_RD_GENCS_NSCN(base))

/*! @brief Set the NSCN field to a new value. */
#define TSI_WR_GENCS_NSCN(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_NSCN_MASK, TSI_GENCS_NSCN(value)))
#define TSI_BWR_GENCS_NSCN(base, value) (TSI_WR_GENCS_NSCN(base, value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field LPSCNITV[27:24] (RW)
 *
 * This bit-field can only be changed if the TSI module is disabled (TSIEN bit =
 * 0).
 *
 * Values:
 * - 0000 - 1 ms scan interval
 * - 0001 - 5 ms scan interval
 * - 0010 - 10 ms scan interval
 * - 0011 - 15 ms scan interval
 * - 0100 - 20 ms scan interval
 * - 0101 - 30 ms scan interval
 * - 0110 - 40 ms scan interval
 * - 0111 - 50 ms scan interval
 * - 1000 - 75 ms scan interval
 * - 1001 - 100 ms scan interval
 * - 1010 - 125 ms scan interval
 * - 1011 - 150 ms scan interval
 * - 1100 - 200 ms scan interval
 * - 1101 - 300 ms scan interval
 * - 1110 - 400 ms scan interval
 * - 1111 - 500 ms scan interval
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_LPSCNITV field. */
#define TSI_RD_GENCS_LPSCNITV(base) ((TSI_GENCS_REG(base) & TSI_GENCS_LPSCNITV_MASK) >> TSI_GENCS_LPSCNITV_SHIFT)
#define TSI_BRD_GENCS_LPSCNITV(base) (TSI_RD_GENCS_LPSCNITV(base))

/*! @brief Set the LPSCNITV field to a new value. */
#define TSI_WR_GENCS_LPSCNITV(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_LPSCNITV_MASK, TSI_GENCS_LPSCNITV(value)))
#define TSI_BWR_GENCS_LPSCNITV(base, value) (TSI_WR_GENCS_LPSCNITV(base, value))
/*@}*/

/*!
 * @name Register TSI_GENCS, field LPCLKS[28] (RW)
 *
 * This bit-field can only be changed if the TSI module is disabled (TSIEN bit =
 * 0).
 *
 * Values:
 * - 0 - LPOCLK is selected to determine the scan period in low power mode
 * - 1 - VLPOSCCLK is selected to determine the scan period in low power mode
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_LPCLKS field. */
#define TSI_RD_GENCS_LPCLKS(base) ((TSI_GENCS_REG(base) & TSI_GENCS_LPCLKS_MASK) >> TSI_GENCS_LPCLKS_SHIFT)
#define TSI_BRD_GENCS_LPCLKS(base) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_LPCLKS_SHIFT))

/*! @brief Set the LPCLKS field to a new value. */
#define TSI_WR_GENCS_LPCLKS(base, value) (TSI_RMW_GENCS(base, TSI_GENCS_LPCLKS_MASK, TSI_GENCS_LPCLKS(value)))
#define TSI_BWR_GENCS_LPCLKS(base, value) (BITBAND_ACCESS32(&TSI_GENCS_REG(base), TSI_GENCS_LPCLKS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * TSI_SCANC - SCAN Control Register
 ******************************************************************************/

/*!
 * @brief TSI_SCANC - SCAN Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_SCANC register
 */
/*@{*/
#define TSI_RD_SCANC(base)       (TSI_SCANC_REG(base))
#define TSI_WR_SCANC(base, value) (TSI_SCANC_REG(base) = (value))
#define TSI_RMW_SCANC(base, mask, value) (TSI_WR_SCANC(base, (TSI_RD_SCANC(base) & ~(mask)) | (value)))
#define TSI_SET_SCANC(base, value) (TSI_WR_SCANC(base, TSI_RD_SCANC(base) |  (value)))
#define TSI_CLR_SCANC(base, value) (TSI_WR_SCANC(base, TSI_RD_SCANC(base) & ~(value)))
#define TSI_TOG_SCANC(base, value) (TSI_WR_SCANC(base, TSI_RD_SCANC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TSI_SCANC bitfields
 */

/*!
 * @name Register TSI_SCANC, field AMPSC[2:0] (RW)
 *
 * Values:
 * - 000 - Input Clock Source divided by 1.
 * - 001 - Input Clock Source divided by 2.
 * - 010 - Input Clock Source divided by 4.
 * - 011 - Input Clock Source divided by 8.
 * - 100 - Input Clock Source divided by 16.
 * - 101 - Input Clock Source divided by 32.
 * - 110 - Input Clock Source divided by 64.
 * - 111 - Input Clock Source divided by 128.
 */
/*@{*/
/*! @brief Read current value of the TSI_SCANC_AMPSC field. */
#define TSI_RD_SCANC_AMPSC(base) ((TSI_SCANC_REG(base) & TSI_SCANC_AMPSC_MASK) >> TSI_SCANC_AMPSC_SHIFT)
#define TSI_BRD_SCANC_AMPSC(base) (TSI_RD_SCANC_AMPSC(base))

/*! @brief Set the AMPSC field to a new value. */
#define TSI_WR_SCANC_AMPSC(base, value) (TSI_RMW_SCANC(base, TSI_SCANC_AMPSC_MASK, TSI_SCANC_AMPSC(value)))
#define TSI_BWR_SCANC_AMPSC(base, value) (TSI_WR_SCANC_AMPSC(base, value))
/*@}*/

/*!
 * @name Register TSI_SCANC, field AMCLKS[4:3] (RW)
 *
 * Values:
 * - 00 - LPOSCCLK
 * - 01 - MCGIRCLK.
 * - 10 - OSCERCLK.
 * - 11 - Not valid.
 */
/*@{*/
/*! @brief Read current value of the TSI_SCANC_AMCLKS field. */
#define TSI_RD_SCANC_AMCLKS(base) ((TSI_SCANC_REG(base) & TSI_SCANC_AMCLKS_MASK) >> TSI_SCANC_AMCLKS_SHIFT)
#define TSI_BRD_SCANC_AMCLKS(base) (TSI_RD_SCANC_AMCLKS(base))

/*! @brief Set the AMCLKS field to a new value. */
#define TSI_WR_SCANC_AMCLKS(base, value) (TSI_RMW_SCANC(base, TSI_SCANC_AMCLKS_MASK, TSI_SCANC_AMCLKS(value)))
#define TSI_BWR_SCANC_AMCLKS(base, value) (TSI_WR_SCANC_AMCLKS(base, value))
/*@}*/

/*!
 * @name Register TSI_SCANC, field SMOD[15:8] (RW)
 *
 * Values:
 * - 00000000 - Continue Scan.
 */
/*@{*/
/*! @brief Read current value of the TSI_SCANC_SMOD field. */
#define TSI_RD_SCANC_SMOD(base) ((TSI_SCANC_REG(base) & TSI_SCANC_SMOD_MASK) >> TSI_SCANC_SMOD_SHIFT)
#define TSI_BRD_SCANC_SMOD(base) (TSI_RD_SCANC_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define TSI_WR_SCANC_SMOD(base, value) (TSI_RMW_SCANC(base, TSI_SCANC_SMOD_MASK, TSI_SCANC_SMOD(value)))
#define TSI_BWR_SCANC_SMOD(base, value) (TSI_WR_SCANC_SMOD(base, value))
/*@}*/

/*!
 * @name Register TSI_SCANC, field EXTCHRG[19:16] (RW)
 *
 * Values:
 * - 0000 - 2 uA charge current.
 * - 0001 - 4 uA charge current.
 * - 0010 - 6 uA charge current.
 * - 0011 - 8 uA charge current.
 * - 0100 - 10 uA charge current.
 * - 0101 - 12 uA charge current.
 * - 0110 - 14 uA charge current.
 * - 0111 - 16 uA charge current.
 * - 1000 - 18 uA charge current.
 * - 1001 - 20 uA charge current.
 * - 1010 - 22 uA charge current.
 * - 1011 - 24 uA charge current.
 * - 1100 - 26 uA charge current.
 * - 1101 - 28 uA charge current.
 * - 1110 - 30 uA charge current.
 * - 1111 - 32 uA charge current.
 */
/*@{*/
/*! @brief Read current value of the TSI_SCANC_EXTCHRG field. */
#define TSI_RD_SCANC_EXTCHRG(base) ((TSI_SCANC_REG(base) & TSI_SCANC_EXTCHRG_MASK) >> TSI_SCANC_EXTCHRG_SHIFT)
#define TSI_BRD_SCANC_EXTCHRG(base) (TSI_RD_SCANC_EXTCHRG(base))

/*! @brief Set the EXTCHRG field to a new value. */
#define TSI_WR_SCANC_EXTCHRG(base, value) (TSI_RMW_SCANC(base, TSI_SCANC_EXTCHRG_MASK, TSI_SCANC_EXTCHRG(value)))
#define TSI_BWR_SCANC_EXTCHRG(base, value) (TSI_WR_SCANC_EXTCHRG(base, value))
/*@}*/

/*!
 * @name Register TSI_SCANC, field REFCHRG[27:24] (RW)
 *
 * Values:
 * - 0000 - 2 uA charge current.
 * - 0001 - 4 uA charge current.
 * - 0010 - 6 uA charge current.
 * - 0011 - 8 uA charge current.
 * - 0100 - 10 uA charge current.
 * - 0101 - 12 uA charge current.
 * - 0110 - 14 uA charge current.
 * - 0111 - 16 uA charge current.
 * - 1000 - 18 uA charge current.
 * - 1001 - 20 uA charge current.
 * - 1010 - 22 uA charge current.
 * - 1011 - 24 uA charge current.
 * - 1100 - 26 uA charge current.
 * - 1101 - 28 uA charge current.
 * - 1110 - 30 uA charge current.
 * - 1111 - 32 uA charge current.
 */
/*@{*/
/*! @brief Read current value of the TSI_SCANC_REFCHRG field. */
#define TSI_RD_SCANC_REFCHRG(base) ((TSI_SCANC_REG(base) & TSI_SCANC_REFCHRG_MASK) >> TSI_SCANC_REFCHRG_SHIFT)
#define TSI_BRD_SCANC_REFCHRG(base) (TSI_RD_SCANC_REFCHRG(base))

/*! @brief Set the REFCHRG field to a new value. */
#define TSI_WR_SCANC_REFCHRG(base, value) (TSI_RMW_SCANC(base, TSI_SCANC_REFCHRG_MASK, TSI_SCANC_REFCHRG(value)))
#define TSI_BWR_SCANC_REFCHRG(base, value) (TSI_WR_SCANC_REFCHRG(base, value))
/*@}*/

/*******************************************************************************
 * TSI_PEN - Pin Enable Register
 ******************************************************************************/

/*!
 * @brief TSI_PEN - Pin Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Do not change the settings when TSIEN is 1.
 */
/*!
 * @name Constants and macros for entire TSI_PEN register
 */
/*@{*/
#define TSI_RD_PEN(base)         (TSI_PEN_REG(base))
#define TSI_WR_PEN(base, value)  (TSI_PEN_REG(base) = (value))
#define TSI_RMW_PEN(base, mask, value) (TSI_WR_PEN(base, (TSI_RD_PEN(base) & ~(mask)) | (value)))
#define TSI_SET_PEN(base, value) (TSI_WR_PEN(base, TSI_RD_PEN(base) |  (value)))
#define TSI_CLR_PEN(base, value) (TSI_WR_PEN(base, TSI_RD_PEN(base) & ~(value)))
#define TSI_TOG_PEN(base, value) (TSI_WR_PEN(base, TSI_RD_PEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TSI_PEN bitfields
 */

/*!
 * @name Register TSI_PEN, field PEN0[0] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN0 field. */
#define TSI_RD_PEN_PEN0(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN0_MASK) >> TSI_PEN_PEN0_SHIFT)
#define TSI_BRD_PEN_PEN0(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN0_SHIFT))

/*! @brief Set the PEN0 field to a new value. */
#define TSI_WR_PEN_PEN0(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN0_MASK, TSI_PEN_PEN0(value)))
#define TSI_BWR_PEN_PEN0(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN1[1] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN1 field. */
#define TSI_RD_PEN_PEN1(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN1_MASK) >> TSI_PEN_PEN1_SHIFT)
#define TSI_BRD_PEN_PEN1(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN1_SHIFT))

/*! @brief Set the PEN1 field to a new value. */
#define TSI_WR_PEN_PEN1(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN1_MASK, TSI_PEN_PEN1(value)))
#define TSI_BWR_PEN_PEN1(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN2[2] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN2 field. */
#define TSI_RD_PEN_PEN2(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN2_MASK) >> TSI_PEN_PEN2_SHIFT)
#define TSI_BRD_PEN_PEN2(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN2_SHIFT))

/*! @brief Set the PEN2 field to a new value. */
#define TSI_WR_PEN_PEN2(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN2_MASK, TSI_PEN_PEN2(value)))
#define TSI_BWR_PEN_PEN2(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN3[3] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN3 field. */
#define TSI_RD_PEN_PEN3(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN3_MASK) >> TSI_PEN_PEN3_SHIFT)
#define TSI_BRD_PEN_PEN3(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN3_SHIFT))

/*! @brief Set the PEN3 field to a new value. */
#define TSI_WR_PEN_PEN3(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN3_MASK, TSI_PEN_PEN3(value)))
#define TSI_BWR_PEN_PEN3(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN4[4] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN4 field. */
#define TSI_RD_PEN_PEN4(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN4_MASK) >> TSI_PEN_PEN4_SHIFT)
#define TSI_BRD_PEN_PEN4(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN4_SHIFT))

/*! @brief Set the PEN4 field to a new value. */
#define TSI_WR_PEN_PEN4(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN4_MASK, TSI_PEN_PEN4(value)))
#define TSI_BWR_PEN_PEN4(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN5[5] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN5 field. */
#define TSI_RD_PEN_PEN5(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN5_MASK) >> TSI_PEN_PEN5_SHIFT)
#define TSI_BRD_PEN_PEN5(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN5_SHIFT))

/*! @brief Set the PEN5 field to a new value. */
#define TSI_WR_PEN_PEN5(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN5_MASK, TSI_PEN_PEN5(value)))
#define TSI_BWR_PEN_PEN5(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN6[6] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN6 field. */
#define TSI_RD_PEN_PEN6(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN6_MASK) >> TSI_PEN_PEN6_SHIFT)
#define TSI_BRD_PEN_PEN6(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN6_SHIFT))

/*! @brief Set the PEN6 field to a new value. */
#define TSI_WR_PEN_PEN6(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN6_MASK, TSI_PEN_PEN6(value)))
#define TSI_BWR_PEN_PEN6(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN7[7] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN7 field. */
#define TSI_RD_PEN_PEN7(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN7_MASK) >> TSI_PEN_PEN7_SHIFT)
#define TSI_BRD_PEN_PEN7(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN7_SHIFT))

/*! @brief Set the PEN7 field to a new value. */
#define TSI_WR_PEN_PEN7(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN7_MASK, TSI_PEN_PEN7(value)))
#define TSI_BWR_PEN_PEN7(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN8[8] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN8 field. */
#define TSI_RD_PEN_PEN8(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN8_MASK) >> TSI_PEN_PEN8_SHIFT)
#define TSI_BRD_PEN_PEN8(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN8_SHIFT))

/*! @brief Set the PEN8 field to a new value. */
#define TSI_WR_PEN_PEN8(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN8_MASK, TSI_PEN_PEN8(value)))
#define TSI_BWR_PEN_PEN8(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN9[9] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN9 field. */
#define TSI_RD_PEN_PEN9(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN9_MASK) >> TSI_PEN_PEN9_SHIFT)
#define TSI_BRD_PEN_PEN9(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN9_SHIFT))

/*! @brief Set the PEN9 field to a new value. */
#define TSI_WR_PEN_PEN9(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN9_MASK, TSI_PEN_PEN9(value)))
#define TSI_BWR_PEN_PEN9(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN10[10] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN10 field. */
#define TSI_RD_PEN_PEN10(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN10_MASK) >> TSI_PEN_PEN10_SHIFT)
#define TSI_BRD_PEN_PEN10(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN10_SHIFT))

/*! @brief Set the PEN10 field to a new value. */
#define TSI_WR_PEN_PEN10(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN10_MASK, TSI_PEN_PEN10(value)))
#define TSI_BWR_PEN_PEN10(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN11[11] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN11 field. */
#define TSI_RD_PEN_PEN11(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN11_MASK) >> TSI_PEN_PEN11_SHIFT)
#define TSI_BRD_PEN_PEN11(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN11_SHIFT))

/*! @brief Set the PEN11 field to a new value. */
#define TSI_WR_PEN_PEN11(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN11_MASK, TSI_PEN_PEN11(value)))
#define TSI_BWR_PEN_PEN11(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN12[12] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN12 field. */
#define TSI_RD_PEN_PEN12(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN12_MASK) >> TSI_PEN_PEN12_SHIFT)
#define TSI_BRD_PEN_PEN12(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN12_SHIFT))

/*! @brief Set the PEN12 field to a new value. */
#define TSI_WR_PEN_PEN12(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN12_MASK, TSI_PEN_PEN12(value)))
#define TSI_BWR_PEN_PEN12(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN13[13] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN13 field. */
#define TSI_RD_PEN_PEN13(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN13_MASK) >> TSI_PEN_PEN13_SHIFT)
#define TSI_BRD_PEN_PEN13(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN13_SHIFT))

/*! @brief Set the PEN13 field to a new value. */
#define TSI_WR_PEN_PEN13(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN13_MASK, TSI_PEN_PEN13(value)))
#define TSI_BWR_PEN_PEN13(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN14[14] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN14 field. */
#define TSI_RD_PEN_PEN14(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN14_MASK) >> TSI_PEN_PEN14_SHIFT)
#define TSI_BRD_PEN_PEN14(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN14_SHIFT))

/*! @brief Set the PEN14 field to a new value. */
#define TSI_WR_PEN_PEN14(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN14_MASK, TSI_PEN_PEN14(value)))
#define TSI_BWR_PEN_PEN14(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field PEN15[15] (RW)
 *
 * Values:
 * - 0 - The corresponding pin is not used by TSI.
 * - 1 - The corresponding pin is used by TSI.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_PEN15 field. */
#define TSI_RD_PEN_PEN15(base) ((TSI_PEN_REG(base) & TSI_PEN_PEN15_MASK) >> TSI_PEN_PEN15_SHIFT)
#define TSI_BRD_PEN_PEN15(base) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN15_SHIFT))

/*! @brief Set the PEN15 field to a new value. */
#define TSI_WR_PEN_PEN15(base, value) (TSI_RMW_PEN(base, TSI_PEN_PEN15_MASK, TSI_PEN_PEN15(value)))
#define TSI_BWR_PEN_PEN15(base, value) (BITBAND_ACCESS32(&TSI_PEN_REG(base), TSI_PEN_PEN15_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TSI_PEN, field LPSP[19:16] (RW)
 *
 * Values:
 * - 0000 - TSI_IN[0] is active in low power mode.
 * - 0001 - TSI_IN[1] is active in low power mode.
 * - 0010 - TSI_IN[2] is active in low power mode.
 * - 0011 - TSI_IN[3] is active in low power mode.
 * - 0100 - TSI_IN[4] is active in low power mode.
 * - 0101 - TSI_IN[5] is active in low power mode.
 * - 0110 - TSI_IN[6] is active in low power mode.
 * - 0111 - TSI_IN[7] is active in low power mode.
 * - 1000 - TSI_IN[8] is active in low power mode.
 * - 1001 - TSI_IN[9] is active in low power mode.
 * - 1010 - TSI_IN[10] is active in low power mode.
 * - 1011 - TSI_IN[11] is active in low power mode.
 * - 1100 - TSI_IN[12] is active in low power mode.
 * - 1101 - TSI_IN[13] is active in low power mode.
 * - 1110 - TSI_IN[14] is active in low power mode.
 * - 1111 - TSI_IN[15] is active in low power mode.
 */
/*@{*/
/*! @brief Read current value of the TSI_PEN_LPSP field. */
#define TSI_RD_PEN_LPSP(base) ((TSI_PEN_REG(base) & TSI_PEN_LPSP_MASK) >> TSI_PEN_LPSP_SHIFT)
#define TSI_BRD_PEN_LPSP(base) (TSI_RD_PEN_LPSP(base))

/*! @brief Set the LPSP field to a new value. */
#define TSI_WR_PEN_LPSP(base, value) (TSI_RMW_PEN(base, TSI_PEN_LPSP_MASK, TSI_PEN_LPSP(value)))
#define TSI_BWR_PEN_LPSP(base, value) (TSI_WR_PEN_LPSP(base, value))
/*@}*/

/*******************************************************************************
 * TSI_WUCNTR - Wake-Up Channel Counter Register
 ******************************************************************************/

/*!
 * @brief TSI_WUCNTR - Wake-Up Channel Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_WUCNTR register
 */
/*@{*/
#define TSI_RD_WUCNTR(base)      (TSI_WUCNTR_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSI_WUCNTR bitfields
 */

/*!
 * @name Register TSI_WUCNTR, field WUCNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_WUCNTR_WUCNT field. */
#define TSI_RD_WUCNTR_WUCNT(base) ((TSI_WUCNTR_REG(base) & TSI_WUCNTR_WUCNT_MASK) >> TSI_WUCNTR_WUCNT_SHIFT)
#define TSI_BRD_WUCNTR_WUCNT(base) (TSI_RD_WUCNTR_WUCNT(base))
/*@}*/

/*******************************************************************************
 * TSI_CNTR1 - Counter Register
 ******************************************************************************/

/*!
 * @brief TSI_CNTR1 - Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_CNTR1 register
 */
/*@{*/
#define TSI_RD_CNTR1(base)       (TSI_CNTR1_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSI_CNTR1 bitfields
 */

/*!
 * @name Register TSI_CNTR1, field CTN1[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR1_CTN1 field. */
#define TSI_RD_CNTR1_CTN1(base) ((TSI_CNTR1_REG(base) & TSI_CNTR1_CTN1_MASK) >> TSI_CNTR1_CTN1_SHIFT)
#define TSI_BRD_CNTR1_CTN1(base) (TSI_RD_CNTR1_CTN1(base))
/*@}*/

/*!
 * @name Register TSI_CNTR1, field CTN[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR1_CTN field. */
#define TSI_RD_CNTR1_CTN(base) ((TSI_CNTR1_REG(base) & TSI_CNTR1_CTN_MASK) >> TSI_CNTR1_CTN_SHIFT)
#define TSI_BRD_CNTR1_CTN(base) (TSI_RD_CNTR1_CTN(base))
/*@}*/

/*******************************************************************************
 * TSI_CNTR3 - Counter Register
 ******************************************************************************/

/*!
 * @brief TSI_CNTR3 - Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_CNTR3 register
 */
/*@{*/
#define TSI_RD_CNTR3(base)       (TSI_CNTR3_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSI_CNTR3 bitfields
 */

/*!
 * @name Register TSI_CNTR3, field CTN1[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR3_CTN1 field. */
#define TSI_RD_CNTR3_CTN1(base) ((TSI_CNTR3_REG(base) & TSI_CNTR3_CTN1_MASK) >> TSI_CNTR3_CTN1_SHIFT)
#define TSI_BRD_CNTR3_CTN1(base) (TSI_RD_CNTR3_CTN1(base))
/*@}*/

/*!
 * @name Register TSI_CNTR3, field CTN[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR3_CTN field. */
#define TSI_RD_CNTR3_CTN(base) ((TSI_CNTR3_REG(base) & TSI_CNTR3_CTN_MASK) >> TSI_CNTR3_CTN_SHIFT)
#define TSI_BRD_CNTR3_CTN(base) (TSI_RD_CNTR3_CTN(base))
/*@}*/

/*******************************************************************************
 * TSI_CNTR5 - Counter Register
 ******************************************************************************/

/*!
 * @brief TSI_CNTR5 - Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_CNTR5 register
 */
/*@{*/
#define TSI_RD_CNTR5(base)       (TSI_CNTR5_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSI_CNTR5 bitfields
 */

/*!
 * @name Register TSI_CNTR5, field CTN1[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR5_CTN1 field. */
#define TSI_RD_CNTR5_CTN1(base) ((TSI_CNTR5_REG(base) & TSI_CNTR5_CTN1_MASK) >> TSI_CNTR5_CTN1_SHIFT)
#define TSI_BRD_CNTR5_CTN1(base) (TSI_RD_CNTR5_CTN1(base))
/*@}*/

/*!
 * @name Register TSI_CNTR5, field CTN[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR5_CTN field. */
#define TSI_RD_CNTR5_CTN(base) ((TSI_CNTR5_REG(base) & TSI_CNTR5_CTN_MASK) >> TSI_CNTR5_CTN_SHIFT)
#define TSI_BRD_CNTR5_CTN(base) (TSI_RD_CNTR5_CTN(base))
/*@}*/

/*******************************************************************************
 * TSI_CNTR7 - Counter Register
 ******************************************************************************/

/*!
 * @brief TSI_CNTR7 - Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_CNTR7 register
 */
/*@{*/
#define TSI_RD_CNTR7(base)       (TSI_CNTR7_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSI_CNTR7 bitfields
 */

/*!
 * @name Register TSI_CNTR7, field CTN1[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR7_CTN1 field. */
#define TSI_RD_CNTR7_CTN1(base) ((TSI_CNTR7_REG(base) & TSI_CNTR7_CTN1_MASK) >> TSI_CNTR7_CTN1_SHIFT)
#define TSI_BRD_CNTR7_CTN1(base) (TSI_RD_CNTR7_CTN1(base))
/*@}*/

/*!
 * @name Register TSI_CNTR7, field CTN[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR7_CTN field. */
#define TSI_RD_CNTR7_CTN(base) ((TSI_CNTR7_REG(base) & TSI_CNTR7_CTN_MASK) >> TSI_CNTR7_CTN_SHIFT)
#define TSI_BRD_CNTR7_CTN(base) (TSI_RD_CNTR7_CTN(base))
/*@}*/

/*******************************************************************************
 * TSI_CNTR9 - Counter Register
 ******************************************************************************/

/*!
 * @brief TSI_CNTR9 - Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_CNTR9 register
 */
/*@{*/
#define TSI_RD_CNTR9(base)       (TSI_CNTR9_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSI_CNTR9 bitfields
 */

/*!
 * @name Register TSI_CNTR9, field CTN1[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR9_CTN1 field. */
#define TSI_RD_CNTR9_CTN1(base) ((TSI_CNTR9_REG(base) & TSI_CNTR9_CTN1_MASK) >> TSI_CNTR9_CTN1_SHIFT)
#define TSI_BRD_CNTR9_CTN1(base) (TSI_RD_CNTR9_CTN1(base))
/*@}*/

/*!
 * @name Register TSI_CNTR9, field CTN[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR9_CTN field. */
#define TSI_RD_CNTR9_CTN(base) ((TSI_CNTR9_REG(base) & TSI_CNTR9_CTN_MASK) >> TSI_CNTR9_CTN_SHIFT)
#define TSI_BRD_CNTR9_CTN(base) (TSI_RD_CNTR9_CTN(base))
/*@}*/

/*******************************************************************************
 * TSI_CNTR11 - Counter Register
 ******************************************************************************/

/*!
 * @brief TSI_CNTR11 - Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_CNTR11 register
 */
/*@{*/
#define TSI_RD_CNTR11(base)      (TSI_CNTR11_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSI_CNTR11 bitfields
 */

/*!
 * @name Register TSI_CNTR11, field CTN1[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR11_CTN1 field. */
#define TSI_RD_CNTR11_CTN1(base) ((TSI_CNTR11_REG(base) & TSI_CNTR11_CTN1_MASK) >> TSI_CNTR11_CTN1_SHIFT)
#define TSI_BRD_CNTR11_CTN1(base) (TSI_RD_CNTR11_CTN1(base))
/*@}*/

/*!
 * @name Register TSI_CNTR11, field CTN[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR11_CTN field. */
#define TSI_RD_CNTR11_CTN(base) ((TSI_CNTR11_REG(base) & TSI_CNTR11_CTN_MASK) >> TSI_CNTR11_CTN_SHIFT)
#define TSI_BRD_CNTR11_CTN(base) (TSI_RD_CNTR11_CTN(base))
/*@}*/

/*******************************************************************************
 * TSI_CNTR13 - Counter Register
 ******************************************************************************/

/*!
 * @brief TSI_CNTR13 - Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_CNTR13 register
 */
/*@{*/
#define TSI_RD_CNTR13(base)      (TSI_CNTR13_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSI_CNTR13 bitfields
 */

/*!
 * @name Register TSI_CNTR13, field CTN1[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR13_CTN1 field. */
#define TSI_RD_CNTR13_CTN1(base) ((TSI_CNTR13_REG(base) & TSI_CNTR13_CTN1_MASK) >> TSI_CNTR13_CTN1_SHIFT)
#define TSI_BRD_CNTR13_CTN1(base) (TSI_RD_CNTR13_CTN1(base))
/*@}*/

/*!
 * @name Register TSI_CNTR13, field CTN[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR13_CTN field. */
#define TSI_RD_CNTR13_CTN(base) ((TSI_CNTR13_REG(base) & TSI_CNTR13_CTN_MASK) >> TSI_CNTR13_CTN_SHIFT)
#define TSI_BRD_CNTR13_CTN(base) (TSI_RD_CNTR13_CTN(base))
/*@}*/

/*******************************************************************************
 * TSI_CNTR15 - Counter Register
 ******************************************************************************/

/*!
 * @brief TSI_CNTR15 - Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_CNTR15 register
 */
/*@{*/
#define TSI_RD_CNTR15(base)      (TSI_CNTR15_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSI_CNTR15 bitfields
 */

/*!
 * @name Register TSI_CNTR15, field CTN1[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR15_CTN1 field. */
#define TSI_RD_CNTR15_CTN1(base) ((TSI_CNTR15_REG(base) & TSI_CNTR15_CTN1_MASK) >> TSI_CNTR15_CTN1_SHIFT)
#define TSI_BRD_CNTR15_CTN1(base) (TSI_RD_CNTR15_CTN1(base))
/*@}*/

/*!
 * @name Register TSI_CNTR15, field CTN[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the TSI_CNTR15_CTN field. */
#define TSI_RD_CNTR15_CTN(base) ((TSI_CNTR15_REG(base) & TSI_CNTR15_CTN_MASK) >> TSI_CNTR15_CTN_SHIFT)
#define TSI_BRD_CNTR15_CTN(base) (TSI_RD_CNTR15_CTN(base))
/*@}*/

/*******************************************************************************
 * TSI_THRESHOLD - Low Power Channel Threshold Register
 ******************************************************************************/

/*!
 * @brief TSI_THRESHOLD - Low Power Channel Threshold Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_THRESHOLD register
 */
/*@{*/
#define TSI_RD_THRESHOLD(base)   (TSI_THRESHOLD_REG(base))
#define TSI_WR_THRESHOLD(base, value) (TSI_THRESHOLD_REG(base) = (value))
#define TSI_RMW_THRESHOLD(base, mask, value) (TSI_WR_THRESHOLD(base, (TSI_RD_THRESHOLD(base) & ~(mask)) | (value)))
#define TSI_SET_THRESHOLD(base, value) (TSI_WR_THRESHOLD(base, TSI_RD_THRESHOLD(base) |  (value)))
#define TSI_CLR_THRESHOLD(base, value) (TSI_WR_THRESHOLD(base, TSI_RD_THRESHOLD(base) & ~(value)))
#define TSI_TOG_THRESHOLD(base, value) (TSI_WR_THRESHOLD(base, TSI_RD_THRESHOLD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TSI_THRESHOLD bitfields
 */

/*!
 * @name Register TSI_THRESHOLD, field HTHH[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the TSI_THRESHOLD_HTHH field. */
#define TSI_RD_THRESHOLD_HTHH(base) ((TSI_THRESHOLD_REG(base) & TSI_THRESHOLD_HTHH_MASK) >> TSI_THRESHOLD_HTHH_SHIFT)
#define TSI_BRD_THRESHOLD_HTHH(base) (TSI_RD_THRESHOLD_HTHH(base))

/*! @brief Set the HTHH field to a new value. */
#define TSI_WR_THRESHOLD_HTHH(base, value) (TSI_RMW_THRESHOLD(base, TSI_THRESHOLD_HTHH_MASK, TSI_THRESHOLD_HTHH(value)))
#define TSI_BWR_THRESHOLD_HTHH(base, value) (TSI_WR_THRESHOLD_HTHH(base, value))
/*@}*/

/*!
 * @name Register TSI_THRESHOLD, field LTHH[31:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the TSI_THRESHOLD_LTHH field. */
#define TSI_RD_THRESHOLD_LTHH(base) ((TSI_THRESHOLD_REG(base) & TSI_THRESHOLD_LTHH_MASK) >> TSI_THRESHOLD_LTHH_SHIFT)
#define TSI_BRD_THRESHOLD_LTHH(base) (TSI_RD_THRESHOLD_LTHH(base))

/*! @brief Set the LTHH field to a new value. */
#define TSI_WR_THRESHOLD_LTHH(base, value) (TSI_RMW_THRESHOLD(base, TSI_THRESHOLD_LTHH_MASK, TSI_THRESHOLD_LTHH(value)))
#define TSI_BWR_THRESHOLD_LTHH(base, value) (TSI_WR_THRESHOLD_LTHH(base, value))
/*@}*/

/*
 * MK20D5 UART
 *
 * Serial Communication Interface
 *
 * Registers defined in this header file:
 * - UART_BDH - UART Baud Rate Registers:High
 * - UART_BDL - UART Baud Rate Registers: Low
 * - UART_C1 - UART Control Register 1
 * - UART_C2 - UART Control Register 2
 * - UART_S1 - UART Status Register 1
 * - UART_S2 - UART Status Register 2
 * - UART_C3 - UART Control Register 3
 * - UART_D - UART Data Register
 * - UART_MA1 - UART Match Address Registers 1
 * - UART_MA2 - UART Match Address Registers 2
 * - UART_C4 - UART Control Register 4
 * - UART_C5 - UART Control Register 5
 * - UART_ED - UART Extended Data Register
 * - UART_MODEM - UART Modem Register
 * - UART_IR - UART Infrared Register
 * - UART_PFIFO - UART FIFO Parameters
 * - UART_CFIFO - UART FIFO Control Register
 * - UART_SFIFO - UART FIFO Status Register
 * - UART_TWFIFO - UART FIFO Transmit Watermark
 * - UART_TCFIFO - UART FIFO Transmit Count
 * - UART_RWFIFO - UART FIFO Receive Watermark
 * - UART_RCFIFO - UART FIFO Receive Count
 * - UART_C7816 - UART 7816 Control Register
 * - UART_IE7816 - UART 7816 Interrupt Enable Register
 * - UART_IS7816 - UART 7816 Interrupt Status Register
 * - UART_WP7816T0 - UART 7816 Wait Parameter Register
 * - UART_WP7816T1 - UART 7816 Wait Parameter Register
 * - UART_WN7816 - UART 7816 Wait N Register
 * - UART_WF7816 - UART 7816 Wait FD Register
 * - UART_ET7816 - UART 7816 Error Threshold Register
 * - UART_TL7816 - UART 7816 Transmit Length Register
 * - UART_C6 - UART CEA709.1-B Control Register 6
 * - UART_PCTH - UART CEA709.1-B Packet Cycle Time Counter High
 * - UART_PCTL - UART CEA709.1-B Packet Cycle Time Counter Low
 * - UART_B1T - UART CEA709.1-B Beta1 Timer
 * - UART_SDTH - UART CEA709.1-B Secondary Delay Timer High
 * - UART_SDTL - UART CEA709.1-B Secondary Delay Timer Low
 * - UART_PRE - UART CEA709.1-B Preamble
 * - UART_TPL - UART CEA709.1-B Transmit Packet Length
 * - UART_IE - UART CEA709.1-B Interrupt Enable Register
 * - UART_WB - UART CEA709.1-B WBASE
 * - UART_S3 - UART CEA709.1-B Status Register
 * - UART_S4 - UART CEA709.1-B Status Register
 * - UART_RPL - UART CEA709.1-B Received Packet Length
 * - UART_RPREL - UART CEA709.1-B Received Preamble Length
 * - UART_CPW - UART CEA709.1-B Collision Pulse Width
 * - UART_RIDT - UART CEA709.1-B Receive Indeterminate Time
 * - UART_TIDT - UART CEA709.1-B Transmit Indeterminate Time
 */

#define UART_INSTANCE_COUNT (3U) /*!< Number of instances of the UART module. */
#define UART0_IDX (0U) /*!< Instance number for UART0. */
#define UART1_IDX (1U) /*!< Instance number for UART1. */
#define UART2_IDX (2U) /*!< Instance number for UART2. */

/*******************************************************************************
 * UART_BDH - UART Baud Rate Registers:High
 ******************************************************************************/

/*!
 * @brief UART_BDH - UART Baud Rate Registers:High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with the BDL register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a non-zero value, but after reset the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled (C2[RE] or
 * C2[TE] bits are set).
 */
/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define UART_RD_BDH(base)        (UART_BDH_REG(base))
#define UART_WR_BDH(base, value) (UART_BDH_REG(base) = (value))
#define UART_RMW_BDH(base, mask, value) (UART_WR_BDH(base, (UART_RD_BDH(base) & ~(mask)) | (value)))
#define UART_SET_BDH(base, value) (UART_WR_BDH(base, UART_RD_BDH(base) |  (value)))
#define UART_CLR_BDH(base, value) (UART_WR_BDH(base, UART_RD_BDH(base) & ~(value)))
#define UART_TOG_BDH(base, value) (UART_WR_BDH(base, UART_RD_BDH(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The baud rate for the UART is determined by these 13 bits. See Baud rate
 * generation for details. The baud rate generator is disabled until the C2[TE] bit
 * or the C2[RE] bit is set for the first time after reset.The baud rate generator
 * is disabled when SBR = 0. Writing to BDH has no effect without writing to
 * BDL, since writing to BDH puts the data in a temporary location until BDL is
 * written.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_SBR field. */
#define UART_RD_BDH_SBR(base) ((UART_BDH_REG(base) & UART_BDH_SBR_MASK) >> UART_BDH_SBR_SHIFT)
#define UART_BRD_BDH_SBR(base) (UART_RD_BDH_SBR(base))

/*! @brief Set the SBR field to a new value. */
#define UART_WR_BDH_SBR(base, value) (UART_RMW_BDH(base, UART_BDH_SBR_MASK, UART_BDH_SBR(value)))
#define UART_BWR_BDH_SBR(base, value) (UART_WR_BDH_SBR(base, value))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * RXEDGIE enables the Receive input active edge, RXEDGIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from RXEDGIF disabled (use polling).
 * - 1 - RXEDGIF interrupt request enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define UART_RD_BDH_RXEDGIE(base) ((UART_BDH_REG(base) & UART_BDH_RXEDGIE_MASK) >> UART_BDH_RXEDGIE_SHIFT)
#define UART_BRD_BDH_RXEDGIE(base) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_RXEDGIE_SHIFT))

/*! @brief Set the RXEDGIE field to a new value. */
#define UART_WR_BDH_RXEDGIE(base, value) (UART_RMW_BDH(base, UART_BDH_RXEDGIE_MASK, UART_BDH_RXEDGIE(value)))
#define UART_BWR_BDH_RXEDGIE(base, value) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_RXEDGIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_BDH, field LBKDIE[7] (RW)
 *
 * LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrupt
 * requests based on the state of LBKDDMAS.
 *
 * Values:
 * - 0 - LBKDIF interrupt requests disabled.
 * - 1 - LBKDIF interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_LBKDIE field. */
#define UART_RD_BDH_LBKDIE(base) ((UART_BDH_REG(base) & UART_BDH_LBKDIE_MASK) >> UART_BDH_LBKDIE_SHIFT)
#define UART_BRD_BDH_LBKDIE(base) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_LBKDIE_SHIFT))

/*! @brief Set the LBKDIE field to a new value. */
#define UART_WR_BDH_LBKDIE(base, value) (UART_RMW_BDH(base, UART_BDH_LBKDIE_MASK, UART_BDH_LBKDIE(value)))
#define UART_BWR_BDH_LBKDIE(base, value) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_LBKDIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_BDL - UART Baud Rate Registers: Low
 ******************************************************************************/

/*!
 * @brief UART_BDL - UART Baud Rate Registers: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with the BDH register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a non-zero value, but after reset the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled (C2[RE] or
 * C2[TE] bits are set)
 */
/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define UART_RD_BDL(base)        (UART_BDL_REG(base))
#define UART_WR_BDL(base, value) (UART_BDL_REG(base) = (value))
#define UART_RMW_BDL(base, mask, value) (UART_WR_BDL(base, (UART_RD_BDL(base) & ~(mask)) | (value)))
#define UART_SET_BDL(base, value) (UART_WR_BDL(base, UART_RD_BDL(base) |  (value)))
#define UART_CLR_BDL(base, value) (UART_WR_BDL(base, UART_RD_BDL(base) & ~(value)))
#define UART_TOG_BDL(base, value) (UART_WR_BDL(base, UART_RD_BDL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define UART_RD_C1(base)         (UART_C1_REG(base))
#define UART_WR_C1(base, value)  (UART_C1_REG(base) = (value))
#define UART_RMW_C1(base, mask, value) (UART_WR_C1(base, (UART_RD_C1(base) & ~(mask)) | (value)))
#define UART_SET_C1(base, value) (UART_WR_C1(base, UART_RD_C1(base) |  (value)))
#define UART_CLR_C1(base, value) (UART_WR_C1(base, UART_RD_C1(base) & ~(value)))
#define UART_TOG_C1(base, value) (UART_WR_C1(base, UART_RD_C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * PT determines whether the UART generates and checks for even parity or odd
 * parity. With even parity, an even number of 1s clears the parity bit and an odd
 * number of 1s sets the parity bit. With odd parity, an odd number of 1s clears
 * the parity bit and an even number of 1s sets the parity bit.This bit must be
 * cleared when 7816E is set/enabled.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PT field. */
#define UART_RD_C1_PT(base)  ((UART_C1_REG(base) & UART_C1_PT_MASK) >> UART_C1_PT_SHIFT)
#define UART_BRD_C1_PT(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_PT_SHIFT))

/*! @brief Set the PT field to a new value. */
#define UART_WR_C1_PT(base, value) (UART_RMW_C1(base, UART_C1_PT_MASK, UART_C1_PT(value)))
#define UART_BWR_C1_PT(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_PT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables the parity function. When parity is enabled, parity function inserts
 * a parity bit in the bit position immediately preceding the stop bit. This bit
 * must be set when 7816E is set/enabled.
 *
 * Values:
 * - 0 - Parity function disabled.
 * - 1 - Parity function enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PE field. */
#define UART_RD_C1_PE(base)  ((UART_C1_REG(base) & UART_C1_PE_MASK) >> UART_C1_PE_SHIFT)
#define UART_BRD_C1_PE(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_PE_SHIFT))

/*! @brief Set the PE field to a new value. */
#define UART_WR_C1_PE(base, value) (UART_RMW_C1(base, UART_C1_PE_MASK, UART_C1_PE(value)))
#define UART_BWR_C1_PE(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * ILT determines when the receiver starts counting logic 1s as idle character
 * bits. The counting begins either after a valid start bit or after the stop bit.
 * If the count begins after the start bit, then a string of logic 1s preceding
 * the stop bit can cause false recognition of an idle character. Beginning the
 * count after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In the case where UART is programmed with
 * ILT = 1, a logic of 1'b0 is automatically shifted after a received stop bit
 * thus resetting the idle count. In the case where UART is programmed for IDLE
 * line wakeup (RWU = 1 and WAKE = 0), ILT has no effect on when the receiver
 * starts counting logic 1s as idle character bits. In idle line wakeup an idle
 * character is recognized at anytime the receiver sees 10, 11, or 12 1s depending on
 * the M, PE, and C4[M10] bits.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_ILT field. */
#define UART_RD_C1_ILT(base) ((UART_C1_REG(base) & UART_C1_ILT_MASK) >> UART_C1_ILT_SHIFT)
#define UART_BRD_C1_ILT(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_ILT_SHIFT))

/*! @brief Set the ILT field to a new value. */
#define UART_WR_C1_ILT(base, value) (UART_RMW_C1(base, UART_C1_ILT_MASK, UART_C1_ILT(value)))
#define UART_BWR_C1_ILT(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_ILT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * WAKE determines which condition wakes the UART: address mark in the most
 * significant bit position of a received data character or an idle condition on the
 * receive pin input signal.
 *
 * Values:
 * - 0 - Idle-line wakeup.
 * - 1 - Address-mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_WAKE field. */
#define UART_RD_C1_WAKE(base) ((UART_C1_REG(base) & UART_C1_WAKE_MASK) >> UART_C1_WAKE_SHIFT)
#define UART_BRD_C1_WAKE(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_WAKE_SHIFT))

/*! @brief Set the WAKE field to a new value. */
#define UART_WR_C1_WAKE(base, value) (UART_RMW_C1(base, UART_C1_WAKE_MASK, UART_C1_WAKE(value)))
#define UART_BWR_C1_WAKE(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_WAKE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * This bit must be set when 7816E is set/enabled.
 *
 * Values:
 * - 0 - Normal - start + 8 data bits (MSB/LSB first as determined by MSBF) +
 *     stop.
 * - 1 - Use - start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_M field. */
#define UART_RD_C1_M(base)   ((UART_C1_REG(base) & UART_C1_M_MASK) >> UART_C1_M_SHIFT)
#define UART_BRD_C1_M(base)  (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_M_SHIFT))

/*! @brief Set the M field to a new value. */
#define UART_WR_C1_M(base, value) (UART_RMW_C1(base, UART_C1_M_MASK, UART_C1_M(value)))
#define UART_BWR_C1_M(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_M_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This bit has no meaning or effect unless the LOOPS bit is set. When LOOPS is
 * set, the RSRC bit determines the source for the receiver shift register input.
 *
 * Values:
 * - 0 - Selects internal loop back mode and receiver input is internally
 *     connected to transmitter output.
 * - 1 - Single-wire UART mode where the receiver input is connected to the
 *     transmit pin input signal.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_RSRC field. */
#define UART_RD_C1_RSRC(base) ((UART_C1_REG(base) & UART_C1_RSRC_MASK) >> UART_C1_RSRC_SHIFT)
#define UART_BRD_C1_RSRC(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_RSRC_SHIFT))

/*! @brief Set the RSRC field to a new value. */
#define UART_WR_C1_RSRC(base, value) (UART_RMW_C1(base, UART_C1_RSRC_MASK, UART_C1_RSRC(value)))
#define UART_BWR_C1_RSRC(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_RSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field UARTSWAI[6] (RW)
 *
 * Values:
 * - 0 - UART clock continues to run in wait mode.
 * - 1 - UART clock freezes while CPU is in wait mode.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_UARTSWAI field. */
#define UART_RD_C1_UARTSWAI(base) ((UART_C1_REG(base) & UART_C1_UARTSWAI_MASK) >> UART_C1_UARTSWAI_SHIFT)
#define UART_BRD_C1_UARTSWAI(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_UARTSWAI_SHIFT))

/*! @brief Set the UARTSWAI field to a new value. */
#define UART_WR_C1_UARTSWAI(base, value) (UART_RMW_C1(base, UART_C1_UARTSWAI_MASK, UART_C1_UARTSWAI(value)))
#define UART_BWR_C1_UARTSWAI(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_UARTSWAI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the RxD pin is disconnected from the UART and the
 * transmitter output is internally connected to the receiver input.The transmitter and
 * the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Loop mode where transmitter output is internally connected to receiver
 *     input. The receiver input is determined by the RSRC bit.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_LOOPS field. */
#define UART_RD_C1_LOOPS(base) ((UART_C1_REG(base) & UART_C1_LOOPS_MASK) >> UART_C1_LOOPS_SHIFT)
#define UART_BRD_C1_LOOPS(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_LOOPS_SHIFT))

/*! @brief Set the LOOPS field to a new value. */
#define UART_WR_C1_LOOPS(base, value) (UART_RMW_C1(base, UART_C1_LOOPS_MASK, UART_C1_LOOPS(value)))
#define UART_BWR_C1_LOOPS(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_LOOPS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define UART_RD_C2(base)         (UART_C2_REG(base))
#define UART_WR_C2(base, value)  (UART_C2_REG(base) = (value))
#define UART_RMW_C2(base, mask, value) (UART_WR_C2(base, (UART_RD_C2(base) & ~(mask)) | (value)))
#define UART_SET_C2(base, value) (UART_WR_C2(base, UART_RD_C2(base) |  (value)))
#define UART_CLR_C2(base, value) (UART_WR_C2(base, UART_RD_C2(base) & ~(value)))
#define UART_TOG_C2(base, value) (UART_WR_C2(base, UART_RD_C2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Toggling SBK sends one break character (10, 11, or 12 logic 0s, if S2[BRK13]
 * is cleared; 13 or 14 logic 0s, if S2[BRK13] is set). See Transmitting break
 * characters for the number of logic 0s for the different configurations. Toggling
 * implies clearing the SBK bit before the break character has finished
 * transmitting. As long as SBK is set, the transmitter continues to send complete break
 * characters (10, 11, or 12 bits, or 13 or 14 bits).This bit must be cleared
 * when 7816E is set.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break character(s) to be sent.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_SBK field. */
#define UART_RD_C2_SBK(base) ((UART_C2_REG(base) & UART_C2_SBK_MASK) >> UART_C2_SBK_SHIFT)
#define UART_BRD_C2_SBK(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_SBK_SHIFT))

/*! @brief Set the SBK field to a new value. */
#define UART_WR_C2_SBK(base, value) (UART_RMW_C2(base, UART_C2_SBK_MASK, UART_C2_SBK(value)))
#define UART_BWR_C2_SBK(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_SBK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This bit can be set to place the UART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs (an IDLE event when C1[WAKE] is clear
 * or an address match when C1[WAKE] is set). This bit must be cleared when 7816E
 * is set. RWU should only be set with C1[WAKE] = 0 (wakeup on idle) if the
 * channel is currently not idle. This can be determined by the S2[RAF] flag. If set
 * to wake up an IDLE event and the channel is already idle, it is possible that
 * the UART will discard data since data must be received (or a LIN break detect)
 * after an IDLE is detected before IDLE is allowed to reasserted.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - RWU enables the wakeup function and inhibits further receiver interrupt
 *     requests. Normally, hardware wakes the receiver by automatically clearing
 *     RWU.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RWU field. */
#define UART_RD_C2_RWU(base) ((UART_C2_REG(base) & UART_C2_RWU_MASK) >> UART_C2_RWU_SHIFT)
#define UART_BRD_C2_RWU(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RWU_SHIFT))

/*! @brief Set the RWU field to a new value. */
#define UART_WR_C2_RWU(base, value) (UART_RMW_C2(base, UART_C2_RWU_MASK, UART_C2_RWU(value)))
#define UART_BWR_C2_RWU(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RWU_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * RE enables the UART receiver.
 *
 * Values:
 * - 0 - Receiver off.
 * - 1 - Receiver on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RE field. */
#define UART_RD_C2_RE(base)  ((UART_C2_REG(base) & UART_C2_RE_MASK) >> UART_C2_RE_SHIFT)
#define UART_BRD_C2_RE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RE_SHIFT))

/*! @brief Set the RE field to a new value. */
#define UART_WR_C2_RE(base, value) (UART_RMW_C2(base, UART_C2_RE_MASK, UART_C2_RE(value)))
#define UART_BWR_C2_RE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * TE enables the UART transmitter.The TE bit can be used to queue an idle
 * preamble by clearing and then setting the TE bit. When 7816E is set/enabled and
 * C7816[TTYPE] = 1, this bit is automatically cleared after the requested block has
 * been transmitted. This condition is detected when TL7816[TLEN] = 0 and four
 * additional characters have been transmitted.
 *
 * Values:
 * - 0 - Transmitter off.
 * - 1 - Transmitter on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TE field. */
#define UART_RD_C2_TE(base)  ((UART_C2_REG(base) & UART_C2_TE_MASK) >> UART_C2_TE_SHIFT)
#define UART_BRD_C2_TE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TE_SHIFT))

/*! @brief Set the TE field to a new value. */
#define UART_WR_C2_TE(base, value) (UART_RMW_C2(base, UART_C2_TE_MASK, UART_C2_TE(value)))
#define UART_BWR_C2_TE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * ILIE enables the idle line flag, S1[IDLE], to generate interrupt requests,
 * based on the state of C5[ILDMAS].
 *
 * Values:
 * - 0 - IDLE interrupt requests disabled.
 * - 1 - IDLE interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_ILIE field. */
#define UART_RD_C2_ILIE(base) ((UART_C2_REG(base) & UART_C2_ILIE_MASK) >> UART_C2_ILIE_SHIFT)
#define UART_BRD_C2_ILIE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_ILIE_SHIFT))

/*! @brief Set the ILIE field to a new value. */
#define UART_WR_C2_ILIE(base, value) (UART_RMW_C2(base, UART_C2_ILIE_MASK, UART_C2_ILIE(value)))
#define UART_BWR_C2_ILIE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_ILIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * RIE enables the S1[RDRF] flag, to generate interrupt requests or DMA transfer
 * requests, based on the state of C5[RDMAS].
 *
 * Values:
 * - 0 - RDRF interrupt and DMA transfer requests disabled.
 * - 1 - RDRF interrupt or DMA transfer requests enabled
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RIE field. */
#define UART_RD_C2_RIE(base) ((UART_C2_REG(base) & UART_C2_RIE_MASK) >> UART_C2_RIE_SHIFT)
#define UART_BRD_C2_RIE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RIE_SHIFT))

/*! @brief Set the RIE field to a new value. */
#define UART_WR_C2_RIE(base, value) (UART_RMW_C2(base, UART_C2_RIE_MASK, UART_C2_RIE(value)))
#define UART_BWR_C2_RIE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * TCIE enables the transmission complete flag, S1[TC], to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - TC interrupt requests disabled.
 * - 1 - TC interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TCIE field. */
#define UART_RD_C2_TCIE(base) ((UART_C2_REG(base) & UART_C2_TCIE_MASK) >> UART_C2_TCIE_SHIFT)
#define UART_BRD_C2_TCIE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TCIE_SHIFT))

/*! @brief Set the TCIE field to a new value. */
#define UART_WR_C2_TCIE(base, value) (UART_RMW_C2(base, UART_C2_TCIE_MASK, UART_C2_TCIE(value)))
#define UART_BWR_C2_TCIE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * TIE enables the S1[TDRE] flag, to generate interrupt requests or DMA transfer
 * requests, based on the state of C5[TDMAS]. If C2[TIE] and C5[TDMAS] are both
 * set, then TCIE must be cleared, and D[D] must not be written outside of
 * servicing of a DMA request.
 *
 * Values:
 * - 0 - TDRE interrupt and DMA transfer requests disabled.
 * - 1 - TDRE interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TIE field. */
#define UART_RD_C2_TIE(base) ((UART_C2_REG(base) & UART_C2_TIE_MASK) >> UART_C2_TIE_SHIFT)
#define UART_BRD_C2_TIE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TIE_SHIFT))

/*! @brief Set the TIE field to a new value. */
#define UART_WR_C2_TIE(base, value) (UART_RMW_C2(base, UART_C2_TIE_MASK, UART_C2_TIE(value)))
#define UART_BWR_C2_TIE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * The S1 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. This register can also be polled by the MCU to check the
 * status of these bits. To clear a flag, the status register should be read followed
 * by a read or write (depending on interrupt flag type) to the UART Data
 * Register. Other instructions can be executed between the two steps as long as it
 * does not compromise the handling of I/O, but the order of operations is important
 * for flag clearing. When a flag is configured to trigger a DMA request,
 * assertion of the associated DMA done signal from the DMA controller, clears the
 * flag. If the condition that results in the assertion of the flag, interrupt or DMA
 * request is not resolved prior to clearing the flag, the flag (and
 * interrupt/DMA request) will reassert. For example, if the DMA or interrupt service
 * routine failed to write sufficient data to the transmit buffer to raise it above the
 * watermark level, the flag will reassert and generate another interrupt or DMA
 * request. Reading an empty data register to clear one of these flags causes
 * the FIFO pointers to get out of alignment. A receive FIFO flush reinitializes
 * the pointers.
 */
/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define UART_RD_S1(base)         (UART_S1_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set when PE is set, S2[LBKDE] is disabled, and the parity of the
 * received data does not match its parity bit. The PF is not set in the case of an
 * overrun condition. When the PF bit is set it only indicates that a dataword was
 * received with parity error since the last time it was cleared. There is no
 * guarantee that the first dataword read from the receive buffer has a parity error
 * or that there is only one dataword in the buffer that was received with a
 * parity error unless the receive buffer was a depth of one. To clear PF, read S1
 * and then read the UART data register (D). Within the receive buffer structure
 * the received dataword is tagged if it was received with a parity error. That
 * information is available by reading the ED register prior to reading the D
 * register. When EN709 is set/enabled parity error flag is not set.
 *
 * Values:
 * - 0 - No parity error has been detected since the last time this flag was
 *     cleared. If the receive buffer has a depth greater than 1 then there may be
 *     data in the receive buffer what was received with a parity error.
 * - 1 - At least one dataword was received with a parity error since the last
 *     time this flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_PF field. */
#define UART_RD_S1_PF(base)  ((UART_S1_REG(base) & UART_S1_PF_MASK) >> UART_S1_PF_SHIFT)
#define UART_BRD_S1_PF(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_PF_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set when a logic 0 is accepted as the stop bit. FE bit does not set in
 * the case of an overrun or while the LIN break detect feature is enabled
 * (S2[LBKDE] = 1). FE inhibits further data reception until it is cleared. To clear
 * FE, read S1 with FE set and then read the UART data register (D). The last data
 * in the receive buffer represents the data that was received with the frame
 * error enabled. However, framing errors are not supported when 7816E is
 * set/enabled. However, if this flag is set, data will still not be received in 7816 mode.
 * Framing errors are not supported in 709 mode.
 *
 * Values:
 * - 0 - No framing error detected.
 * - 1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_FE field. */
#define UART_RD_S1_FE(base)  ((UART_S1_REG(base) & UART_S1_FE_MASK) >> UART_S1_FE_SHIFT)
#define UART_BRD_S1_FE(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_FE_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * NF is set when the UART detects noise on the receiver input. NF bit does not
 * get set in the case of an overrun or while the LIN break detect feature is
 * enabled (S2[LBKDE] = 1). When NF is set, it only indicates that a dataword has
 * been received with noise since the last time it was cleared. There is no
 * guarantee that the first dataword read from the receive buffer has noise or that
 * there is only one dataword in the buffer that was received with noise unless the
 * receive buffer has a depth of one. To clear NF, read S1 and then read the UART
 * data register (D). When EN709 is set/enabled, noise flag is not set.
 *
 * Values:
 * - 0 - No noise detected since the last time this flag was cleared. If the
 *     receive buffer has a depth greater than 1 then there may be data in the
 *     receiver buffer that was received with noise.
 * - 1 - At least one dataword was received with noise detected since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_NF field. */
#define UART_RD_S1_NF(base)  ((UART_S1_REG(base) & UART_S1_NF_MASK) >> UART_S1_NF_SHIFT)
#define UART_BRD_S1_NF(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_NF_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE,NF and PF) are prevented from setting. The data in the shift
 * register is lost, but the data already in the UART data registers is not
 * affected. If the OR flag is set, no data will be stored in the data buffer even if
 * sufficient room exists. Additionally, while the OR flag is set the RDRF flag,
 * and IDLE flags will be blocked from asserting, i.e. transition from an
 * inactive to an active state. To clear OR, read S1 when OR is set and then read UART
 * data register (D). If LBKDE is enabled and a LIN Break is detected, the OR bit
 * will assert if the S2[LBKDIF] flag is not cleared before the next data
 * character is received.See Overrun (OR) flag implications for more details regarding
 * the operation of the OR bit. In 7816 mode, it is possible to configure a NACK
 * to be returned by programing the C7816[ONACK] bit.
 *
 * Values:
 * - 0 - No overrun has occurred since the last time the flag was cleared.
 * - 1 - Overrun has occurred or the overrun flag has not been cleared since the
 *     last overrun occured.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_OR field. */
#define UART_RD_S1_OR(base)  ((UART_S1_REG(base) & UART_S1_OR_MASK) >> UART_S1_OR_SHIFT)
#define UART_BRD_S1_OR(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_OR_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * IDLE is set when 10 consecutive logic 1s (if C1[M] = 0), 11 consecutive logic
 * 1s (if C1[M] = 1 and C4[M10] = 0), or 12 consecutive logic 1s (if C1[M] = 1,
 * C4[M10] = 1, and C1[PE] = 1) appear on the receiver input. After the IDLE flag
 * is cleared, a frame must be received (although not necessarily stored in the
 * data buffer, for example if C2[RWU] is set) or a LIN break character must set
 * the S2[LBKDIF] flag before an idle condition can set the IDLE flag. To clear
 * IDLE, read UART status S1 with IDLE set and then read D. Idle detection is not
 * supported when 7816E or EN709 is set/enabled and hence this flag is ignored.
 * When the receiver wakeup bit (RWU) is set and WAKE is cleared, an idle line
 * condition sets the IDLE flag if RWUID is set, else the IDLE flag does not get set.
 *
 * Values:
 * - 0 - Receiver input is either active now or has never become active since
 *     the IDLE flag was last cleared.
 * - 1 - Receiver input has become idle or the flag has not been cleared since
 *     it last asserted.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_IDLE field. */
#define UART_RD_S1_IDLE(base) ((UART_S1_REG(base) & UART_S1_IDLE_MASK) >> UART_S1_IDLE_SHIFT)
#define UART_BRD_S1_IDLE(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_IDLE_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF is set when the number of datawords in the receive buffer is equal to or
 * more than the number indicated by RWFIFO[RXWATER]. A dataword that is in the
 * process of being received is not included in the count. RDRF is prevented from
 * setting while S2[LBKDE] is set. Additionally, when S2[LBKDE] is set,
 * datawords that are received will be stored in the receive buffer but will over-write
 * each other. To clear RDRF, read S1 when RDRF is set and then read the UART data
 * register (D). For more efficient interrupt and DMA operation all data except
 * the final value is to be read from the buffer using D/C3[T8]/ED. The S1 should
 * then be read and the final data value read, resulting in the clearing of the
 * RDRF flag. Even if the RDRF flag is set, data will continue to be received
 * until an overrun condition occurs.
 *
 * Values:
 * - 0 - The number of datawords in the receive buffer is less than the number
 *     indicated by RXWATER.
 * - 1 - The number of datawords in the receive buffer is equal to or greater
 *     than the number indicated by RXWATER at some point in time since this flag
 *     was last cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_RDRF field. */
#define UART_RD_S1_RDRF(base) ((UART_S1_REG(base) & UART_S1_RDRF_MASK) >> UART_S1_RDRF_SHIFT)
#define UART_BRD_S1_RDRF(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_RDRF_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is cleared when there is a transmission in progress or when a preamble or
 * break character is loaded. TC is set when the transmit buffer is empty and no
 * data, preamble, or break character is being transmitted. When TC is set, the
 * transmit data output signal becomes idle (logic 1). When 7816E is set/enabled
 * this bit is set after any NACK signal has been received but prior to any
 * corresponding guard times expiring. When EN709 is set/enabled this flag is not set
 * on transmit packet completion. TC is cleared by reading S1 with TC set and then
 * doing one of the following: Writing to the UART data register (D) to transmit
 * new data Queuing a preamble by clearing and then setting the C2[TE] bit.
 * Queuing a break character by writing 1 to SBK in C2
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TC field. */
#define UART_RD_S1_TC(base)  ((UART_S1_REG(base) & UART_S1_TC_MASK) >> UART_S1_TC_SHIFT)
#define UART_BRD_S1_TC(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_TC_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE will set when the number of datawords in the transmit buffer (D and
 * C3[T8])is equal to or less than the number indicated by TWFIFO[TXWATER]. A
 * character that is in the process of being transmitted is not included in the count.
 * To clear TDRE, read S1 when TDRE is set and then write to the UART data
 * register (D). For more efficient interrupt servicing all data except the final value
 * to be written to the buffer should written to D/C3[T8]. Then S1 can be read
 * before writing the final data value, resulting in the clearing of the TRDE flag.
 * This is more efficient since the TDRE will reassert until the watermark has
 * been exceeded so attempting to clear the TDRE every write will be ineffective
 * until sufficient data has been written.
 *
 * Values:
 * - 0 - The amount of data in the transmit buffer is greater than the value
 *     indicated by TWFIFO[TXWATER].
 * - 1 - The amount of data in the transmit buffer is less than or equal to the
 *     value indicated by TWFIFO[TXWATER] at some point in time since the flag
 *     has been cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TDRE field. */
#define UART_RD_S1_TDRE(base) ((UART_S1_REG(base) & UART_S1_TDRE_MASK) >> UART_S1_TDRE_SHIFT)
#define UART_BRD_S1_TDRE(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_TDRE_SHIFT))
/*@}*/

/*******************************************************************************
 * UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The S2 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. Also, this register can be polled by the MCU to check the
 * status of these bits. This register can be read or written at any time, with the
 * exception of the MSBF and RXINV bits which should only be changed by the user
 * between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define UART_RD_S2(base)         (UART_S2_REG(base))
#define UART_WR_S2(base, value)  (UART_S2_REG(base) = (value))
#define UART_RMW_S2(base, mask, value) (UART_WR_S2(base, (UART_RD_S2(base) & ~(mask)) | (value)))
#define UART_SET_S2(base, value) (UART_WR_S2(base, UART_RD_S2(base) |  (value)))
#define UART_CLR_S2(base, value) (UART_WR_S2(base, UART_RD_S2(base) & ~(value)))
#define UART_TOG_S2(base, value) (UART_WR_S2(base, UART_RD_S2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects a logic 0 during the RT1 time
 * period of the start bit search. RAF is cleared when the receiver detects an idle
 * character when C7816[ISO7816E] is cleared/disabled. When C7816[ISO7816E] is
 * enabled the RAF is cleared if the C7816[TTYPE] = 0 expires or the C7816[TTYPE] = 1
 * expires. In the case when C7816[ISO7816E] is set and C7816[TTYPE] = 0, it is
 * possible to configure the guard time to be 12. However, in the event that a
 * NACK is required to be transmitted the data transfer actually takes 13 ETU with
 * the 13th ETU slot being a inactive buffer. Hence in this situation the RAF may
 * deassert one ETU prior to actually being inactive.
 *
 * Values:
 * - 0 - UART receiver idle/inactive waiting for a start bit.
 * - 1 - UART receiver active (RxD input not idle).
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RAF field. */
#define UART_RD_S2_RAF(base) ((UART_S2_REG(base) & UART_S2_RAF_MASK) >> UART_S2_RAF_SHIFT)
#define UART_BRD_S2_RAF(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RAF_SHIFT))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDE[1] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * the S1[RDRF], S1[NF], S1[FE], and S1[PF] flags are prevented from setting.
 * When LBKDE is set, see Overrun operation. The LBKDE bit must be cleared when
 * C7816[ISO7816E] is set.
 *
 * Values:
 * - 0 - Break character is detected at length of 10 bit times (C1[M] = 0), 11
 *     (C1[M] = 1 and C4[M10] = 0), or 12 (C1[M] = 1, C4[M10] = 1, and S1[PE] = 1).
 * - 1 - Break character is detected at length of 11 bits times (if C1[M] = 0 or
 *     12 bits time (if C1[M] = 1).
 */
/*@{*/
/*! @brief Read current value of the UART_S2_LBKDE field. */
#define UART_RD_S2_LBKDE(base) ((UART_S2_REG(base) & UART_S2_LBKDE_MASK) >> UART_S2_LBKDE_SHIFT)
#define UART_BRD_S2_LBKDE(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_LBKDE_SHIFT))

/*! @brief Set the LBKDE field to a new value. */
#define UART_WR_S2_LBKDE(base, value) (UART_RMW_S2(base, UART_S2_LBKDE_MASK, UART_S2_LBKDE(value)))
#define UART_BWR_S2_LBKDE(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_LBKDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * This bit determines whether the transmit break character is 10, 11, or 12
 * bits long, or 13 or 14 bits long. Refer to Transmitting break characters for the
 * length of the break character for the different configurations. The detection
 * of a framing error is not affected by this bit.
 *
 * Values:
 * - 0 - Break character is 10, 11, or 12 bits long.
 * - 1 - Break character is 13 or 14 bits long.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_BRK13 field. */
#define UART_RD_S2_BRK13(base) ((UART_S2_REG(base) & UART_S2_BRK13_MASK) >> UART_S2_BRK13_SHIFT)
#define UART_BRD_S2_BRK13(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_BRK13_SHIFT))

/*! @brief Set the BRK13 field to a new value. */
#define UART_WR_S2_BRK13(base, value) (UART_RMW_S2(base, UART_S2_BRK13_MASK, UART_S2_BRK13(value)))
#define UART_BWR_S2_BRK13(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_BRK13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * When RWU is set and WAKE is cleared, this bit controls whether the idle
 * character that wakes the receiver sets the S1[IDLE] bit.This bit must be cleared
 * when C7816[ISO7816E] is set/enabled.
 *
 * Values:
 * - 0 - The S1[IDLE] bit is not set upon detection of an idle character.
 * - 1 - The S1[IDLE] bit is set upon detection of an idle character.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RWUID field. */
#define UART_RD_S2_RWUID(base) ((UART_S2_REG(base) & UART_S2_RWUID_MASK) >> UART_S2_RWUID_SHIFT)
#define UART_BRD_S2_RWUID(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RWUID_SHIFT))

/*! @brief Set the RWUID field to a new value. */
#define UART_WR_S2_RWUID(base, value) (UART_RMW_S2(base, UART_S2_RWUID_MASK, UART_S2_RWUID(value)))
#define UART_BWR_S2_RWUID(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RWUID_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this bit, reverses the polarity of the received data input. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space for
 * normal polarity, and the opposite for inverted polarity. In IrDA format, a
 * zero is represented by short high pulse in the middle of a bit time remaining
 * idle low for a one for normal polarity, and a zero is represented by short low
 * pulse in the middle of a bit time remaining idle high for a one for inverted
 * polarity. This bit is automatically set or cleared when C7816[INIT] and
 * C7816[ISO7816E] are enabled and an initial character is detected. In EN709 mode, this
 * bit affects the polarity of bits the same as it does in normal mode. Setting
 * RXINV inverts the RxD input for: data bits, start and stop bits, break, and
 * idle. When C7816[ISO7816E] is set/enabled then only the data bits and the parity
 * bit are inverted.
 *
 * Values:
 * - 0 - Receive data is not inverted.
 * - 1 - Receive data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXINV field. */
#define UART_RD_S2_RXINV(base) ((UART_S2_REG(base) & UART_S2_RXINV_MASK) >> UART_S2_RXINV_SHIFT)
#define UART_BRD_S2_RXINV(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RXINV_SHIFT))

/*! @brief Set the RXINV field to a new value. */
#define UART_WR_S2_RXINV(base, value) (UART_RMW_S2(base, UART_S2_RXINV_MASK, UART_S2_RXINV(value)))
#define UART_BWR_S2_RXINV(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RXINV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field MSBF[5] (RW)
 *
 * Setting this bit reverses the order of the bits that are transmitted and
 * received on the wire. This bit does not affect the polarity of the bits, the
 * location of the parity bit or the location of the start or stop bits.This bit is
 * automatically set or cleared when C7816[INIT] and C7816[ISO7816E] are enabled
 * and an initial character is detected. In EN709 mode, this bit affects the order
 * of bits the same way as it does in normal mode.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit8, bit7 or bit6) is the first bit that is transmitted following
 *     the start bit depending on the setting of C1[M] and C1[PE]. Further, the
 *     first bit received after the start bit is identified as bit8, bit7 or bit6
 *     depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
/*! @brief Read current value of the UART_S2_MSBF field. */
#define UART_RD_S2_MSBF(base) ((UART_S2_REG(base) & UART_S2_MSBF_MASK) >> UART_S2_MSBF_SHIFT)
#define UART_BRD_S2_MSBF(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_MSBF_SHIFT))

/*! @brief Set the MSBF field to a new value. */
#define UART_WR_S2_MSBF(base, value) (UART_RMW_S2(base, UART_S2_MSBF_MASK, UART_S2_MSBF(value)))
#define UART_BWR_S2_MSBF(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_MSBF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (RW)
 *
 * RXEDGIF is set when an active edge (falling if RXINV = 0, rising if RXINV=1)
 * on the RxD pin occurs. RXEDGIF is cleared by writing a 1 to it. See RXEDGIF
 * description for additional details. The active edge is only detected when in two
 * wire mode and on receive data coming from the RxD pin.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define UART_RD_S2_RXEDGIF(base) ((UART_S2_REG(base) & UART_S2_RXEDGIF_MASK) >> UART_S2_RXEDGIF_SHIFT)
#define UART_BRD_S2_RXEDGIF(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RXEDGIF_SHIFT))

/*! @brief Set the RXEDGIF field to a new value. */
#define UART_WR_S2_RXEDGIF(base, value) (UART_RMW_S2(base, UART_S2_RXEDGIF_MASK, UART_S2_RXEDGIF(value)))
#define UART_BWR_S2_RXEDGIF(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RXEDGIF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDIF[7] (RW)
 *
 * LBKDIF is set when LBKDE is set and a LIN break character is detected, when
 * 11 consecutive logic 0s (if C1[M] = 0) or 12 consecutive logic 0s (if C1[M] =
 * 1) appear on the receiver input. LBKDIF is set right after receiving the last
 * LIN break character bit. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No LIN break character has been detected.
 * - 1 - LIN break character has been detected.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_LBKDIF field. */
#define UART_RD_S2_LBKDIF(base) ((UART_S2_REG(base) & UART_S2_LBKDIF_MASK) >> UART_S2_LBKDIF_SHIFT)
#define UART_BRD_S2_LBKDIF(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_LBKDIF_SHIFT))

/*! @brief Set the LBKDIF field to a new value. */
#define UART_WR_S2_LBKDIF(base, value) (UART_RMW_S2(base, UART_S2_LBKDIF_MASK, UART_S2_LBKDIF(value)))
#define UART_BWR_S2_LBKDIF(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_LBKDIF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Writing to R8 bit does not have any effect. The TXDIR and TXINV bits can only
 * be changed between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define UART_RD_C3(base)         (UART_C3_REG(base))
#define UART_WR_C3(base, value)  (UART_C3_REG(base) = (value))
#define UART_RMW_C3(base, mask, value) (UART_WR_C3(base, (UART_RD_C3(base) & ~(mask)) | (value)))
#define UART_SET_C3(base, value) (UART_WR_C3(base, UART_RD_C3(base) |  (value)))
#define UART_CLR_C3(base, value) (UART_WR_C3(base, UART_RD_C3(base) & ~(value)))
#define UART_TOG_C3(base, value) (UART_WR_C3(base, UART_RD_C3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * This bit enables the parity error flag (S1[PF]) to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - PF interrupt requests are disabled.
 * - 1 - PF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_PEIE field. */
#define UART_RD_C3_PEIE(base) ((UART_C3_REG(base) & UART_C3_PEIE_MASK) >> UART_C3_PEIE_SHIFT)
#define UART_BRD_C3_PEIE(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_PEIE_SHIFT))

/*! @brief Set the PEIE field to a new value. */
#define UART_WR_C3_PEIE(base, value) (UART_RMW_C3(base, UART_C3_PEIE_MASK, UART_C3_PEIE(value)))
#define UART_BWR_C3_PEIE(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_PEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * This bit enables the framing error flag (S1[FE]) to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - FE interrupt requests are disabled.
 * - 1 - FE interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_FEIE field. */
#define UART_RD_C3_FEIE(base) ((UART_C3_REG(base) & UART_C3_FEIE_MASK) >> UART_C3_FEIE_SHIFT)
#define UART_BRD_C3_FEIE(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define UART_WR_C3_FEIE(base, value) (UART_RMW_C3(base, UART_C3_FEIE_MASK, UART_C3_FEIE(value)))
#define UART_BWR_C3_FEIE(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * This bit enables the noise flag (S1[NF]) to generate interrupt requests.
 *
 * Values:
 * - 0 - NF interrupt requests are disabled.
 * - 1 - NF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_NEIE field. */
#define UART_RD_C3_NEIE(base) ((UART_C3_REG(base) & UART_C3_NEIE_MASK) >> UART_C3_NEIE_SHIFT)
#define UART_BRD_C3_NEIE(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_NEIE_SHIFT))

/*! @brief Set the NEIE field to a new value. */
#define UART_WR_C3_NEIE(base, value) (UART_RMW_C3(base, UART_C3_NEIE_MASK, UART_C3_NEIE(value)))
#define UART_BWR_C3_NEIE(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_NEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * This bit enables the overrun error flag (S1[OR]) to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - OR interrupts are disabled.
 * - 1 - OR interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_ORIE field. */
#define UART_RD_C3_ORIE(base) ((UART_C3_REG(base) & UART_C3_ORIE_MASK) >> UART_C3_ORIE_SHIFT)
#define UART_BRD_C3_ORIE(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_ORIE_SHIFT))

/*! @brief Set the ORIE field to a new value. */
#define UART_WR_C3_ORIE(base, value) (UART_RMW_C3(base, UART_C3_ORIE_MASK, UART_C3_ORIE(value)))
#define UART_BWR_C3_ORIE(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_ORIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space
 * for normal polarity, and the opposite for inverted polarity. In IrDA format, a
 * zero is represented by short high pulse in the middle of a bit time remaining
 * idle low for a one for normal polarity, and a zero is represented by short low
 * pulse in the middle of a bit time remaining idle high for a one for inverted
 * polarity. This bit is automatically set or cleared when C7816[INIT] and
 * C7816[ISO7816E] are enabled and an initial character is detected. Setting TXINV
 * inverts all transmitted values, including idle, break, start, and stop bits. In
 * loop mode, if TXINV is set, the receiver gets the transmit inversion bit when
 * RXINV is disabled.When C7816[ISO7816E] is set/enabled then only the transmitted
 * data bits and parity bit are inverted.
 *
 * Values:
 * - 0 - Transmit data is not inverted.
 * - 1 - Transmit data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXINV field. */
#define UART_RD_C3_TXINV(base) ((UART_C3_REG(base) & UART_C3_TXINV_MASK) >> UART_C3_TXINV_SHIFT)
#define UART_BRD_C3_TXINV(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_TXINV_SHIFT))

/*! @brief Set the TXINV field to a new value. */
#define UART_WR_C3_TXINV(base, value) (UART_RMW_C3(base, UART_C3_TXINV_MASK, UART_C3_TXINV(value)))
#define UART_BWR_C3_TXINV(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_TXINV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * This bit determines whether the TXD pin is used as an input or output in the
 * single-wire mode of operation. This bit is relevant only to the single-wire
 * mode. When C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 1, this bit is
 * automatically cleared after the requested block has been transmitted. This
 * condition is detected when TL7816[TLEN] = 0 and 4 additional characters have been
 * transmitted. Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0
 * and a NACK is being transmitted, the hardware will automatically override
 * this bit as needed. In this situation TXDIR will not reflect the temporary state
 * associated with the NACK.
 *
 * Values:
 * - 0 - TXD pin is an input in single-wire mode.
 * - 1 - TXD pin is an output in single-wire mode.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXDIR field. */
#define UART_RD_C3_TXDIR(base) ((UART_C3_REG(base) & UART_C3_TXDIR_MASK) >> UART_C3_TXDIR_SHIFT)
#define UART_BRD_C3_TXDIR(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_TXDIR_SHIFT))

/*! @brief Set the TXDIR field to a new value. */
#define UART_WR_C3_TXDIR(base, value) (UART_RMW_C3(base, UART_C3_TXDIR_MASK, UART_C3_TXDIR(value)))
#define UART_BWR_C3_TXDIR(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_TXDIR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * T8 is the ninth data bit transmitted when the UART is configured for 9-bit
 * data format (C1[M] = 1) or (C4[M10] = 1). If the value of T8 is the same as in
 * the previous transmission, T8 does not have to be rewritten. The same value is
 * transmitted until T8 is rewritten.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_T8 field. */
#define UART_RD_C3_T8(base)  ((UART_C3_REG(base) & UART_C3_T8_MASK) >> UART_C3_T8_SHIFT)
#define UART_BRD_C3_T8(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_T8_SHIFT))

/*! @brief Set the T8 field to a new value. */
#define UART_WR_C3_T8(base, value) (UART_RMW_C3(base, UART_C3_T8_MASK, UART_C3_T8(value)))
#define UART_BWR_C3_T8(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_T8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * R8 is the ninth data bit received when the UART is configured for 9-bit data
 * format (C1[M] = 1) or (C4[M10] = 1).
 */
/*@{*/
/*! @brief Read current value of the UART_C3_R8 field. */
#define UART_RD_C3_R8(base)  ((UART_C3_REG(base) & UART_C3_R8_MASK) >> UART_C3_R8_SHIFT)
#define UART_BRD_C3_R8(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_R8_SHIFT))
/*@}*/

/*******************************************************************************
 * UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data register and writes go to the write-only transmit
 * data register. In 8-bit or 9-bit data format, only UART data register (D)
 * needs to be accessed in order to clear the S1[RDRF] bit (assuming receiver buffer
 * level is less than RWFIFO[RXWATER]). The C3 register only needs to be read
 * (prior to the D register) if the ninth bit of data needs to be captured.
 * Likewise the ED register only needs to be read (prior to the D register) if the
 * additional flag data for the dataword needs to be captured. In the normal 8-bit
 * mode (M bit cleared) if the parity is enabled, you get seven data bits and one
 * parity bit. That one parity bit will be loaded into the D register. So if you
 * care about only the data bits, you have to mask off the parity bit from the
 * value you read out of this register. When transmitting in 9-bit data format and
 * using 8-bit write instructions, write first to transmit bit 8 in UART control
 * register 3 (C3[T8]), then D. A write to C3[T8] stores the data in a temporary
 * register. If D register is written first then the new data on data bus is stored
 * in D register, while the temporary value (written by last write to C3[T8])
 * gets stored in C3[T8] register.
 */
/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define UART_RD_D(base)          (UART_D_REG(base))
#define UART_WR_D(base, value)   (UART_D_REG(base) = (value))
#define UART_RMW_D(base, mask, value) (UART_WR_D(base, (UART_RD_D(base) & ~(mask)) | (value)))
#define UART_SET_D(base, value)  (UART_WR_D(base, UART_RD_D(base) |  (value)))
#define UART_CLR_D(base, value)  (UART_WR_D(base, UART_RD_D(base) & ~(value)))
#define UART_TOG_D(base, value)  (UART_WR_D(base, UART_RD_D(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief UART_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match fails,
 * the following data is discarded. These registers can be read and written at
 * anytime.
 */
/*!
 * @name Constants and macros for entire UART_MA1 register
 */
/*@{*/
#define UART_RD_MA1(base)        (UART_MA1_REG(base))
#define UART_WR_MA1(base, value) (UART_MA1_REG(base) = (value))
#define UART_RMW_MA1(base, mask, value) (UART_WR_MA1(base, (UART_RD_MA1(base) & ~(mask)) | (value)))
#define UART_SET_MA1(base, value) (UART_WR_MA1(base, UART_RD_MA1(base) |  (value)))
#define UART_CLR_MA1(base, value) (UART_WR_MA1(base, UART_RD_MA1(base) & ~(value)))
#define UART_TOG_MA1(base, value) (UART_WR_MA1(base, UART_RD_MA1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief UART_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * These registers can be read and written at anytime. The MA1 and MA2 registers
 * are compared to input data addresses when the most significant bit is set and
 * the associated C4[MAEN] bit is set. If a match occurs, the following data is
 * transferred to the data register. If a match fails, the following data is
 * discarded.
 */
/*!
 * @name Constants and macros for entire UART_MA2 register
 */
/*@{*/
#define UART_RD_MA2(base)        (UART_MA2_REG(base))
#define UART_WR_MA2(base, value) (UART_MA2_REG(base) = (value))
#define UART_RMW_MA2(base, mask, value) (UART_WR_MA2(base, (UART_RD_MA2(base) & ~(mask)) | (value)))
#define UART_SET_MA2(base, value) (UART_WR_MA2(base, UART_RD_MA2(base) |  (value)))
#define UART_CLR_MA2(base, value) (UART_WR_MA2(base, UART_RD_MA2(base) & ~(value)))
#define UART_TOG_MA2(base, value) (UART_WR_MA2(base, UART_RD_MA2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define UART_RD_C4(base)         (UART_C4_REG(base))
#define UART_WR_C4(base, value)  (UART_C4_REG(base) = (value))
#define UART_RMW_C4(base, mask, value) (UART_WR_C4(base, (UART_RD_C4(base) & ~(mask)) | (value)))
#define UART_SET_C4(base, value) (UART_WR_C4(base, UART_RD_C4(base) |  (value)))
#define UART_CLR_C4(base, value) (UART_WR_C4(base, UART_RD_C4(base) & ~(value)))
#define UART_TOG_C4(base, value) (UART_WR_C4(base, UART_RD_C4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field BRFA[4:0] (RW)
 *
 * This bit field is used to add more timing resolution to the average baud
 * frequency, in increments of 1/32. Refer to Baud rate generation for more
 * information.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_BRFA field. */
#define UART_RD_C4_BRFA(base) ((UART_C4_REG(base) & UART_C4_BRFA_MASK) >> UART_C4_BRFA_SHIFT)
#define UART_BRD_C4_BRFA(base) (UART_RD_C4_BRFA(base))

/*! @brief Set the BRFA field to a new value. */
#define UART_WR_C4_BRFA(base, value) (UART_RMW_C4(base, UART_C4_BRFA_MASK, UART_C4_BRFA(value)))
#define UART_BWR_C4_BRFA(base, value) (UART_WR_C4_BRFA(base, value))
/*@}*/

/*!
 * @name Register UART_C4, field M10[5] (RW)
 *
 * The M10 bit causes a tenth, non-memory mapped bit to be part of the serial
 * transmission. This tenth bit is generated and interpreted as a parity bit. The
 * M10 bit does not affect the LIN send or detect break behavior. If M10 is set
 * then both C1[M] and C1[PE] bits must also be set. This bit must be cleared when
 * C7816[ISO7816E] is set/enabled. Refer to Data format (non ISO-7816) for more
 * information.
 *
 * Values:
 * - 0 - The parity bit is the ninth bit in the serial transmission.
 * - 1 - The parity bit is the tenth bit in the serial transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_M10 field. */
#define UART_RD_C4_M10(base) ((UART_C4_REG(base) & UART_C4_M10_MASK) >> UART_C4_M10_SHIFT)
#define UART_BRD_C4_M10(base) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_M10_SHIFT))

/*! @brief Set the M10 field to a new value. */
#define UART_WR_C4_M10(base, value) (UART_RMW_C4(base, UART_C4_M10_MASK, UART_C4_M10(value)))
#define UART_BWR_C4_M10(base, value) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_M10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN2[6] (RW)
 *
 * Refer to Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN1 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer.This bit must be cleared
 *     when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN2 field. */
#define UART_RD_C4_MAEN2(base) ((UART_C4_REG(base) & UART_C4_MAEN2_MASK) >> UART_C4_MAEN2_SHIFT)
#define UART_BRD_C4_MAEN2(base) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_MAEN2_SHIFT))

/*! @brief Set the MAEN2 field to a new value. */
#define UART_WR_C4_MAEN2(base, value) (UART_RMW_C4(base, UART_C4_MAEN2_MASK, UART_C4_MAEN2(value)))
#define UART_BWR_C4_MAEN2(base, value) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_MAEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN1[7] (RW)
 *
 * Refer to Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN2 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer.This bit must be cleared
 *     when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN1 field. */
#define UART_RD_C4_MAEN1(base) ((UART_C4_REG(base) & UART_C4_MAEN1_MASK) >> UART_C4_MAEN1_SHIFT)
#define UART_BRD_C4_MAEN1(base) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_MAEN1_SHIFT))

/*! @brief Set the MAEN1 field to a new value. */
#define UART_WR_C4_MAEN1(base, value) (UART_RMW_C4(base, UART_C4_MAEN1_MASK, UART_C4_MAEN1(value)))
#define UART_BWR_C4_MAEN1(base, value) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_MAEN1_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief UART_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C5 register
 */
/*@{*/
#define UART_RD_C5(base)         (UART_C5_REG(base))
#define UART_WR_C5(base, value)  (UART_C5_REG(base) = (value))
#define UART_RMW_C5(base, mask, value) (UART_WR_C5(base, (UART_RD_C5(base) & ~(mask)) | (value)))
#define UART_SET_C5(base, value) (UART_WR_C5(base, UART_RD_C5(base) |  (value)))
#define UART_CLR_C5(base, value) (UART_WR_C5(base, UART_RD_C5(base) & ~(value)))
#define UART_TOG_C5(base, value) (UART_WR_C5(base, UART_RD_C5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C5 bitfields
 */

/*!
 * @name Register UART_C5, field RDMAS[5] (RW)
 *
 * RDMAS configures the receiver data register full flag, S1[RDRF], to generate
 * interrupt or DMA requests if C2[RIE] is set. If C2[RIE] is cleared, the RDRF
 * DMA and RDFR interrupt request signals are not asserted when the S1[RDRF] flag
 * is set, regardless of the state of RDMAS.
 *
 * Values:
 * - 0 - If C2[RIE] is set and the S1[RDRF] flag is set, the RDFR interrupt
 *     request signal is asserted to request interrupt service.
 * - 1 - If C2[RIE] is set and the S1[RDRF] flag is set, the RDRF DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_RDMAS field. */
#define UART_RD_C5_RDMAS(base) ((UART_C5_REG(base) & UART_C5_RDMAS_MASK) >> UART_C5_RDMAS_SHIFT)
#define UART_BRD_C5_RDMAS(base) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_RDMAS_SHIFT))

/*! @brief Set the RDMAS field to a new value. */
#define UART_WR_C5_RDMAS(base, value) (UART_RMW_C5(base, UART_C5_RDMAS_MASK, UART_C5_RDMAS(value)))
#define UART_BWR_C5_RDMAS(base, value) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_RDMAS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C5, field TDMAS[7] (RW)
 *
 * TDMAS configures the transmit data register empty flag, S1[TDRE], to generate
 * interrupt or DMA requests if C2[TIE] is set. If C2[TIE] is cleared, TDRE DMA
 * and TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If C2[TIE] and TDMAS are both set, then
 * C2[TCIE] must be cleared, and D register must not be written outside of servicing
 * of a DMA request.
 *
 * Values:
 * - 0 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt
 *     request signal is asserted to request interrupt service.
 * - 1 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_TDMAS field. */
#define UART_RD_C5_TDMAS(base) ((UART_C5_REG(base) & UART_C5_TDMAS_MASK) >> UART_C5_TDMAS_SHIFT)
#define UART_BRD_C5_TDMAS(base) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_TDMAS_SHIFT))

/*! @brief Set the TDMAS field to a new value. */
#define UART_WR_C5_TDMAS(base, value) (UART_RMW_C5(base, UART_C5_TDMAS_MASK, UART_C5_TDMAS(value)))
#define UART_BWR_C5_TDMAS(base, value) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_TDMAS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_ED - UART Extended Data Register
 ******************************************************************************/

/*!
 * @brief UART_ED - UART Extended Data Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register contains additional information flags that are stored with a
 * received dataword. This register may be read at any time but only contains valid
 * data if there is a dataword in the receive FIFO. The data contained in this
 * register represents additional information regarding the conditions on which a
 * dataword was received. The importance of this data varies with application,
 * and in some cases maybe completely optional. These fields automatically update
 * to reflect the conditions of the next dataword whenever D is read. If the
 * S1[NF] and S1[PF] flags have not been set since the last time the receive buffer
 * was empty, the NOISY and PARITYE bits will be zero.
 */
/*!
 * @name Constants and macros for entire UART_ED register
 */
/*@{*/
#define UART_RD_ED(base)         (UART_ED_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_ED bitfields
 */

/*!
 * @name Register UART_ED, field PARITYE[6] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with a
 * parity error.
 *
 * Values:
 * - 0 - The dataword was received without a parity error.
 * - 1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_PARITYE field. */
#define UART_RD_ED_PARITYE(base) ((UART_ED_REG(base) & UART_ED_PARITYE_MASK) >> UART_ED_PARITYE_SHIFT)
#define UART_BRD_ED_PARITYE(base) (BITBAND_ACCESS8(&UART_ED_REG(base), UART_ED_PARITYE_SHIFT))
/*@}*/

/*!
 * @name Register UART_ED, field NOISY[7] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with
 * noise.
 *
 * Values:
 * - 0 - The dataword was received without noise.
 * - 1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_NOISY field. */
#define UART_RD_ED_NOISY(base) ((UART_ED_REG(base) & UART_ED_NOISY_MASK) >> UART_ED_NOISY_SHIFT)
#define UART_BRD_ED_NOISY(base) (BITBAND_ACCESS8(&UART_ED_REG(base), UART_ED_NOISY_SHIFT))
/*@}*/

/*******************************************************************************
 * UART_MODEM - UART Modem Register
 ******************************************************************************/

/*!
 * @brief UART_MODEM - UART Modem Register (RW)
 *
 * Reset value: 0x00U
 *
 * The MODEM register controls options for setting the modem configuration.
 * RXRTSE, TXRTSPOL, TXRTSE and TXCTSE must all be cleared when C7816[ISO7816EN] is
 * enabled. This will cause the RTS to deassert during ISO-7816 wait times. The
 * ISO-7816 protocol does not make use of the RTS and CTS signals.
 */
/*!
 * @name Constants and macros for entire UART_MODEM register
 */
/*@{*/
#define UART_RD_MODEM(base)      (UART_MODEM_REG(base))
#define UART_WR_MODEM(base, value) (UART_MODEM_REG(base) = (value))
#define UART_RMW_MODEM(base, mask, value) (UART_WR_MODEM(base, (UART_RD_MODEM(base) & ~(mask)) | (value)))
#define UART_SET_MODEM(base, value) (UART_WR_MODEM(base, UART_RD_MODEM(base) |  (value)))
#define UART_CLR_MODEM(base, value) (UART_WR_MODEM(base, UART_RD_MODEM(base) & ~(value)))
#define UART_TOG_MODEM(base, value) (UART_WR_MODEM(base, UART_RD_MODEM(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_MODEM bitfields
 */

/*!
 * @name Register UART_MODEM, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0 - CTS has no effect on the transmitter.
 * - 1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as a
 *     character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXCTSE field. */
#define UART_RD_MODEM_TXCTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXCTSE_MASK) >> UART_MODEM_TXCTSE_SHIFT)
#define UART_BRD_MODEM_TXCTSE(base) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXCTSE_SHIFT))

/*! @brief Set the TXCTSE field to a new value. */
#define UART_WR_MODEM_TXCTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXCTSE_MASK, UART_MODEM_TXCTSE(value)))
#define UART_BWR_MODEM_TXCTSE(base, value) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXCTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0 - The transmitter has no effect on RTS.
 * - 1 - When a character is placed into an empty transmitter data buffer(FIFO),
 *     RTS asserts one bit time before the start bit is transmitted. RTS
 *     deasserts one bit time after all characters in the transmitter data buffer(FIFO)
 *     and shift register are completely sent, including the last stop bit.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSE field. */
#define UART_RD_MODEM_TXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSE_MASK) >> UART_MODEM_TXRTSE_SHIFT)
#define UART_BRD_MODEM_TXRTSE(base) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXRTSE_SHIFT))

/*! @brief Set the TXRTSE field to a new value. */
#define UART_WR_MODEM_TXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSE_MASK, UART_MODEM_TXRTSE(value)))
#define UART_BWR_MODEM_TXRTSE(base, value) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXRTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0 - Transmitter RTS is active low.
 * - 1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSPOL field. */
#define UART_RD_MODEM_TXRTSPOL(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSPOL_MASK) >> UART_MODEM_TXRTSPOL_SHIFT)
#define UART_BRD_MODEM_TXRTSPOL(base) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXRTSPOL_SHIFT))

/*! @brief Set the TXRTSPOL field to a new value. */
#define UART_WR_MODEM_TXRTSPOL(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSPOL_MASK, UART_MODEM_TXRTSPOL(value)))
#define UART_BWR_MODEM_TXRTSPOL(base, value) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXRTSPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_MODEM, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0 - The receiver has no effect on RTS.
 * - 1 - RTS is deasserted if the number of characters in the receiver data
 *     register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted
 *     when the number of characters in the receiver data register (FIFO) is less
 *     than RWFIFO[RXWATER].
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_RXRTSE field. */
#define UART_RD_MODEM_RXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_RXRTSE_MASK) >> UART_MODEM_RXRTSE_SHIFT)
#define UART_BRD_MODEM_RXRTSE(base) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_RXRTSE_SHIFT))

/*! @brief Set the RXRTSE field to a new value. */
#define UART_WR_MODEM_RXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_RXRTSE_MASK, UART_MODEM_RXRTSE(value)))
#define UART_BWR_MODEM_RXRTSE(base, value) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_RXRTSE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_IR - UART Infrared Register
 ******************************************************************************/

/*!
 * @brief UART_IR - UART Infrared Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IR register controls options for setting the infrared configuration.
 */
/*!
 * @name Constants and macros for entire UART_IR register
 */
/*@{*/
#define UART_RD_IR(base)         (UART_IR_REG(base))
#define UART_WR_IR(base, value)  (UART_IR_REG(base) = (value))
#define UART_RMW_IR(base, mask, value) (UART_WR_IR(base, (UART_RD_IR(base) & ~(mask)) | (value)))
#define UART_SET_IR(base, value) (UART_WR_IR(base, UART_RD_IR(base) |  (value)))
#define UART_CLR_IR(base, value) (UART_WR_IR(base, UART_RD_IR(base) & ~(value)))
#define UART_TOG_IR(base, value) (UART_WR_IR(base, UART_RD_IR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_IR bitfields
 */

/*!
 * @name Register UART_IR, field TNP[1:0] (RW)
 *
 * These bits enable whether the UART transmits a 1/16, 3/16, 1/32 or 1/4 narrow
 * pulse.
 *
 * Values:
 * - 00 - 3/16.
 * - 01 - 1/16.
 * - 10 - 1/32.
 * - 11 - 1/4.
 */
/*@{*/
/*! @brief Read current value of the UART_IR_TNP field. */
#define UART_RD_IR_TNP(base) ((UART_IR_REG(base) & UART_IR_TNP_MASK) >> UART_IR_TNP_SHIFT)
#define UART_BRD_IR_TNP(base) (UART_RD_IR_TNP(base))

/*! @brief Set the TNP field to a new value. */
#define UART_WR_IR_TNP(base, value) (UART_RMW_IR(base, UART_IR_TNP_MASK, UART_IR_TNP(value)))
#define UART_BWR_IR_TNP(base, value) (UART_WR_IR_TNP(base, value))
/*@}*/

/*!
 * @name Register UART_IR, field IREN[2] (RW)
 *
 * This bit enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0 - IR disabled.
 * - 1 - IR enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IR_IREN field. */
#define UART_RD_IR_IREN(base) ((UART_IR_REG(base) & UART_IR_IREN_MASK) >> UART_IR_IREN_SHIFT)
#define UART_BRD_IR_IREN(base) (BITBAND_ACCESS8(&UART_IR_REG(base), UART_IR_IREN_SHIFT))

/*! @brief Set the IREN field to a new value. */
#define UART_WR_IR_IREN(base, value) (UART_RMW_IR(base, UART_IR_IREN_MASK, UART_IR_IREN(value)))
#define UART_BWR_IR_IREN(base, value) (BITBAND_ACCESS8(&UART_IR_REG(base), UART_IR_IREN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_PFIFO - UART FIFO Parameters
 ******************************************************************************/

/*!
 * @brief UART_PFIFO - UART FIFO Parameters (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability for the programmer to turn on and off FIFO
 * functionality. It also provides the size of the FIFO that has been
 * implemented. This register may be read at any time. This register should only be written
 * when the C2[RE] and C2[TE] bits are cleared / not set and when the data
 * buffer/FIFO is empty.
 */
/*!
 * @name Constants and macros for entire UART_PFIFO register
 */
/*@{*/
#define UART_RD_PFIFO(base)      (UART_PFIFO_REG(base))
#define UART_WR_PFIFO(base, value) (UART_PFIFO_REG(base) = (value))
#define UART_RMW_PFIFO(base, mask, value) (UART_WR_PFIFO(base, (UART_RD_PFIFO(base) & ~(mask)) | (value)))
#define UART_SET_PFIFO(base, value) (UART_WR_PFIFO(base, UART_RD_PFIFO(base) |  (value)))
#define UART_CLR_PFIFO(base, value) (UART_WR_PFIFO(base, UART_RD_PFIFO(base) & ~(value)))
#define UART_TOG_PFIFO(base, value) (UART_WR_PFIFO(base, UART_RD_PFIFO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_PFIFO bitfields
 */

/*!
 * @name Register UART_PFIFO, field RXFIFOSIZE[2:0] (RO)
 *
 * The maximum number of receive datawords that can be stored in the receive
 * buffer before an overrun occurs. This field is read only.
 *
 * Values:
 * - 000 - Receive FIFO/Buffer Depth = 1 Dataword.
 * - 001 - Receive FIFO/Buffer Depth = 4 Datawords.
 * - 010 - Receive FIFO/Buffer Depth = 8 Datawords.
 * - 011 - Receive FIFO/Buffer Depth = 16 Datawords.
 * - 100 - Receive FIFO/Buffer Depth = 32 Datawords.
 * - 101 - Receive FIFO/Buffer Depth = 64 Datawords.
 * - 110 - Receive FIFO/Buffer Depth = 128 Datawords.
 * - 111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFIFOSIZE field. */
#define UART_RD_PFIFO_RXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFIFOSIZE_MASK) >> UART_PFIFO_RXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_RXFIFOSIZE(base) (UART_RD_PFIFO_RXFIFOSIZE(base))
/*@}*/

/*!
 * @name Register UART_PFIFO, field RXFE[3] (RW)
 *
 * When this bit is set the built in FIFO structure for the receive buffer is
 * enabled. The size of the FIFO structure is indicated by the RXFIFOSIZE field. If
 * this bit is not set then the receive buffer operates as a FIFO of depth one
 * dataword regardless of the value in RXFIFOSIZE. Both C2[TE] and C2[RE] must be
 * cleared prior to changing this bit. Additionally TXFLUSH and RXFLUSH commands
 * should be issued immediately after changing this bit.
 *
 * Values:
 * - 0 - Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
 * - 1 - Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFE field. */
#define UART_RD_PFIFO_RXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFE_MASK) >> UART_PFIFO_RXFE_SHIFT)
#define UART_BRD_PFIFO_RXFE(base) (BITBAND_ACCESS8(&UART_PFIFO_REG(base), UART_PFIFO_RXFE_SHIFT))

/*! @brief Set the RXFE field to a new value. */
#define UART_WR_PFIFO_RXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_RXFE_MASK, UART_PFIFO_RXFE(value)))
#define UART_BWR_PFIFO_RXFE(base, value) (BITBAND_ACCESS8(&UART_PFIFO_REG(base), UART_PFIFO_RXFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFIFOSIZE[6:4] (RO)
 *
 * The maximum number of transmit datawords that can be stored in the transmit
 * buffer. This field is read only.
 *
 * Values:
 * - 000 - Transmit FIFO/Buffer Depth = 1 Dataword.
 * - 001 - Transmit FIFO/Buffer Depth = 4 Datawords.
 * - 010 - Transmit FIFO/Buffer Depth = 8 Datawords.
 * - 011 - Transmit FIFO/Buffer Depth = 16 Datawords.
 * - 100 - Transmit FIFO/Buffer Depth = 32 Datawords.
 * - 101 - Transmit FIFO/Buffer Depth = 64 Datawords.
 * - 110 - Transmit FIFO/Buffer Depth = 128 Datawords.
 * - 111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFIFOSIZE field. */
#define UART_RD_PFIFO_TXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFIFOSIZE_MASK) >> UART_PFIFO_TXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_TXFIFOSIZE(base) (UART_RD_PFIFO_TXFIFOSIZE(base))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFE[7] (RW)
 *
 * When this bit is set the built in FIFO structure for the transmit buffer is
 * enabled. The size of the FIFO structure is indicated by the TXFIFOSIZE field.
 * If this bit is not set then the transmit buffer operates as a FIFO of depth one
 * dataword regardless of the value in TXFIFOSIZE. Both C2[TE] and C2[RE] must
 * be cleared prior to changing this bit. Additionally TXFLUSH and RXFLUSH
 * commands should be issued immediately after changing this bit.
 *
 * Values:
 * - 0 - Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
 * - 1 - Transmit FIFO is enabled. Buffer is depth indicted by TXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFE field. */
#define UART_RD_PFIFO_TXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFE_MASK) >> UART_PFIFO_TXFE_SHIFT)
#define UART_BRD_PFIFO_TXFE(base) (BITBAND_ACCESS8(&UART_PFIFO_REG(base), UART_PFIFO_TXFE_SHIFT))

/*! @brief Set the TXFE field to a new value. */
#define UART_WR_PFIFO_TXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_TXFE_MASK, UART_PFIFO_TXFE(value)))
#define UART_BWR_PFIFO_TXFE(base, value) (BITBAND_ACCESS8(&UART_PFIFO_REG(base), UART_PFIFO_TXFE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_CFIFO - UART FIFO Control Register
 ******************************************************************************/

/*!
 * @brief UART_CFIFO - UART FIFO Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to program various control bits for FIFO
 * operation. This register may be read or written at any time. Note that writing
 * the TXFLUSH and RXFLUSH bits may result in data loss and requires careful
 * action to prevent unintended / unpredictable behavior, hence it is recommended
 * that TE and RE be cleared prior to flushing the corresponding FIFO.
 */
/*!
 * @name Constants and macros for entire UART_CFIFO register
 */
/*@{*/
#define UART_RD_CFIFO(base)      (UART_CFIFO_REG(base))
#define UART_WR_CFIFO(base, value) (UART_CFIFO_REG(base) = (value))
#define UART_RMW_CFIFO(base, mask, value) (UART_WR_CFIFO(base, (UART_RD_CFIFO(base) & ~(mask)) | (value)))
#define UART_SET_CFIFO(base, value) (UART_WR_CFIFO(base, UART_RD_CFIFO(base) |  (value)))
#define UART_CLR_CFIFO(base, value) (UART_WR_CFIFO(base, UART_RD_CFIFO(base) & ~(value)))
#define UART_TOG_CFIFO(base, value) (UART_WR_CFIFO(base, UART_RD_CFIFO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_CFIFO bitfields
 */

/*!
 * @name Register UART_CFIFO, field RXUFE[0] (RW)
 *
 * When this bit is set the RXUF flag will generate an interrupt to the host.
 *
 * Values:
 * - 0 - RXUF flag does not generate an interrupt to the host.
 * - 1 - RXUF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_RXUFE field. */
#define UART_RD_CFIFO_RXUFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_RXUFE_MASK) >> UART_CFIFO_RXUFE_SHIFT)
#define UART_BRD_CFIFO_RXUFE(base) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_RXUFE_SHIFT))

/*! @brief Set the RXUFE field to a new value. */
#define UART_WR_CFIFO_RXUFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXUFE_MASK, UART_CFIFO_RXUFE(value)))
#define UART_BWR_CFIFO_RXUFE(base, value) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_RXUFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXOFE[1] (RW)
 *
 * When this bit is set the TXOF flag will generate an interrupt to the host.
 *
 * Values:
 * - 0 - TXOF flag does not generate an interrupt to the host.
 * - 1 - TXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_TXOFE field. */
#define UART_RD_CFIFO_TXOFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_TXOFE_MASK) >> UART_CFIFO_TXOFE_SHIFT)
#define UART_BRD_CFIFO_TXOFE(base) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_TXOFE_SHIFT))

/*! @brief Set the TXOFE field to a new value. */
#define UART_WR_CFIFO_TXOFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXOFE_MASK, UART_CFIFO_TXOFE(value)))
#define UART_BWR_CFIFO_TXOFE(base, value) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_TXOFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXFLUSH[6] (WORZ)
 *
 * Writing to this bit causes all data that is stored in the receive FIFO/buffer
 * to be flushed. This does not affect data that is in the receive shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the receive FIFO/buffer is cleared out.
 */
/*@{*/
/*! @brief Set the RXFLUSH field to a new value. */
#define UART_WR_CFIFO_RXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXFLUSH_MASK, UART_CFIFO_RXFLUSH(value)))
#define UART_BWR_CFIFO_RXFLUSH(base, value) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_RXFLUSH_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXFLUSH[7] (WORZ)
 *
 * Writing to this bit causes all data that is stored in the transmit
 * FIFO/buffer to be flushed. This does not affect data that is in the transmit shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the transmit FIFO/Buffer is cleared out.
 */
/*@{*/
/*! @brief Set the TXFLUSH field to a new value. */
#define UART_WR_CFIFO_TXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXFLUSH_MASK, UART_CFIFO_TXFLUSH(value)))
#define UART_BWR_CFIFO_TXFLUSH(base, value) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_TXFLUSH_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_SFIFO - UART FIFO Status Register
 ******************************************************************************/

/*!
 * @brief UART_SFIFO - UART FIFO Status Register (RW)
 *
 * Reset value: 0xC0U
 *
 * This register provides various status information regarding the transmit and
 * receiver buffers/FIFOs, including interrupt information. This register may be
 * written or read at anytime.
 */
/*!
 * @name Constants and macros for entire UART_SFIFO register
 */
/*@{*/
#define UART_RD_SFIFO(base)      (UART_SFIFO_REG(base))
#define UART_WR_SFIFO(base, value) (UART_SFIFO_REG(base) = (value))
#define UART_RMW_SFIFO(base, mask, value) (UART_WR_SFIFO(base, (UART_RD_SFIFO(base) & ~(mask)) | (value)))
#define UART_SET_SFIFO(base, value) (UART_WR_SFIFO(base, UART_RD_SFIFO(base) |  (value)))
#define UART_CLR_SFIFO(base, value) (UART_WR_SFIFO(base, UART_RD_SFIFO(base) & ~(value)))
#define UART_TOG_SFIFO(base, value) (UART_WR_SFIFO(base, UART_RD_SFIFO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_SFIFO bitfields
 */

/*!
 * @name Register UART_SFIFO, field RXUF[0] (RW)
 *
 * This flag indicates that more data has been read from the receive buffer than
 * was present. This bit will assert regardless of the value of CFIFO[RXUFE].
 * However, an interrupt will only be issued to the host if the CFIFO[RXUFE] bit is
 * set. This flag is cleared by writing a "1".
 *
 * Values:
 * - 0 - No receive buffer underflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one receive buffer underflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXUF field. */
#define UART_RD_SFIFO_RXUF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXUF_MASK) >> UART_SFIFO_RXUF_SHIFT)
#define UART_BRD_SFIFO_RXUF(base) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_RXUF_SHIFT))

/*! @brief Set the RXUF field to a new value. */
#define UART_WR_SFIFO_RXUF(base, value) (UART_RMW_SFIFO(base, UART_SFIFO_RXUF_MASK, UART_SFIFO_RXUF(value)))
#define UART_BWR_SFIFO_RXUF(base, value) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_RXUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXOF[1] (RW)
 *
 * This flag indicates that more data has been written to the transmit buffer
 * than it can hold. This bit will assert regardless of the value of CFIFO[TXOFE].
 * However, an interrupt will only be issued to the host if the CFIFO[TXOFE] bit
 * is set. This flag is cleared by writing a "1".
 *
 * Values:
 * - 0 - No transmit buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one transmit buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXOF field. */
#define UART_RD_SFIFO_TXOF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXOF_MASK) >> UART_SFIFO_TXOF_SHIFT)
#define UART_BRD_SFIFO_TXOF(base) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_TXOF_SHIFT))

/*! @brief Set the TXOF field to a new value. */
#define UART_WR_SFIFO_TXOF(base, value) (UART_RMW_SFIFO(base, UART_SFIFO_TXOF_MASK, UART_SFIFO_TXOF(value)))
#define UART_BWR_SFIFO_TXOF(base, value) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_TXOF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXEMPT[6] (RO)
 *
 * This status bit asserts when there is no data in the receive FIFO/Buffer.
 * This bit does not take into account data that is in the receive shift register.
 *
 * Values:
 * - 0 - Receive buffer is not empty.
 * - 1 - Receive buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXEMPT field. */
#define UART_RD_SFIFO_RXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXEMPT_MASK) >> UART_SFIFO_RXEMPT_SHIFT)
#define UART_BRD_SFIFO_RXEMPT(base) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_RXEMPT_SHIFT))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXEMPT[7] (RO)
 *
 * This status bit asserts when there is no data in the Transmit FIFO/buffer.
 * This bit does not take into account data that is in the transmit shift register.
 *
 * Values:
 * - 0 - Transmit buffer is not empty.
 * - 1 - Transmit buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXEMPT field. */
#define UART_RD_SFIFO_TXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXEMPT_MASK) >> UART_SFIFO_TXEMPT_SHIFT)
#define UART_BRD_SFIFO_TXEMPT(base) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_TXEMPT_SHIFT))
/*@}*/

/*******************************************************************************
 * UART_TWFIFO - UART FIFO Transmit Watermark
 ******************************************************************************/

/*!
 * @brief UART_TWFIFO - UART FIFO Transmit Watermark (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing additional transmit data. This register may be read at any
 * time but should only be written when C2[TE] is not set. Changing the value of
 * the watermark will not clear the S1[TDRE] flag.
 */
/*!
 * @name Constants and macros for entire UART_TWFIFO register
 */
/*@{*/
#define UART_RD_TWFIFO(base)     (UART_TWFIFO_REG(base))
#define UART_WR_TWFIFO(base, value) (UART_TWFIFO_REG(base) = (value))
#define UART_RMW_TWFIFO(base, mask, value) (UART_WR_TWFIFO(base, (UART_RD_TWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_TWFIFO(base, value) (UART_WR_TWFIFO(base, UART_RD_TWFIFO(base) |  (value)))
#define UART_CLR_TWFIFO(base, value) (UART_WR_TWFIFO(base, UART_RD_TWFIFO(base) & ~(value)))
#define UART_TOG_TWFIFO(base, value) (UART_WR_TWFIFO(base, UART_RD_TWFIFO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_TCFIFO - UART FIFO Transmit Count
 ******************************************************************************/

/*!
 * @brief UART_TCFIFO - UART FIFO Transmit Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the transmit buffer/FIFO. It may be read at anytime.
 */
/*!
 * @name Constants and macros for entire UART_TCFIFO register
 */
/*@{*/
#define UART_RD_TCFIFO(base)     (UART_TCFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * UART_RWFIFO - UART FIFO Receive Watermark
 ******************************************************************************/

/*!
 * @brief UART_RWFIFO - UART FIFO Receive Watermark (RW)
 *
 * Reset value: 0x01U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing to remove data from the receiver buffer/FIFO. This register
 * may be read at any time but should only be written when C2[RE] is not
 * asserted. Changing the value in this register will not clear the S1[RDRF] flag.
 */
/*!
 * @name Constants and macros for entire UART_RWFIFO register
 */
/*@{*/
#define UART_RD_RWFIFO(base)     (UART_RWFIFO_REG(base))
#define UART_WR_RWFIFO(base, value) (UART_RWFIFO_REG(base) = (value))
#define UART_RMW_RWFIFO(base, mask, value) (UART_WR_RWFIFO(base, (UART_RD_RWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_RWFIFO(base, value) (UART_WR_RWFIFO(base, UART_RD_RWFIFO(base) |  (value)))
#define UART_CLR_RWFIFO(base, value) (UART_WR_RWFIFO(base, UART_RD_RWFIFO(base) & ~(value)))
#define UART_TOG_RWFIFO(base, value) (UART_WR_RWFIFO(base, UART_RD_RWFIFO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_RCFIFO - UART FIFO Receive Count
 ******************************************************************************/

/*!
 * @brief UART_RCFIFO - UART FIFO Receive Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the receive buffer/FIFO. It may be read at anytime.
 */
/*!
 * @name Constants and macros for entire UART_RCFIFO register
 */
/*@{*/
#define UART_RD_RCFIFO(base)     (UART_RCFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * UART_C7816 - UART 7816 Control Register
 ******************************************************************************/

/*!
 * @brief UART_C7816 - UART 7816 Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The C7816 register is the primary control register for ISO-7816 specific
 * functionality. This register is specific to 7816 functionality and the values in
 * this register have no effect on UART operation and should be ignored if
 * ISO_7816E is not set/enabled. This register may be read at anytime but values should
 * only be changed when the ISO_7816E bit is not set.
 */
/*!
 * @name Constants and macros for entire UART_C7816 register
 */
/*@{*/
#define UART_RD_C7816(base)      (UART_C7816_REG(base))
#define UART_WR_C7816(base, value) (UART_C7816_REG(base) = (value))
#define UART_RMW_C7816(base, mask, value) (UART_WR_C7816(base, (UART_RD_C7816(base) & ~(mask)) | (value)))
#define UART_SET_C7816(base, value) (UART_WR_C7816(base, UART_RD_C7816(base) |  (value)))
#define UART_CLR_C7816(base, value) (UART_WR_C7816(base, UART_RD_C7816(base) & ~(value)))
#define UART_TOG_C7816(base, value) (UART_WR_C7816(base, UART_RD_C7816(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C7816 bitfields
 */

/*!
 * @name Register UART_C7816, field ISO_7816E[0] (RW)
 *
 * This bit indicates that the UART is operating according to the ISO-7816
 * protocol. This bit should only be modified when no transmit or receive is
 * occurring. If this bit is changed during a data transfer the data being transmitted or
 * received may be transferred incorrectly.
 *
 * Values:
 * - 0 - ISO-7816 functionality is turned off / not enabled.
 * - 1 - ISO-7816 functionality is turned on / enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ISO_7816E field. */
#define UART_RD_C7816_ISO_7816E(base) ((UART_C7816_REG(base) & UART_C7816_ISO_7816E_MASK) >> UART_C7816_ISO_7816E_SHIFT)
#define UART_BRD_C7816_ISO_7816E(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ISO_7816E_SHIFT))

/*! @brief Set the ISO_7816E field to a new value. */
#define UART_WR_C7816_ISO_7816E(base, value) (UART_RMW_C7816(base, UART_C7816_ISO_7816E_MASK, UART_C7816_ISO_7816E(value)))
#define UART_BWR_C7816_ISO_7816E(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ISO_7816E_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C7816, field TTYPE[1] (RW)
 *
 * This bit indicates the transfer protocol being used. Refer to ISO-7816 /
 * smartcard support for more details.
 *
 * Values:
 * - 0 - T = 0 Per the ISO-7816 specification.
 * - 1 - T = 1 Per the ISO-7816 specification.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_TTYPE field. */
#define UART_RD_C7816_TTYPE(base) ((UART_C7816_REG(base) & UART_C7816_TTYPE_MASK) >> UART_C7816_TTYPE_SHIFT)
#define UART_BRD_C7816_TTYPE(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_TTYPE_SHIFT))

/*! @brief Set the TTYPE field to a new value. */
#define UART_WR_C7816_TTYPE(base, value) (UART_RMW_C7816(base, UART_C7816_TTYPE_MASK, UART_C7816_TTYPE(value)))
#define UART_BWR_C7816_TTYPE(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_TTYPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C7816, field INIT[2] (RW)
 *
 * When this bit is set, all received characters will be searched for a valid
 * initial character. If an invalid initial character is identified then a NACK
 * will be sent if ANACK is set. All received data is discarded and error flags
 * blocked (S1[NF], S1[OR], S1[FE], S1[PF], IS7816[WT], IS7816[CWT], IS7816[BWT],
 * IS7816[GTV]) until a valid initial character is detected. Upon detection of a
 * valid initial character the configuration values S2[MSBF], C3[TXINV] and
 * S2[RXINV] are automatically updated to reflect the initial character that was
 * received. The actual INIT data value is not stored in the receive buffer.
 * Additionally, upon detection of a valid initial character the IS7816[INITD] flag is set
 * and an interrupt issued as programmed by the IE7816[INITDE] bit. When a valid
 * initial character is detected the INIT bit is automatically cleared.
 *
 * Values:
 * - 0 - Normal operating mode. Receiver does not seek to identify initial
 *     character.
 * - 1 - Receiver searches for initial character.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_INIT field. */
#define UART_RD_C7816_INIT(base) ((UART_C7816_REG(base) & UART_C7816_INIT_MASK) >> UART_C7816_INIT_SHIFT)
#define UART_BRD_C7816_INIT(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_INIT_SHIFT))

/*! @brief Set the INIT field to a new value. */
#define UART_WR_C7816_INIT(base, value) (UART_RMW_C7816(base, UART_C7816_INIT_MASK, UART_C7816_INIT(value)))
#define UART_BWR_C7816_INIT(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_INIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C7816, field ANACK[3] (RW)
 *
 * When this bit is set, the receiver will automatically generate a NACK
 * response if a parity error occurs or if INIT is set and an invalid initial character
 * is detected. A NACK is only generated if TTYPE = 0. If ANACK is set the UART
 * will attempt to retransmit the data indefinitely. To stop retransmission
 * attempts, clear C2[TE] or ISO_7816E and do not set until S1[TC] set C2[TE] again.
 *
 * Values:
 * - 0 - No NACK is automatically generated.
 * - 1 - A NACK is automatically generated if a parity error is detected or if
 *     an invalid initial character is detected.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ANACK field. */
#define UART_RD_C7816_ANACK(base) ((UART_C7816_REG(base) & UART_C7816_ANACK_MASK) >> UART_C7816_ANACK_SHIFT)
#define UART_BRD_C7816_ANACK(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ANACK_SHIFT))

/*! @brief Set the ANACK field to a new value. */
#define UART_WR_C7816_ANACK(base, value) (UART_RMW_C7816(base, UART_C7816_ANACK_MASK, UART_C7816_ANACK(value)))
#define UART_BWR_C7816_ANACK(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ANACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C7816, field ONACK[4] (RW)
 *
 * When this bit is set, the receiver will automatically generate a NACK
 * response if a receive buffer overrun occurs as indicated by the S1[OR] field. In many
 * systems this will result in the transmitter resending the packet that
 * overflowed until the retransmit threshold for that transmitter has been reached. A
 * NACK is only generated if TTYPE=0. This bit operates independently of ANACK. See
 * Overrun NACK considerations.
 *
 * Values:
 * - 0 - The received data does not generate a NACK when the receipt of the data
 *     results in an overflow event.
 * - 1 - If the receiver buffer overflows, a NACK is automatically sent on a
 *     received character.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ONACK field. */
#define UART_RD_C7816_ONACK(base) ((UART_C7816_REG(base) & UART_C7816_ONACK_MASK) >> UART_C7816_ONACK_SHIFT)
#define UART_BRD_C7816_ONACK(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ONACK_SHIFT))

/*! @brief Set the ONACK field to a new value. */
#define UART_WR_C7816_ONACK(base, value) (UART_RMW_C7816(base, UART_C7816_ONACK_MASK, UART_C7816_ONACK(value)))
#define UART_BWR_C7816_ONACK(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ONACK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_IE7816 - UART 7816 Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief UART_IE7816 - UART 7816 Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IE7816 register controls which flags result in an interrupt being issued.
 * This register is specific to 7816 functionality, the corresponding flags that
 * drive the interrupts will not assert when 7816E is not set/enabled. However,
 * these flags may remain set if they asserted while 7816E was set and not
 * subsequently cleared. This register maybe read or written at anytime.
 */
/*!
 * @name Constants and macros for entire UART_IE7816 register
 */
/*@{*/
#define UART_RD_IE7816(base)     (UART_IE7816_REG(base))
#define UART_WR_IE7816(base, value) (UART_IE7816_REG(base) = (value))
#define UART_RMW_IE7816(base, mask, value) (UART_WR_IE7816(base, (UART_RD_IE7816(base) & ~(mask)) | (value)))
#define UART_SET_IE7816(base, value) (UART_WR_IE7816(base, UART_RD_IE7816(base) |  (value)))
#define UART_CLR_IE7816(base, value) (UART_WR_IE7816(base, UART_RD_IE7816(base) & ~(value)))
#define UART_TOG_IE7816(base, value) (UART_WR_IE7816(base, UART_RD_IE7816(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_IE7816 bitfields
 */

/*!
 * @name Register UART_IE7816, field RXTE[0] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[RXT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[RXT] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_RXTE field. */
#define UART_RD_IE7816_RXTE(base) ((UART_IE7816_REG(base) & UART_IE7816_RXTE_MASK) >> UART_IE7816_RXTE_SHIFT)
#define UART_BRD_IE7816_RXTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_RXTE_SHIFT))

/*! @brief Set the RXTE field to a new value. */
#define UART_WR_IE7816_RXTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_RXTE_MASK, UART_IE7816_RXTE(value)))
#define UART_BWR_IE7816_RXTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_RXTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field TXTE[1] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[TXT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[TXT] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_TXTE field. */
#define UART_RD_IE7816_TXTE(base) ((UART_IE7816_REG(base) & UART_IE7816_TXTE_MASK) >> UART_IE7816_TXTE_SHIFT)
#define UART_BRD_IE7816_TXTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_TXTE_SHIFT))

/*! @brief Set the TXTE field to a new value. */
#define UART_WR_IE7816_TXTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_TXTE_MASK, UART_IE7816_TXTE(value)))
#define UART_BWR_IE7816_TXTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_TXTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field GTVE[2] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[GTV] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[GTV] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_GTVE field. */
#define UART_RD_IE7816_GTVE(base) ((UART_IE7816_REG(base) & UART_IE7816_GTVE_MASK) >> UART_IE7816_GTVE_SHIFT)
#define UART_BRD_IE7816_GTVE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_GTVE_SHIFT))

/*! @brief Set the GTVE field to a new value. */
#define UART_WR_IE7816_GTVE(base, value) (UART_RMW_IE7816(base, UART_IE7816_GTVE_MASK, UART_IE7816_GTVE(value)))
#define UART_BWR_IE7816_GTVE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_GTVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field INITDE[4] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[INITD] bit will not result in the
 *     generation of an interrupt.
 * - 1 - The assertion of the IS7816[INITD] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_INITDE field. */
#define UART_RD_IE7816_INITDE(base) ((UART_IE7816_REG(base) & UART_IE7816_INITDE_MASK) >> UART_IE7816_INITDE_SHIFT)
#define UART_BRD_IE7816_INITDE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_INITDE_SHIFT))

/*! @brief Set the INITDE field to a new value. */
#define UART_WR_IE7816_INITDE(base, value) (UART_RMW_IE7816(base, UART_IE7816_INITDE_MASK, UART_IE7816_INITDE(value)))
#define UART_BWR_IE7816_INITDE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_INITDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field BWTE[5] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[BWT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[BWT] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_BWTE field. */
#define UART_RD_IE7816_BWTE(base) ((UART_IE7816_REG(base) & UART_IE7816_BWTE_MASK) >> UART_IE7816_BWTE_SHIFT)
#define UART_BRD_IE7816_BWTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_BWTE_SHIFT))

/*! @brief Set the BWTE field to a new value. */
#define UART_WR_IE7816_BWTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_BWTE_MASK, UART_IE7816_BWTE(value)))
#define UART_BWR_IE7816_BWTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_BWTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field CWTE[6] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[CWT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[CWT] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_CWTE field. */
#define UART_RD_IE7816_CWTE(base) ((UART_IE7816_REG(base) & UART_IE7816_CWTE_MASK) >> UART_IE7816_CWTE_SHIFT)
#define UART_BRD_IE7816_CWTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_CWTE_SHIFT))

/*! @brief Set the CWTE field to a new value. */
#define UART_WR_IE7816_CWTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_CWTE_MASK, UART_IE7816_CWTE(value)))
#define UART_BWR_IE7816_CWTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_CWTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field WTE[7] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[WT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[WT] bit will result in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_WTE field. */
#define UART_RD_IE7816_WTE(base) ((UART_IE7816_REG(base) & UART_IE7816_WTE_MASK) >> UART_IE7816_WTE_SHIFT)
#define UART_BRD_IE7816_WTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_WTE_SHIFT))

/*! @brief Set the WTE field to a new value. */
#define UART_WR_IE7816_WTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_WTE_MASK, UART_IE7816_WTE(value)))
#define UART_BWR_IE7816_WTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_WTE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_IS7816 - UART 7816 Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief UART_IS7816 - UART 7816 Interrupt Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IS7816 register provides a mechanism to read and clear the interrupt
 * flags. All flags/interrupts are cleared by writing a "1" to the bit location.
 * Writing a "0" has no effect. All bits are "sticky", meaning they only indicate
 * that the flag condition occurred since the last time the bit was cleared not that
 * the condition currently exists. The status flags are set regardless of if the
 * corresponding bit in the IC7816 is set or cleared, the IC7816 only controls
 * if a interrupt is issued to the host processor. This register is specific to
 * 7816 functionality and the values in this register have no affect on UART
 * operation and should be ignored if 7816E is not set/enabled. This register may be
 * read or written at anytime.
 */
/*!
 * @name Constants and macros for entire UART_IS7816 register
 */
/*@{*/
#define UART_RD_IS7816(base)     (UART_IS7816_REG(base))
#define UART_WR_IS7816(base, value) (UART_IS7816_REG(base) = (value))
#define UART_RMW_IS7816(base, mask, value) (UART_WR_IS7816(base, (UART_RD_IS7816(base) & ~(mask)) | (value)))
#define UART_SET_IS7816(base, value) (UART_WR_IS7816(base, UART_RD_IS7816(base) |  (value)))
#define UART_CLR_IS7816(base, value) (UART_WR_IS7816(base, UART_RD_IS7816(base) & ~(value)))
#define UART_TOG_IS7816(base, value) (UART_WR_IS7816(base, UART_RD_IS7816(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_IS7816 bitfields
 */

/*!
 * @name Register UART_IS7816, field RXT[0] (RW)
 *
 * This flag indicates that there were more than ET7816[RXTHRESHOLD] consecutive
 * NACKS generated in response to parity errors on received data. This flag
 * requires ANACK to be set. Additionally, this flag only asserts when C7816[TTYPE] =
 * 0. Clearing this bit also resets the counter keeping track of consecutive
 * NACKS. The UART will continue to attempt to receive data regardless of if this
 * flag is set. If 7816E is cleared/disabled, RE is cleared/disabled, C7816[TTYPE]
 * = 1 or packet is received without needing to issue a NACK, the internal NACK
 * detection counter is cleared and the count restarts from zero on the next
 * transmitted NACK. This interrupt is cleared by writing `1'.
 *
 * Values:
 * - 0 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is less than or equal to the value in
 *     ET7816[RXTHRESHOLD].
 * - 1 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_RXT field. */
#define UART_RD_IS7816_RXT(base) ((UART_IS7816_REG(base) & UART_IS7816_RXT_MASK) >> UART_IS7816_RXT_SHIFT)
#define UART_BRD_IS7816_RXT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_RXT_SHIFT))

/*! @brief Set the RXT field to a new value. */
#define UART_WR_IS7816_RXT(base, value) (UART_RMW_IS7816(base, UART_IS7816_RXT_MASK, UART_IS7816_RXT(value)))
#define UART_BWR_IS7816_RXT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_RXT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field TXT[1] (RW)
 *
 * This flag indicates that the transmit NACK threshold has been exceeded as
 * indicated by the ET7816[TXTHRESHOLD] field. Regardless if this flag is set, the
 * UART will continue to retransmit indefinitely. This flag only asserts when
 * C7816[TTYPE] = 0. If 7816E is cleared/disabled, ANACK is cleared/disabled, C2[TE]
 * is cleared/disabled, C7816[TTYPE] = 1 or packet is transferred without
 * receiving a NACK the internal NACK detection counter is cleared and the count
 * restarts from zero on the next received NACK. This interrupt is cleared by writing
 * `1'.
 *
 * Values:
 * - 0 - The number of retries and corresponding NACKS does not exceed the value
 *     in the ET7816[TXTHRESHOLD] field.
 * - 1 - The number of retries and corresponding NACKS exceeds the value in the
 *     ET7816[TXTHRESHOLD] field.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_TXT field. */
#define UART_RD_IS7816_TXT(base) ((UART_IS7816_REG(base) & UART_IS7816_TXT_MASK) >> UART_IS7816_TXT_SHIFT)
#define UART_BRD_IS7816_TXT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_TXT_SHIFT))

/*! @brief Set the TXT field to a new value. */
#define UART_WR_IS7816_TXT(base, value) (UART_RMW_IS7816(base, UART_IS7816_TXT_MASK, UART_IS7816_TXT(value)))
#define UART_BWR_IS7816_TXT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_TXT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field GTV[2] (RW)
 *
 * This flag indicates that one or more of the character guard time, block guard
 * time or guard time were violated. This interrupt is cleared by writing `1'.
 *
 * Values:
 * - 0 - A guard time (GT, CGT or BGT) has not been violated.
 * - 1 - A guard time (GT, CGT or BGT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_GTV field. */
#define UART_RD_IS7816_GTV(base) ((UART_IS7816_REG(base) & UART_IS7816_GTV_MASK) >> UART_IS7816_GTV_SHIFT)
#define UART_BRD_IS7816_GTV(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_GTV_SHIFT))

/*! @brief Set the GTV field to a new value. */
#define UART_WR_IS7816_GTV(base, value) (UART_RMW_IS7816(base, UART_IS7816_GTV_MASK, UART_IS7816_GTV(value)))
#define UART_BWR_IS7816_GTV(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_GTV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field INITD[4] (RW)
 *
 * This flag indicates that a valid initial character was received. This
 * interrupt is cleared by writing `1'.
 *
 * Values:
 * - 0 - A valid initial character has not been received.
 * - 1 - A valid initial character has been received.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_INITD field. */
#define UART_RD_IS7816_INITD(base) ((UART_IS7816_REG(base) & UART_IS7816_INITD_MASK) >> UART_IS7816_INITD_SHIFT)
#define UART_BRD_IS7816_INITD(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_INITD_SHIFT))

/*! @brief Set the INITD field to a new value. */
#define UART_WR_IS7816_INITD(base, value) (UART_RMW_IS7816(base, UART_IS7816_INITD_MASK, UART_IS7816_INITD(value)))
#define UART_BWR_IS7816_INITD(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_INITD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field BWT[5] (RW)
 *
 * This flag indicates that the block wait time, the time between the leading
 * edge of first received character of a block and the leading edge of the last
 * character the previously transmitted block. This flag only asserts when
 * C7816[TTYPE] = 1.This interrupt is cleared by writing '1'.
 *
 * Values:
 * - 0 - Block wait time (BWT) has not been violated.
 * - 1 - Block wait tTime (BWT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_BWT field. */
#define UART_RD_IS7816_BWT(base) ((UART_IS7816_REG(base) & UART_IS7816_BWT_MASK) >> UART_IS7816_BWT_SHIFT)
#define UART_BRD_IS7816_BWT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_BWT_SHIFT))

/*! @brief Set the BWT field to a new value. */
#define UART_WR_IS7816_BWT(base, value) (UART_RMW_IS7816(base, UART_IS7816_BWT_MASK, UART_IS7816_BWT(value)))
#define UART_BWR_IS7816_BWT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_BWT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field CWT[6] (RW)
 *
 * This flag indicates that the character wait time, the time between the
 * leading edges of two consecutive characters in a block has exceed the programed
 * value. This flag only asserts when C7816[TTYPE] = 1. This interrupt is cleared by
 * writing `1'.
 *
 * Values:
 * - 0 - Character wait time (CWT) has not been violated.
 * - 1 - Character wait time (CWT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_CWT field. */
#define UART_RD_IS7816_CWT(base) ((UART_IS7816_REG(base) & UART_IS7816_CWT_MASK) >> UART_IS7816_CWT_SHIFT)
#define UART_BRD_IS7816_CWT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_CWT_SHIFT))

/*! @brief Set the CWT field to a new value. */
#define UART_WR_IS7816_CWT(base, value) (UART_RMW_IS7816(base, UART_IS7816_CWT_MASK, UART_IS7816_CWT(value)))
#define UART_BWR_IS7816_CWT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_CWT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field WT[7] (RW)
 *
 * This flag indicates that the wait time, the time between the leading edge of
 * a character being transmitted and the leading edge of the next response
 * character has exceeded the programed value. This flag only asserts when C7816[TTYPE]
 * = 0. This interrupt is cleared by writing `1'.
 *
 * Values:
 * - 0 - Wait time (WT) has not been violated.
 * - 1 - Wait time (WT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_WT field. */
#define UART_RD_IS7816_WT(base) ((UART_IS7816_REG(base) & UART_IS7816_WT_MASK) >> UART_IS7816_WT_SHIFT)
#define UART_BRD_IS7816_WT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_WT_SHIFT))

/*! @brief Set the WT field to a new value. */
#define UART_WR_IS7816_WT(base, value) (UART_RMW_IS7816(base, UART_IS7816_WT_MASK, UART_IS7816_WT(value)))
#define UART_BWR_IS7816_WT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_WT_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_WP7816T0 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief UART_WP7816T0 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x0AU
 *
 * The WP7816 register contains constants used in the generation of various wait
 * timer counters. To save register space this register is used differently when
 * C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at anytime.
 * This register must only be written when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816T0 register
 */
/*@{*/
#define UART_RD_WP7816T0(base)   (UART_WP7816T0_REG(base))
#define UART_WR_WP7816T0(base, value) (UART_WP7816T0_REG(base) = (value))
#define UART_RMW_WP7816T0(base, mask, value) (UART_WR_WP7816T0(base, (UART_RD_WP7816T0(base) & ~(mask)) | (value)))
#define UART_SET_WP7816T0(base, value) (UART_WR_WP7816T0(base, UART_RD_WP7816T0(base) |  (value)))
#define UART_CLR_WP7816T0(base, value) (UART_WR_WP7816T0(base, UART_RD_WP7816T0(base) & ~(value)))
#define UART_TOG_WP7816T0(base, value) (UART_WR_WP7816T0(base, UART_RD_WP7816T0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816T1 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief UART_WP7816T1 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x0AU
 *
 * The WP7816 register contains constants used in the generation of various wait
 * timer counters. To save register space this register is used differently when
 * C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register maybe read at anytime.
 * This register must only be written when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816T1 register
 */
/*@{*/
#define UART_RD_WP7816T1(base)   (UART_WP7816T1_REG(base))
#define UART_WR_WP7816T1(base, value) (UART_WP7816T1_REG(base) = (value))
#define UART_RMW_WP7816T1(base, mask, value) (UART_WR_WP7816T1(base, (UART_RD_WP7816T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816T1(base, value) (UART_WR_WP7816T1(base, UART_RD_WP7816T1(base) |  (value)))
#define UART_CLR_WP7816T1(base, value) (UART_WR_WP7816T1(base, UART_RD_WP7816T1(base) & ~(value)))
#define UART_TOG_WP7816T1(base, value) (UART_WR_WP7816T1(base, UART_RD_WP7816T1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816T1 bitfields
 */

/*!
 * @name Register UART_WP7816T1, field BWI[3:0] (RW)
 *
 * This value is used to calculate the value used for the BWT counter. It
 * represent a value between 0 and 15. This value is only used when C7816[TTYPE] = 1.
 * See Wait time and guard time parameters.
 */
/*@{*/
/*! @brief Read current value of the UART_WP7816T1_BWI field. */
#define UART_RD_WP7816T1_BWI(base) ((UART_WP7816T1_REG(base) & UART_WP7816T1_BWI_MASK) >> UART_WP7816T1_BWI_SHIFT)
#define UART_BRD_WP7816T1_BWI(base) (UART_RD_WP7816T1_BWI(base))

/*! @brief Set the BWI field to a new value. */
#define UART_WR_WP7816T1_BWI(base, value) (UART_RMW_WP7816T1(base, UART_WP7816T1_BWI_MASK, UART_WP7816T1_BWI(value)))
#define UART_BWR_WP7816T1_BWI(base, value) (UART_WR_WP7816T1_BWI(base, value))
/*@}*/

/*!
 * @name Register UART_WP7816T1, field CWI[7:4] (RW)
 *
 * This value is used to calculate the value used for the CWT counter. It
 * represents a value between 0 and 15. This value is only used when C7816[TTYPE] = 1.
 * See Wait time and guard time parameters.
 */
/*@{*/
/*! @brief Read current value of the UART_WP7816T1_CWI field. */
#define UART_RD_WP7816T1_CWI(base) ((UART_WP7816T1_REG(base) & UART_WP7816T1_CWI_MASK) >> UART_WP7816T1_CWI_SHIFT)
#define UART_BRD_WP7816T1_CWI(base) (UART_RD_WP7816T1_CWI(base))

/*! @brief Set the CWI field to a new value. */
#define UART_WR_WP7816T1_CWI(base, value) (UART_RMW_WP7816T1(base, UART_WP7816T1_CWI_MASK, UART_WP7816T1_CWI(value)))
#define UART_BWR_WP7816T1_CWI(base, value) (UART_WR_WP7816T1_CWI(base, value))
/*@}*/

/*******************************************************************************
 * UART_WN7816 - UART 7816 Wait N Register
 ******************************************************************************/

/*!
 * @brief UART_WN7816 - UART 7816 Wait N Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WN7816 register contains a parameter that is used in the calculation of
 * the guard time counter. This register may be read at anytime. This register
 * must only be written when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WN7816 register
 */
/*@{*/
#define UART_RD_WN7816(base)     (UART_WN7816_REG(base))
#define UART_WR_WN7816(base, value) (UART_WN7816_REG(base) = (value))
#define UART_RMW_WN7816(base, mask, value) (UART_WR_WN7816(base, (UART_RD_WN7816(base) & ~(mask)) | (value)))
#define UART_SET_WN7816(base, value) (UART_WR_WN7816(base, UART_RD_WN7816(base) |  (value)))
#define UART_CLR_WN7816(base, value) (UART_WR_WN7816(base, UART_RD_WN7816(base) & ~(value)))
#define UART_TOG_WN7816(base, value) (UART_WR_WN7816(base, UART_RD_WN7816(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_WF7816 - UART 7816 Wait FD Register
 ******************************************************************************/

/*!
 * @brief UART_WF7816 - UART 7816 Wait FD Register (RW)
 *
 * Reset value: 0x01U
 *
 * The WF7816 contains parameters that are used in the generation of various
 * counters including GT, CGT, BGT, WT and BWT. This register may be read from at
 * anytime. This register must only be written to when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WF7816 register
 */
/*@{*/
#define UART_RD_WF7816(base)     (UART_WF7816_REG(base))
#define UART_WR_WF7816(base, value) (UART_WF7816_REG(base) = (value))
#define UART_RMW_WF7816(base, mask, value) (UART_WR_WF7816(base, (UART_RD_WF7816(base) & ~(mask)) | (value)))
#define UART_SET_WF7816(base, value) (UART_WR_WF7816(base, UART_RD_WF7816(base) |  (value)))
#define UART_CLR_WF7816(base, value) (UART_WR_WF7816(base, UART_RD_WF7816(base) & ~(value)))
#define UART_TOG_WF7816(base, value) (UART_WR_WF7816(base, UART_RD_WF7816(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_ET7816 - UART 7816 Error Threshold Register
 ******************************************************************************/

/*!
 * @brief UART_ET7816 - UART 7816 Error Threshold Register (RW)
 *
 * Reset value: 0x00U
 *
 * The ET7816 register contains fields that determine the number of NACKs that
 * must be received or transmitted before the host processor is notified. This
 * register may be read at anytime. This register must only be written when
 * C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_ET7816 register
 */
/*@{*/
#define UART_RD_ET7816(base)     (UART_ET7816_REG(base))
#define UART_WR_ET7816(base, value) (UART_ET7816_REG(base) = (value))
#define UART_RMW_ET7816(base, mask, value) (UART_WR_ET7816(base, (UART_RD_ET7816(base) & ~(mask)) | (value)))
#define UART_SET_ET7816(base, value) (UART_WR_ET7816(base, UART_RD_ET7816(base) |  (value)))
#define UART_CLR_ET7816(base, value) (UART_WR_ET7816(base, UART_RD_ET7816(base) & ~(value)))
#define UART_TOG_ET7816(base, value) (UART_WR_ET7816(base, UART_RD_ET7816(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_ET7816 bitfields
 */

/*!
 * @name Register UART_ET7816, field RXTHRESHOLD[3:0] (RW)
 *
 * The value written to this field indicates the maximum number of consecutive
 * NACKs generated as a result of a parity error or receiver buffer overruns
 * before the host processor is notified. Once the counter exceeds that value in the
 * field the IS7816[RXT] will be asserted. This field is only meaningful when
 * C7816[TTYPE] = 0. The value read from this field represents the number of
 * consecutive NACKs that have been transmitted since the last successful reception. This
 * counter saturates at 4'hF and does not wrap around. Regardless of the number
 * of NACKs sent, the UART will continue to receive valid packets indefinitely.
 * For additional information see IS7816[RXT] bit description.
 */
/*@{*/
/*! @brief Read current value of the UART_ET7816_RXTHRESHOLD field. */
#define UART_RD_ET7816_RXTHRESHOLD(base) ((UART_ET7816_REG(base) & UART_ET7816_RXTHRESHOLD_MASK) >> UART_ET7816_RXTHRESHOLD_SHIFT)
#define UART_BRD_ET7816_RXTHRESHOLD(base) (UART_RD_ET7816_RXTHRESHOLD(base))

/*! @brief Set the RXTHRESHOLD field to a new value. */
#define UART_WR_ET7816_RXTHRESHOLD(base, value) (UART_RMW_ET7816(base, UART_ET7816_RXTHRESHOLD_MASK, UART_ET7816_RXTHRESHOLD(value)))
#define UART_BWR_ET7816_RXTHRESHOLD(base, value) (UART_WR_ET7816_RXTHRESHOLD(base, value))
/*@}*/

/*!
 * @name Register UART_ET7816, field TXTHRESHOLD[7:4] (RW)
 *
 * The value written to this field indicates the maximum number of failed
 * attempts (NACKs) a transmitted character can have before the host processor is
 * notified. Meaning a value of 0 will always result in TXT asserting on the first
 * NACK that is received. A value of 1 will result in TXT being asserted on the
 * second NACK that is received. This field is only meaningful when C7816[TTYPE] = 0
 * and C7816[ANACK] = 1. The value read from this field represents the number of
 * consecutive NACKs that have been received since the last successful
 * transmission. This counter saturates at 4'hF and does not wrap around. Regardless of how
 * many NACKs that are received, the UART will continue to retransmit
 * indefinitely. This flag only asserts when C7816[TTYPE] = 0. For additional information
 * see the IS7816[TXT] bit description.
 */
/*@{*/
/*! @brief Read current value of the UART_ET7816_TXTHRESHOLD field. */
#define UART_RD_ET7816_TXTHRESHOLD(base) ((UART_ET7816_REG(base) & UART_ET7816_TXTHRESHOLD_MASK) >> UART_ET7816_TXTHRESHOLD_SHIFT)
#define UART_BRD_ET7816_TXTHRESHOLD(base) (UART_RD_ET7816_TXTHRESHOLD(base))

/*! @brief Set the TXTHRESHOLD field to a new value. */
#define UART_WR_ET7816_TXTHRESHOLD(base, value) (UART_RMW_ET7816(base, UART_ET7816_TXTHRESHOLD_MASK, UART_ET7816_TXTHRESHOLD(value)))
#define UART_BWR_ET7816_TXTHRESHOLD(base, value) (UART_WR_ET7816_TXTHRESHOLD(base, value))
/*@}*/

/*******************************************************************************
 * UART_TL7816 - UART 7816 Transmit Length Register
 ******************************************************************************/

/*!
 * @brief UART_TL7816 - UART 7816 Transmit Length Register (RW)
 *
 * Reset value: 0x00U
 *
 * The TL7816 register is used to indicate how many characters are contained in
 * the block being transmitted. This register is only used when C7816[TTYPE] = 1.
 * This register may be read at anytime. This register should only be written
 * when C2[TE] is not enabled.
 */
/*!
 * @name Constants and macros for entire UART_TL7816 register
 */
/*@{*/
#define UART_RD_TL7816(base)     (UART_TL7816_REG(base))
#define UART_WR_TL7816(base, value) (UART_TL7816_REG(base) = (value))
#define UART_RMW_TL7816(base, mask, value) (UART_WR_TL7816(base, (UART_RD_TL7816(base) & ~(mask)) | (value)))
#define UART_SET_TL7816(base, value) (UART_WR_TL7816(base, UART_RD_TL7816(base) |  (value)))
#define UART_CLR_TL7816(base, value) (UART_WR_TL7816(base, UART_RD_TL7816(base) & ~(value)))
#define UART_TOG_TL7816(base, value) (UART_WR_TL7816(base, UART_RD_TL7816(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_C6 - UART CEA709.1-B Control Register 6
 ******************************************************************************/

/*!
 * @brief UART_C6 - UART CEA709.1-B Control Register 6 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C6 register
 */
/*@{*/
#define UART_RD_C6(base)         (UART_C6_REG(base))
#define UART_WR_C6(base, value)  (UART_C6_REG(base) = (value))
#define UART_RMW_C6(base, mask, value) (UART_WR_C6(base, (UART_RD_C6(base) & ~(mask)) | (value)))
#define UART_SET_C6(base, value) (UART_WR_C6(base, UART_RD_C6(base) |  (value)))
#define UART_CLR_C6(base, value) (UART_WR_C6(base, UART_RD_C6(base) & ~(value)))
#define UART_TOG_C6(base, value) (UART_WR_C6(base, UART_RD_C6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C6 bitfields
 */

/*!
 * @name Register UART_C6, field CP[4] (RW)
 *
 * This bit indicates the polarity of collision signal.
 *
 * Values:
 * - 0 - Collision signal is active low.
 * - 1 - Collision signal is active high.
 */
/*@{*/
/*! @brief Read current value of the UART_C6_CP field. */
#define UART_RD_C6_CP(base)  ((UART_C6_REG(base) & UART_C6_CP_MASK) >> UART_C6_CP_SHIFT)
#define UART_BRD_C6_CP(base) (BITBAND_ACCESS8(&UART_C6_REG(base), UART_C6_CP_SHIFT))

/*! @brief Set the CP field to a new value. */
#define UART_WR_C6_CP(base, value) (UART_RMW_C6(base, UART_C6_CP_MASK, UART_C6_CP(value)))
#define UART_BWR_C6_CP(base, value) (BITBAND_ACCESS8(&UART_C6_REG(base), UART_C6_CP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C6, field CE[5] (RW)
 *
 * This bit enables the collision detect functionality.
 *
 * Values:
 * - 0 - Collision detect feature is disabled.
 * - 1 - Collision detect feature is enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C6_CE field. */
#define UART_RD_C6_CE(base)  ((UART_C6_REG(base) & UART_C6_CE_MASK) >> UART_C6_CE_SHIFT)
#define UART_BRD_C6_CE(base) (BITBAND_ACCESS8(&UART_C6_REG(base), UART_C6_CE_SHIFT))

/*! @brief Set the CE field to a new value. */
#define UART_WR_C6_CE(base, value) (UART_RMW_C6(base, UART_C6_CE_MASK, UART_C6_CE(value)))
#define UART_BWR_C6_CE(base, value) (BITBAND_ACCESS8(&UART_C6_REG(base), UART_C6_CE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C6, field TX709[6] (RW)
 *
 * This register is used to start CEA709.1-B transmission.
 *
 * Values:
 * - 0 - CEA709.1-B transmitter is disabled.
 * - 1 - CEA709.1-B transmitter is enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C6_TX709 field. */
#define UART_RD_C6_TX709(base) ((UART_C6_REG(base) & UART_C6_TX709_MASK) >> UART_C6_TX709_SHIFT)
#define UART_BRD_C6_TX709(base) (BITBAND_ACCESS8(&UART_C6_REG(base), UART_C6_TX709_SHIFT))

/*! @brief Set the TX709 field to a new value. */
#define UART_WR_C6_TX709(base, value) (UART_RMW_C6(base, UART_C6_TX709_MASK, UART_C6_TX709(value)))
#define UART_BWR_C6_TX709(base, value) (BITBAND_ACCESS8(&UART_C6_REG(base), UART_C6_TX709_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C6, field EN709[7] (RW)
 *
 * This register is used to enable the CEA709.1-B feature.
 *
 * Values:
 * - 0 - CEA709.1-B is disabled.
 * - 1 - CEA709.1-B is enabled
 */
/*@{*/
/*! @brief Read current value of the UART_C6_EN709 field. */
#define UART_RD_C6_EN709(base) ((UART_C6_REG(base) & UART_C6_EN709_MASK) >> UART_C6_EN709_SHIFT)
#define UART_BRD_C6_EN709(base) (BITBAND_ACCESS8(&UART_C6_REG(base), UART_C6_EN709_SHIFT))

/*! @brief Set the EN709 field to a new value. */
#define UART_WR_C6_EN709(base, value) (UART_RMW_C6(base, UART_C6_EN709_MASK, UART_C6_EN709(value)))
#define UART_BWR_C6_EN709(base, value) (BITBAND_ACCESS8(&UART_C6_REG(base), UART_C6_EN709_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_PCTH - UART CEA709.1-B Packet Cycle Time Counter High
 ******************************************************************************/

/*!
 * @brief UART_PCTH - UART CEA709.1-B Packet Cycle Time Counter High (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_PCTH register
 */
/*@{*/
#define UART_RD_PCTH(base)       (UART_PCTH_REG(base))
#define UART_WR_PCTH(base, value) (UART_PCTH_REG(base) = (value))
#define UART_RMW_PCTH(base, mask, value) (UART_WR_PCTH(base, (UART_RD_PCTH(base) & ~(mask)) | (value)))
#define UART_SET_PCTH(base, value) (UART_WR_PCTH(base, UART_RD_PCTH(base) |  (value)))
#define UART_CLR_PCTH(base, value) (UART_WR_PCTH(base, UART_RD_PCTH(base) & ~(value)))
#define UART_TOG_PCTH(base, value) (UART_WR_PCTH(base, UART_RD_PCTH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_PCTL - UART CEA709.1-B Packet Cycle Time Counter Low
 ******************************************************************************/

/*!
 * @brief UART_PCTL - UART CEA709.1-B Packet Cycle Time Counter Low (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_PCTL register
 */
/*@{*/
#define UART_RD_PCTL(base)       (UART_PCTL_REG(base))
#define UART_WR_PCTL(base, value) (UART_PCTL_REG(base) = (value))
#define UART_RMW_PCTL(base, mask, value) (UART_WR_PCTL(base, (UART_RD_PCTL(base) & ~(mask)) | (value)))
#define UART_SET_PCTL(base, value) (UART_WR_PCTL(base, UART_RD_PCTL(base) |  (value)))
#define UART_CLR_PCTL(base, value) (UART_WR_PCTL(base, UART_RD_PCTL(base) & ~(value)))
#define UART_TOG_PCTL(base, value) (UART_WR_PCTL(base, UART_RD_PCTL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_B1T - UART CEA709.1-B Beta1 Timer
 ******************************************************************************/

/*!
 * @brief UART_B1T - UART CEA709.1-B Beta1 Timer (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_B1T register
 */
/*@{*/
#define UART_RD_B1T(base)        (UART_B1T_REG(base))
#define UART_WR_B1T(base, value) (UART_B1T_REG(base) = (value))
#define UART_RMW_B1T(base, mask, value) (UART_WR_B1T(base, (UART_RD_B1T(base) & ~(mask)) | (value)))
#define UART_SET_B1T(base, value) (UART_WR_B1T(base, UART_RD_B1T(base) |  (value)))
#define UART_CLR_B1T(base, value) (UART_WR_B1T(base, UART_RD_B1T(base) & ~(value)))
#define UART_TOG_B1T(base, value) (UART_WR_B1T(base, UART_RD_B1T(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_SDTH - UART CEA709.1-B Secondary Delay Timer High
 ******************************************************************************/

/*!
 * @brief UART_SDTH - UART CEA709.1-B Secondary Delay Timer High (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_SDTH register
 */
/*@{*/
#define UART_RD_SDTH(base)       (UART_SDTH_REG(base))
#define UART_WR_SDTH(base, value) (UART_SDTH_REG(base) = (value))
#define UART_RMW_SDTH(base, mask, value) (UART_WR_SDTH(base, (UART_RD_SDTH(base) & ~(mask)) | (value)))
#define UART_SET_SDTH(base, value) (UART_WR_SDTH(base, UART_RD_SDTH(base) |  (value)))
#define UART_CLR_SDTH(base, value) (UART_WR_SDTH(base, UART_RD_SDTH(base) & ~(value)))
#define UART_TOG_SDTH(base, value) (UART_WR_SDTH(base, UART_RD_SDTH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_SDTL - UART CEA709.1-B Secondary Delay Timer Low
 ******************************************************************************/

/*!
 * @brief UART_SDTL - UART CEA709.1-B Secondary Delay Timer Low (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_SDTL register
 */
/*@{*/
#define UART_RD_SDTL(base)       (UART_SDTL_REG(base))
#define UART_WR_SDTL(base, value) (UART_SDTL_REG(base) = (value))
#define UART_RMW_SDTL(base, mask, value) (UART_WR_SDTL(base, (UART_RD_SDTL(base) & ~(mask)) | (value)))
#define UART_SET_SDTL(base, value) (UART_WR_SDTL(base, UART_RD_SDTL(base) |  (value)))
#define UART_CLR_SDTL(base, value) (UART_WR_SDTL(base, UART_RD_SDTL(base) & ~(value)))
#define UART_TOG_SDTL(base, value) (UART_WR_SDTL(base, UART_RD_SDTL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_PRE - UART CEA709.1-B Preamble
 ******************************************************************************/

/*!
 * @brief UART_PRE - UART CEA709.1-B Preamble (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_PRE register
 */
/*@{*/
#define UART_RD_PRE(base)        (UART_PRE_REG(base))
#define UART_WR_PRE(base, value) (UART_PRE_REG(base) = (value))
#define UART_RMW_PRE(base, mask, value) (UART_WR_PRE(base, (UART_RD_PRE(base) & ~(mask)) | (value)))
#define UART_SET_PRE(base, value) (UART_WR_PRE(base, UART_RD_PRE(base) |  (value)))
#define UART_CLR_PRE(base, value) (UART_WR_PRE(base, UART_RD_PRE(base) & ~(value)))
#define UART_TOG_PRE(base, value) (UART_WR_PRE(base, UART_RD_PRE(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_TPL - UART CEA709.1-B Transmit Packet Length
 ******************************************************************************/

/*!
 * @brief UART_TPL - UART CEA709.1-B Transmit Packet Length (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_TPL register
 */
/*@{*/
#define UART_RD_TPL(base)        (UART_TPL_REG(base))
#define UART_WR_TPL(base, value) (UART_TPL_REG(base) = (value))
#define UART_RMW_TPL(base, mask, value) (UART_WR_TPL(base, (UART_RD_TPL(base) & ~(mask)) | (value)))
#define UART_SET_TPL(base, value) (UART_WR_TPL(base, UART_RD_TPL(base) |  (value)))
#define UART_CLR_TPL(base, value) (UART_WR_TPL(base, UART_RD_TPL(base) & ~(value)))
#define UART_TOG_TPL(base, value) (UART_WR_TPL(base, UART_RD_TPL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_IE - UART CEA709.1-B Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief UART_IE - UART CEA709.1-B Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_IE register
 */
/*@{*/
#define UART_RD_IE(base)         (UART_IE_REG(base))
#define UART_WR_IE(base, value)  (UART_IE_REG(base) = (value))
#define UART_RMW_IE(base, mask, value) (UART_WR_IE(base, (UART_RD_IE(base) & ~(mask)) | (value)))
#define UART_SET_IE(base, value) (UART_WR_IE(base, UART_RD_IE(base) |  (value)))
#define UART_CLR_IE(base, value) (UART_WR_IE(base, UART_RD_IE(base) & ~(value)))
#define UART_TOG_IE(base, value) (UART_WR_IE(base, UART_RD_IE(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_IE bitfields
 */

/*!
 * @name Register UART_IE, field TXFIE[0] (RW)
 *
 * Interrupt enable for transmission fail flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IE_TXFIE field. */
#define UART_RD_IE_TXFIE(base) ((UART_IE_REG(base) & UART_IE_TXFIE_MASK) >> UART_IE_TXFIE_SHIFT)
#define UART_BRD_IE_TXFIE(base) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_TXFIE_SHIFT))

/*! @brief Set the TXFIE field to a new value. */
#define UART_WR_IE_TXFIE(base, value) (UART_RMW_IE(base, UART_IE_TXFIE_MASK, UART_IE_TXFIE(value)))
#define UART_BWR_IE_TXFIE(base, value) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_TXFIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE, field PSIE[1] (RW)
 *
 * Interrupt enable for preamble start flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IE_PSIE field. */
#define UART_RD_IE_PSIE(base) ((UART_IE_REG(base) & UART_IE_PSIE_MASK) >> UART_IE_PSIE_SHIFT)
#define UART_BRD_IE_PSIE(base) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_PSIE_SHIFT))

/*! @brief Set the PSIE field to a new value. */
#define UART_WR_IE_PSIE(base, value) (UART_RMW_IE(base, UART_IE_PSIE_MASK, UART_IE_PSIE(value)))
#define UART_BWR_IE_PSIE(base, value) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_PSIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE, field PCTEIE[2] (RW)
 *
 * Interrupt enable for packet cycle time expired flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IE_PCTEIE field. */
#define UART_RD_IE_PCTEIE(base) ((UART_IE_REG(base) & UART_IE_PCTEIE_MASK) >> UART_IE_PCTEIE_SHIFT)
#define UART_BRD_IE_PCTEIE(base) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_PCTEIE_SHIFT))

/*! @brief Set the PCTEIE field to a new value. */
#define UART_WR_IE_PCTEIE(base, value) (UART_RMW_IE(base, UART_IE_PCTEIE_MASK, UART_IE_PCTEIE(value)))
#define UART_BWR_IE_PCTEIE(base, value) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_PCTEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE, field PTXIE[3] (RW)
 *
 * Interrupt enable for packet transmitted flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IE_PTXIE field. */
#define UART_RD_IE_PTXIE(base) ((UART_IE_REG(base) & UART_IE_PTXIE_MASK) >> UART_IE_PTXIE_SHIFT)
#define UART_BRD_IE_PTXIE(base) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_PTXIE_SHIFT))

/*! @brief Set the PTXIE field to a new value. */
#define UART_WR_IE_PTXIE(base, value) (UART_RMW_IE(base, UART_IE_PTXIE_MASK, UART_IE_PTXIE(value)))
#define UART_BWR_IE_PTXIE(base, value) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_PTXIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE, field PRXIE[4] (RW)
 *
 * Interrupt enable for packet received flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IE_PRXIE field. */
#define UART_RD_IE_PRXIE(base) ((UART_IE_REG(base) & UART_IE_PRXIE_MASK) >> UART_IE_PRXIE_SHIFT)
#define UART_BRD_IE_PRXIE(base) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_PRXIE_SHIFT))

/*! @brief Set the PRXIE field to a new value. */
#define UART_WR_IE_PRXIE(base, value) (UART_RMW_IE(base, UART_IE_PRXIE_MASK, UART_IE_PRXIE(value)))
#define UART_BWR_IE_PRXIE(base, value) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_PRXIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE, field ISDIE[5] (RW)
 *
 * Interrupt enable for initial synchronization detection flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IE_ISDIE field. */
#define UART_RD_IE_ISDIE(base) ((UART_IE_REG(base) & UART_IE_ISDIE_MASK) >> UART_IE_ISDIE_SHIFT)
#define UART_BRD_IE_ISDIE(base) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_ISDIE_SHIFT))

/*! @brief Set the ISDIE field to a new value. */
#define UART_WR_IE_ISDIE(base, value) (UART_RMW_IE(base, UART_IE_ISDIE_MASK, UART_IE_ISDIE(value)))
#define UART_BWR_IE_ISDIE(base, value) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_ISDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE, field WBEIE[6] (RW)
 *
 * Interrupt enable for Wbase expired flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IE_WBEIE field. */
#define UART_RD_IE_WBEIE(base) ((UART_IE_REG(base) & UART_IE_WBEIE_MASK) >> UART_IE_WBEIE_SHIFT)
#define UART_BRD_IE_WBEIE(base) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_WBEIE_SHIFT))

/*! @brief Set the WBEIE field to a new value. */
#define UART_WR_IE_WBEIE(base, value) (UART_RMW_IE(base, UART_IE_WBEIE_MASK, UART_IE_WBEIE(value)))
#define UART_BWR_IE_WBEIE(base, value) (BITBAND_ACCESS8(&UART_IE_REG(base), UART_IE_WBEIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_WB - UART CEA709.1-B WBASE
 ******************************************************************************/

/*!
 * @brief UART_WB - UART CEA709.1-B WBASE (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_WB register
 */
/*@{*/
#define UART_RD_WB(base)         (UART_WB_REG(base))
#define UART_WR_WB(base, value)  (UART_WB_REG(base) = (value))
#define UART_RMW_WB(base, mask, value) (UART_WR_WB(base, (UART_RD_WB(base) & ~(mask)) | (value)))
#define UART_SET_WB(base, value) (UART_WR_WB(base, UART_RD_WB(base) |  (value)))
#define UART_CLR_WB(base, value) (UART_WR_WB(base, UART_RD_WB(base) & ~(value)))
#define UART_TOG_WB(base, value) (UART_WR_WB(base, UART_RD_WB(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_S3 - UART CEA709.1-B Status Register
 ******************************************************************************/

/*!
 * @brief UART_S3 - UART CEA709.1-B Status Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_S3 register
 */
/*@{*/
#define UART_RD_S3(base)         (UART_S3_REG(base))
#define UART_WR_S3(base, value)  (UART_S3_REG(base) = (value))
#define UART_RMW_S3(base, mask, value) (UART_WR_S3(base, (UART_RD_S3(base) & ~(mask)) | (value)))
#define UART_SET_S3(base, value) (UART_WR_S3(base, UART_RD_S3(base) |  (value)))
#define UART_CLR_S3(base, value) (UART_WR_S3(base, UART_RD_S3(base) & ~(value)))
#define UART_TOG_S3(base, value) (UART_WR_S3(base, UART_RD_S3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_S3 bitfields
 */

/*!
 * @name Register UART_S3, field TXFF[0] (RW)
 *
 * This flag indicates that transmission could not proceed. This flag is
 * asserted when the packet is queued for transmission but before the random delay is
 * expired an incoming receive packet is detected. This flag is also asserted while
 * transmission when the TX fifo becomes empty or overflows. During these cases
 * Line Code Violation is transmitted on TX line immediately after current byte
 * or preamble transmission is finished, without waiting for completion of
 * transmit packet length. If the transmission fail flag is asserted then TX709 bit of
 * UART_C6 register is cleared. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Transmission continues normally.
 * - 1 - Transmission is failed.
 */
/*@{*/
/*! @brief Read current value of the UART_S3_TXFF field. */
#define UART_RD_S3_TXFF(base) ((UART_S3_REG(base) & UART_S3_TXFF_MASK) >> UART_S3_TXFF_SHIFT)
#define UART_BRD_S3_TXFF(base) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_TXFF_SHIFT))

/*! @brief Set the TXFF field to a new value. */
#define UART_WR_S3_TXFF(base, value) (UART_RMW_S3(base, UART_S3_TXFF_MASK, UART_S3_TXFF(value)))
#define UART_BWR_S3_TXFF(base, value) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_TXFF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S3, field PSF[1] (RW)
 *
 * This flag indicates start of preamble while the packet is being transmitted.
 * This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Preamble start is not detected.
 * - 1 - Preamble start is detected.
 */
/*@{*/
/*! @brief Read current value of the UART_S3_PSF field. */
#define UART_RD_S3_PSF(base) ((UART_S3_REG(base) & UART_S3_PSF_MASK) >> UART_S3_PSF_SHIFT)
#define UART_BRD_S3_PSF(base) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PSF_SHIFT))

/*! @brief Set the PSF field to a new value. */
#define UART_WR_S3_PSF(base, value) (UART_RMW_S3(base, UART_S3_PSF_MASK, UART_S3_PSF(value)))
#define UART_BWR_S3_PSF(base, value) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PSF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S3, field PCTEF[2] (RW)
 *
 * This flag indicates that packet cycle time period has been expired with no
 * activity on the line. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Packet Cycle Time is not expired.
 * - 1 - Packet cycle time is expired.
 */
/*@{*/
/*! @brief Read current value of the UART_S3_PCTEF field. */
#define UART_RD_S3_PCTEF(base) ((UART_S3_REG(base) & UART_S3_PCTEF_MASK) >> UART_S3_PCTEF_SHIFT)
#define UART_BRD_S3_PCTEF(base) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PCTEF_SHIFT))

/*! @brief Set the PCTEF field to a new value. */
#define UART_WR_S3_PCTEF(base, value) (UART_RMW_S3(base, UART_S3_PCTEF_MASK, UART_S3_PCTEF(value)))
#define UART_BWR_S3_PCTEF(base, value) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PCTEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S3, field PTXF[3] (RW)
 *
 * This flag indicates that complete packet is transmitted. This flag is cleared
 * by writing `1'. In case TX packet gets aborted due to fifo becoming empty or
 * overflow, packet transmitted flag will still be generated.
 *
 * Values:
 * - 0 - Packet transmission is not complete.
 * - 1 - Packet transmission is complete.
 */
/*@{*/
/*! @brief Read current value of the UART_S3_PTXF field. */
#define UART_RD_S3_PTXF(base) ((UART_S3_REG(base) & UART_S3_PTXF_MASK) >> UART_S3_PTXF_SHIFT)
#define UART_BRD_S3_PTXF(base) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PTXF_SHIFT))

/*! @brief Set the PTXF field to a new value. */
#define UART_WR_S3_PTXF(base, value) (UART_RMW_S3(base, UART_S3_PTXF_MASK, UART_S3_PTXF(value)))
#define UART_BWR_S3_PTXF(base, value) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PTXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S3, field PRXF[4] (RW)
 *
 * This flag indicates that complete packet is received. This flag is cleared by
 * writing `1'.
 *
 * Values:
 * - 0 - Packet is not received.
 * - 1 - Packet is received.
 */
/*@{*/
/*! @brief Read current value of the UART_S3_PRXF field. */
#define UART_RD_S3_PRXF(base) ((UART_S3_REG(base) & UART_S3_PRXF_MASK) >> UART_S3_PRXF_SHIFT)
#define UART_BRD_S3_PRXF(base) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PRXF_SHIFT))

/*! @brief Set the PRXF field to a new value. */
#define UART_WR_S3_PRXF(base, value) (UART_RMW_S3(base, UART_S3_PRXF_MASK, UART_S3_PRXF(value)))
#define UART_BWR_S3_PRXF(base, value) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PRXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S3, field ISD[5] (RO)
 *
 * This flag indicates that initially a valid one and a line code violation is
 * detected. This flag is cleared by deasserting EN709 bit.
 *
 * Values:
 * - 0 - Initial sync is not detected.
 * - 1 - Initial sync is detected.
 */
/*@{*/
/*! @brief Read current value of the UART_S3_ISD field. */
#define UART_RD_S3_ISD(base) ((UART_S3_REG(base) & UART_S3_ISD_MASK) >> UART_S3_ISD_SHIFT)
#define UART_BRD_S3_ISD(base) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_ISD_SHIFT))
/*@}*/

/*!
 * @name Register UART_S3, field WBEF[6] (RW)
 *
 * This flag indicates that Wbase time period has been expired after Beta1 time
 * slots. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Wbase time period is not expired.
 * - 1 - Wbase time period has been expired after beta1 time slots.
 */
/*@{*/
/*! @brief Read current value of the UART_S3_WBEF field. */
#define UART_RD_S3_WBEF(base) ((UART_S3_REG(base) & UART_S3_WBEF_MASK) >> UART_S3_WBEF_SHIFT)
#define UART_BRD_S3_WBEF(base) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_WBEF_SHIFT))

/*! @brief Set the WBEF field to a new value. */
#define UART_WR_S3_WBEF(base, value) (UART_RMW_S3(base, UART_S3_WBEF_MASK, UART_S3_WBEF(value)))
#define UART_BWR_S3_WBEF(base, value) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_WBEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S3, field PEF[7] (RW)
 *
 * This flag indicates that received preamble is in error. If the received
 * preamble length is greater than or less than the transmit preamble length, the
 * preamble error flag is asserted. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Preamble is correct.
 * - 1 - Preamble is in error.
 */
/*@{*/
/*! @brief Read current value of the UART_S3_PEF field. */
#define UART_RD_S3_PEF(base) ((UART_S3_REG(base) & UART_S3_PEF_MASK) >> UART_S3_PEF_SHIFT)
#define UART_BRD_S3_PEF(base) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PEF_SHIFT))

/*! @brief Set the PEF field to a new value. */
#define UART_WR_S3_PEF(base, value) (UART_RMW_S3(base, UART_S3_PEF_MASK, UART_S3_PEF(value)))
#define UART_BWR_S3_PEF(base, value) (BITBAND_ACCESS8(&UART_S3_REG(base), UART_S3_PEF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_S4 - UART CEA709.1-B Status Register
 ******************************************************************************/

/*!
 * @brief UART_S4 - UART CEA709.1-B Status Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_S4 register
 */
/*@{*/
#define UART_RD_S4(base)         (UART_S4_REG(base))
#define UART_WR_S4(base, value)  (UART_S4_REG(base) = (value))
#define UART_RMW_S4(base, mask, value) (UART_WR_S4(base, (UART_RD_S4(base) & ~(mask)) | (value)))
#define UART_SET_S4(base, value) (UART_WR_S4(base, UART_RD_S4(base) |  (value)))
#define UART_CLR_S4(base, value) (UART_WR_S4(base, UART_RD_S4(base) & ~(value)))
#define UART_TOG_S4(base, value) (UART_WR_S4(base, UART_RD_S4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_S4 bitfields
 */

/*!
 * @name Register UART_S4, field FE[0] (RW)
 *
 * This flag indicates that received CEA709.1-B packet is finish at byte
 * boundary. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Received packet is byte bound.
 * - 1 - Received packet is not byte bound.
 */
/*@{*/
/*! @brief Read current value of the UART_S4_FE field. */
#define UART_RD_S4_FE(base)  ((UART_S4_REG(base) & UART_S4_FE_MASK) >> UART_S4_FE_SHIFT)
#define UART_BRD_S4_FE(base) (BITBAND_ACCESS8(&UART_S4_REG(base), UART_S4_FE_SHIFT))

/*! @brief Set the FE field to a new value. */
#define UART_WR_S4_FE(base, value) (UART_RMW_S4(base, UART_S4_FE_MASK, UART_S4_FE(value)))
#define UART_BWR_S4_FE(base, value) (BITBAND_ACCESS8(&UART_S4_REG(base), UART_S4_FE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S4, field ILCV[1] (RW)
 *
 * This flag indicates that Line Code violation received is not proper. This
 * flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Line code violation received is proper.
 * - 1 - Line code violation received is improper i.e less than 3-bit periods.
 */
/*@{*/
/*! @brief Read current value of the UART_S4_ILCV field. */
#define UART_RD_S4_ILCV(base) ((UART_S4_REG(base) & UART_S4_ILCV_MASK) >> UART_S4_ILCV_SHIFT)
#define UART_BRD_S4_ILCV(base) (BITBAND_ACCESS8(&UART_S4_REG(base), UART_S4_ILCV_SHIFT))

/*! @brief Set the ILCV field to a new value. */
#define UART_WR_S4_ILCV(base, value) (UART_RMW_S4(base, UART_S4_ILCV_MASK, UART_S4_ILCV(value)))
#define UART_BWR_S4_ILCV(base, value) (BITBAND_ACCESS8(&UART_S4_REG(base), UART_S4_ILCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S4, field CDET[3:2] (RW)
 *
 * These bits indicates when the collision occurs during Transmission. This flag
 * is cleared by writing 2'b11. If collision flag is not cleared by software and
 * valid collision pulse is detected during some other phase of transmission,
 * then collision flag will continue to indicate the previous value.
 *
 * Values:
 * - 00 - No collision.
 * - 01 - Collision occurred during preamble.
 * - 10 - Collision occurred during data.
 * - 11 - Collision occurred during line code violation.
 */
/*@{*/
/*! @brief Read current value of the UART_S4_CDET field. */
#define UART_RD_S4_CDET(base) ((UART_S4_REG(base) & UART_S4_CDET_MASK) >> UART_S4_CDET_SHIFT)
#define UART_BRD_S4_CDET(base) (UART_RD_S4_CDET(base))

/*! @brief Set the CDET field to a new value. */
#define UART_WR_S4_CDET(base, value) (UART_RMW_S4(base, UART_S4_CDET_MASK, UART_S4_CDET(value)))
#define UART_BWR_S4_CDET(base, value) (UART_WR_S4_CDET(base, value))
/*@}*/

/*!
 * @name Register UART_S4, field INITF[4] (RO)
 *
 * This bit indicates that initial synchronization is failed and the packet
 * cycle time is expired after enabling EN709 register. This flag is cleared if EN709
 * is cleared.
 *
 * Values:
 * - 0 - Initial synchronization is not failed.
 * - 1 - Initial synchronization is failed.
 */
/*@{*/
/*! @brief Read current value of the UART_S4_INITF field. */
#define UART_RD_S4_INITF(base) ((UART_S4_REG(base) & UART_S4_INITF_MASK) >> UART_S4_INITF_SHIFT)
#define UART_BRD_S4_INITF(base) (BITBAND_ACCESS8(&UART_S4_REG(base), UART_S4_INITF_SHIFT))
/*@}*/

/*******************************************************************************
 * UART_RPL - UART CEA709.1-B Received Packet Length
 ******************************************************************************/

/*!
 * @brief UART_RPL - UART CEA709.1-B Received Packet Length (RO)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_RPL register
 */
/*@{*/
#define UART_RD_RPL(base)        (UART_RPL_REG(base))
/*@}*/

/*******************************************************************************
 * UART_RPREL - UART CEA709.1-B Received Preamble Length
 ******************************************************************************/

/*!
 * @brief UART_RPREL - UART CEA709.1-B Received Preamble Length (RO)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_RPREL register
 */
/*@{*/
#define UART_RD_RPREL(base)      (UART_RPREL_REG(base))
/*@}*/

/*******************************************************************************
 * UART_CPW - UART CEA709.1-B Collision Pulse Width
 ******************************************************************************/

/*!
 * @brief UART_CPW - UART CEA709.1-B Collision Pulse Width (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_CPW register
 */
/*@{*/
#define UART_RD_CPW(base)        (UART_CPW_REG(base))
#define UART_WR_CPW(base, value) (UART_CPW_REG(base) = (value))
#define UART_RMW_CPW(base, mask, value) (UART_WR_CPW(base, (UART_RD_CPW(base) & ~(mask)) | (value)))
#define UART_SET_CPW(base, value) (UART_WR_CPW(base, UART_RD_CPW(base) |  (value)))
#define UART_CLR_CPW(base, value) (UART_WR_CPW(base, UART_RD_CPW(base) & ~(value)))
#define UART_TOG_CPW(base, value) (UART_WR_CPW(base, UART_RD_CPW(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_RIDT - UART CEA709.1-B Receive Indeterminate Time
 ******************************************************************************/

/*!
 * @brief UART_RIDT - UART CEA709.1-B Receive Indeterminate Time (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_RIDT register
 */
/*@{*/
#define UART_RD_RIDT(base)       (UART_RIDT_REG(base))
#define UART_WR_RIDT(base, value) (UART_RIDT_REG(base) = (value))
#define UART_RMW_RIDT(base, mask, value) (UART_WR_RIDT(base, (UART_RD_RIDT(base) & ~(mask)) | (value)))
#define UART_SET_RIDT(base, value) (UART_WR_RIDT(base, UART_RD_RIDT(base) |  (value)))
#define UART_CLR_RIDT(base, value) (UART_WR_RIDT(base, UART_RD_RIDT(base) & ~(value)))
#define UART_TOG_RIDT(base, value) (UART_WR_RIDT(base, UART_RD_RIDT(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_TIDT - UART CEA709.1-B Transmit Indeterminate Time
 ******************************************************************************/

/*!
 * @brief UART_TIDT - UART CEA709.1-B Transmit Indeterminate Time (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_TIDT register
 */
/*@{*/
#define UART_RD_TIDT(base)       (UART_TIDT_REG(base))
#define UART_WR_TIDT(base, value) (UART_TIDT_REG(base) = (value))
#define UART_RMW_TIDT(base, mask, value) (UART_WR_TIDT(base, (UART_RD_TIDT(base) & ~(mask)) | (value)))
#define UART_SET_TIDT(base, value) (UART_WR_TIDT(base, UART_RD_TIDT(base) |  (value)))
#define UART_CLR_TIDT(base, value) (UART_WR_TIDT(base, UART_RD_TIDT(base) & ~(value)))
#define UART_TOG_TIDT(base, value) (UART_WR_TIDT(base, UART_RD_TIDT(base) ^  (value)))
/*@}*/

/*
 * MK20D5 USB
 *
 * Universal Serial Bus, OTG Capable Controller
 *
 * Registers defined in this header file:
 * - USB_PERID - Peripheral ID Register
 * - USB_IDCOMP - Peripheral ID Complement Register
 * - USB_REV - Peripheral Revision Register
 * - USB_ADDINFO - Peripheral Additional Info Register
 * - USB_OTGISTAT - OTG Interrupt Status Register
 * - USB_OTGICR - OTG Interrupt Control Register
 * - USB_OTGSTAT - OTG Status Register
 * - USB_OTGCTL - OTG Control Register
 * - USB_ISTAT - Interrupt Status Register
 * - USB_INTEN - Interrupt Enable Register
 * - USB_ERRSTAT - Error Interrupt Status Register
 * - USB_ERREN - Error Interrupt Enable Register
 * - USB_STAT - Status Register
 * - USB_CTL - Control Register
 * - USB_ADDR - Address Register
 * - USB_BDTPAGE1 - BDT Page Register 1
 * - USB_FRMNUML - Frame Number Register Low
 * - USB_FRMNUMH - Frame Number Register High
 * - USB_TOKEN - Token Register
 * - USB_SOFTHLD - SOF Threshold Register
 * - USB_BDTPAGE2 - BDT Page Register 2
 * - USB_BDTPAGE3 - BDT Page Register 3
 * - USB_ENDPT - Endpoint Control Register
 * - USB_USBCTRL - USB Control Register
 * - USB_OBSERVE - USB OTG Observe Register
 * - USB_CONTROL - USB OTG Control Register
 * - USB_USBTRC0 - USB Transceiver Control Register 0
 * - USB_USBFRMADJUST - Frame Adjust Register
 */

#define USB_INSTANCE_COUNT (1U) /*!< Number of instances of the USB module. */
#define USB0_IDX (0U) /*!< Instance number for USB0. */

/*******************************************************************************
 * USB_PERID - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief USB_PERID - Peripheral ID Register (RO)
 *
 * Reset value: 0x04U
 *
 * The Peripheral ID Register reads back the value of 0x04. This value is
 * defined for the USB Peripheral.
 */
/*!
 * @name Constants and macros for entire USB_PERID register
 */
/*@{*/
#define USB_RD_PERID(base)       (USB_PERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_PERID bitfields
 */

/*!
 * @name Register USB_PERID, field ID[5:0] (RO)
 *
 * These bits always read 0x04 (00_0100)
 */
/*@{*/
/*! @brief Read current value of the USB_PERID_ID field. */
#define USB_RD_PERID_ID(base) ((USB_PERID_REG(base) & USB_PERID_ID_MASK) >> USB_PERID_ID_SHIFT)
#define USB_BRD_PERID_ID(base) (USB_RD_PERID_ID(base))
/*@}*/

/*******************************************************************************
 * USB_IDCOMP - Peripheral ID Complement Register
 ******************************************************************************/

/*!
 * @brief USB_IDCOMP - Peripheral ID Complement Register (RO)
 *
 * Reset value: 0xFBU
 *
 * The Peripheral ID Complement Register reads back the complement of the
 * Peripheral ID Register. For the USB Peripheral, this is the value 0xFB.
 */
/*!
 * @name Constants and macros for entire USB_IDCOMP register
 */
/*@{*/
#define USB_RD_IDCOMP(base)      (USB_IDCOMP_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_IDCOMP bitfields
 */

/*!
 * @name Register USB_IDCOMP, field NID[5:0] (RO)
 *
 * Ones complement of peripheral identification bits.
 */
/*@{*/
/*! @brief Read current value of the USB_IDCOMP_NID field. */
#define USB_RD_IDCOMP_NID(base) ((USB_IDCOMP_REG(base) & USB_IDCOMP_NID_MASK) >> USB_IDCOMP_NID_SHIFT)
#define USB_BRD_IDCOMP_NID(base) (USB_RD_IDCOMP_NID(base))
/*@}*/

/*******************************************************************************
 * USB_REV - Peripheral Revision Register
 ******************************************************************************/

/*!
 * @brief USB_REV - Peripheral Revision Register (RO)
 *
 * Reset value: 0x33U
 *
 * This register contains the revision number of the USB Module.
 */
/*!
 * @name Constants and macros for entire USB_REV register
 */
/*@{*/
#define USB_RD_REV(base)         (USB_REV_REG(base))
/*@}*/

/*******************************************************************************
 * USB_ADDINFO - Peripheral Additional Info Register
 ******************************************************************************/

/*!
 * @brief USB_ADDINFO - Peripheral Additional Info Register (RO)
 *
 * Reset value: 0x01U
 *
 * The Peripheral Additional info Register reads back the value of the fixed
 * Interrupt Request Level (IRQNUM) along with the Host Enable bit. If set to 1, the
 * Host Enable bit indicates the USB peripheral is operating in host mode.
 */
/*!
 * @name Constants and macros for entire USB_ADDINFO register
 */
/*@{*/
#define USB_RD_ADDINFO(base)     (USB_ADDINFO_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_ADDINFO bitfields
 */

/*!
 * @name Register USB_ADDINFO, field IEHOST[0] (RO)
 *
 * This bit is set if host mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ADDINFO_IEHOST field. */
#define USB_RD_ADDINFO_IEHOST(base) ((USB_ADDINFO_REG(base) & USB_ADDINFO_IEHOST_MASK) >> USB_ADDINFO_IEHOST_SHIFT)
#define USB_BRD_ADDINFO_IEHOST(base) (BITBAND_ACCESS8(&USB_ADDINFO_REG(base), USB_ADDINFO_IEHOST_SHIFT))
/*@}*/

/*!
 * @name Register USB_ADDINFO, field IRQNUM[7:3] (RO)
 */
/*@{*/
/*! @brief Read current value of the USB_ADDINFO_IRQNUM field. */
#define USB_RD_ADDINFO_IRQNUM(base) ((USB_ADDINFO_REG(base) & USB_ADDINFO_IRQNUM_MASK) >> USB_ADDINFO_IRQNUM_SHIFT)
#define USB_BRD_ADDINFO_IRQNUM(base) (USB_RD_ADDINFO_IRQNUM(base))
/*@}*/

/*******************************************************************************
 * USB_OTGISTAT - OTG Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief USB_OTGISTAT - OTG Interrupt Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The OTG Interrupt Status Register records changes of the ID sense and VBUS
 * signals. Software can read this register to determine which event has caused an
 * interrupt. Only bits that have changed since the last software read are set.
 * Writing a one to a bit clears the associated interrupt.
 */
/*!
 * @name Constants and macros for entire USB_OTGISTAT register
 */
/*@{*/
#define USB_RD_OTGISTAT(base)    (USB_OTGISTAT_REG(base))
#define USB_WR_OTGISTAT(base, value) (USB_OTGISTAT_REG(base) = (value))
#define USB_RMW_OTGISTAT(base, mask, value) (USB_WR_OTGISTAT(base, (USB_RD_OTGISTAT(base) & ~(mask)) | (value)))
#define USB_SET_OTGISTAT(base, value) (USB_WR_OTGISTAT(base, USB_RD_OTGISTAT(base) |  (value)))
#define USB_CLR_OTGISTAT(base, value) (USB_WR_OTGISTAT(base, USB_RD_OTGISTAT(base) & ~(value)))
#define USB_TOG_OTGISTAT(base, value) (USB_WR_OTGISTAT(base, USB_RD_OTGISTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGISTAT bitfields
 */

/*!
 * @name Register USB_OTGISTAT, field AVBUSCHG[0] (RW)
 *
 * This bit is set when a change in VBUS is detected on an A device.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_AVBUSCHG field. */
#define USB_RD_OTGISTAT_AVBUSCHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_AVBUSCHG_MASK) >> USB_OTGISTAT_AVBUSCHG_SHIFT)
#define USB_BRD_OTGISTAT_AVBUSCHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_AVBUSCHG_SHIFT))

/*! @brief Set the AVBUSCHG field to a new value. */
#define USB_WR_OTGISTAT_AVBUSCHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_AVBUSCHG_MASK, USB_OTGISTAT_AVBUSCHG(value)))
#define USB_BWR_OTGISTAT_AVBUSCHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_AVBUSCHG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field B_SESS_CHG[2] (RW)
 *
 * This bit is set when a change in VBUS is detected on a B device.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_B_SESS_CHG field. */
#define USB_RD_OTGISTAT_B_SESS_CHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_B_SESS_CHG_MASK) >> USB_OTGISTAT_B_SESS_CHG_SHIFT)
#define USB_BRD_OTGISTAT_B_SESS_CHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_B_SESS_CHG_SHIFT))

/*! @brief Set the B_SESS_CHG field to a new value. */
#define USB_WR_OTGISTAT_B_SESS_CHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_B_SESS_CHG_MASK, USB_OTGISTAT_B_SESS_CHG(value)))
#define USB_BWR_OTGISTAT_B_SESS_CHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_B_SESS_CHG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field SESSVLDCHG[3] (RW)
 *
 * This bit is set when a change in VBUS is detected indicating a session valid
 * or a session no longer valid.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_SESSVLDCHG field. */
#define USB_RD_OTGISTAT_SESSVLDCHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_SESSVLDCHG_MASK) >> USB_OTGISTAT_SESSVLDCHG_SHIFT)
#define USB_BRD_OTGISTAT_SESSVLDCHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_SESSVLDCHG_SHIFT))

/*! @brief Set the SESSVLDCHG field to a new value. */
#define USB_WR_OTGISTAT_SESSVLDCHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_SESSVLDCHG_MASK, USB_OTGISTAT_SESSVLDCHG(value)))
#define USB_BWR_OTGISTAT_SESSVLDCHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_SESSVLDCHG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field LINE_STATE_CHG[5] (RW)
 *
 * This bit is set when the USB line state changes. The interrupt associated
 * with this bit can be used to detect Reset, Resume, Connect, and Data Line Pulse
 * signals.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_LINE_STATE_CHG field. */
#define USB_RD_OTGISTAT_LINE_STATE_CHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_LINE_STATE_CHG_MASK) >> USB_OTGISTAT_LINE_STATE_CHG_SHIFT)
#define USB_BRD_OTGISTAT_LINE_STATE_CHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_LINE_STATE_CHG_SHIFT))

/*! @brief Set the LINE_STATE_CHG field to a new value. */
#define USB_WR_OTGISTAT_LINE_STATE_CHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_LINE_STATE_CHG_MASK, USB_OTGISTAT_LINE_STATE_CHG(value)))
#define USB_BWR_OTGISTAT_LINE_STATE_CHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_LINE_STATE_CHG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field ONEMSEC[6] (RW)
 *
 * This bit is set when the 1 millisecond timer expires. This bit stays asserted
 * until cleared by software. The interrupt must be serviced every millisecond
 * to avoid losing 1msec counts.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_ONEMSEC field. */
#define USB_RD_OTGISTAT_ONEMSEC(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_ONEMSEC_MASK) >> USB_OTGISTAT_ONEMSEC_SHIFT)
#define USB_BRD_OTGISTAT_ONEMSEC(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_ONEMSEC_SHIFT))

/*! @brief Set the ONEMSEC field to a new value. */
#define USB_WR_OTGISTAT_ONEMSEC(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_ONEMSEC_MASK, USB_OTGISTAT_ONEMSEC(value)))
#define USB_BWR_OTGISTAT_ONEMSEC(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_ONEMSEC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field IDCHG[7] (RW)
 *
 * This bit is set when a change in the ID Signal from the USB connector is
 * sensed.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_IDCHG field. */
#define USB_RD_OTGISTAT_IDCHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_IDCHG_MASK) >> USB_OTGISTAT_IDCHG_SHIFT)
#define USB_BRD_OTGISTAT_IDCHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_IDCHG_SHIFT))

/*! @brief Set the IDCHG field to a new value. */
#define USB_WR_OTGISTAT_IDCHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_IDCHG_MASK, USB_OTGISTAT_IDCHG(value)))
#define USB_BWR_OTGISTAT_IDCHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_IDCHG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_OTGICR - OTG Interrupt Control Register
 ******************************************************************************/

/*!
 * @brief USB_OTGICR - OTG Interrupt Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The OTG Interrupt Control Register enables the corresponding interrupt status
 * bits defined in the OTG Interrupt Status Register.
 */
/*!
 * @name Constants and macros for entire USB_OTGICR register
 */
/*@{*/
#define USB_RD_OTGICR(base)      (USB_OTGICR_REG(base))
#define USB_WR_OTGICR(base, value) (USB_OTGICR_REG(base) = (value))
#define USB_RMW_OTGICR(base, mask, value) (USB_WR_OTGICR(base, (USB_RD_OTGICR(base) & ~(mask)) | (value)))
#define USB_SET_OTGICR(base, value) (USB_WR_OTGICR(base, USB_RD_OTGICR(base) |  (value)))
#define USB_CLR_OTGICR(base, value) (USB_WR_OTGICR(base, USB_RD_OTGICR(base) & ~(value)))
#define USB_TOG_OTGICR(base, value) (USB_WR_OTGICR(base, USB_RD_OTGICR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGICR bitfields
 */

/*!
 * @name Register USB_OTGICR, field AVBUSEN[0] (RW)
 *
 * Values:
 * - 0 - The AVBUSCHG interrupt is disabled
 * - 1 - The AVBUSCHG interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_AVBUSEN field. */
#define USB_RD_OTGICR_AVBUSEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_AVBUSEN_MASK) >> USB_OTGICR_AVBUSEN_SHIFT)
#define USB_BRD_OTGICR_AVBUSEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_AVBUSEN_SHIFT))

/*! @brief Set the AVBUSEN field to a new value. */
#define USB_WR_OTGICR_AVBUSEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_AVBUSEN_MASK, USB_OTGICR_AVBUSEN(value)))
#define USB_BWR_OTGICR_AVBUSEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_AVBUSEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field BSESSEN[2] (RW)
 *
 * Values:
 * - 0 - The B_SESS_CHG interrupt is disabled
 * - 1 - The B_SESS_CHG interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_BSESSEN field. */
#define USB_RD_OTGICR_BSESSEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_BSESSEN_MASK) >> USB_OTGICR_BSESSEN_SHIFT)
#define USB_BRD_OTGICR_BSESSEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_BSESSEN_SHIFT))

/*! @brief Set the BSESSEN field to a new value. */
#define USB_WR_OTGICR_BSESSEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_BSESSEN_MASK, USB_OTGICR_BSESSEN(value)))
#define USB_BWR_OTGICR_BSESSEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_BSESSEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field SESSVLDEN[3] (RW)
 *
 * Values:
 * - 0 - The SESSVLDCHG interrupt is disabled.
 * - 1 - The SESSVLDCHG interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_SESSVLDEN field. */
#define USB_RD_OTGICR_SESSVLDEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_SESSVLDEN_MASK) >> USB_OTGICR_SESSVLDEN_SHIFT)
#define USB_BRD_OTGICR_SESSVLDEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_SESSVLDEN_SHIFT))

/*! @brief Set the SESSVLDEN field to a new value. */
#define USB_WR_OTGICR_SESSVLDEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_SESSVLDEN_MASK, USB_OTGICR_SESSVLDEN(value)))
#define USB_BWR_OTGICR_SESSVLDEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_SESSVLDEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field LINESTATEEN[5] (RW)
 *
 * Values:
 * - 0 - The LINE_STAT_CHG interrupt is disabled.
 * - 1 - The LINE_STAT_CHG interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_LINESTATEEN field. */
#define USB_RD_OTGICR_LINESTATEEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_LINESTATEEN_MASK) >> USB_OTGICR_LINESTATEEN_SHIFT)
#define USB_BRD_OTGICR_LINESTATEEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_LINESTATEEN_SHIFT))

/*! @brief Set the LINESTATEEN field to a new value. */
#define USB_WR_OTGICR_LINESTATEEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_LINESTATEEN_MASK, USB_OTGICR_LINESTATEEN(value)))
#define USB_BWR_OTGICR_LINESTATEEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_LINESTATEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field ONEMSECEN[6] (RW)
 *
 * Values:
 * - 0 - The 1msec timer interrupt is disabled.
 * - 1 - The 1msec timer interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_ONEMSECEN field. */
#define USB_RD_OTGICR_ONEMSECEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_ONEMSECEN_MASK) >> USB_OTGICR_ONEMSECEN_SHIFT)
#define USB_BRD_OTGICR_ONEMSECEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_ONEMSECEN_SHIFT))

/*! @brief Set the ONEMSECEN field to a new value. */
#define USB_WR_OTGICR_ONEMSECEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_ONEMSECEN_MASK, USB_OTGICR_ONEMSECEN(value)))
#define USB_BWR_OTGICR_ONEMSECEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_ONEMSECEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field IDEN[7] (RW)
 *
 * Values:
 * - 0 - The ID interrupt is disabled
 * - 1 - The ID interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_IDEN field. */
#define USB_RD_OTGICR_IDEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_IDEN_MASK) >> USB_OTGICR_IDEN_SHIFT)
#define USB_BRD_OTGICR_IDEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_IDEN_SHIFT))

/*! @brief Set the IDEN field to a new value. */
#define USB_WR_OTGICR_IDEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_IDEN_MASK, USB_OTGICR_IDEN(value)))
#define USB_BWR_OTGICR_IDEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_IDEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_OTGSTAT - OTG Status Register
 ******************************************************************************/

/*!
 * @brief USB_OTGSTAT - OTG Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The OTG Status Register displays the actual value from the external
 * comparator outputs of the ID pin and VBUS.
 */
/*!
 * @name Constants and macros for entire USB_OTGSTAT register
 */
/*@{*/
#define USB_RD_OTGSTAT(base)     (USB_OTGSTAT_REG(base))
#define USB_WR_OTGSTAT(base, value) (USB_OTGSTAT_REG(base) = (value))
#define USB_RMW_OTGSTAT(base, mask, value) (USB_WR_OTGSTAT(base, (USB_RD_OTGSTAT(base) & ~(mask)) | (value)))
#define USB_SET_OTGSTAT(base, value) (USB_WR_OTGSTAT(base, USB_RD_OTGSTAT(base) |  (value)))
#define USB_CLR_OTGSTAT(base, value) (USB_WR_OTGSTAT(base, USB_RD_OTGSTAT(base) & ~(value)))
#define USB_TOG_OTGSTAT(base, value) (USB_WR_OTGSTAT(base, USB_RD_OTGSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGSTAT bitfields
 */

/*!
 * @name Register USB_OTGSTAT, field AVBUSVLD[0] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is below the A VBUS Valid threshold.
 * - 1 - The VBUS voltage is above the A VBUS Valid threshold.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_AVBUSVLD field. */
#define USB_RD_OTGSTAT_AVBUSVLD(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_AVBUSVLD_MASK) >> USB_OTGSTAT_AVBUSVLD_SHIFT)
#define USB_BRD_OTGSTAT_AVBUSVLD(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_AVBUSVLD_SHIFT))

/*! @brief Set the AVBUSVLD field to a new value. */
#define USB_WR_OTGSTAT_AVBUSVLD(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_AVBUSVLD_MASK, USB_OTGSTAT_AVBUSVLD(value)))
#define USB_BWR_OTGSTAT_AVBUSVLD(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_AVBUSVLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field BSESSEND[2] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is above the B session End threshold.
 * - 1 - The VBUS voltage is below the B session End threshold.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_BSESSEND field. */
#define USB_RD_OTGSTAT_BSESSEND(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_BSESSEND_MASK) >> USB_OTGSTAT_BSESSEND_SHIFT)
#define USB_BRD_OTGSTAT_BSESSEND(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_BSESSEND_SHIFT))

/*! @brief Set the BSESSEND field to a new value. */
#define USB_WR_OTGSTAT_BSESSEND(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_BSESSEND_MASK, USB_OTGSTAT_BSESSEND(value)))
#define USB_BWR_OTGSTAT_BSESSEND(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_BSESSEND_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field SESS_VLD[3] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is below the B session Valid threshold
 * - 1 - The VBUS voltage is above the B session Valid threshold.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_SESS_VLD field. */
#define USB_RD_OTGSTAT_SESS_VLD(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_SESS_VLD_MASK) >> USB_OTGSTAT_SESS_VLD_SHIFT)
#define USB_BRD_OTGSTAT_SESS_VLD(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_SESS_VLD_SHIFT))

/*! @brief Set the SESS_VLD field to a new value. */
#define USB_WR_OTGSTAT_SESS_VLD(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_SESS_VLD_MASK, USB_OTGSTAT_SESS_VLD(value)))
#define USB_BWR_OTGSTAT_SESS_VLD(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_SESS_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field LINESTATESTABLE[5] (RW)
 *
 * This bit indicates that the internal signals that control the LINE_STATE_CHG
 * bit (bit 5) of the OTGISTAT register have been stable for at least 1
 * millisecond. First read the LINE_STATE_CHG bit, and then read this bit. If this bit
 * reads as 1, then the value of LINE_STATE_CHG can be considered stable.
 *
 * Values:
 * - 0 - The LINE_STAT_CHG bit is not yet stable.
 * - 1 - The LINE_STAT_CHG bit has been debounced and is stable.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_LINESTATESTABLE field. */
#define USB_RD_OTGSTAT_LINESTATESTABLE(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_LINESTATESTABLE_MASK) >> USB_OTGSTAT_LINESTATESTABLE_SHIFT)
#define USB_BRD_OTGSTAT_LINESTATESTABLE(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_LINESTATESTABLE_SHIFT))

/*! @brief Set the LINESTATESTABLE field to a new value. */
#define USB_WR_OTGSTAT_LINESTATESTABLE(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_LINESTATESTABLE_MASK, USB_OTGSTAT_LINESTATESTABLE(value)))
#define USB_BWR_OTGSTAT_LINESTATESTABLE(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_LINESTATESTABLE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ONEMSECEN[6] (RW)
 *
 * This bit is reserved for the 1msec count, but it is not useful to software.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_ONEMSECEN field. */
#define USB_RD_OTGSTAT_ONEMSECEN(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_ONEMSECEN_MASK) >> USB_OTGSTAT_ONEMSECEN_SHIFT)
#define USB_BRD_OTGSTAT_ONEMSECEN(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ONEMSECEN_SHIFT))

/*! @brief Set the ONEMSECEN field to a new value. */
#define USB_WR_OTGSTAT_ONEMSECEN(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_ONEMSECEN_MASK, USB_OTGSTAT_ONEMSECEN(value)))
#define USB_BWR_OTGSTAT_ONEMSECEN(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ONEMSECEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ID[7] (RW)
 *
 * Indicates the current state of the ID pin on the USB connector
 *
 * Values:
 * - 0 - Indicates a Type A cable has been plugged into the USB connector
 * - 1 - Indicates no cable is attached or a Type B cable has been plugged into
 *     the USB connector
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_ID field. */
#define USB_RD_OTGSTAT_ID(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_ID_MASK) >> USB_OTGSTAT_ID_SHIFT)
#define USB_BRD_OTGSTAT_ID(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ID_SHIFT))

/*! @brief Set the ID field to a new value. */
#define USB_WR_OTGSTAT_ID(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_ID_MASK, USB_OTGSTAT_ID(value)))
#define USB_BWR_OTGSTAT_ID(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ID_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_OTGCTL - OTG Control Register
 ******************************************************************************/

/*!
 * @brief USB_OTGCTL - OTG Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The OTG Control Register controls the operation of VBUS and Data Line
 * termination resistors.
 */
/*!
 * @name Constants and macros for entire USB_OTGCTL register
 */
/*@{*/
#define USB_RD_OTGCTL(base)      (USB_OTGCTL_REG(base))
#define USB_WR_OTGCTL(base, value) (USB_OTGCTL_REG(base) = (value))
#define USB_RMW_OTGCTL(base, mask, value) (USB_WR_OTGCTL(base, (USB_RD_OTGCTL(base) & ~(mask)) | (value)))
#define USB_SET_OTGCTL(base, value) (USB_WR_OTGCTL(base, USB_RD_OTGCTL(base) |  (value)))
#define USB_CLR_OTGCTL(base, value) (USB_WR_OTGCTL(base, USB_RD_OTGCTL(base) & ~(value)))
#define USB_TOG_OTGCTL(base, value) (USB_WR_OTGCTL(base, USB_RD_OTGCTL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGCTL bitfields
 */

/*!
 * @name Register USB_OTGCTL, field OTGEN[2] (RW)
 *
 * Values:
 * - 0 - If USB_EN is set and HOST_MODE is clear in the Control Register (CTL),
 *     then the D+ Data Line pull-up resistors are enabled. If HOST_MODE is set
 *     the D+ and D- Data Line pull-down resistors are engaged.
 * - 1 - The pull-up and pull-down controls in this register are used.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_OTGEN field. */
#define USB_RD_OTGCTL_OTGEN(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_OTGEN_MASK) >> USB_OTGCTL_OTGEN_SHIFT)
#define USB_BRD_OTGCTL_OTGEN(base) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_OTGEN_SHIFT))

/*! @brief Set the OTGEN field to a new value. */
#define USB_WR_OTGCTL_OTGEN(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_OTGEN_MASK, USB_OTGCTL_OTGEN(value)))
#define USB_BWR_OTGCTL_OTGEN(base, value) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_OTGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DMLOW[4] (RW)
 *
 * Values:
 * - 0 - D- pulldown resistor is not enabled.
 * - 1 - D- pulldown resistor is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_DMLOW field. */
#define USB_RD_OTGCTL_DMLOW(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_DMLOW_MASK) >> USB_OTGCTL_DMLOW_SHIFT)
#define USB_BRD_OTGCTL_DMLOW(base) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DMLOW_SHIFT))

/*! @brief Set the DMLOW field to a new value. */
#define USB_WR_OTGCTL_DMLOW(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_DMLOW_MASK, USB_OTGCTL_DMLOW(value)))
#define USB_BWR_OTGCTL_DMLOW(base, value) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DMLOW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPLOW[5] (RW)
 *
 * This bit should always be enabled together with bit 4 (DMLOW)
 *
 * Values:
 * - 0 - D+ pulldown resistor is not enabled.
 * - 1 - D+ pulldown resistor is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_DPLOW field. */
#define USB_RD_OTGCTL_DPLOW(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_DPLOW_MASK) >> USB_OTGCTL_DPLOW_SHIFT)
#define USB_BRD_OTGCTL_DPLOW(base) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPLOW_SHIFT))

/*! @brief Set the DPLOW field to a new value. */
#define USB_WR_OTGCTL_DPLOW(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_DPLOW_MASK, USB_OTGCTL_DPLOW(value)))
#define USB_BWR_OTGCTL_DPLOW(base, value) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPLOW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPHIGH[7] (RW)
 *
 * Values:
 * - 0 - D+ pullup resistor is not enabled
 * - 1 - D+ pullup resistor is enabled
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_DPHIGH field. */
#define USB_RD_OTGCTL_DPHIGH(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_DPHIGH_MASK) >> USB_OTGCTL_DPHIGH_SHIFT)
#define USB_BRD_OTGCTL_DPHIGH(base) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPHIGH_SHIFT))

/*! @brief Set the DPHIGH field to a new value. */
#define USB_WR_OTGCTL_DPHIGH(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_DPHIGH_MASK, USB_OTGCTL_DPHIGH(value)))
#define USB_BWR_OTGCTL_DPHIGH(base, value) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPHIGH_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_ISTAT - Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief USB_ISTAT - Interrupt Status Register (W1C)
 *
 * Reset value: 0x00U
 *
 * The Interrupt Status Register contains bits for each of the interrupt sources
 * within the USB Module. Each of these bits are qualified with their respective
 * interrupt enable bits. All bits of this register are logically OR'd together
 * along with the OTG Interrupt Status Register (OTGSTAT) to form a single
 * interrupt source for the processor's interrupt controller. After an interrupt bit
 * has been set it may only be cleared by writing a one to the respective interrupt
 * bit. This register contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_ISTAT register
 */
/*@{*/
#define USB_RD_ISTAT(base)       (USB_ISTAT_REG(base))
#define USB_WR_ISTAT(base, value) (USB_ISTAT_REG(base) = (value))
#define USB_RMW_ISTAT(base, mask, value) (USB_WR_ISTAT(base, (USB_RD_ISTAT(base) & ~(mask)) | (value)))
#define USB_SET_ISTAT(base, value) (USB_WR_ISTAT(base, USB_RD_ISTAT(base) |  (value)))
#define USB_CLR_ISTAT(base, value) (USB_WR_ISTAT(base, USB_RD_ISTAT(base) & ~(value)))
#define USB_TOG_ISTAT(base, value) (USB_WR_ISTAT(base, USB_RD_ISTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ISTAT bitfields
 */

/*!
 * @name Register USB_ISTAT, field USBRST[0] (W1C)
 *
 * This bit is set when the USB Module has decoded a valid USB reset. This
 * informs the Microprocessor that it should write 0x00 into the address register and
 * enable endpoint 0. USBRST is set after a USB reset has been detected for 2.5
 * microseconds. It is not asserted again until the USB reset condition has been
 * removed and then reasserted.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_USBRST field. */
#define USB_RD_ISTAT_USBRST(base) ((USB_ISTAT_REG(base) & USB_ISTAT_USBRST_MASK) >> USB_ISTAT_USBRST_SHIFT)
#define USB_BRD_ISTAT_USBRST(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_USBRST_SHIFT))

/*! @brief Set the USBRST field to a new value. */
#define USB_WR_ISTAT_USBRST(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_USBRST(value)))
#define USB_BWR_ISTAT_USBRST(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_USBRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ERROR[1] (W1C)
 *
 * This bit is set when any of the error conditions within the ERRSTAT register
 * occur. The processor must then read the ERRSTAT register to determine the
 * source of the error.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_ERROR field. */
#define USB_RD_ISTAT_ERROR(base) ((USB_ISTAT_REG(base) & USB_ISTAT_ERROR_MASK) >> USB_ISTAT_ERROR_SHIFT)
#define USB_BRD_ISTAT_ERROR(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_ERROR_SHIFT))

/*! @brief Set the ERROR field to a new value. */
#define USB_WR_ISTAT_ERROR(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_ERROR_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_ERROR(value)))
#define USB_BWR_ISTAT_ERROR(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_ERROR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SOFTOK[2] (W1C)
 *
 * This bit is set when the USB Module receives a Start Of Frame (SOF) token. In
 * Host mode this bit is set when the SOF threshold is reached, so that software
 * can prepare for the next SOF.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_SOFTOK field. */
#define USB_RD_ISTAT_SOFTOK(base) ((USB_ISTAT_REG(base) & USB_ISTAT_SOFTOK_MASK) >> USB_ISTAT_SOFTOK_SHIFT)
#define USB_BRD_ISTAT_SOFTOK(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_SOFTOK_SHIFT))

/*! @brief Set the SOFTOK field to a new value. */
#define USB_WR_ISTAT_SOFTOK(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_SOFTOK_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_SOFTOK(value)))
#define USB_BWR_ISTAT_SOFTOK(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_SOFTOK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field TOKDNE[3] (W1C)
 *
 * This bit is set when the current token being processed has completed. The
 * processor should immediately read the STAT register to determine the EndPoint and
 * BD used for this token. Clearing this bit (by writing a one) causes the STAT
 * register to be cleared or the STAT holding register to be loaded into the STAT
 * register.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_TOKDNE field. */
#define USB_RD_ISTAT_TOKDNE(base) ((USB_ISTAT_REG(base) & USB_ISTAT_TOKDNE_MASK) >> USB_ISTAT_TOKDNE_SHIFT)
#define USB_BRD_ISTAT_TOKDNE(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_TOKDNE_SHIFT))

/*! @brief Set the TOKDNE field to a new value. */
#define USB_WR_ISTAT_TOKDNE(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_TOKDNE_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_TOKDNE(value)))
#define USB_BWR_ISTAT_TOKDNE(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_TOKDNE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SLEEP[4] (W1C)
 *
 * This bit is set when the USB Module detects a constant idle on the USB bus
 * for 3 milliseconds. The sleep timer is reset by activity on the USB bus.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_SLEEP field. */
#define USB_RD_ISTAT_SLEEP(base) ((USB_ISTAT_REG(base) & USB_ISTAT_SLEEP_MASK) >> USB_ISTAT_SLEEP_SHIFT)
#define USB_BRD_ISTAT_SLEEP(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_SLEEP_SHIFT))

/*! @brief Set the SLEEP field to a new value. */
#define USB_WR_ISTAT_SLEEP(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_SLEEP_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_SLEEP(value)))
#define USB_BWR_ISTAT_SLEEP(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_SLEEP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field RESUME[5] (W1C)
 *
 * This bit is set depending upon the DP/DM signals, and can be used to signal
 * remote wake-up signaling on the USB bus. When not in suspend mode this
 * interrupt should be disabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_RESUME field. */
#define USB_RD_ISTAT_RESUME(base) ((USB_ISTAT_REG(base) & USB_ISTAT_RESUME_MASK) >> USB_ISTAT_RESUME_SHIFT)
#define USB_BRD_ISTAT_RESUME(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_RESUME_SHIFT))

/*! @brief Set the RESUME field to a new value. */
#define USB_WR_ISTAT_RESUME(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_RESUME_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_RESUME(value)))
#define USB_BWR_ISTAT_RESUME(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_RESUME_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ATTACH[6] (W1C)
 *
 * This bit is set when the USB Module detects an attach of a USB device. This
 * signal is only valid if HOSTMODEEN is true. This interrupt signifies that a
 * peripheral is now present and must be configured.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_ATTACH field. */
#define USB_RD_ISTAT_ATTACH(base) ((USB_ISTAT_REG(base) & USB_ISTAT_ATTACH_MASK) >> USB_ISTAT_ATTACH_SHIFT)
#define USB_BRD_ISTAT_ATTACH(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_ATTACH_SHIFT))

/*! @brief Set the ATTACH field to a new value. */
#define USB_WR_ISTAT_ATTACH(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_ATTACH_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_ATTACH(value)))
#define USB_BWR_ISTAT_ATTACH(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_ATTACH_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field STALL[7] (W1C)
 *
 * In Target mode this bit is asserted when a STALL handshake is sent by the
 * SIE. In Host mode this bit is set when the USB Module detects a STALL acknowledge
 * during the handshake phase of a USB transaction. This interrupt can be use to
 * determine is the last USB transaction was completed successfully or if it
 * stalled.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_STALL field. */
#define USB_RD_ISTAT_STALL(base) ((USB_ISTAT_REG(base) & USB_ISTAT_STALL_MASK) >> USB_ISTAT_STALL_SHIFT)
#define USB_BRD_ISTAT_STALL(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_STALL_SHIFT))

/*! @brief Set the STALL field to a new value. */
#define USB_WR_ISTAT_STALL(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_STALL_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK), USB_ISTAT_STALL(value)))
#define USB_BWR_ISTAT_STALL(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_STALL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_INTEN - Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief USB_INTEN - Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The Interrupt Enable Register contains enable bits for each of the interrupt
 * sources within the USB Module. Setting any of these bits enables the
 * respective interrupt source in the ISTAT register. This register contains the value of
 * 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_INTEN register
 */
/*@{*/
#define USB_RD_INTEN(base)       (USB_INTEN_REG(base))
#define USB_WR_INTEN(base, value) (USB_INTEN_REG(base) = (value))
#define USB_RMW_INTEN(base, mask, value) (USB_WR_INTEN(base, (USB_RD_INTEN(base) & ~(mask)) | (value)))
#define USB_SET_INTEN(base, value) (USB_WR_INTEN(base, USB_RD_INTEN(base) |  (value)))
#define USB_CLR_INTEN(base, value) (USB_WR_INTEN(base, USB_RD_INTEN(base) & ~(value)))
#define USB_TOG_INTEN(base, value) (USB_WR_INTEN(base, USB_RD_INTEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_INTEN bitfields
 */

/*!
 * @name Register USB_INTEN, field USBRSTEN[0] (RW)
 *
 * Values:
 * - 0 - The USBRST interrupt is not enabled.
 * - 1 - The USBRST interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_USBRSTEN field. */
#define USB_RD_INTEN_USBRSTEN(base) ((USB_INTEN_REG(base) & USB_INTEN_USBRSTEN_MASK) >> USB_INTEN_USBRSTEN_SHIFT)
#define USB_BRD_INTEN_USBRSTEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_USBRSTEN_SHIFT))

/*! @brief Set the USBRSTEN field to a new value. */
#define USB_WR_INTEN_USBRSTEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_USBRSTEN_MASK, USB_INTEN_USBRSTEN(value)))
#define USB_BWR_INTEN_USBRSTEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_USBRSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field ERROREN[1] (RW)
 *
 * Values:
 * - 0 - The ERROR interrupt is not enabled.
 * - 1 - The ERROR interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_ERROREN field. */
#define USB_RD_INTEN_ERROREN(base) ((USB_INTEN_REG(base) & USB_INTEN_ERROREN_MASK) >> USB_INTEN_ERROREN_SHIFT)
#define USB_BRD_INTEN_ERROREN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_ERROREN_SHIFT))

/*! @brief Set the ERROREN field to a new value. */
#define USB_WR_INTEN_ERROREN(base, value) (USB_RMW_INTEN(base, USB_INTEN_ERROREN_MASK, USB_INTEN_ERROREN(value)))
#define USB_BWR_INTEN_ERROREN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_ERROREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field SOFTOKEN[2] (RW)
 *
 * Values:
 * - 0 - The SOFTOK interrupt is not enabled.
 * - 1 - The SOFTOK interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_SOFTOKEN field. */
#define USB_RD_INTEN_SOFTOKEN(base) ((USB_INTEN_REG(base) & USB_INTEN_SOFTOKEN_MASK) >> USB_INTEN_SOFTOKEN_SHIFT)
#define USB_BRD_INTEN_SOFTOKEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_SOFTOKEN_SHIFT))

/*! @brief Set the SOFTOKEN field to a new value. */
#define USB_WR_INTEN_SOFTOKEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_SOFTOKEN_MASK, USB_INTEN_SOFTOKEN(value)))
#define USB_BWR_INTEN_SOFTOKEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_SOFTOKEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field TOKDNEEN[3] (RW)
 *
 * Values:
 * - 0 - The TOKDNE interrupt is not enabled.
 * - 1 - The TOKDNE interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_TOKDNEEN field. */
#define USB_RD_INTEN_TOKDNEEN(base) ((USB_INTEN_REG(base) & USB_INTEN_TOKDNEEN_MASK) >> USB_INTEN_TOKDNEEN_SHIFT)
#define USB_BRD_INTEN_TOKDNEEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_TOKDNEEN_SHIFT))

/*! @brief Set the TOKDNEEN field to a new value. */
#define USB_WR_INTEN_TOKDNEEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_TOKDNEEN_MASK, USB_INTEN_TOKDNEEN(value)))
#define USB_BWR_INTEN_TOKDNEEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_TOKDNEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field SLEEPEN[4] (RW)
 *
 * Values:
 * - 0 - The SLEEP interrupt is not enabled.
 * - 1 - The SLEEP interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_SLEEPEN field. */
#define USB_RD_INTEN_SLEEPEN(base) ((USB_INTEN_REG(base) & USB_INTEN_SLEEPEN_MASK) >> USB_INTEN_SLEEPEN_SHIFT)
#define USB_BRD_INTEN_SLEEPEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_SLEEPEN_SHIFT))

/*! @brief Set the SLEEPEN field to a new value. */
#define USB_WR_INTEN_SLEEPEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_SLEEPEN_MASK, USB_INTEN_SLEEPEN(value)))
#define USB_BWR_INTEN_SLEEPEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_SLEEPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field RESUMEEN[5] (RW)
 *
 * Values:
 * - 0 - The RESUME interrupt is not enabled.
 * - 1 - The RESUME interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_RESUMEEN field. */
#define USB_RD_INTEN_RESUMEEN(base) ((USB_INTEN_REG(base) & USB_INTEN_RESUMEEN_MASK) >> USB_INTEN_RESUMEEN_SHIFT)
#define USB_BRD_INTEN_RESUMEEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_RESUMEEN_SHIFT))

/*! @brief Set the RESUMEEN field to a new value. */
#define USB_WR_INTEN_RESUMEEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_RESUMEEN_MASK, USB_INTEN_RESUMEEN(value)))
#define USB_BWR_INTEN_RESUMEEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_RESUMEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field ATTACHEN[6] (RW)
 *
 * Values:
 * - 0 - The ATTACH interrupt is not enabled.
 * - 1 - The ATTACH interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_ATTACHEN field. */
#define USB_RD_INTEN_ATTACHEN(base) ((USB_INTEN_REG(base) & USB_INTEN_ATTACHEN_MASK) >> USB_INTEN_ATTACHEN_SHIFT)
#define USB_BRD_INTEN_ATTACHEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_ATTACHEN_SHIFT))

/*! @brief Set the ATTACHEN field to a new value. */
#define USB_WR_INTEN_ATTACHEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_ATTACHEN_MASK, USB_INTEN_ATTACHEN(value)))
#define USB_BWR_INTEN_ATTACHEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_ATTACHEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field STALLEN[7] (RW)
 *
 * Values:
 * - 0 - The STALL interrupt is not enabled.
 * - 1 - The STALL interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_STALLEN field. */
#define USB_RD_INTEN_STALLEN(base) ((USB_INTEN_REG(base) & USB_INTEN_STALLEN_MASK) >> USB_INTEN_STALLEN_SHIFT)
#define USB_BRD_INTEN_STALLEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_STALLEN_SHIFT))

/*! @brief Set the STALLEN field to a new value. */
#define USB_WR_INTEN_STALLEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_STALLEN_MASK, USB_INTEN_STALLEN(value)))
#define USB_BWR_INTEN_STALLEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_STALLEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_ERRSTAT - Error Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief USB_ERRSTAT - Error Interrupt Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The Error Interrupt Status Register contains enable bits for each of the
 * error sources within the USB Module. Each of these bits are qualified with their
 * respective error enable bits. All bits of this Register are logically OR'd
 * together and the result placed in the ERROR bit of the ISTAT register. After an
 * interrupt bit has been set it may only be cleared by writing a one to the
 * respective interrupt bit. Each bit is set as soon as the error conditions is
 * detected. Therefore, the interrupt does not typically correspond with the end of a
 * token being processed. This register contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_ERRSTAT register
 */
/*@{*/
#define USB_RD_ERRSTAT(base)     (USB_ERRSTAT_REG(base))
#define USB_WR_ERRSTAT(base, value) (USB_ERRSTAT_REG(base) = (value))
#define USB_RMW_ERRSTAT(base, mask, value) (USB_WR_ERRSTAT(base, (USB_RD_ERRSTAT(base) & ~(mask)) | (value)))
#define USB_SET_ERRSTAT(base, value) (USB_WR_ERRSTAT(base, USB_RD_ERRSTAT(base) |  (value)))
#define USB_CLR_ERRSTAT(base, value) (USB_WR_ERRSTAT(base, USB_RD_ERRSTAT(base) & ~(value)))
#define USB_TOG_ERRSTAT(base, value) (USB_WR_ERRSTAT(base, USB_RD_ERRSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ERRSTAT bitfields
 */

/*!
 * @name Register USB_ERRSTAT, field PIDERR[0] (W1C)
 *
 * This bit is set when the PID check field fails.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_PIDERR field. */
#define USB_RD_ERRSTAT_PIDERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_PIDERR_MASK) >> USB_ERRSTAT_PIDERR_SHIFT)
#define USB_BRD_ERRSTAT_PIDERR(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_PIDERR_SHIFT))

/*! @brief Set the PIDERR field to a new value. */
#define USB_WR_ERRSTAT_PIDERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_PIDERR(value)))
#define USB_BWR_ERRSTAT_PIDERR(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_PIDERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC5EOF[1] (W1C)
 *
 * This error interrupt has two functions. When the USB Module is operating in
 * peripheral mode (HOSTMODEEN=0), this interrupt detects CRC5 errors in the token
 * packets generated by the host. If set the token packet was rejected due to a
 * CRC5 error. When the USB Module is operating in host mode (HOSTMODEEN=1), this
 * interrupt detects End Of Frame (EOF) error conditions. This occurs when the
 * USB Module is transmitting or receiving data and the SOF counter reaches zero.
 * This interrupt is useful when developing USB packet scheduling software to
 * ensure that no USB transactions cross the start of the next frame.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_CRC5EOF field. */
#define USB_RD_ERRSTAT_CRC5EOF(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_CRC5EOF_MASK) >> USB_ERRSTAT_CRC5EOF_SHIFT)
#define USB_BRD_ERRSTAT_CRC5EOF(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC5EOF_SHIFT))

/*! @brief Set the CRC5EOF field to a new value. */
#define USB_WR_ERRSTAT_CRC5EOF(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_CRC5EOF(value)))
#define USB_BWR_ERRSTAT_CRC5EOF(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC5EOF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC16[2] (W1C)
 *
 * This bit is set when a data packet is rejected due to a CRC16 error.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_CRC16 field. */
#define USB_RD_ERRSTAT_CRC16(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_CRC16_MASK) >> USB_ERRSTAT_CRC16_SHIFT)
#define USB_BRD_ERRSTAT_CRC16(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC16_SHIFT))

/*! @brief Set the CRC16 field to a new value. */
#define USB_WR_ERRSTAT_CRC16(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_CRC16(value)))
#define USB_BWR_ERRSTAT_CRC16(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC16_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DFN8[3] (W1C)
 *
 * This bit is set if the data field received was not 8 bits in length. USB
 * Specification 1.0 requires that data fields be an integral number of bytes. If the
 * data field was not an integral number of bytes, this bit is set.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_DFN8 field. */
#define USB_RD_ERRSTAT_DFN8(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_DFN8_MASK) >> USB_ERRSTAT_DFN8_SHIFT)
#define USB_BRD_ERRSTAT_DFN8(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DFN8_SHIFT))

/*! @brief Set the DFN8 field to a new value. */
#define USB_WR_ERRSTAT_DFN8(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_DFN8(value)))
#define USB_BWR_ERRSTAT_DFN8(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DFN8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTOERR[4] (W1C)
 *
 * This bit is set when a bus turnaround timeout error occurs. The USB Module
 * contains a bus turnaround timer that keeps track of the amount of time elapsed
 * between the token and data phases of a SETUP or OUT TOKEN or the data and
 * handshake phases of a IN TOKEN. If more than 16 bit times are counted from the
 * previous EOP before a transition from IDLE, a bus turnaround timeout error occurs.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_BTOERR field. */
#define USB_RD_ERRSTAT_BTOERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_BTOERR_MASK) >> USB_ERRSTAT_BTOERR_SHIFT)
#define USB_BRD_ERRSTAT_BTOERR(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTOERR_SHIFT))

/*! @brief Set the BTOERR field to a new value. */
#define USB_WR_ERRSTAT_BTOERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_BTOERR(value)))
#define USB_BWR_ERRSTAT_BTOERR(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTOERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DMAERR[5] (W1C)
 *
 * This bit is set if the USB Module has requested a DMA access to read a new
 * BDT but has not been given the bus before it needs to receive or transmit data.
 * If processing a TX transfer this would cause a transmit data underflow
 * condition. If processing a RX transfer this would cause a receive data overflow
 * condition. This interrupt is useful when developing device arbitration hardware for
 * the microprocessor and the USB Module to minimize bus request and bus grant
 * latency. This bit is also set if a data packet to or from the host is larger
 * than the buffer size allocated in the BDT. In this case the data packet is
 * truncated as it is put into buffer memory.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_DMAERR field. */
#define USB_RD_ERRSTAT_DMAERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_DMAERR_MASK) >> USB_ERRSTAT_DMAERR_SHIFT)
#define USB_BRD_ERRSTAT_DMAERR(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DMAERR_SHIFT))

/*! @brief Set the DMAERR field to a new value. */
#define USB_WR_ERRSTAT_DMAERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_DMAERR(value)))
#define USB_BWR_ERRSTAT_DMAERR(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DMAERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTSERR[7] (W1C)
 *
 * This bit is set when a bit stuff error is detected. If set, the corresponding
 * packet is rejected due to the error.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_BTSERR field. */
#define USB_RD_ERRSTAT_BTSERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_BTSERR_MASK) >> USB_ERRSTAT_BTSERR_SHIFT)
#define USB_BRD_ERRSTAT_BTSERR(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTSERR_SHIFT))

/*! @brief Set the BTSERR field to a new value. */
#define USB_WR_ERRSTAT_BTSERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_BTSERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK), USB_ERRSTAT_BTSERR(value)))
#define USB_BWR_ERRSTAT_BTSERR(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTSERR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_ERREN - Error Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief USB_ERREN - Error Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The Error Interrupt Enable Register contains enable bits for each of the
 * error interrupt sources within the USB Module. Setting any of these bits enables
 * the respective interrupt source in the ERRSTAT register. Each bit is set as
 * soon as the error conditions is detected. Therefore, the interrupt does not
 * typically correspond with the end of a token being processed. This register
 * contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_ERREN register
 */
/*@{*/
#define USB_RD_ERREN(base)       (USB_ERREN_REG(base))
#define USB_WR_ERREN(base, value) (USB_ERREN_REG(base) = (value))
#define USB_RMW_ERREN(base, mask, value) (USB_WR_ERREN(base, (USB_RD_ERREN(base) & ~(mask)) | (value)))
#define USB_SET_ERREN(base, value) (USB_WR_ERREN(base, USB_RD_ERREN(base) |  (value)))
#define USB_CLR_ERREN(base, value) (USB_WR_ERREN(base, USB_RD_ERREN(base) & ~(value)))
#define USB_TOG_ERREN(base, value) (USB_WR_ERREN(base, USB_RD_ERREN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ERREN bitfields
 */

/*!
 * @name Register USB_ERREN, field PIDERREN[0] (RW)
 *
 * Values:
 * - 0 - The PIDERR interrupt is not enabled.
 * - 1 - The PIDERR interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_PIDERREN field. */
#define USB_RD_ERREN_PIDERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_PIDERREN_MASK) >> USB_ERREN_PIDERREN_SHIFT)
#define USB_BRD_ERREN_PIDERREN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_PIDERREN_SHIFT))

/*! @brief Set the PIDERREN field to a new value. */
#define USB_WR_ERREN_PIDERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_PIDERREN_MASK, USB_ERREN_PIDERREN(value)))
#define USB_BWR_ERREN_PIDERREN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_PIDERREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC5EOFEN[1] (RW)
 *
 * Values:
 * - 0 - The CRC5/EOF interrupt is not enabled.
 * - 1 - The CRC5/EOF interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_CRC5EOFEN field. */
#define USB_RD_ERREN_CRC5EOFEN(base) ((USB_ERREN_REG(base) & USB_ERREN_CRC5EOFEN_MASK) >> USB_ERREN_CRC5EOFEN_SHIFT)
#define USB_BRD_ERREN_CRC5EOFEN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_CRC5EOFEN_SHIFT))

/*! @brief Set the CRC5EOFEN field to a new value. */
#define USB_WR_ERREN_CRC5EOFEN(base, value) (USB_RMW_ERREN(base, USB_ERREN_CRC5EOFEN_MASK, USB_ERREN_CRC5EOFEN(value)))
#define USB_BWR_ERREN_CRC5EOFEN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_CRC5EOFEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC16EN[2] (RW)
 *
 * Values:
 * - 0 - The CRC16 interrupt is not enabled.
 * - 1 - The CRC16 interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_CRC16EN field. */
#define USB_RD_ERREN_CRC16EN(base) ((USB_ERREN_REG(base) & USB_ERREN_CRC16EN_MASK) >> USB_ERREN_CRC16EN_SHIFT)
#define USB_BRD_ERREN_CRC16EN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_CRC16EN_SHIFT))

/*! @brief Set the CRC16EN field to a new value. */
#define USB_WR_ERREN_CRC16EN(base, value) (USB_RMW_ERREN(base, USB_ERREN_CRC16EN_MASK, USB_ERREN_CRC16EN(value)))
#define USB_BWR_ERREN_CRC16EN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_CRC16EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field DFN8EN[3] (RW)
 *
 * Values:
 * - 0 - The DFN8 interrupt is not enabled.
 * - 1 - The DFN8 interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_DFN8EN field. */
#define USB_RD_ERREN_DFN8EN(base) ((USB_ERREN_REG(base) & USB_ERREN_DFN8EN_MASK) >> USB_ERREN_DFN8EN_SHIFT)
#define USB_BRD_ERREN_DFN8EN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_DFN8EN_SHIFT))

/*! @brief Set the DFN8EN field to a new value. */
#define USB_WR_ERREN_DFN8EN(base, value) (USB_RMW_ERREN(base, USB_ERREN_DFN8EN_MASK, USB_ERREN_DFN8EN(value)))
#define USB_BWR_ERREN_DFN8EN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_DFN8EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTOERREN[4] (RW)
 *
 * Values:
 * - 0 - The BTOERR interrupt is not enabled.
 * - 1 - The BTOERR interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_BTOERREN field. */
#define USB_RD_ERREN_BTOERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_BTOERREN_MASK) >> USB_ERREN_BTOERREN_SHIFT)
#define USB_BRD_ERREN_BTOERREN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_BTOERREN_SHIFT))

/*! @brief Set the BTOERREN field to a new value. */
#define USB_WR_ERREN_BTOERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_BTOERREN_MASK, USB_ERREN_BTOERREN(value)))
#define USB_BWR_ERREN_BTOERREN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_BTOERREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field DMAERREN[5] (RW)
 *
 * Values:
 * - 0 - The DMAERR interrupt is not enabled.
 * - 1 - The DMAERR interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_DMAERREN field. */
#define USB_RD_ERREN_DMAERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_DMAERREN_MASK) >> USB_ERREN_DMAERREN_SHIFT)
#define USB_BRD_ERREN_DMAERREN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_DMAERREN_SHIFT))

/*! @brief Set the DMAERREN field to a new value. */
#define USB_WR_ERREN_DMAERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_DMAERREN_MASK, USB_ERREN_DMAERREN(value)))
#define USB_BWR_ERREN_DMAERREN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_DMAERREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTSERREN[7] (RW)
 *
 * Values:
 * - 0 - The BTSERR interrupt is not enabled.
 * - 1 - The BTSERR interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_BTSERREN field. */
#define USB_RD_ERREN_BTSERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_BTSERREN_MASK) >> USB_ERREN_BTSERREN_SHIFT)
#define USB_BRD_ERREN_BTSERREN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_BTSERREN_SHIFT))

/*! @brief Set the BTSERREN field to a new value. */
#define USB_WR_ERREN_BTSERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_BTSERREN_MASK, USB_ERREN_BTSERREN(value)))
#define USB_BWR_ERREN_BTSERREN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_BTSERREN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_STAT - Status Register
 ******************************************************************************/

/*!
 * @brief USB_STAT - Status Register (RO)
 *
 * Reset value: 0x00U
 *
 * The Status Register reports the transaction status within the USB Module.
 * When the processor's interrupt controller has received a TOKDNE interrupt the
 * Status Register should be read to determine the status of the previous endpoint
 * communication. The data in the status register is valid when the TOKDNE
 * interrupt bit is asserted. The STAT register is actually a read window into a status
 * FIFO maintained by the USB Module. When the USB Module uses a BD, it updates
 * the Status Register. If another USB transaction is performed before the TOKDNE
 * interrupt is serviced, the USB Module stores the status of the next
 * transaction in the STAT FIFO. Thus the STAT register is actually a four byte FIFO that
 * allows the processor core to process one transaction while the SIE is
 * processing the next transaction. Clearing the TOKDNE bit in the ISTAT register causes
 * the SIE to update the STAT register with the contents of the next STAT value.
 * If the data in the STAT holding register is valid, the SIE immediately
 * reasserts to TOKDNE interrupt.
 */
/*!
 * @name Constants and macros for entire USB_STAT register
 */
/*@{*/
#define USB_RD_STAT(base)        (USB_STAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_STAT bitfields
 */

/*!
 * @name Register USB_STAT, field ODD[2] (RO)
 *
 * this bit is set if the last Buffer Descriptor updated was in the odd bank of
 * the BDT.
 */
/*@{*/
/*! @brief Read current value of the USB_STAT_ODD field. */
#define USB_RD_STAT_ODD(base) ((USB_STAT_REG(base) & USB_STAT_ODD_MASK) >> USB_STAT_ODD_SHIFT)
#define USB_BRD_STAT_ODD(base) (BITBAND_ACCESS8(&USB_STAT_REG(base), USB_STAT_ODD_SHIFT))
/*@}*/

/*!
 * @name Register USB_STAT, field TX[3] (RO)
 *
 * Values:
 * - 0 - The most recent transaction was a Receive operation.
 * - 1 - The most recent transaction was a Transmit operation.
 */
/*@{*/
/*! @brief Read current value of the USB_STAT_TX field. */
#define USB_RD_STAT_TX(base) ((USB_STAT_REG(base) & USB_STAT_TX_MASK) >> USB_STAT_TX_SHIFT)
#define USB_BRD_STAT_TX(base) (BITBAND_ACCESS8(&USB_STAT_REG(base), USB_STAT_TX_SHIFT))
/*@}*/

/*!
 * @name Register USB_STAT, field ENDP[7:4] (RO)
 *
 * This four-bit field encodes the endpoint address that received or transmitted
 * the previous token. This allows the processor core to determine which BDT
 * entry was updated by the last USB transaction.
 */
/*@{*/
/*! @brief Read current value of the USB_STAT_ENDP field. */
#define USB_RD_STAT_ENDP(base) ((USB_STAT_REG(base) & USB_STAT_ENDP_MASK) >> USB_STAT_ENDP_SHIFT)
#define USB_BRD_STAT_ENDP(base) (USB_RD_STAT_ENDP(base))
/*@}*/

/*******************************************************************************
 * USB_CTL - Control Register
 ******************************************************************************/

/*!
 * @brief USB_CTL - Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The Control Register provides various control and configuration information
 * for the USB Module.
 */
/*!
 * @name Constants and macros for entire USB_CTL register
 */
/*@{*/
#define USB_RD_CTL(base)         (USB_CTL_REG(base))
#define USB_WR_CTL(base, value)  (USB_CTL_REG(base) = (value))
#define USB_RMW_CTL(base, mask, value) (USB_WR_CTL(base, (USB_RD_CTL(base) & ~(mask)) | (value)))
#define USB_SET_CTL(base, value) (USB_WR_CTL(base, USB_RD_CTL(base) |  (value)))
#define USB_CLR_CTL(base, value) (USB_WR_CTL(base, USB_RD_CTL(base) & ~(value)))
#define USB_TOG_CTL(base, value) (USB_WR_CTL(base, USB_RD_CTL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_CTL bitfields
 */

/*!
 * @name Register USB_CTL, field USBENSOFEN[0] (RW)
 *
 * Setting this bit causes the SIE to reset all of its ODD bits to the BDTs.
 * Therefore, setting this bit resets much of the logic in the SIE. When host mode
 * is enabled, clearing this bit causes the SIE to stop sending SOF tokens.
 *
 * Values:
 * - 0 - The USB Module is disabled.
 * - 1 - The USB Module is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_USBENSOFEN field. */
#define USB_RD_CTL_USBENSOFEN(base) ((USB_CTL_REG(base) & USB_CTL_USBENSOFEN_MASK) >> USB_CTL_USBENSOFEN_SHIFT)
#define USB_BRD_CTL_USBENSOFEN(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_USBENSOFEN_SHIFT))

/*! @brief Set the USBENSOFEN field to a new value. */
#define USB_WR_CTL_USBENSOFEN(base, value) (USB_RMW_CTL(base, USB_CTL_USBENSOFEN_MASK, USB_CTL_USBENSOFEN(value)))
#define USB_BWR_CTL_USBENSOFEN(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_USBENSOFEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field ODDRST[1] (RW)
 *
 * Setting this bit to 1 resets all the BDT ODD ping/pong bits to 0, which then
 * specifies the EVEN BDT bank.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_ODDRST field. */
#define USB_RD_CTL_ODDRST(base) ((USB_CTL_REG(base) & USB_CTL_ODDRST_MASK) >> USB_CTL_ODDRST_SHIFT)
#define USB_BRD_CTL_ODDRST(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_ODDRST_SHIFT))

/*! @brief Set the ODDRST field to a new value. */
#define USB_WR_CTL_ODDRST(base, value) (USB_RMW_CTL(base, USB_CTL_ODDRST_MASK, USB_CTL_ODDRST(value)))
#define USB_BWR_CTL_ODDRST(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_ODDRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field RESUME[2] (RW)
 *
 * When set to 1 this bit enables the USB Module to execute resume signaling.
 * This allows the USB Module to perform remote wake-up. Software must set RESUME
 * to 1 for the required amount of time and then clear it to 0. If the HOSTMODEEN
 * bit is set, the USB module appends a Low Speed End of Packet to the Resume
 * signaling when the RESUME bit is cleared. For more information on RESUME
 * signaling see Section 7.1.4.5 of the USB specification version 1.0.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_RESUME field. */
#define USB_RD_CTL_RESUME(base) ((USB_CTL_REG(base) & USB_CTL_RESUME_MASK) >> USB_CTL_RESUME_SHIFT)
#define USB_BRD_CTL_RESUME(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_RESUME_SHIFT))

/*! @brief Set the RESUME field to a new value. */
#define USB_WR_CTL_RESUME(base, value) (USB_RMW_CTL(base, USB_CTL_RESUME_MASK, USB_CTL_RESUME(value)))
#define USB_BWR_CTL_RESUME(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_RESUME_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field HOSTMODEEN[3] (RW)
 *
 * When set to 1, this bit enables the USB Module to operate in Host mode. In
 * host mode, the USB module performs USB transactions under the programmed control
 * of the host processor.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_HOSTMODEEN field. */
#define USB_RD_CTL_HOSTMODEEN(base) ((USB_CTL_REG(base) & USB_CTL_HOSTMODEEN_MASK) >> USB_CTL_HOSTMODEEN_SHIFT)
#define USB_BRD_CTL_HOSTMODEEN(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_HOSTMODEEN_SHIFT))

/*! @brief Set the HOSTMODEEN field to a new value. */
#define USB_WR_CTL_HOSTMODEEN(base, value) (USB_RMW_CTL(base, USB_CTL_HOSTMODEEN_MASK, USB_CTL_HOSTMODEEN(value)))
#define USB_BWR_CTL_HOSTMODEEN(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_HOSTMODEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field RESET[4] (RW)
 *
 * Setting this bit enables the USB Module to generate USB reset signaling. This
 * allows the USB Module to reset USB peripherals. This control signal is only
 * valid in Host mode (HOSTMODEEN=1). Software must set RESET to 1 for the
 * required amount of time and then clear it to 0 to end reset signaling. For more
 * information on RESET signaling see Section 7.1.4.3 of the USB specification version
 * 1.0.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_RESET field. */
#define USB_RD_CTL_RESET(base) ((USB_CTL_REG(base) & USB_CTL_RESET_MASK) >> USB_CTL_RESET_SHIFT)
#define USB_BRD_CTL_RESET(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_RESET_SHIFT))

/*! @brief Set the RESET field to a new value. */
#define USB_WR_CTL_RESET(base, value) (USB_RMW_CTL(base, USB_CTL_RESET_MASK, USB_CTL_RESET(value)))
#define USB_BWR_CTL_RESET(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_RESET_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field TXSUSPENDTOKENBUSY[5] (RW)
 *
 * When the USB Module is in Host mode TOKEN_BUSY is set when the USB Module is
 * busy executing a USB token and no more token commands should be written to the
 * Token Register. Software should check this bit before writing any tokens to
 * the Token Register to ensure that token commands are not lost. In Target mode
 * TXD_SUSPEND is set when the SIE has disabled packet transmission and reception.
 * Clearing this bit allows the SIE to continue token processing. This bit is
 * set by the SIE when a Setup Token is received allowing software to dequeue any
 * pending packet transactions in the BDT before resuming token processing.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_TXSUSPENDTOKENBUSY field. */
#define USB_RD_CTL_TXSUSPENDTOKENBUSY(base) ((USB_CTL_REG(base) & USB_CTL_TXSUSPENDTOKENBUSY_MASK) >> USB_CTL_TXSUSPENDTOKENBUSY_SHIFT)
#define USB_BRD_CTL_TXSUSPENDTOKENBUSY(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_TXSUSPENDTOKENBUSY_SHIFT))

/*! @brief Set the TXSUSPENDTOKENBUSY field to a new value. */
#define USB_WR_CTL_TXSUSPENDTOKENBUSY(base, value) (USB_RMW_CTL(base, USB_CTL_TXSUSPENDTOKENBUSY_MASK, USB_CTL_TXSUSPENDTOKENBUSY(value)))
#define USB_BWR_CTL_TXSUSPENDTOKENBUSY(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_TXSUSPENDTOKENBUSY_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field SE0[6] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_SE0 field. */
#define USB_RD_CTL_SE0(base) ((USB_CTL_REG(base) & USB_CTL_SE0_MASK) >> USB_CTL_SE0_SHIFT)
#define USB_BRD_CTL_SE0(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_SE0_SHIFT))

/*! @brief Set the SE0 field to a new value. */
#define USB_WR_CTL_SE0(base, value) (USB_RMW_CTL(base, USB_CTL_SE0_MASK, USB_CTL_SE0(value)))
#define USB_BWR_CTL_SE0(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_SE0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field JSTATE[7] (RW)
 *
 * The polarity of this signal is affected by the current state of LSEN .
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_JSTATE field. */
#define USB_RD_CTL_JSTATE(base) ((USB_CTL_REG(base) & USB_CTL_JSTATE_MASK) >> USB_CTL_JSTATE_SHIFT)
#define USB_BRD_CTL_JSTATE(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_JSTATE_SHIFT))

/*! @brief Set the JSTATE field to a new value. */
#define USB_WR_CTL_JSTATE(base, value) (USB_RMW_CTL(base, USB_CTL_JSTATE_MASK, USB_CTL_JSTATE(value)))
#define USB_BWR_CTL_JSTATE(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_JSTATE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_ADDR - Address Register
 ******************************************************************************/

/*!
 * @brief USB_ADDR - Address Register (RW)
 *
 * Reset value: 0x00U
 *
 * The Address Register holds the unique USB address that the USB Module decodes
 * when in Peripheral mode (HOSTMODEEN=0). When operating in Host mode
 * (HOSTMODEEN=1) the USB Module transmits this address with a TOKEN packet. This enables
 * the USB Module to uniquely address an USB peripheral. In either mode, the
 * USB_EN bit within the control register must be set. The Address Register is reset
 * to 0x00 after the reset input becomes active or the USB Module decodes a USB
 * reset signal. This action initializes the Address Register to decode address
 * 0x00 as required by the USB specification.
 */
/*!
 * @name Constants and macros for entire USB_ADDR register
 */
/*@{*/
#define USB_RD_ADDR(base)        (USB_ADDR_REG(base))
#define USB_WR_ADDR(base, value) (USB_ADDR_REG(base) = (value))
#define USB_RMW_ADDR(base, mask, value) (USB_WR_ADDR(base, (USB_RD_ADDR(base) & ~(mask)) | (value)))
#define USB_SET_ADDR(base, value) (USB_WR_ADDR(base, USB_RD_ADDR(base) |  (value)))
#define USB_CLR_ADDR(base, value) (USB_WR_ADDR(base, USB_RD_ADDR(base) & ~(value)))
#define USB_TOG_ADDR(base, value) (USB_WR_ADDR(base, USB_RD_ADDR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ADDR bitfields
 */

/*!
 * @name Register USB_ADDR, field ADDR[6:0] (RW)
 *
 * This 7-bit value defines the USB address that the USB Module decodes in
 * peripheral mode, or transmit when in host mode.
 */
/*@{*/
/*! @brief Read current value of the USB_ADDR_ADDR field. */
#define USB_RD_ADDR_ADDR(base) ((USB_ADDR_REG(base) & USB_ADDR_ADDR_MASK) >> USB_ADDR_ADDR_SHIFT)
#define USB_BRD_ADDR_ADDR(base) (USB_RD_ADDR_ADDR(base))

/*! @brief Set the ADDR field to a new value. */
#define USB_WR_ADDR_ADDR(base, value) (USB_RMW_ADDR(base, USB_ADDR_ADDR_MASK, USB_ADDR_ADDR(value)))
#define USB_BWR_ADDR_ADDR(base, value) (USB_WR_ADDR_ADDR(base, value))
/*@}*/

/*!
 * @name Register USB_ADDR, field LSEN[7] (RW)
 *
 * This bit informs the USB Module that the next token command written to the
 * token register must be performed at low speed. This enables the USB Module to
 * perform the necessary preamble required for low-speed data transmissions.
 */
/*@{*/
/*! @brief Read current value of the USB_ADDR_LSEN field. */
#define USB_RD_ADDR_LSEN(base) ((USB_ADDR_REG(base) & USB_ADDR_LSEN_MASK) >> USB_ADDR_LSEN_SHIFT)
#define USB_BRD_ADDR_LSEN(base) (BITBAND_ACCESS8(&USB_ADDR_REG(base), USB_ADDR_LSEN_SHIFT))

/*! @brief Set the LSEN field to a new value. */
#define USB_WR_ADDR_LSEN(base, value) (USB_RMW_ADDR(base, USB_ADDR_LSEN_MASK, USB_ADDR_LSEN(value)))
#define USB_BWR_ADDR_LSEN(base, value) (BITBAND_ACCESS8(&USB_ADDR_REG(base), USB_ADDR_LSEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_BDTPAGE1 - BDT Page Register 1
 ******************************************************************************/

/*!
 * @brief USB_BDTPAGE1 - BDT Page Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The Buffer Descriptor Table Page Register 1 provides address bits 15 through
 * 9 of the base address where the current Buffer Descriptor Table (BDT) resides
 * in system memory. The 32-bit BDT Base Address is always aligned on 512-byte
 * boundaries, so bits 8 through 0 of the base address are always taken as zero.
 */
/*!
 * @name Constants and macros for entire USB_BDTPAGE1 register
 */
/*@{*/
#define USB_RD_BDTPAGE1(base)    (USB_BDTPAGE1_REG(base))
#define USB_WR_BDTPAGE1(base, value) (USB_BDTPAGE1_REG(base) = (value))
#define USB_RMW_BDTPAGE1(base, mask, value) (USB_WR_BDTPAGE1(base, (USB_RD_BDTPAGE1(base) & ~(mask)) | (value)))
#define USB_SET_BDTPAGE1(base, value) (USB_WR_BDTPAGE1(base, USB_RD_BDTPAGE1(base) |  (value)))
#define USB_CLR_BDTPAGE1(base, value) (USB_WR_BDTPAGE1(base, USB_RD_BDTPAGE1(base) & ~(value)))
#define USB_TOG_BDTPAGE1(base, value) (USB_WR_BDTPAGE1(base, USB_RD_BDTPAGE1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE1 bitfields
 */

/*!
 * @name Register USB_BDTPAGE1, field BDTBA[7:1] (RW)
 *
 * This field provides address bits 15 through 9 of the BDT base address.
 */
/*@{*/
/*! @brief Read current value of the USB_BDTPAGE1_BDTBA field. */
#define USB_RD_BDTPAGE1_BDTBA(base) ((USB_BDTPAGE1_REG(base) & USB_BDTPAGE1_BDTBA_MASK) >> USB_BDTPAGE1_BDTBA_SHIFT)
#define USB_BRD_BDTPAGE1_BDTBA(base) (USB_RD_BDTPAGE1_BDTBA(base))

/*! @brief Set the BDTBA field to a new value. */
#define USB_WR_BDTPAGE1_BDTBA(base, value) (USB_RMW_BDTPAGE1(base, USB_BDTPAGE1_BDTBA_MASK, USB_BDTPAGE1_BDTBA(value)))
#define USB_BWR_BDTPAGE1_BDTBA(base, value) (USB_WR_BDTPAGE1_BDTBA(base, value))
/*@}*/

/*******************************************************************************
 * USB_FRMNUML - Frame Number Register Low
 ******************************************************************************/

/*!
 * @brief USB_FRMNUML - Frame Number Register Low (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number Register (Low and High) contains an 11-bit value used to
 * compute the address where the current Buffer Descriptor Table (BDT) resides in
 * system memory.
 */
/*!
 * @name Constants and macros for entire USB_FRMNUML register
 */
/*@{*/
#define USB_RD_FRMNUML(base)     (USB_FRMNUML_REG(base))
#define USB_WR_FRMNUML(base, value) (USB_FRMNUML_REG(base) = (value))
#define USB_RMW_FRMNUML(base, mask, value) (USB_WR_FRMNUML(base, (USB_RD_FRMNUML(base) & ~(mask)) | (value)))
#define USB_SET_FRMNUML(base, value) (USB_WR_FRMNUML(base, USB_RD_FRMNUML(base) |  (value)))
#define USB_CLR_FRMNUML(base, value) (USB_WR_FRMNUML(base, USB_RD_FRMNUML(base) & ~(value)))
#define USB_TOG_FRMNUML(base, value) (USB_WR_FRMNUML(base, USB_RD_FRMNUML(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * USB_FRMNUMH - Frame Number Register High
 ******************************************************************************/

/*!
 * @brief USB_FRMNUMH - Frame Number Register High (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number Register (Low and High) contains an 11-bit value used to
 * compute the address where the current Buffer Descriptor Table (BDT) resides in
 * system memory.
 */
/*!
 * @name Constants and macros for entire USB_FRMNUMH register
 */
/*@{*/
#define USB_RD_FRMNUMH(base)     (USB_FRMNUMH_REG(base))
#define USB_WR_FRMNUMH(base, value) (USB_FRMNUMH_REG(base) = (value))
#define USB_RMW_FRMNUMH(base, mask, value) (USB_WR_FRMNUMH(base, (USB_RD_FRMNUMH(base) & ~(mask)) | (value)))
#define USB_SET_FRMNUMH(base, value) (USB_WR_FRMNUMH(base, USB_RD_FRMNUMH(base) |  (value)))
#define USB_CLR_FRMNUMH(base, value) (USB_WR_FRMNUMH(base, USB_RD_FRMNUMH(base) & ~(value)))
#define USB_TOG_FRMNUMH(base, value) (USB_WR_FRMNUMH(base, USB_RD_FRMNUMH(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUMH bitfields
 */

/*!
 * @name Register USB_FRMNUMH, field FRM[2:0] (RW)
 *
 * This 3-bit field and the 8-bit field in the Frame Number Register Low are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
/*! @brief Read current value of the USB_FRMNUMH_FRM field. */
#define USB_RD_FRMNUMH_FRM(base) ((USB_FRMNUMH_REG(base) & USB_FRMNUMH_FRM_MASK) >> USB_FRMNUMH_FRM_SHIFT)
#define USB_BRD_FRMNUMH_FRM(base) (USB_RD_FRMNUMH_FRM(base))

/*! @brief Set the FRM field to a new value. */
#define USB_WR_FRMNUMH_FRM(base, value) (USB_RMW_FRMNUMH(base, USB_FRMNUMH_FRM_MASK, USB_FRMNUMH_FRM(value)))
#define USB_BWR_FRMNUMH_FRM(base, value) (USB_WR_FRMNUMH_FRM(base, value))
/*@}*/

/*******************************************************************************
 * USB_TOKEN - Token Register
 ******************************************************************************/

/*!
 * @brief USB_TOKEN - Token Register (RW)
 *
 * Reset value: 0x00U
 *
 * The Token Register is used to perform USB transactions when in host mode
 * (HOSTMODEEN=1). When the processor core wishes to execute a USB transaction to a
 * peripheral, it writes the TOKEN type and endpoint to this register. After this
 * register has been written, the USB module begins the specified USB transaction
 * to the address contained in the address register. The processor core should
 * always check that the TOKEN_BUSY bit in the control register is not set before
 * performing a write to the Token Register. This ensures token commands are not
 * overwritten before they can be executed. The address register and endpoint
 * control register 0 are also used when performing a token command and therefore
 * must also be written before the Token Register. The address register is used to
 * correctly select the USB peripheral address transmitted by the token command.
 * The endpoint control register determines the handshake and retry policies used
 * during the transfer.
 */
/*!
 * @name Constants and macros for entire USB_TOKEN register
 */
/*@{*/
#define USB_RD_TOKEN(base)       (USB_TOKEN_REG(base))
#define USB_WR_TOKEN(base, value) (USB_TOKEN_REG(base) = (value))
#define USB_RMW_TOKEN(base, mask, value) (USB_WR_TOKEN(base, (USB_RD_TOKEN(base) & ~(mask)) | (value)))
#define USB_SET_TOKEN(base, value) (USB_WR_TOKEN(base, USB_RD_TOKEN(base) |  (value)))
#define USB_CLR_TOKEN(base, value) (USB_WR_TOKEN(base, USB_RD_TOKEN(base) & ~(value)))
#define USB_TOG_TOKEN(base, value) (USB_WR_TOKEN(base, USB_RD_TOKEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_TOKEN bitfields
 */

/*!
 * @name Register USB_TOKEN, field TOKENENDPT[3:0] (RW)
 *
 * This 4 bit field holds the Endpoint address for the token command. The four
 * bit value written must be a valid endpoint.
 */
/*@{*/
/*! @brief Read current value of the USB_TOKEN_TOKENENDPT field. */
#define USB_RD_TOKEN_TOKENENDPT(base) ((USB_TOKEN_REG(base) & USB_TOKEN_TOKENENDPT_MASK) >> USB_TOKEN_TOKENENDPT_SHIFT)
#define USB_BRD_TOKEN_TOKENENDPT(base) (USB_RD_TOKEN_TOKENENDPT(base))

/*! @brief Set the TOKENENDPT field to a new value. */
#define USB_WR_TOKEN_TOKENENDPT(base, value) (USB_RMW_TOKEN(base, USB_TOKEN_TOKENENDPT_MASK, USB_TOKEN_TOKENENDPT(value)))
#define USB_BWR_TOKEN_TOKENENDPT(base, value) (USB_WR_TOKEN_TOKENENDPT(base, value))
/*@}*/

/*!
 * @name Register USB_TOKEN, field TOKENPID[7:4] (RW)
 *
 * This 4-bit field contains the token type executed by the USB Module.
 *
 * Values:
 * - 0001 - OUT Token. USB Module performs an OUT (TX) transaction.
 * - 1001 - IN Token. USB Module performs an In (RX) transaction.
 * - 1101 - SETUP Token. USB Module performs a SETUP (TX) transaction
 */
/*@{*/
/*! @brief Read current value of the USB_TOKEN_TOKENPID field. */
#define USB_RD_TOKEN_TOKENPID(base) ((USB_TOKEN_REG(base) & USB_TOKEN_TOKENPID_MASK) >> USB_TOKEN_TOKENPID_SHIFT)
#define USB_BRD_TOKEN_TOKENPID(base) (USB_RD_TOKEN_TOKENPID(base))

/*! @brief Set the TOKENPID field to a new value. */
#define USB_WR_TOKEN_TOKENPID(base, value) (USB_RMW_TOKEN(base, USB_TOKEN_TOKENPID_MASK, USB_TOKEN_TOKENPID(value)))
#define USB_BWR_TOKEN_TOKENPID(base, value) (USB_WR_TOKEN_TOKENPID(base, value))
/*@}*/

/*******************************************************************************
 * USB_SOFTHLD - SOF Threshold Register
 ******************************************************************************/

/*!
 * @brief USB_SOFTHLD - SOF Threshold Register (RW)
 *
 * Reset value: 0x00U
 *
 * The SOF Threshold Register is used only in Hosts mode (HOSTMODEEN=1). When in
 * Host mode, the 14-bit SOF counter counts the interval between SOF frames. The
 * SOF must be transmitted every 1msec so the SOF counter is loaded with a value
 * of 12000. When the SOF counter reaches zero, a Start Of Frame (SOF) token is
 * transmitted. The SOF threshold register is used to program the number of USB
 * byte times before the SOF to stop initiating token packet transactions. This
 * register must be set to a value that ensures that other packets are not actively
 * being transmitted when the SOF time counts to zero. When the SOF counter
 * reaches the threshold value, no more tokens are transmitted until after the SOF ha
 * been transmitted. The value programmed into the threshold register must
 * reserve enough time to ensure the worst case transaction completes. In general the
 * worst case transaction is a IN token followed by a data packet from the target
 * followed by the response from the host. The actual time required is a
 * function of the maximum packet size on the bus. Typical values for the SOF threshold
 * are: 64-byte packets=74; 32-byte packets=42; 16-byte packets=26; 8-byte
 * packets=18.
 */
/*!
 * @name Constants and macros for entire USB_SOFTHLD register
 */
/*@{*/
#define USB_RD_SOFTHLD(base)     (USB_SOFTHLD_REG(base))
#define USB_WR_SOFTHLD(base, value) (USB_SOFTHLD_REG(base) = (value))
#define USB_RMW_SOFTHLD(base, mask, value) (USB_WR_SOFTHLD(base, (USB_RD_SOFTHLD(base) & ~(mask)) | (value)))
#define USB_SET_SOFTHLD(base, value) (USB_WR_SOFTHLD(base, USB_RD_SOFTHLD(base) |  (value)))
#define USB_CLR_SOFTHLD(base, value) (USB_WR_SOFTHLD(base, USB_RD_SOFTHLD(base) & ~(value)))
#define USB_TOG_SOFTHLD(base, value) (USB_WR_SOFTHLD(base, USB_RD_SOFTHLD(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * USB_BDTPAGE2 - BDT Page Register 2
 ******************************************************************************/

/*!
 * @brief USB_BDTPAGE2 - BDT Page Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The Buffer Descriptor Table Page Register 2 contains an 8-bit value used to
 * compute the address where the current Buffer Descriptor Table (BDT) resides in
 * system memory.
 */
/*!
 * @name Constants and macros for entire USB_BDTPAGE2 register
 */
/*@{*/
#define USB_RD_BDTPAGE2(base)    (USB_BDTPAGE2_REG(base))
#define USB_WR_BDTPAGE2(base, value) (USB_BDTPAGE2_REG(base) = (value))
#define USB_RMW_BDTPAGE2(base, mask, value) (USB_WR_BDTPAGE2(base, (USB_RD_BDTPAGE2(base) & ~(mask)) | (value)))
#define USB_SET_BDTPAGE2(base, value) (USB_WR_BDTPAGE2(base, USB_RD_BDTPAGE2(base) |  (value)))
#define USB_CLR_BDTPAGE2(base, value) (USB_WR_BDTPAGE2(base, USB_RD_BDTPAGE2(base) & ~(value)))
#define USB_TOG_BDTPAGE2(base, value) (USB_WR_BDTPAGE2(base, USB_RD_BDTPAGE2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * USB_BDTPAGE3 - BDT Page Register 3
 ******************************************************************************/

/*!
 * @brief USB_BDTPAGE3 - BDT Page Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * The Buffer Descriptor Table Page Register 3 contains an 8-bit value used to
 * compute the address where the current Buffer Descriptor Table (BDT) resides in
 * system memory.
 */
/*!
 * @name Constants and macros for entire USB_BDTPAGE3 register
 */
/*@{*/
#define USB_RD_BDTPAGE3(base)    (USB_BDTPAGE3_REG(base))
#define USB_WR_BDTPAGE3(base, value) (USB_BDTPAGE3_REG(base) = (value))
#define USB_RMW_BDTPAGE3(base, mask, value) (USB_WR_BDTPAGE3(base, (USB_RD_BDTPAGE3(base) & ~(mask)) | (value)))
#define USB_SET_BDTPAGE3(base, value) (USB_WR_BDTPAGE3(base, USB_RD_BDTPAGE3(base) |  (value)))
#define USB_CLR_BDTPAGE3(base, value) (USB_WR_BDTPAGE3(base, USB_RD_BDTPAGE3(base) & ~(value)))
#define USB_TOG_BDTPAGE3(base, value) (USB_WR_BDTPAGE3(base, USB_RD_BDTPAGE3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * USB_ENDPT - Endpoint Control Register
 ******************************************************************************/

/*!
 * @brief USB_ENDPT - Endpoint Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The Endpoint Control Registers contain the endpoint control bits for each of
 * the 16 endpoints available within the USB Module for a decoded address. The
 * format for these registers is shown in the following figure. Endpoint 0 (ENDPT0)
 * is associated with control pipe 0, which is required for all USB functions.
 * Therefore, after a USBRST interrupt occurs the processor core should set the
 * ENDPT0 register to contain 0x0D. In Host mode ENDPT0 is used to determine the
 * handshake, retry and low speed characteristics of the host transfer. For Host
 * mode control, bulk and interrupt transfers the EPHSHK bit should be set to 1.
 * For Isochronous transfers it should be set to 0. Common values to use for ENDPT0
 * in host mode are 0x4D for Control, Bulk, and Interrupt transfers, and 0x4C
 * for Isochronous transfers.
 */
/*!
 * @name Constants and macros for entire USB_ENDPT register
 */
/*@{*/
#define USB_RD_ENDPT(base, index) (USB_ENDPT_REG(base, index))
#define USB_WR_ENDPT(base, index, value) (USB_ENDPT_REG(base, index) = (value))
#define USB_RMW_ENDPT(base, index, mask, value) (USB_WR_ENDPT(base, index, (USB_RD_ENDPT(base, index) & ~(mask)) | (value)))
#define USB_SET_ENDPT(base, index, value) (USB_WR_ENDPT(base, index, USB_RD_ENDPT(base, index) |  (value)))
#define USB_CLR_ENDPT(base, index, value) (USB_WR_ENDPT(base, index, USB_RD_ENDPT(base, index) & ~(value)))
#define USB_TOG_ENDPT(base, index, value) (USB_WR_ENDPT(base, index, USB_RD_ENDPT(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ENDPT bitfields
 */

/*!
 * @name Register USB_ENDPT, field EPHSHK[0] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPHSHK field. */
#define USB_RD_ENDPT_EPHSHK(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPHSHK_MASK) >> USB_ENDPT_EPHSHK_SHIFT)
#define USB_BRD_ENDPT_EPHSHK(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPHSHK_SHIFT))

/*! @brief Set the EPHSHK field to a new value. */
#define USB_WR_ENDPT_EPHSHK(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPHSHK_MASK, USB_ENDPT_EPHSHK(value)))
#define USB_BWR_ENDPT_EPHSHK(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPHSHK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPSTALL[1] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPSTALL field. */
#define USB_RD_ENDPT_EPSTALL(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPSTALL_MASK) >> USB_ENDPT_EPSTALL_SHIFT)
#define USB_BRD_ENDPT_EPSTALL(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPSTALL_SHIFT))

/*! @brief Set the EPSTALL field to a new value. */
#define USB_WR_ENDPT_EPSTALL(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPSTALL_MASK, USB_ENDPT_EPSTALL(value)))
#define USB_BWR_ENDPT_EPSTALL(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPTXEN[2] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPTXEN field. */
#define USB_RD_ENDPT_EPTXEN(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPTXEN_MASK) >> USB_ENDPT_EPTXEN_SHIFT)
#define USB_BRD_ENDPT_EPTXEN(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPTXEN_SHIFT))

/*! @brief Set the EPTXEN field to a new value. */
#define USB_WR_ENDPT_EPTXEN(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPTXEN_MASK, USB_ENDPT_EPTXEN(value)))
#define USB_BWR_ENDPT_EPTXEN(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPTXEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPRXEN[3] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPRXEN field. */
#define USB_RD_ENDPT_EPRXEN(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPRXEN_MASK) >> USB_ENDPT_EPRXEN_SHIFT)
#define USB_BRD_ENDPT_EPRXEN(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPRXEN_SHIFT))

/*! @brief Set the EPRXEN field to a new value. */
#define USB_WR_ENDPT_EPRXEN(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPRXEN_MASK, USB_ENDPT_EPRXEN(value)))
#define USB_BWR_ENDPT_EPRXEN(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPRXEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPCTLDIS[4] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPCTLDIS field. */
#define USB_RD_ENDPT_EPCTLDIS(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPCTLDIS_MASK) >> USB_ENDPT_EPCTLDIS_SHIFT)
#define USB_BRD_ENDPT_EPCTLDIS(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPCTLDIS_SHIFT))

/*! @brief Set the EPCTLDIS field to a new value. */
#define USB_WR_ENDPT_EPCTLDIS(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPCTLDIS_MASK, USB_ENDPT_EPCTLDIS(value)))
#define USB_BWR_ENDPT_EPCTLDIS(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPCTLDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field RETRYDIS[6] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_RETRYDIS field. */
#define USB_RD_ENDPT_RETRYDIS(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_RETRYDIS_MASK) >> USB_ENDPT_RETRYDIS_SHIFT)
#define USB_BRD_ENDPT_RETRYDIS(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_RETRYDIS_SHIFT))

/*! @brief Set the RETRYDIS field to a new value. */
#define USB_WR_ENDPT_RETRYDIS(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_RETRYDIS_MASK, USB_ENDPT_RETRYDIS(value)))
#define USB_BWR_ENDPT_RETRYDIS(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_RETRYDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field HOSTWOHUB[7] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_HOSTWOHUB field. */
#define USB_RD_ENDPT_HOSTWOHUB(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_HOSTWOHUB_MASK) >> USB_ENDPT_HOSTWOHUB_SHIFT)
#define USB_BRD_ENDPT_HOSTWOHUB(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_HOSTWOHUB_SHIFT))

/*! @brief Set the HOSTWOHUB field to a new value. */
#define USB_WR_ENDPT_HOSTWOHUB(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_HOSTWOHUB_MASK, USB_ENDPT_HOSTWOHUB(value)))
#define USB_BWR_ENDPT_HOSTWOHUB(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_HOSTWOHUB_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_USBCTRL - USB Control Register
 ******************************************************************************/

/*!
 * @brief USB_USBCTRL - USB Control Register (RW)
 *
 * Reset value: 0xC0U
 */
/*!
 * @name Constants and macros for entire USB_USBCTRL register
 */
/*@{*/
#define USB_RD_USBCTRL(base)     (USB_USBCTRL_REG(base))
#define USB_WR_USBCTRL(base, value) (USB_USBCTRL_REG(base) = (value))
#define USB_RMW_USBCTRL(base, mask, value) (USB_WR_USBCTRL(base, (USB_RD_USBCTRL(base) & ~(mask)) | (value)))
#define USB_SET_USBCTRL(base, value) (USB_WR_USBCTRL(base, USB_RD_USBCTRL(base) |  (value)))
#define USB_CLR_USBCTRL(base, value) (USB_WR_USBCTRL(base, USB_RD_USBCTRL(base) & ~(value)))
#define USB_TOG_USBCTRL(base, value) (USB_WR_USBCTRL(base, USB_RD_USBCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_USBCTRL bitfields
 */

/*!
 * @name Register USB_USBCTRL, field PDE[6] (RW)
 *
 * Enables the weak pulldowns on the USB transceiver.
 *
 * Values:
 * - 0 - Weak pulldowns are disabled on D+ and D-
 * - 1 - Weak pulldowns are enabled on D+ and D-.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_PDE field. */
#define USB_RD_USBCTRL_PDE(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_PDE_MASK) >> USB_USBCTRL_PDE_SHIFT)
#define USB_BRD_USBCTRL_PDE(base) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_PDE_SHIFT))

/*! @brief Set the PDE field to a new value. */
#define USB_WR_USBCTRL_PDE(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_PDE_MASK, USB_USBCTRL_PDE(value)))
#define USB_BWR_USBCTRL_PDE(base, value) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_PDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field SUSP[7] (RW)
 *
 * Places the USB transceiver into the suspend state.
 *
 * Values:
 * - 0 - USB transceiver is not in suspend state.
 * - 1 - USB transceiver is in suspend state.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_SUSP field. */
#define USB_RD_USBCTRL_SUSP(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_SUSP_MASK) >> USB_USBCTRL_SUSP_SHIFT)
#define USB_BRD_USBCTRL_SUSP(base) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_SUSP_SHIFT))

/*! @brief Set the SUSP field to a new value. */
#define USB_WR_USBCTRL_SUSP(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_SUSP_MASK, USB_USBCTRL_SUSP(value)))
#define USB_BWR_USBCTRL_SUSP(base, value) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_SUSP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_OBSERVE - USB OTG Observe Register
 ******************************************************************************/

/*!
 * @brief USB_OBSERVE - USB OTG Observe Register (RO)
 *
 * Reset value: 0x50U
 *
 * Provides visibility on the state of the pull-ups and pull-downs at the
 * transceiver. Useful when interfacing to an external OTG control module via a serial
 * interface.
 */
/*!
 * @name Constants and macros for entire USB_OBSERVE register
 */
/*@{*/
#define USB_RD_OBSERVE(base)     (USB_OBSERVE_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_OBSERVE bitfields
 */

/*!
 * @name Register USB_OBSERVE, field DMPD[4] (RO)
 *
 * Provides observability of the D- Pull Down enable at the USB transceiver.
 *
 * Values:
 * - 0 - D- pulldown disabled.
 * - 1 - D- pulldown enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OBSERVE_DMPD field. */
#define USB_RD_OBSERVE_DMPD(base) ((USB_OBSERVE_REG(base) & USB_OBSERVE_DMPD_MASK) >> USB_OBSERVE_DMPD_SHIFT)
#define USB_BRD_OBSERVE_DMPD(base) (BITBAND_ACCESS8(&USB_OBSERVE_REG(base), USB_OBSERVE_DMPD_SHIFT))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPD[6] (RO)
 *
 * Provides observability of the D+ Pull Down enable at the USB transceiver.
 *
 * Values:
 * - 0 - D+ pulldown disabled.
 * - 1 - D+ pulldown enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OBSERVE_DPPD field. */
#define USB_RD_OBSERVE_DPPD(base) ((USB_OBSERVE_REG(base) & USB_OBSERVE_DPPD_MASK) >> USB_OBSERVE_DPPD_SHIFT)
#define USB_BRD_OBSERVE_DPPD(base) (BITBAND_ACCESS8(&USB_OBSERVE_REG(base), USB_OBSERVE_DPPD_SHIFT))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPU[7] (RO)
 *
 * Provides observability of the D+ Pull Up enable at the USB transceiver.
 *
 * Values:
 * - 0 - D+ pullup disabled.
 * - 1 - D+ pullup enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OBSERVE_DPPU field. */
#define USB_RD_OBSERVE_DPPU(base) ((USB_OBSERVE_REG(base) & USB_OBSERVE_DPPU_MASK) >> USB_OBSERVE_DPPU_SHIFT)
#define USB_BRD_OBSERVE_DPPU(base) (BITBAND_ACCESS8(&USB_OBSERVE_REG(base), USB_OBSERVE_DPPU_SHIFT))
/*@}*/

/*******************************************************************************
 * USB_CONTROL - USB OTG Control Register
 ******************************************************************************/

/*!
 * @brief USB_CONTROL - USB OTG Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire USB_CONTROL register
 */
/*@{*/
#define USB_RD_CONTROL(base)     (USB_CONTROL_REG(base))
#define USB_WR_CONTROL(base, value) (USB_CONTROL_REG(base) = (value))
#define USB_RMW_CONTROL(base, mask, value) (USB_WR_CONTROL(base, (USB_RD_CONTROL(base) & ~(mask)) | (value)))
#define USB_SET_CONTROL(base, value) (USB_WR_CONTROL(base, USB_RD_CONTROL(base) |  (value)))
#define USB_CLR_CONTROL(base, value) (USB_WR_CONTROL(base, USB_RD_CONTROL(base) & ~(value)))
#define USB_TOG_CONTROL(base, value) (USB_WR_CONTROL(base, USB_RD_CONTROL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_CONTROL bitfields
 */

/*!
 * @name Register USB_CONTROL, field DPPULLUPNONOTG[4] (RW)
 *
 * Provides control of the DP PULLUP in the USB OTG module, if USB is configured
 * in non-OTG device mode.
 *
 * Values:
 * - 0 - DP Pull up in non-OTG device mode is not enabled.
 * - 1 - DP Pull up in non-OTG device mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_CONTROL_DPPULLUPNONOTG field. */
#define USB_RD_CONTROL_DPPULLUPNONOTG(base) ((USB_CONTROL_REG(base) & USB_CONTROL_DPPULLUPNONOTG_MASK) >> USB_CONTROL_DPPULLUPNONOTG_SHIFT)
#define USB_BRD_CONTROL_DPPULLUPNONOTG(base) (BITBAND_ACCESS8(&USB_CONTROL_REG(base), USB_CONTROL_DPPULLUPNONOTG_SHIFT))

/*! @brief Set the DPPULLUPNONOTG field to a new value. */
#define USB_WR_CONTROL_DPPULLUPNONOTG(base, value) (USB_RMW_CONTROL(base, USB_CONTROL_DPPULLUPNONOTG_MASK, USB_CONTROL_DPPULLUPNONOTG(value)))
#define USB_BWR_CONTROL_DPPULLUPNONOTG(base, value) (BITBAND_ACCESS8(&USB_CONTROL_REG(base), USB_CONTROL_DPPULLUPNONOTG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_USBTRC0 - USB Transceiver Control Register 0
 ******************************************************************************/

/*!
 * @brief USB_USBTRC0 - USB Transceiver Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire USB_USBTRC0 register
 */
/*@{*/
#define USB_RD_USBTRC0(base)     (USB_USBTRC0_REG(base))
#define USB_WR_USBTRC0(base, value) (USB_USBTRC0_REG(base) = (value))
#define USB_RMW_USBTRC0(base, mask, value) (USB_WR_USBTRC0(base, (USB_RD_USBTRC0(base) & ~(mask)) | (value)))
#define USB_SET_USBTRC0(base, value) (USB_WR_USBTRC0(base, USB_RD_USBTRC0(base) |  (value)))
#define USB_CLR_USBTRC0(base, value) (USB_WR_USBTRC0(base, USB_RD_USBTRC0(base) & ~(value)))
#define USB_TOG_USBTRC0(base, value) (USB_WR_USBTRC0(base, USB_RD_USBTRC0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_USBTRC0 bitfields
 */

/*!
 * @name Register USB_USBTRC0, field USB_RESUME_INT[0] (RO)
 *
 * Values:
 * - 0 - No interrupt was generated.
 * - 1 - Interrupt was generated because of the USB asynchronous interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_USB_RESUME_INT field. */
#define USB_RD_USBTRC0_USB_RESUME_INT(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_USB_RESUME_INT_MASK) >> USB_USBTRC0_USB_RESUME_INT_SHIFT)
#define USB_BRD_USBTRC0_USB_RESUME_INT(base) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_USB_RESUME_INT_SHIFT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field SYNC_DET[1] (RO)
 *
 * Values:
 * - 0 - Synchronous interrupt has not been detected.
 * - 1 - Synchronous interrupt has been detected.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_SYNC_DET field. */
#define USB_RD_USBTRC0_SYNC_DET(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_SYNC_DET_MASK) >> USB_USBTRC0_SYNC_DET_SHIFT)
#define USB_BRD_USBTRC0_SYNC_DET(base) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_SYNC_DET_SHIFT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESMEN[5] (RW)
 *
 * This bit, when set, allows the USB module to send an asynchronous wakeup
 * event to the MCU upon detection of resume signaling on the USB bus. The MCU then
 * re-enables clocks to the USB module. It is used for low-power suspend mode when
 * USB module clocks are stopped or the USB transceiver is in Suspend mode.
 * Async wakeup only works in device mode.
 *
 * Values:
 * - 0 - USB asynchronous wakeup from suspend mode disabled.
 * - 1 - USB asynchronous wakeup from suspend mode enabled. The asynchronous
 *     resume interrupt differs from the synchronous resume interrupt in that it
 *     asynchronously detects K-state using the unfiltered state of the D+ and D-
 *     pins. This interupt should only be enabled when the Transceiver is suspended.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_USBRESMEN field. */
#define USB_RD_USBTRC0_USBRESMEN(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_USBRESMEN_MASK) >> USB_USBTRC0_USBRESMEN_SHIFT)
#define USB_BRD_USBTRC0_USBRESMEN(base) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_USBRESMEN_SHIFT))

/*! @brief Set the USBRESMEN field to a new value. */
#define USB_WR_USBTRC0_USBRESMEN(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_USBRESMEN_MASK, USB_USBTRC0_USBRESMEN(value)))
#define USB_BWR_USBTRC0_USBRESMEN(base, value) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_USBRESMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESET[7] (WO)
 *
 * Generates a hard reset to the USB_OTG module. After this bit is set and the
 * reset occurs, this bit is automatically cleared. It is always read as zero.
 *
 * Values:
 * - 0 - Normal USB module operation.
 * - 1 - Returns the USB module to its reset state.
 */
/*@{*/
/*! @brief Set the USBRESET field to a new value. */
#define USB_WR_USBTRC0_USBRESET(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_USBRESET_MASK, USB_USBTRC0_USBRESET(value)))
#define USB_BWR_USBTRC0_USBRESET(base, value) (USB_WR_USBTRC0_USBRESET(base, value))
/*@}*/

/*******************************************************************************
 * USB_USBFRMADJUST - Frame Adjust Register
 ******************************************************************************/

/*!
 * @brief USB_USBFRMADJUST - Frame Adjust Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire USB_USBFRMADJUST register
 */
/*@{*/
#define USB_RD_USBFRMADJUST(base) (USB_USBFRMADJUST_REG(base))
#define USB_WR_USBFRMADJUST(base, value) (USB_USBFRMADJUST_REG(base) = (value))
#define USB_RMW_USBFRMADJUST(base, mask, value) (USB_WR_USBFRMADJUST(base, (USB_RD_USBFRMADJUST(base) & ~(mask)) | (value)))
#define USB_SET_USBFRMADJUST(base, value) (USB_WR_USBFRMADJUST(base, USB_RD_USBFRMADJUST(base) |  (value)))
#define USB_CLR_USBFRMADJUST(base, value) (USB_WR_USBFRMADJUST(base, USB_RD_USBFRMADJUST(base) & ~(value)))
#define USB_TOG_USBFRMADJUST(base, value) (USB_WR_USBFRMADJUST(base, USB_RD_USBFRMADJUST(base) ^  (value)))
/*@}*/

/*
 * MK20D5 USBDCD
 *
 * USB Device Charger Detection module
 *
 * Registers defined in this header file:
 * - USBDCD_CONTROL - Control Register
 * - USBDCD_CLOCK - Clock Register
 * - USBDCD_STATUS - Status Register
 * - USBDCD_TIMER0 - TIMER0 Register
 * - USBDCD_TIMER1 -
 * - USBDCD_TIMER2 -
 */

#define USBDCD_INSTANCE_COUNT (1U) /*!< Number of instances of the USBDCD module. */
#define USBDCD_IDX (0U) /*!< Instance number for USBDCD. */

/*******************************************************************************
 * USBDCD_CONTROL - Control Register
 ******************************************************************************/

/*!
 * @brief USBDCD_CONTROL - Control Register (RW)
 *
 * Reset value: 0x00010000U
 *
 * Contains the control and interrupt bit fields.
 */
/*!
 * @name Constants and macros for entire USBDCD_CONTROL register
 */
/*@{*/
#define USBDCD_RD_CONTROL(base)  (USBDCD_CONTROL_REG(base))
#define USBDCD_WR_CONTROL(base, value) (USBDCD_CONTROL_REG(base) = (value))
#define USBDCD_RMW_CONTROL(base, mask, value) (USBDCD_WR_CONTROL(base, (USBDCD_RD_CONTROL(base) & ~(mask)) | (value)))
#define USBDCD_SET_CONTROL(base, value) (USBDCD_WR_CONTROL(base, USBDCD_RD_CONTROL(base) |  (value)))
#define USBDCD_CLR_CONTROL(base, value) (USBDCD_WR_CONTROL(base, USBDCD_RD_CONTROL(base) & ~(value)))
#define USBDCD_TOG_CONTROL(base, value) (USBDCD_WR_CONTROL(base, USBDCD_RD_CONTROL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_CONTROL bitfields
 */

/*!
 * @name Register USBDCD_CONTROL, field IACK[0] (WORZ)
 *
 * Determines whether the interrupt is cleared.
 *
 * Values:
 * - 0 - Do not clear the interrupt.
 * - 1 - Clear the IF bit (interrupt flag).
 */
/*@{*/
/*! @brief Set the IACK field to a new value. */
#define USBDCD_WR_CONTROL_IACK(base, value) (USBDCD_RMW_CONTROL(base, USBDCD_CONTROL_IACK_MASK, USBDCD_CONTROL_IACK(value)))
#define USBDCD_BWR_CONTROL_IACK(base, value) (BITBAND_ACCESS32(&USBDCD_CONTROL_REG(base), USBDCD_CONTROL_IACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USBDCD_CONTROL, field IF[8] (RO)
 *
 * Determines whether an interrupt is pending
 *
 * Values:
 * - 0 - No interrupt is pending.
 * - 1 - An interrupt is pending.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_CONTROL_IF field. */
#define USBDCD_RD_CONTROL_IF(base) ((USBDCD_CONTROL_REG(base) & USBDCD_CONTROL_IF_MASK) >> USBDCD_CONTROL_IF_SHIFT)
#define USBDCD_BRD_CONTROL_IF(base) (BITBAND_ACCESS32(&USBDCD_CONTROL_REG(base), USBDCD_CONTROL_IF_SHIFT))
/*@}*/

/*!
 * @name Register USBDCD_CONTROL, field IE[16] (RW)
 *
 * Enables/disables interrupts to the system.
 *
 * Values:
 * - 0 - Disable interrupts to the system.
 * - 1 - Enable interrupts to the system.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_CONTROL_IE field. */
#define USBDCD_RD_CONTROL_IE(base) ((USBDCD_CONTROL_REG(base) & USBDCD_CONTROL_IE_MASK) >> USBDCD_CONTROL_IE_SHIFT)
#define USBDCD_BRD_CONTROL_IE(base) (BITBAND_ACCESS32(&USBDCD_CONTROL_REG(base), USBDCD_CONTROL_IE_SHIFT))

/*! @brief Set the IE field to a new value. */
#define USBDCD_WR_CONTROL_IE(base, value) (USBDCD_RMW_CONTROL(base, USBDCD_CONTROL_IE_MASK, USBDCD_CONTROL_IE(value)))
#define USBDCD_BWR_CONTROL_IE(base, value) (BITBAND_ACCESS32(&USBDCD_CONTROL_REG(base), USBDCD_CONTROL_IE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USBDCD_CONTROL, field START[24] (WORZ)
 *
 * Determines whether the charger detection sequence is initiated.
 *
 * Values:
 * - 0 - Do not start the sequence. Writes of this value have no effect.
 * - 1 - Initiate the charger detection sequence. If the sequence is already
 *     running, writes of this value have no effect.
 */
/*@{*/
/*! @brief Set the START field to a new value. */
#define USBDCD_WR_CONTROL_START(base, value) (USBDCD_RMW_CONTROL(base, USBDCD_CONTROL_START_MASK, USBDCD_CONTROL_START(value)))
#define USBDCD_BWR_CONTROL_START(base, value) (BITBAND_ACCESS32(&USBDCD_CONTROL_REG(base), USBDCD_CONTROL_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USBDCD_CONTROL, field SR[25] (WORZ)
 *
 * Determines whether a software reset is performed.
 *
 * Values:
 * - 0 - Do not perform a software reset.
 * - 1 - Perform a software reset.
 */
/*@{*/
/*! @brief Set the SR field to a new value. */
#define USBDCD_WR_CONTROL_SR(base, value) (USBDCD_RMW_CONTROL(base, USBDCD_CONTROL_SR_MASK, USBDCD_CONTROL_SR(value)))
#define USBDCD_BWR_CONTROL_SR(base, value) (BITBAND_ACCESS32(&USBDCD_CONTROL_REG(base), USBDCD_CONTROL_SR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USBDCD_CLOCK - Clock Register
 ******************************************************************************/

/*!
 * @brief USBDCD_CLOCK - Clock Register (RW)
 *
 * Reset value: 0x000000C1U
 */
/*!
 * @name Constants and macros for entire USBDCD_CLOCK register
 */
/*@{*/
#define USBDCD_RD_CLOCK(base)    (USBDCD_CLOCK_REG(base))
#define USBDCD_WR_CLOCK(base, value) (USBDCD_CLOCK_REG(base) = (value))
#define USBDCD_RMW_CLOCK(base, mask, value) (USBDCD_WR_CLOCK(base, (USBDCD_RD_CLOCK(base) & ~(mask)) | (value)))
#define USBDCD_SET_CLOCK(base, value) (USBDCD_WR_CLOCK(base, USBDCD_RD_CLOCK(base) |  (value)))
#define USBDCD_CLR_CLOCK(base, value) (USBDCD_WR_CLOCK(base, USBDCD_RD_CLOCK(base) & ~(value)))
#define USBDCD_TOG_CLOCK(base, value) (USBDCD_WR_CLOCK(base, USBDCD_RD_CLOCK(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_CLOCK bitfields
 */

/*!
 * @name Register USBDCD_CLOCK, field CLOCK_UNIT[0] (RW)
 *
 * Specifies the unit of measure for the clock speed.
 *
 * Values:
 * - 0 - kHz Speed (between 1 kHz and 1023 kHz)
 * - 1 - MHz Speed (between 1 MHz and 1023 MHz)
 */
/*@{*/
/*! @brief Read current value of the USBDCD_CLOCK_CLOCK_UNIT field. */
#define USBDCD_RD_CLOCK_CLOCK_UNIT(base) ((USBDCD_CLOCK_REG(base) & USBDCD_CLOCK_CLOCK_UNIT_MASK) >> USBDCD_CLOCK_CLOCK_UNIT_SHIFT)
#define USBDCD_BRD_CLOCK_CLOCK_UNIT(base) (BITBAND_ACCESS32(&USBDCD_CLOCK_REG(base), USBDCD_CLOCK_CLOCK_UNIT_SHIFT))

/*! @brief Set the CLOCK_UNIT field to a new value. */
#define USBDCD_WR_CLOCK_CLOCK_UNIT(base, value) (USBDCD_RMW_CLOCK(base, USBDCD_CLOCK_CLOCK_UNIT_MASK, USBDCD_CLOCK_CLOCK_UNIT(value)))
#define USBDCD_BWR_CLOCK_CLOCK_UNIT(base, value) (BITBAND_ACCESS32(&USBDCD_CLOCK_REG(base), USBDCD_CLOCK_CLOCK_UNIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USBDCD_CLOCK, field CLOCK_SPEED[11:2] (RW)
 *
 * The unit of measure is programmed in CLOCK_UNIT. The valid range is from 1 to
 * 1023 when clock unit is MHz and 4 to 1023 when clock unit is KHz. Examples
 * with CLOCK_UNIT = 1: For 48 MHz: 0b00_0011_0000 (48) (Default) For 24 MHz:
 * 0b00_0001_1000 (24) Examples with CLOCK_UNIT = 0: For 100 kHz: 0b00_0110_0100 (100)
 * For 500 kHz: 0b01_1111_0100 (500)
 */
/*@{*/
/*! @brief Read current value of the USBDCD_CLOCK_CLOCK_SPEED field. */
#define USBDCD_RD_CLOCK_CLOCK_SPEED(base) ((USBDCD_CLOCK_REG(base) & USBDCD_CLOCK_CLOCK_SPEED_MASK) >> USBDCD_CLOCK_CLOCK_SPEED_SHIFT)
#define USBDCD_BRD_CLOCK_CLOCK_SPEED(base) (USBDCD_RD_CLOCK_CLOCK_SPEED(base))

/*! @brief Set the CLOCK_SPEED field to a new value. */
#define USBDCD_WR_CLOCK_CLOCK_SPEED(base, value) (USBDCD_RMW_CLOCK(base, USBDCD_CLOCK_CLOCK_SPEED_MASK, USBDCD_CLOCK_CLOCK_SPEED(value)))
#define USBDCD_BWR_CLOCK_CLOCK_SPEED(base, value) (USBDCD_WR_CLOCK_CLOCK_SPEED(base, value))
/*@}*/

/*******************************************************************************
 * USBDCD_STATUS - Status Register
 ******************************************************************************/

/*!
 * @brief USBDCD_STATUS - Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The status register provides the current state of the module for system
 * software monitoring.
 */
/*!
 * @name Constants and macros for entire USBDCD_STATUS register
 */
/*@{*/
#define USBDCD_RD_STATUS(base)   (USBDCD_STATUS_REG(base))
/*@}*/

/*
 * Constants & macros for individual USBDCD_STATUS bitfields
 */

/*!
 * @name Register USBDCD_STATUS, field SEQ_RES[17:16] (RO)
 *
 * Reports how charger detection is attached.
 *
 * Values:
 * - 00 - No results to report.
 * - 01 - Attached to a standard host. Must comply with USB Spec 2.0 by drawing
 *     only 2.5mA (max) until connected.
 * - 10 - Attached to a charging port. The exact meaning depends on bit 18: 0:
 *     Attached to either a charging host or a dedicated charger (The charger type
 *     detection has not completed.) 1: Attached to a charging host (The charger
 *     type detection has completed.)
 * - 11 - Attached to a dedicated charger.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_STATUS_SEQ_RES field. */
#define USBDCD_RD_STATUS_SEQ_RES(base) ((USBDCD_STATUS_REG(base) & USBDCD_STATUS_SEQ_RES_MASK) >> USBDCD_STATUS_SEQ_RES_SHIFT)
#define USBDCD_BRD_STATUS_SEQ_RES(base) (USBDCD_RD_STATUS_SEQ_RES(base))
/*@}*/

/*!
 * @name Register USBDCD_STATUS, field SEQ_STAT[19:18] (RO)
 *
 * Indicates the status of the charger detection sequence.
 *
 * Values:
 * - 00 - The module is either not enabled, or the module is enabled but the
 *     data pins have not yet been detected.
 * - 01 - Data pin contact detection is complete.
 * - 10 - Charger detection is complete.
 * - 11 - Charger type detection is complete.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_STATUS_SEQ_STAT field. */
#define USBDCD_RD_STATUS_SEQ_STAT(base) ((USBDCD_STATUS_REG(base) & USBDCD_STATUS_SEQ_STAT_MASK) >> USBDCD_STATUS_SEQ_STAT_SHIFT)
#define USBDCD_BRD_STATUS_SEQ_STAT(base) (USBDCD_RD_STATUS_SEQ_STAT(base))
/*@}*/

/*!
 * @name Register USBDCD_STATUS, field ERR[20] (RO)
 *
 * Indicates whether there is an error in the detection sequence.
 *
 * Values:
 * - 0 - No sequence errors.
 * - 1 - Error in the detection sequence. See the SEQ_STAT field to determine
 *     the phase in which the error occurred.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_STATUS_ERR field. */
#define USBDCD_RD_STATUS_ERR(base) ((USBDCD_STATUS_REG(base) & USBDCD_STATUS_ERR_MASK) >> USBDCD_STATUS_ERR_SHIFT)
#define USBDCD_BRD_STATUS_ERR(base) (BITBAND_ACCESS32(&USBDCD_STATUS_REG(base), USBDCD_STATUS_ERR_SHIFT))
/*@}*/

/*!
 * @name Register USBDCD_STATUS, field TO[21] (RO)
 *
 * Indicates whether the detection sequence has passed the timeout threshhold.
 *
 * Values:
 * - 0 - The detection sequence has not been running for over 1 s.
 * - 1 - It has been over 1 s since the data pin contact was detected and
 *     debounced.{
 */
/*@{*/
/*! @brief Read current value of the USBDCD_STATUS_TO field. */
#define USBDCD_RD_STATUS_TO(base) ((USBDCD_STATUS_REG(base) & USBDCD_STATUS_TO_MASK) >> USBDCD_STATUS_TO_SHIFT)
#define USBDCD_BRD_STATUS_TO(base) (BITBAND_ACCESS32(&USBDCD_STATUS_REG(base), USBDCD_STATUS_TO_SHIFT))
/*@}*/

/*!
 * @name Register USBDCD_STATUS, field ACTIVE[22] (RO)
 *
 * Indicates whether the sequence is running.
 *
 * Values:
 * - 0 - The sequence is not running.
 * - 1 - The sequence is running.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_STATUS_ACTIVE field. */
#define USBDCD_RD_STATUS_ACTIVE(base) ((USBDCD_STATUS_REG(base) & USBDCD_STATUS_ACTIVE_MASK) >> USBDCD_STATUS_ACTIVE_SHIFT)
#define USBDCD_BRD_STATUS_ACTIVE(base) (BITBAND_ACCESS32(&USBDCD_STATUS_REG(base), USBDCD_STATUS_ACTIVE_SHIFT))
/*@}*/

/*******************************************************************************
 * USBDCD_TIMER0 - TIMER0 Register
 ******************************************************************************/

/*!
 * @brief USBDCD_TIMER0 - TIMER0 Register (RW)
 *
 * Reset value: 0x00100000U
 *
 * TIMER0 has an TSEQ_INIT field that represents the system latency (in ms)
 * measured from the time VBUS goes active to the time system software initiates the
 * charger detection sequence in the USBDCD module. When software sets the
 * CONTROL[START] bit, the Unit Connection Timer (TUNITCON) is initialized with the
 * value of TSEQ_INIT. Valid values are 0-1023, however the USB Battery Charging
 * Specification requires the entire sequence, including TSEQ_INIT, to be completed
 * in 1s or less.
 */
/*!
 * @name Constants and macros for entire USBDCD_TIMER0 register
 */
/*@{*/
#define USBDCD_RD_TIMER0(base)   (USBDCD_TIMER0_REG(base))
#define USBDCD_WR_TIMER0(base, value) (USBDCD_TIMER0_REG(base) = (value))
#define USBDCD_RMW_TIMER0(base, mask, value) (USBDCD_WR_TIMER0(base, (USBDCD_RD_TIMER0(base) & ~(mask)) | (value)))
#define USBDCD_SET_TIMER0(base, value) (USBDCD_WR_TIMER0(base, USBDCD_RD_TIMER0(base) |  (value)))
#define USBDCD_CLR_TIMER0(base, value) (USBDCD_WR_TIMER0(base, USBDCD_RD_TIMER0(base) & ~(value)))
#define USBDCD_TOG_TIMER0(base, value) (USBDCD_WR_TIMER0(base, USBDCD_RD_TIMER0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_TIMER0 bitfields
 */

/*!
 * @name Register USBDCD_TIMER0, field TUNITCON[11:0] (RO)
 *
 * Displays the current elapsed time since software set the CONTROL[START] bit
 * plus the value of TSEQ_INIT. The timer is initially loaded with the value of
 * TSEQ_INIT before starting to count. This timer enables compliance with the
 * maximum time allowed to connect (TUNIT_CON) under the USB Battery Charging
 * Specification, v1.1.If the timer reaches the TUNIT_CON one second limit, the module
 * triggers an interrupt and sets the error flag STATUS[ERR]. The timer continues
 * counting throughout the charger detection sequence, even when control has been
 * passed to software. As long as the module is active, the timer continues to
 * count until it reaches the maximum value of 0xFFF (4095 ms). The timer does not
 * rollover to zero. A software reset clears the timer.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_TIMER0_TUNITCON field. */
#define USBDCD_RD_TIMER0_TUNITCON(base) ((USBDCD_TIMER0_REG(base) & USBDCD_TIMER0_TUNITCON_MASK) >> USBDCD_TIMER0_TUNITCON_SHIFT)
#define USBDCD_BRD_TIMER0_TUNITCON(base) (USBDCD_RD_TIMER0_TUNITCON(base))
/*@}*/

/*!
 * @name Register USBDCD_TIMER0, field TSEQ_INIT[25:16] (RW)
 *
 * TSEQ_INIT represents the system latency (in ms) measured from the time VBUS
 * goes active to the time system software initiates the charger detection
 * sequence in the USBDCD module. When software sets the CONTROL[START] bit, the Unit
 * Connection Timer (TUNITCON) is initialized with the value of TSEQ_INIT. Valid
 * values are 0-1023, but the USB Battery Charging Specification requires the
 * entire sequence, including TSEQ_INIT, to be completed in 1s or less.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_TIMER0_TSEQ_INIT field. */
#define USBDCD_RD_TIMER0_TSEQ_INIT(base) ((USBDCD_TIMER0_REG(base) & USBDCD_TIMER0_TSEQ_INIT_MASK) >> USBDCD_TIMER0_TSEQ_INIT_SHIFT)
#define USBDCD_BRD_TIMER0_TSEQ_INIT(base) (USBDCD_RD_TIMER0_TSEQ_INIT(base))

/*! @brief Set the TSEQ_INIT field to a new value. */
#define USBDCD_WR_TIMER0_TSEQ_INIT(base, value) (USBDCD_RMW_TIMER0(base, USBDCD_TIMER0_TSEQ_INIT_MASK, USBDCD_TIMER0_TSEQ_INIT(value)))
#define USBDCD_BWR_TIMER0_TSEQ_INIT(base, value) (USBDCD_WR_TIMER0_TSEQ_INIT(base, value))
/*@}*/

/*******************************************************************************
 * USBDCD_TIMER1 -
 ******************************************************************************/

/*!
 * @brief USBDCD_TIMER1 -  (RW)
 *
 * Reset value: 0x000A0028U
 */
/*!
 * @name Constants and macros for entire USBDCD_TIMER1 register
 */
/*@{*/
#define USBDCD_RD_TIMER1(base)   (USBDCD_TIMER1_REG(base))
#define USBDCD_WR_TIMER1(base, value) (USBDCD_TIMER1_REG(base) = (value))
#define USBDCD_RMW_TIMER1(base, mask, value) (USBDCD_WR_TIMER1(base, (USBDCD_RD_TIMER1(base) & ~(mask)) | (value)))
#define USBDCD_SET_TIMER1(base, value) (USBDCD_WR_TIMER1(base, USBDCD_RD_TIMER1(base) |  (value)))
#define USBDCD_CLR_TIMER1(base, value) (USBDCD_WR_TIMER1(base, USBDCD_RD_TIMER1(base) & ~(value)))
#define USBDCD_TOG_TIMER1(base, value) (USBDCD_WR_TIMER1(base, USBDCD_RD_TIMER1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_TIMER1 bitfields
 */

/*!
 * @name Register USBDCD_TIMER1, field TVDPSRC_ON[9:0] (RW)
 *
 * Sets the amount of time (in ms) that VDP_SRC, IDM_SINK, and the D-/VDAT_REF
 * comparator are enabled and connected to the D+/D- lines during the charging
 * port detection phase of the sequence. Valid values are 1-1023, but the USB
 * Battery Charging Specification requires a minimum value of 40 ms.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_TIMER1_TVDPSRC_ON field. */
#define USBDCD_RD_TIMER1_TVDPSRC_ON(base) ((USBDCD_TIMER1_REG(base) & USBDCD_TIMER1_TVDPSRC_ON_MASK) >> USBDCD_TIMER1_TVDPSRC_ON_SHIFT)
#define USBDCD_BRD_TIMER1_TVDPSRC_ON(base) (USBDCD_RD_TIMER1_TVDPSRC_ON(base))

/*! @brief Set the TVDPSRC_ON field to a new value. */
#define USBDCD_WR_TIMER1_TVDPSRC_ON(base, value) (USBDCD_RMW_TIMER1(base, USBDCD_TIMER1_TVDPSRC_ON_MASK, USBDCD_TIMER1_TVDPSRC_ON(value)))
#define USBDCD_BWR_TIMER1_TVDPSRC_ON(base, value) (USBDCD_WR_TIMER1_TVDPSRC_ON(base, value))
/*@}*/

/*!
 * @name Register USBDCD_TIMER1, field TDCD_DBNC[25:16] (RW)
 *
 * Sets the amount of time (in ms) to debounce the D+ signal during the data pin
 * contact detection phase (while IDP_SRC and RDM_DWN are enabled). Valid values
 * are 1-1023, but the USB Battery Charging Specification requires a minimum
 * value of 10 ms.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_TIMER1_TDCD_DBNC field. */
#define USBDCD_RD_TIMER1_TDCD_DBNC(base) ((USBDCD_TIMER1_REG(base) & USBDCD_TIMER1_TDCD_DBNC_MASK) >> USBDCD_TIMER1_TDCD_DBNC_SHIFT)
#define USBDCD_BRD_TIMER1_TDCD_DBNC(base) (USBDCD_RD_TIMER1_TDCD_DBNC(base))

/*! @brief Set the TDCD_DBNC field to a new value. */
#define USBDCD_WR_TIMER1_TDCD_DBNC(base, value) (USBDCD_RMW_TIMER1(base, USBDCD_TIMER1_TDCD_DBNC_MASK, USBDCD_TIMER1_TDCD_DBNC(value)))
#define USBDCD_BWR_TIMER1_TDCD_DBNC(base, value) (USBDCD_WR_TIMER1_TDCD_DBNC(base, value))
/*@}*/

/*******************************************************************************
 * USBDCD_TIMER2 -
 ******************************************************************************/

/*!
 * @brief USBDCD_TIMER2 -  (RW)
 *
 * Reset value: 0x00280001U
 *
 * TIMER2 contains timing parameters. Note that register values can be written
 * that are not compliant with the USB Battery Charging Specification v1.1, so
 * care should be taken when overwriting the default values.
 */
/*!
 * @name Constants and macros for entire USBDCD_TIMER2 register
 */
/*@{*/
#define USBDCD_RD_TIMER2(base)   (USBDCD_TIMER2_REG(base))
#define USBDCD_WR_TIMER2(base, value) (USBDCD_TIMER2_REG(base) = (value))
#define USBDCD_RMW_TIMER2(base, mask, value) (USBDCD_WR_TIMER2(base, (USBDCD_RD_TIMER2(base) & ~(mask)) | (value)))
#define USBDCD_SET_TIMER2(base, value) (USBDCD_WR_TIMER2(base, USBDCD_RD_TIMER2(base) |  (value)))
#define USBDCD_CLR_TIMER2(base, value) (USBDCD_WR_TIMER2(base, USBDCD_RD_TIMER2(base) & ~(value)))
#define USBDCD_TOG_TIMER2(base, value) (USBDCD_WR_TIMER2(base, USBDCD_RD_TIMER2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_TIMER2 bitfields
 */

/*!
 * @name Register USBDCD_TIMER2, field CHECK_DM[3:0] (RW)
 *
 * Sets the amount of time (in ms) that the module waits after the device
 * connects to the USB bus (software enables the D+ pullup) until checking the state of
 * the D- line to determine the type of charging port. Valid values are 1-15ms.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_TIMER2_CHECK_DM field. */
#define USBDCD_RD_TIMER2_CHECK_DM(base) ((USBDCD_TIMER2_REG(base) & USBDCD_TIMER2_CHECK_DM_MASK) >> USBDCD_TIMER2_CHECK_DM_SHIFT)
#define USBDCD_BRD_TIMER2_CHECK_DM(base) (USBDCD_RD_TIMER2_CHECK_DM(base))

/*! @brief Set the CHECK_DM field to a new value. */
#define USBDCD_WR_TIMER2_CHECK_DM(base, value) (USBDCD_RMW_TIMER2(base, USBDCD_TIMER2_CHECK_DM_MASK, USBDCD_TIMER2_CHECK_DM(value)))
#define USBDCD_BWR_TIMER2_CHECK_DM(base, value) (USBDCD_WR_TIMER2_CHECK_DM(base, value))
/*@}*/

/*!
 * @name Register USBDCD_TIMER2, field TVDPSRC_CON[25:16] (RW)
 *
 * Sets the amount of time (in ms) that the module waits after charging port
 * detection before system software should enable the D+ pullup to connect to the
 * USB host. Valid values are 1-1023, but the USB Battery Charging Specification
 * requires a minimum value of 40 ms.
 */
/*@{*/
/*! @brief Read current value of the USBDCD_TIMER2_TVDPSRC_CON field. */
#define USBDCD_RD_TIMER2_TVDPSRC_CON(base) ((USBDCD_TIMER2_REG(base) & USBDCD_TIMER2_TVDPSRC_CON_MASK) >> USBDCD_TIMER2_TVDPSRC_CON_SHIFT)
#define USBDCD_BRD_TIMER2_TVDPSRC_CON(base) (USBDCD_RD_TIMER2_TVDPSRC_CON(base))

/*! @brief Set the TVDPSRC_CON field to a new value. */
#define USBDCD_WR_TIMER2_TVDPSRC_CON(base, value) (USBDCD_RMW_TIMER2(base, USBDCD_TIMER2_TVDPSRC_CON_MASK, USBDCD_TIMER2_TVDPSRC_CON(value)))
#define USBDCD_BWR_TIMER2_TVDPSRC_CON(base, value) (USBDCD_WR_TIMER2_TVDPSRC_CON(base, value))
/*@}*/

/*
 * MK20D5 VREF
 *
 * Voltage Reference
 *
 * Registers defined in this header file:
 * - VREF_TRM - VREF Trim Register
 * - VREF_SC - VREF Status and Control Register
 */

#define VREF_INSTANCE_COUNT (1U) /*!< Number of instances of the VREF module. */
#define VREF_IDX (0U) /*!< Instance number for VREF. */

/*******************************************************************************
 * VREF_TRM - VREF Trim Register
 ******************************************************************************/

/*!
 * @brief VREF_TRM - VREF Trim Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains bits that contain the trim data for the Voltage
 * Reference.
 */
/*!
 * @name Constants and macros for entire VREF_TRM register
 */
/*@{*/
#define VREF_RD_TRM(base)        (VREF_TRM_REG(base))
#define VREF_WR_TRM(base, value) (VREF_TRM_REG(base) = (value))
#define VREF_RMW_TRM(base, mask, value) (VREF_WR_TRM(base, (VREF_RD_TRM(base) & ~(mask)) | (value)))
#define VREF_SET_TRM(base, value) (VREF_WR_TRM(base, VREF_RD_TRM(base) |  (value)))
#define VREF_CLR_TRM(base, value) (VREF_WR_TRM(base, VREF_RD_TRM(base) & ~(value)))
#define VREF_TOG_TRM(base, value) (VREF_WR_TRM(base, VREF_RD_TRM(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual VREF_TRM bitfields
 */

/*!
 * @name Register VREF_TRM, field TRIM[5:0] (RW)
 *
 * These bits change the resulting VREF by approximately +/- 0.5 mV for each
 * step. Min = minimum and max = maximum voltage reference output. For minimum and
 * maximum voltage reference output values, refer to the Data Sheet for this chip.
 *
 * Values:
 * - 000000 - Min
 * - 111111 - Max
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM_TRIM field. */
#define VREF_RD_TRM_TRIM(base) ((VREF_TRM_REG(base) & VREF_TRM_TRIM_MASK) >> VREF_TRM_TRIM_SHIFT)
#define VREF_BRD_TRM_TRIM(base) (VREF_RD_TRM_TRIM(base))

/*! @brief Set the TRIM field to a new value. */
#define VREF_WR_TRM_TRIM(base, value) (VREF_RMW_TRM(base, VREF_TRM_TRIM_MASK, VREF_TRM_TRIM(value)))
#define VREF_BWR_TRM_TRIM(base, value) (VREF_WR_TRM_TRIM(base, value))
/*@}*/

/*!
 * @name Register VREF_TRM, field CHOPEN[6] (RW)
 *
 * Values:
 * - 0 - Chop oscillator is disabled.
 * - 1 - Chop oscillator is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM_CHOPEN field. */
#define VREF_RD_TRM_CHOPEN(base) ((VREF_TRM_REG(base) & VREF_TRM_CHOPEN_MASK) >> VREF_TRM_CHOPEN_SHIFT)
#define VREF_BRD_TRM_CHOPEN(base) (BITBAND_ACCESS8(&VREF_TRM_REG(base), VREF_TRM_CHOPEN_SHIFT))

/*! @brief Set the CHOPEN field to a new value. */
#define VREF_WR_TRM_CHOPEN(base, value) (VREF_RMW_TRM(base, VREF_TRM_CHOPEN_MASK, VREF_TRM_CHOPEN(value)))
#define VREF_BWR_TRM_CHOPEN(base, value) (BITBAND_ACCESS8(&VREF_TRM_REG(base), VREF_TRM_CHOPEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * VREF_SC - VREF Status and Control Register
 ******************************************************************************/

/*!
 * @brief VREF_SC - VREF Status and Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the control bits used to enable the internal voltage
 * reference and to select the buffer mode to be used.
 */
/*!
 * @name Constants and macros for entire VREF_SC register
 */
/*@{*/
#define VREF_RD_SC(base)         (VREF_SC_REG(base))
#define VREF_WR_SC(base, value)  (VREF_SC_REG(base) = (value))
#define VREF_RMW_SC(base, mask, value) (VREF_WR_SC(base, (VREF_RD_SC(base) & ~(mask)) | (value)))
#define VREF_SET_SC(base, value) (VREF_WR_SC(base, VREF_RD_SC(base) |  (value)))
#define VREF_CLR_SC(base, value) (VREF_WR_SC(base, VREF_RD_SC(base) & ~(value)))
#define VREF_TOG_SC(base, value) (VREF_WR_SC(base, VREF_RD_SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual VREF_SC bitfields
 */

/*!
 * @name Register VREF_SC, field MODE_LV[1:0] (RW)
 *
 * These bits select the buffer modes for the Voltage Reference module.
 *
 * Values:
 * - 00 - Bandgap on only, for stabilization and startup
 * - 01 - Low-power buffer mode enabled
 * - 10 - Tight-regulation buffer enabled
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_MODE_LV field. */
#define VREF_RD_SC_MODE_LV(base) ((VREF_SC_REG(base) & VREF_SC_MODE_LV_MASK) >> VREF_SC_MODE_LV_SHIFT)
#define VREF_BRD_SC_MODE_LV(base) (VREF_RD_SC_MODE_LV(base))

/*! @brief Set the MODE_LV field to a new value. */
#define VREF_WR_SC_MODE_LV(base, value) (VREF_RMW_SC(base, VREF_SC_MODE_LV_MASK, VREF_SC_MODE_LV(value)))
#define VREF_BWR_SC_MODE_LV(base, value) (VREF_WR_SC_MODE_LV(base, value))
/*@}*/

/*!
 * @name Register VREF_SC, field VREFST[2] (RO)
 *
 * This bit indicates that the Voltage Reference module has completed its
 * startup and stabilization.
 *
 * Values:
 * - 0 - The module is disabled or not stable.
 * - 1 - The module is stable.
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_VREFST field. */
#define VREF_RD_SC_VREFST(base) ((VREF_SC_REG(base) & VREF_SC_VREFST_MASK) >> VREF_SC_VREFST_SHIFT)
#define VREF_BRD_SC_VREFST(base) (BITBAND_ACCESS8(&VREF_SC_REG(base), VREF_SC_VREFST_SHIFT))
/*@}*/

/*!
 * @name Register VREF_SC, field REGEN[6] (RW)
 *
 * This bit is used to enable the internal 1.75 V regulator to produce a stable
 * voltage reference in order to reduce the supply variation.
 *
 * Values:
 * - 0 - Internal 1.75 V regulator is disabled.
 * - 1 - Internal 1.75 V regulator is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_REGEN field. */
#define VREF_RD_SC_REGEN(base) ((VREF_SC_REG(base) & VREF_SC_REGEN_MASK) >> VREF_SC_REGEN_SHIFT)
#define VREF_BRD_SC_REGEN(base) (BITBAND_ACCESS8(&VREF_SC_REG(base), VREF_SC_REGEN_SHIFT))

/*! @brief Set the REGEN field to a new value. */
#define VREF_WR_SC_REGEN(base, value) (VREF_RMW_SC(base, VREF_SC_REGEN_MASK, VREF_SC_REGEN(value)))
#define VREF_BWR_SC_REGEN(base, value) (BITBAND_ACCESS8(&VREF_SC_REG(base), VREF_SC_REGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register VREF_SC, field VREFEN[7] (RW)
 *
 * This bit is used to enable the bandgap Voltage Reference module. After the
 * VREF is enabled, turning off the clock to the VREF module via the corresponding
 * clock gate register will not disable the VREF. VREF must be disabled via this
 * VREFEN bit.
 *
 * Values:
 * - 0 - The module is disabled.
 * - 1 - The module is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_VREFEN field. */
#define VREF_RD_SC_VREFEN(base) ((VREF_SC_REG(base) & VREF_SC_VREFEN_MASK) >> VREF_SC_VREFEN_SHIFT)
#define VREF_BRD_SC_VREFEN(base) (BITBAND_ACCESS8(&VREF_SC_REG(base), VREF_SC_VREFEN_SHIFT))

/*! @brief Set the VREFEN field to a new value. */
#define VREF_WR_SC_VREFEN(base, value) (VREF_RMW_SC(base, VREF_SC_VREFEN_MASK, VREF_SC_VREFEN(value)))
#define VREF_BWR_SC_VREFEN(base, value) (BITBAND_ACCESS8(&VREF_SC_REG(base), VREF_SC_VREFEN_SHIFT) = (value))
/*@}*/

/*
 * MK20D5 WDOG
 *
 * Generation 2008 Watchdog Timer
 *
 * Registers defined in this header file:
 * - WDOG_STCTRLH - Watchdog Status and Control Register High
 * - WDOG_STCTRLL - Watchdog Status and Control Register Low
 * - WDOG_TOVALH - Watchdog Time-out Value Register High
 * - WDOG_TOVALL - Watchdog Time-out Value Register Low
 * - WDOG_WINH - Watchdog Window Register High
 * - WDOG_WINL - Watchdog Window Register Low
 * - WDOG_REFRESH - Watchdog Refresh Register
 * - WDOG_UNLOCK - Watchdog Unlock Register
 * - WDOG_TMROUTH - Watchdog Timer Output Register High
 * - WDOG_TMROUTL - Watchdog Timer Output Register Low
 * - WDOG_RSTCNT - Watchdog Reset Count Register
 * - WDOG_PRESC - Watchdog Prescaler Register
 */

#define WDOG_INSTANCE_COUNT (1U) /*!< Number of instances of the WDOG module. */
#define WDOG_IDX (0U) /*!< Instance number for WDOG. */

/*******************************************************************************
 * WDOG_STCTRLH - Watchdog Status and Control Register High
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLH - Watchdog Status and Control Register High (RW)
 *
 * Reset value: 0x01D3U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLH register
 */
/*@{*/
#define WDOG_RD_STCTRLH(base)    (WDOG_STCTRLH_REG(base))
#define WDOG_WR_STCTRLH(base, value) (WDOG_STCTRLH_REG(base) = (value))
#define WDOG_RMW_STCTRLH(base, mask, value) (WDOG_WR_STCTRLH(base, (WDOG_RD_STCTRLH(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLH(base, value) (WDOG_WR_STCTRLH(base, WDOG_RD_STCTRLH(base) |  (value)))
#define WDOG_CLR_STCTRLH(base, value) (WDOG_WR_STCTRLH(base, WDOG_RD_STCTRLH(base) & ~(value)))
#define WDOG_TOG_STCTRLH(base, value) (WDOG_WR_STCTRLH(base, WDOG_RD_STCTRLH(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLH bitfields
 */

/*!
 * @name Register WDOG_STCTRLH, field WDOGEN[0] (RW)
 *
 * Enables or disables the WDOG's operation. In the disabled state, the watchdog
 * timer is kept in the reset state, but the other exception conditions can
 * still trigger a reset/interrupt. A change in the value of this bit must be held
 * for more than one WDOG_CLK cycle for the WDOG to be enabled or disabled.
 *
 * Values:
 * - 0 - WDOG is disabled.
 * - 1 - WDOG is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WDOGEN field. */
#define WDOG_RD_STCTRLH_WDOGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WDOGEN_MASK) >> WDOG_STCTRLH_WDOGEN_SHIFT)
#define WDOG_BRD_STCTRLH_WDOGEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WDOGEN_SHIFT))

/*! @brief Set the WDOGEN field to a new value. */
#define WDOG_WR_STCTRLH_WDOGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WDOGEN_MASK, WDOG_STCTRLH_WDOGEN(value)))
#define WDOG_BWR_STCTRLH_WDOGEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WDOGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field CLKSRC[1] (RW)
 *
 * Selects clock source for the WDOG timer and other internal timing operations.
 *
 * Values:
 * - 0 - Dedicated clock source selected as WDOG clock (LPO Oscillator).
 * - 1 - WDOG clock sourced from alternate clock source.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_CLKSRC field. */
#define WDOG_RD_STCTRLH_CLKSRC(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_CLKSRC_MASK) >> WDOG_STCTRLH_CLKSRC_SHIFT)
#define WDOG_BRD_STCTRLH_CLKSRC(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_CLKSRC_SHIFT))

/*! @brief Set the CLKSRC field to a new value. */
#define WDOG_WR_STCTRLH_CLKSRC(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_CLKSRC_MASK, WDOG_STCTRLH_CLKSRC(value)))
#define WDOG_BWR_STCTRLH_CLKSRC(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_CLKSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field IRQRSTEN[2] (RW)
 *
 * Used to enable the debug breadcrumbs feature. A change in this bit is updated
 * immediately, as opposed to updating after WCT.
 *
 * Values:
 * - 0 - WDOG time-out generates reset only.
 * - 1 - WDOG time-out initially generates an interrupt. After WCT time, it
 *     generates a reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_IRQRSTEN field. */
#define WDOG_RD_STCTRLH_IRQRSTEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_IRQRSTEN_MASK) >> WDOG_STCTRLH_IRQRSTEN_SHIFT)
#define WDOG_BRD_STCTRLH_IRQRSTEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_IRQRSTEN_SHIFT))

/*! @brief Set the IRQRSTEN field to a new value. */
#define WDOG_WR_STCTRLH_IRQRSTEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_IRQRSTEN_MASK, WDOG_STCTRLH_IRQRSTEN(value)))
#define WDOG_BWR_STCTRLH_IRQRSTEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_IRQRSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WINEN[3] (RW)
 *
 * Enable windowing mode.
 *
 * Values:
 * - 0 - Windowing mode is disabled.
 * - 1 - Windowing mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WINEN field. */
#define WDOG_RD_STCTRLH_WINEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WINEN_MASK) >> WDOG_STCTRLH_WINEN_SHIFT)
#define WDOG_BRD_STCTRLH_WINEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WINEN_SHIFT))

/*! @brief Set the WINEN field to a new value. */
#define WDOG_WR_STCTRLH_WINEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WINEN_MASK, WDOG_STCTRLH_WINEN(value)))
#define WDOG_BWR_STCTRLH_WINEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WINEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field ALLOWUPDATE[4] (RW)
 *
 * Enables updates to watchdog write once registers, after initial configuration
 * window (WCT) closes, through unlock sequence.
 *
 * Values:
 * - 0 - No further updates allowed to WDOG write once registers.
 * - 1 - WDOG write once registers can be unlocked for updating.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_ALLOWUPDATE field. */
#define WDOG_RD_STCTRLH_ALLOWUPDATE(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_ALLOWUPDATE_MASK) >> WDOG_STCTRLH_ALLOWUPDATE_SHIFT)
#define WDOG_BRD_STCTRLH_ALLOWUPDATE(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_ALLOWUPDATE_SHIFT))

/*! @brief Set the ALLOWUPDATE field to a new value. */
#define WDOG_WR_STCTRLH_ALLOWUPDATE(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_ALLOWUPDATE_MASK, WDOG_STCTRLH_ALLOWUPDATE(value)))
#define WDOG_BWR_STCTRLH_ALLOWUPDATE(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_ALLOWUPDATE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DBGEN[5] (RW)
 *
 * Enables or disables WDOG in Debug mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Debug mode.
 * - 1 - WDOG is enabled in CPU Debug mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DBGEN field. */
#define WDOG_RD_STCTRLH_DBGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DBGEN_MASK) >> WDOG_STCTRLH_DBGEN_SHIFT)
#define WDOG_BRD_STCTRLH_DBGEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DBGEN_SHIFT))

/*! @brief Set the DBGEN field to a new value. */
#define WDOG_WR_STCTRLH_DBGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DBGEN_MASK, WDOG_STCTRLH_DBGEN(value)))
#define WDOG_BWR_STCTRLH_DBGEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DBGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field STOPEN[6] (RW)
 *
 * Enables or disables WDOG in stop mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU stop mode.
 * - 1 - WDOG is enabled in CPU stop mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_STOPEN field. */
#define WDOG_RD_STCTRLH_STOPEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_STOPEN_MASK) >> WDOG_STCTRLH_STOPEN_SHIFT)
#define WDOG_BRD_STCTRLH_STOPEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_STOPEN_SHIFT))

/*! @brief Set the STOPEN field to a new value. */
#define WDOG_WR_STCTRLH_STOPEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_STOPEN_MASK, WDOG_STCTRLH_STOPEN(value)))
#define WDOG_BWR_STCTRLH_STOPEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_STOPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WAITEN[7] (RW)
 *
 * Enables or disables WDOG in wait mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU wait mode.
 * - 1 - WDOG is enabled in CPU wait mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WAITEN field. */
#define WDOG_RD_STCTRLH_WAITEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WAITEN_MASK) >> WDOG_STCTRLH_WAITEN_SHIFT)
#define WDOG_BRD_STCTRLH_WAITEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WAITEN_SHIFT))

/*! @brief Set the WAITEN field to a new value. */
#define WDOG_WR_STCTRLH_WAITEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WAITEN_MASK, WDOG_STCTRLH_WAITEN(value)))
#define WDOG_BWR_STCTRLH_WAITEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WAITEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTWDOG[10] (RW)
 *
 * Puts the watchdog in the functional test mode. In this mode the watchdog
 * timer and the associated compare and reset generation logic is tested for correct
 * operation. The clock for the timer is switched from the main watchdog clock to
 * the fast clock input for watchdog functional test. The TESTSEL bit selects
 * the test to be run.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTWDOG field. */
#define WDOG_RD_STCTRLH_TESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTWDOG_MASK) >> WDOG_STCTRLH_TESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_TESTWDOG(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTWDOG_SHIFT))

/*! @brief Set the TESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_TESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTWDOG_MASK, WDOG_STCTRLH_TESTWDOG(value)))
#define WDOG_BWR_STCTRLH_TESTWDOG(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTWDOG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTSEL[11] (RW)
 *
 * Selects the test to be run on the watchdog timer. Effective only if TESTWDOG
 * is set.
 *
 * Values:
 * - 0 - Quick test. The timer runs in normal operation. You can load a small
 *     time-out value to do a quick test.
 * - 1 - Byte test. Puts the timer in the byte test mode where individual bytes
 *     of the timer are enabled for operation and are compared for time-out
 *     against the corresponding byte of the programmed time-out value. Select the
 *     byte through BYTESEL[1:0] for testing.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTSEL field. */
#define WDOG_RD_STCTRLH_TESTSEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTSEL_MASK) >> WDOG_STCTRLH_TESTSEL_SHIFT)
#define WDOG_BRD_STCTRLH_TESTSEL(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTSEL_SHIFT))

/*! @brief Set the TESTSEL field to a new value. */
#define WDOG_WR_STCTRLH_TESTSEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTSEL_MASK, WDOG_STCTRLH_TESTSEL(value)))
#define WDOG_BWR_STCTRLH_TESTSEL(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field BYTESEL[13:12] (RW)
 *
 * This 2-bit field select the byte to be tested when the watchdog is in the
 * byte test mode.
 *
 * Values:
 * - 00 - Byte 0 selected
 * - 01 - Byte 1 selected
 * - 10 - Byte 2 selected
 * - 11 - Byte 3 selected
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_BYTESEL field. */
#define WDOG_RD_STCTRLH_BYTESEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_BYTESEL_MASK) >> WDOG_STCTRLH_BYTESEL_SHIFT)
#define WDOG_BRD_STCTRLH_BYTESEL(base) (WDOG_RD_STCTRLH_BYTESEL(base))

/*! @brief Set the BYTESEL field to a new value. */
#define WDOG_WR_STCTRLH_BYTESEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_BYTESEL_MASK, WDOG_STCTRLH_BYTESEL(value)))
#define WDOG_BWR_STCTRLH_BYTESEL(base, value) (WDOG_WR_STCTRLH_BYTESEL(base, value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DISTESTWDOG[14] (RW)
 *
 * Allows the WDOG's functional test mode to be disabled permanently. Once set,
 * it can only be cleared by a reset. It cannot be unlocked for editing once it
 * is set.
 *
 * Values:
 * - 0 - WDOG functional test mode is not disabled.
 * - 1 - WDOG functional test mode is disabled permanently until reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DISTESTWDOG field. */
#define WDOG_RD_STCTRLH_DISTESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DISTESTWDOG_MASK) >> WDOG_STCTRLH_DISTESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_DISTESTWDOG(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DISTESTWDOG_SHIFT))

/*! @brief Set the DISTESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_DISTESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DISTESTWDOG_MASK, WDOG_STCTRLH_DISTESTWDOG(value)))
#define WDOG_BWR_STCTRLH_DISTESTWDOG(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DISTESTWDOG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * WDOG_STCTRLL - Watchdog Status and Control Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLL - Watchdog Status and Control Register Low (RW)
 *
 * Reset value: 0x0001U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLL register
 */
/*@{*/
#define WDOG_RD_STCTRLL(base)    (WDOG_STCTRLL_REG(base))
#define WDOG_WR_STCTRLL(base, value) (WDOG_STCTRLL_REG(base) = (value))
#define WDOG_RMW_STCTRLL(base, mask, value) (WDOG_WR_STCTRLL(base, (WDOG_RD_STCTRLL(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLL(base, value) (WDOG_WR_STCTRLL(base, WDOG_RD_STCTRLL(base) |  (value)))
#define WDOG_CLR_STCTRLL(base, value) (WDOG_WR_STCTRLL(base, WDOG_RD_STCTRLL(base) & ~(value)))
#define WDOG_TOG_STCTRLL(base, value) (WDOG_WR_STCTRLL(base, WDOG_RD_STCTRLL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLL bitfields
 */

/*!
 * @name Register WDOG_STCTRLL, field INTFLG[15] (RW)
 *
 * Interrupt flag. It is set when an exception occurs. IRQRSTEN = 1 is a
 * precondition to set this flag. INTFLG = 1 results in an interrupt being issued
 * followed by a reset, WCT time later. The interrupt can be cleared by writing 1 to
 * this bit. It also gets cleared on a system reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLL_INTFLG field. */
#define WDOG_RD_STCTRLL_INTFLG(base) ((WDOG_STCTRLL_REG(base) & WDOG_STCTRLL_INTFLG_MASK) >> WDOG_STCTRLL_INTFLG_SHIFT)
#define WDOG_BRD_STCTRLL_INTFLG(base) (BITBAND_ACCESS16(&WDOG_STCTRLL_REG(base), WDOG_STCTRLL_INTFLG_SHIFT))

/*! @brief Set the INTFLG field to a new value. */
#define WDOG_WR_STCTRLL_INTFLG(base, value) (WDOG_RMW_STCTRLL(base, WDOG_STCTRLL_INTFLG_MASK, WDOG_STCTRLL_INTFLG(value)))
#define WDOG_BWR_STCTRLL_INTFLG(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLL_REG(base), WDOG_STCTRLL_INTFLG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALH - Watchdog Time-out Value Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALH - Watchdog Time-out Value Register High (RW)
 *
 * Reset value: 0x004CU
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALH register
 */
/*@{*/
#define WDOG_RD_TOVALH(base)     (WDOG_TOVALH_REG(base))
#define WDOG_WR_TOVALH(base, value) (WDOG_TOVALH_REG(base) = (value))
#define WDOG_RMW_TOVALH(base, mask, value) (WDOG_WR_TOVALH(base, (WDOG_RD_TOVALH(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALH(base, value) (WDOG_WR_TOVALH(base, WDOG_RD_TOVALH(base) |  (value)))
#define WDOG_CLR_TOVALH(base, value) (WDOG_WR_TOVALH(base, WDOG_RD_TOVALH(base) & ~(value)))
#define WDOG_TOG_TOVALH(base, value) (WDOG_WR_TOVALH(base, WDOG_RD_TOVALH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALL - Watchdog Time-out Value Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALL - Watchdog Time-out Value Register Low (RW)
 *
 * Reset value: 0x4B4CU
 *
 * The time-out value of the watchdog must be set to a minimum of four watchdog
 * clock cycles. This is to take into account the delay in new settings taking
 * effect in the watchdog clock domain.
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALL register
 */
/*@{*/
#define WDOG_RD_TOVALL(base)     (WDOG_TOVALL_REG(base))
#define WDOG_WR_TOVALL(base, value) (WDOG_TOVALL_REG(base) = (value))
#define WDOG_RMW_TOVALL(base, mask, value) (WDOG_WR_TOVALL(base, (WDOG_RD_TOVALL(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALL(base, value) (WDOG_WR_TOVALL(base, WDOG_RD_TOVALL(base) |  (value)))
#define WDOG_CLR_TOVALL(base, value) (WDOG_WR_TOVALL(base, WDOG_RD_TOVALL(base) & ~(value)))
#define WDOG_TOG_TOVALL(base, value) (WDOG_WR_TOVALL(base, WDOG_RD_TOVALL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINH - Watchdog Window Register High
 ******************************************************************************/

/*!
 * @brief WDOG_WINH - Watchdog Window Register High (RW)
 *
 * Reset value: 0x0000U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINH register
 */
/*@{*/
#define WDOG_RD_WINH(base)       (WDOG_WINH_REG(base))
#define WDOG_WR_WINH(base, value) (WDOG_WINH_REG(base) = (value))
#define WDOG_RMW_WINH(base, mask, value) (WDOG_WR_WINH(base, (WDOG_RD_WINH(base) & ~(mask)) | (value)))
#define WDOG_SET_WINH(base, value) (WDOG_WR_WINH(base, WDOG_RD_WINH(base) |  (value)))
#define WDOG_CLR_WINH(base, value) (WDOG_WR_WINH(base, WDOG_RD_WINH(base) & ~(value)))
#define WDOG_TOG_WINH(base, value) (WDOG_WR_WINH(base, WDOG_RD_WINH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINL - Watchdog Window Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_WINL - Watchdog Window Register Low (RW)
 *
 * Reset value: 0x0010U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINL register
 */
/*@{*/
#define WDOG_RD_WINL(base)       (WDOG_WINL_REG(base))
#define WDOG_WR_WINL(base, value) (WDOG_WINL_REG(base) = (value))
#define WDOG_RMW_WINL(base, mask, value) (WDOG_WR_WINL(base, (WDOG_RD_WINL(base) & ~(mask)) | (value)))
#define WDOG_SET_WINL(base, value) (WDOG_WR_WINL(base, WDOG_RD_WINL(base) |  (value)))
#define WDOG_CLR_WINL(base, value) (WDOG_WR_WINL(base, WDOG_RD_WINL(base) & ~(value)))
#define WDOG_TOG_WINL(base, value) (WDOG_WR_WINL(base, WDOG_RD_WINL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_REFRESH - Watchdog Refresh Register
 ******************************************************************************/

/*!
 * @brief WDOG_REFRESH - Watchdog Refresh Register (RW)
 *
 * Reset value: 0xB480U
 */
/*!
 * @name Constants and macros for entire WDOG_REFRESH register
 */
/*@{*/
#define WDOG_RD_REFRESH(base)    (WDOG_REFRESH_REG(base))
#define WDOG_WR_REFRESH(base, value) (WDOG_REFRESH_REG(base) = (value))
#define WDOG_RMW_REFRESH(base, mask, value) (WDOG_WR_REFRESH(base, (WDOG_RD_REFRESH(base) & ~(mask)) | (value)))
#define WDOG_SET_REFRESH(base, value) (WDOG_WR_REFRESH(base, WDOG_RD_REFRESH(base) |  (value)))
#define WDOG_CLR_REFRESH(base, value) (WDOG_WR_REFRESH(base, WDOG_RD_REFRESH(base) & ~(value)))
#define WDOG_TOG_REFRESH(base, value) (WDOG_WR_REFRESH(base, WDOG_RD_REFRESH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_UNLOCK - Watchdog Unlock Register
 ******************************************************************************/

/*!
 * @brief WDOG_UNLOCK - Watchdog Unlock Register (RW)
 *
 * Reset value: 0xD928U
 */
/*!
 * @name Constants and macros for entire WDOG_UNLOCK register
 */
/*@{*/
#define WDOG_RD_UNLOCK(base)     (WDOG_UNLOCK_REG(base))
#define WDOG_WR_UNLOCK(base, value) (WDOG_UNLOCK_REG(base) = (value))
#define WDOG_RMW_UNLOCK(base, mask, value) (WDOG_WR_UNLOCK(base, (WDOG_RD_UNLOCK(base) & ~(mask)) | (value)))
#define WDOG_SET_UNLOCK(base, value) (WDOG_WR_UNLOCK(base, WDOG_RD_UNLOCK(base) |  (value)))
#define WDOG_CLR_UNLOCK(base, value) (WDOG_WR_UNLOCK(base, WDOG_RD_UNLOCK(base) & ~(value)))
#define WDOG_TOG_UNLOCK(base, value) (WDOG_WR_UNLOCK(base, WDOG_RD_UNLOCK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTH - Watchdog Timer Output Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTH - Watchdog Timer Output Register High (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTH register
 */
/*@{*/
#define WDOG_RD_TMROUTH(base)    (WDOG_TMROUTH_REG(base))
#define WDOG_WR_TMROUTH(base, value) (WDOG_TMROUTH_REG(base) = (value))
#define WDOG_RMW_TMROUTH(base, mask, value) (WDOG_WR_TMROUTH(base, (WDOG_RD_TMROUTH(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTH(base, value) (WDOG_WR_TMROUTH(base, WDOG_RD_TMROUTH(base) |  (value)))
#define WDOG_CLR_TMROUTH(base, value) (WDOG_WR_TMROUTH(base, WDOG_RD_TMROUTH(base) & ~(value)))
#define WDOG_TOG_TMROUTH(base, value) (WDOG_WR_TMROUTH(base, WDOG_RD_TMROUTH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTL - Watchdog Timer Output Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTL - Watchdog Timer Output Register Low (RW)
 *
 * Reset value: 0x0000U
 *
 * During stop mode, the WDOG_TIMER_OUT will be caught at the pre-stop value of
 * the watchdog timer. After exiting stop mode, a maximum delay of 1 WDOG_CLK
 * cycle + 3 bus clock cycles will occur before the WDOG_TIMER_OUT starts following
 * the watchdog timer.
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTL register
 */
/*@{*/
#define WDOG_RD_TMROUTL(base)    (WDOG_TMROUTL_REG(base))
#define WDOG_WR_TMROUTL(base, value) (WDOG_TMROUTL_REG(base) = (value))
#define WDOG_RMW_TMROUTL(base, mask, value) (WDOG_WR_TMROUTL(base, (WDOG_RD_TMROUTL(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTL(base, value) (WDOG_WR_TMROUTL(base, WDOG_RD_TMROUTL(base) |  (value)))
#define WDOG_CLR_TMROUTL(base, value) (WDOG_WR_TMROUTL(base, WDOG_RD_TMROUTL(base) & ~(value)))
#define WDOG_TOG_TMROUTL(base, value) (WDOG_WR_TMROUTL(base, WDOG_RD_TMROUTL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_RSTCNT - Watchdog Reset Count Register
 ******************************************************************************/

/*!
 * @brief WDOG_RSTCNT - Watchdog Reset Count Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_RSTCNT register
 */
/*@{*/
#define WDOG_RD_RSTCNT(base)     (WDOG_RSTCNT_REG(base))
#define WDOG_WR_RSTCNT(base, value) (WDOG_RSTCNT_REG(base) = (value))
#define WDOG_RMW_RSTCNT(base, mask, value) (WDOG_WR_RSTCNT(base, (WDOG_RD_RSTCNT(base) & ~(mask)) | (value)))
#define WDOG_SET_RSTCNT(base, value) (WDOG_WR_RSTCNT(base, WDOG_RD_RSTCNT(base) |  (value)))
#define WDOG_CLR_RSTCNT(base, value) (WDOG_WR_RSTCNT(base, WDOG_RD_RSTCNT(base) & ~(value)))
#define WDOG_TOG_RSTCNT(base, value) (WDOG_WR_RSTCNT(base, WDOG_RD_RSTCNT(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_PRESC - Watchdog Prescaler Register
 ******************************************************************************/

/*!
 * @brief WDOG_PRESC - Watchdog Prescaler Register (RW)
 *
 * Reset value: 0x0400U
 */
/*!
 * @name Constants and macros for entire WDOG_PRESC register
 */
/*@{*/
#define WDOG_RD_PRESC(base)      (WDOG_PRESC_REG(base))
#define WDOG_WR_PRESC(base, value) (WDOG_PRESC_REG(base) = (value))
#define WDOG_RMW_PRESC(base, mask, value) (WDOG_WR_PRESC(base, (WDOG_RD_PRESC(base) & ~(mask)) | (value)))
#define WDOG_SET_PRESC(base, value) (WDOG_WR_PRESC(base, WDOG_RD_PRESC(base) |  (value)))
#define WDOG_CLR_PRESC(base, value) (WDOG_WR_PRESC(base, WDOG_RD_PRESC(base) & ~(value)))
#define WDOG_TOG_PRESC(base, value) (WDOG_WR_PRESC(base, WDOG_RD_PRESC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_PRESC bitfields
 */

/*!
 * @name Register WDOG_PRESC, field PRESCVAL[10:8] (RW)
 *
 * 3-bit prescaler for the watchdog clock source. A value of zero indicates no
 * division of the input WDOG clock. The watchdog clock is divided by (PRESCVAL +
 * 1) to provide the prescaled WDOG_CLK.
 */
/*@{*/
/*! @brief Read current value of the WDOG_PRESC_PRESCVAL field. */
#define WDOG_RD_PRESC_PRESCVAL(base) ((WDOG_PRESC_REG(base) & WDOG_PRESC_PRESCVAL_MASK) >> WDOG_PRESC_PRESCVAL_SHIFT)
#define WDOG_BRD_PRESC_PRESCVAL(base) (WDOG_RD_PRESC_PRESCVAL(base))

/*! @brief Set the PRESCVAL field to a new value. */
#define WDOG_WR_PRESC_PRESCVAL(base, value) (WDOG_RMW_PRESC(base, WDOG_PRESC_PRESCVAL_MASK, WDOG_PRESC_PRESCVAL(value)))
#define WDOG_BWR_PRESC_PRESCVAL(base, value) (WDOG_WR_PRESC_PRESCVAL(base, value))
/*@}*/

/* Instance numbers for core modules */
#define JTAG_IDX (0) /*!< Instance number for JTAG. */
#define TPIU_IDX (0) /*!< Instance number for TPIU. */
#define SCB_IDX (0) /*!< Instance number for SCB. */
#define CoreDebug_IDX (0) /*!< Instance number for CoreDebug. */

#endif /* __MK20D5_EXTENSION_H__ */
/* EOF */
